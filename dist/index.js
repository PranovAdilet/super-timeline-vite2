function wO(r, e) {
  for (var t = 0; t < e.length; t++) {
    const n = e[t];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const s in n)
        if (s !== "default" && !(s in r)) {
          const i = Object.getOwnPropertyDescriptor(n, s);
          i && Object.defineProperty(r, s, i.get ? i : {
            enumerable: !0,
            get: () => n[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(r, Symbol.toStringTag, { value: "Module" }));
}
var Jo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function xy(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var _d = { exports: {} }, Qo = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mv;
function xO() {
  if (mv) return Qo;
  mv = 1;
  var r = Symbol.for("react.transitional.element"), e = Symbol.for("react.fragment");
  function t(n, s, i) {
    var a = null;
    if (i !== void 0 && (a = "" + i), s.key !== void 0 && (a = "" + s.key), "key" in s) {
      i = {};
      for (var c in s)
        c !== "key" && (i[c] = s[c]);
    } else i = s;
    return s = i.ref, {
      $$typeof: r,
      type: n,
      key: a,
      ref: s !== void 0 ? s : null,
      props: i
    };
  }
  return Qo.Fragment = e, Qo.jsx = t, Qo.jsxs = t, Qo;
}
var ea = {}, Sd = { exports: {} }, Fe = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vv;
function _O() {
  if (vv) return Fe;
  vv = 1;
  var r = Symbol.for("react.transitional.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), i = Symbol.for("react.consumer"), a = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), h = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), p = Symbol.iterator;
  function g(I) {
    return I === null || typeof I != "object" ? null : (I = p && I[p] || I["@@iterator"], typeof I == "function" ? I : null);
  }
  var v = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, b = Object.assign, _ = {};
  function C(I, W, ce) {
    this.props = I, this.context = W, this.refs = _, this.updater = ce || v;
  }
  C.prototype.isReactComponent = {}, C.prototype.setState = function(I, W) {
    if (typeof I != "object" && typeof I != "function" && I != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, I, W, "setState");
  }, C.prototype.forceUpdate = function(I) {
    this.updater.enqueueForceUpdate(this, I, "forceUpdate");
  };
  function T() {
  }
  T.prototype = C.prototype;
  function k(I, W, ce) {
    this.props = I, this.context = W, this.refs = _, this.updater = ce || v;
  }
  var M = k.prototype = new T();
  M.constructor = k, b(M, C.prototype), M.isPureReactComponent = !0;
  var A = Array.isArray, D = { H: null, A: null, T: null, S: null }, F = Object.prototype.hasOwnProperty;
  function U(I, W, ce, fe, be, ye) {
    return ce = ye.ref, {
      $$typeof: r,
      type: I,
      key: W,
      ref: ce !== void 0 ? ce : null,
      props: ye
    };
  }
  function B(I, W) {
    return U(
      I.type,
      W,
      void 0,
      void 0,
      void 0,
      I.props
    );
  }
  function X(I) {
    return typeof I == "object" && I !== null && I.$$typeof === r;
  }
  function Y(I) {
    var W = { "=": "=0", ":": "=2" };
    return "$" + I.replace(/[=:]/g, function(ce) {
      return W[ce];
    });
  }
  var Z = /\/+/g;
  function G(I, W) {
    return typeof I == "object" && I !== null && I.key != null ? Y("" + I.key) : W.toString(36);
  }
  function K() {
  }
  function oe(I) {
    switch (I.status) {
      case "fulfilled":
        return I.value;
      case "rejected":
        throw I.reason;
      default:
        switch (typeof I.status == "string" ? I.then(K, K) : (I.status = "pending", I.then(
          function(W) {
            I.status === "pending" && (I.status = "fulfilled", I.value = W);
          },
          function(W) {
            I.status === "pending" && (I.status = "rejected", I.reason = W);
          }
        )), I.status) {
          case "fulfilled":
            return I.value;
          case "rejected":
            throw I.reason;
        }
    }
    throw I;
  }
  function ve(I, W, ce, fe, be) {
    var ye = typeof I;
    (ye === "undefined" || ye === "boolean") && (I = null);
    var ue = !1;
    if (I === null) ue = !0;
    else
      switch (ye) {
        case "bigint":
        case "string":
        case "number":
          ue = !0;
          break;
        case "object":
          switch (I.$$typeof) {
            case r:
            case e:
              ue = !0;
              break;
            case d:
              return ue = I._init, ve(
                ue(I._payload),
                W,
                ce,
                fe,
                be
              );
          }
      }
    if (ue)
      return be = be(I), ue = fe === "" ? "." + G(I, 0) : fe, A(be) ? (ce = "", ue != null && (ce = ue.replace(Z, "$&/") + "/"), ve(be, W, ce, "", function(bt) {
        return bt;
      })) : be != null && (X(be) && (be = B(
        be,
        ce + (be.key == null || I && I.key === be.key ? "" : ("" + be.key).replace(
          Z,
          "$&/"
        ) + "/") + ue
      )), W.push(be)), 1;
    ue = 0;
    var Xe = fe === "" ? "." : fe + ":";
    if (A(I))
      for (var We = 0; We < I.length; We++)
        fe = I[We], ye = Xe + G(fe, We), ue += ve(
          fe,
          W,
          ce,
          ye,
          be
        );
    else if (We = g(I), typeof We == "function")
      for (I = We.call(I), We = 0; !(fe = I.next()).done; )
        fe = fe.value, ye = Xe + G(fe, We++), ue += ve(
          fe,
          W,
          ce,
          ye,
          be
        );
    else if (ye === "object") {
      if (typeof I.then == "function")
        return ve(
          oe(I),
          W,
          ce,
          fe,
          be
        );
      throw W = String(I), Error(
        "Objects are not valid as a React child (found: " + (W === "[object Object]" ? "object with keys {" + Object.keys(I).join(", ") + "}" : W) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return ue;
  }
  function Q(I, W, ce) {
    if (I == null) return I;
    var fe = [], be = 0;
    return ve(I, fe, "", "", function(ye) {
      return W.call(ce, ye, be++);
    }), fe;
  }
  function ge(I) {
    if (I._status === -1) {
      var W = I._result;
      W = W(), W.then(
        function(ce) {
          (I._status === 0 || I._status === -1) && (I._status = 1, I._result = ce);
        },
        function(ce) {
          (I._status === 0 || I._status === -1) && (I._status = 2, I._result = ce);
        }
      ), I._status === -1 && (I._status = 0, I._result = W);
    }
    if (I._status === 1) return I._result.default;
    throw I._result;
  }
  var de = typeof reportError == "function" ? reportError : function(I) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var W = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof I == "object" && I !== null && typeof I.message == "string" ? String(I.message) : String(I),
        error: I
      });
      if (!window.dispatchEvent(W)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", I);
      return;
    }
    console.error(I);
  };
  function ne() {
  }
  return Fe.Children = {
    map: Q,
    forEach: function(I, W, ce) {
      Q(
        I,
        function() {
          W.apply(this, arguments);
        },
        ce
      );
    },
    count: function(I) {
      var W = 0;
      return Q(I, function() {
        W++;
      }), W;
    },
    toArray: function(I) {
      return Q(I, function(W) {
        return W;
      }) || [];
    },
    only: function(I) {
      if (!X(I))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return I;
    }
  }, Fe.Component = C, Fe.Fragment = t, Fe.Profiler = s, Fe.PureComponent = k, Fe.StrictMode = n, Fe.Suspense = u, Fe.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = D, Fe.act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, Fe.cache = function(I) {
    return function() {
      return I.apply(null, arguments);
    };
  }, Fe.cloneElement = function(I, W, ce) {
    if (I == null)
      throw Error(
        "The argument must be a React element, but you passed " + I + "."
      );
    var fe = b({}, I.props), be = I.key, ye = void 0;
    if (W != null)
      for (ue in W.ref !== void 0 && (ye = void 0), W.key !== void 0 && (be = "" + W.key), W)
        !F.call(W, ue) || ue === "key" || ue === "__self" || ue === "__source" || ue === "ref" && W.ref === void 0 || (fe[ue] = W[ue]);
    var ue = arguments.length - 2;
    if (ue === 1) fe.children = ce;
    else if (1 < ue) {
      for (var Xe = Array(ue), We = 0; We < ue; We++)
        Xe[We] = arguments[We + 2];
      fe.children = Xe;
    }
    return U(I.type, be, void 0, void 0, ye, fe);
  }, Fe.createContext = function(I) {
    return I = {
      $$typeof: a,
      _currentValue: I,
      _currentValue2: I,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, I.Provider = I, I.Consumer = {
      $$typeof: i,
      _context: I
    }, I;
  }, Fe.createElement = function(I, W, ce) {
    var fe, be = {}, ye = null;
    if (W != null)
      for (fe in W.key !== void 0 && (ye = "" + W.key), W)
        F.call(W, fe) && fe !== "key" && fe !== "__self" && fe !== "__source" && (be[fe] = W[fe]);
    var ue = arguments.length - 2;
    if (ue === 1) be.children = ce;
    else if (1 < ue) {
      for (var Xe = Array(ue), We = 0; We < ue; We++)
        Xe[We] = arguments[We + 2];
      be.children = Xe;
    }
    if (I && I.defaultProps)
      for (fe in ue = I.defaultProps, ue)
        be[fe] === void 0 && (be[fe] = ue[fe]);
    return U(I, ye, void 0, void 0, null, be);
  }, Fe.createRef = function() {
    return { current: null };
  }, Fe.forwardRef = function(I) {
    return { $$typeof: c, render: I };
  }, Fe.isValidElement = X, Fe.lazy = function(I) {
    return {
      $$typeof: d,
      _payload: { _status: -1, _result: I },
      _init: ge
    };
  }, Fe.memo = function(I, W) {
    return {
      $$typeof: h,
      type: I,
      compare: W === void 0 ? null : W
    };
  }, Fe.startTransition = function(I) {
    var W = D.T, ce = {};
    D.T = ce;
    try {
      var fe = I(), be = D.S;
      be !== null && be(ce, fe), typeof fe == "object" && fe !== null && typeof fe.then == "function" && fe.then(ne, de);
    } catch (ye) {
      de(ye);
    } finally {
      D.T = W;
    }
  }, Fe.unstable_useCacheRefresh = function() {
    return D.H.useCacheRefresh();
  }, Fe.use = function(I) {
    return D.H.use(I);
  }, Fe.useActionState = function(I, W, ce) {
    return D.H.useActionState(I, W, ce);
  }, Fe.useCallback = function(I, W) {
    return D.H.useCallback(I, W);
  }, Fe.useContext = function(I) {
    return D.H.useContext(I);
  }, Fe.useDebugValue = function() {
  }, Fe.useDeferredValue = function(I, W) {
    return D.H.useDeferredValue(I, W);
  }, Fe.useEffect = function(I, W) {
    return D.H.useEffect(I, W);
  }, Fe.useId = function() {
    return D.H.useId();
  }, Fe.useImperativeHandle = function(I, W, ce) {
    return D.H.useImperativeHandle(I, W, ce);
  }, Fe.useInsertionEffect = function(I, W) {
    return D.H.useInsertionEffect(I, W);
  }, Fe.useLayoutEffect = function(I, W) {
    return D.H.useLayoutEffect(I, W);
  }, Fe.useMemo = function(I, W) {
    return D.H.useMemo(I, W);
  }, Fe.useOptimistic = function(I, W) {
    return D.H.useOptimistic(I, W);
  }, Fe.useReducer = function(I, W, ce) {
    return D.H.useReducer(I, W, ce);
  }, Fe.useRef = function(I) {
    return D.H.useRef(I);
  }, Fe.useState = function(I) {
    return D.H.useState(I);
  }, Fe.useSyncExternalStore = function(I, W, ce) {
    return D.H.useSyncExternalStore(
      I,
      W,
      ce
    );
  }, Fe.useTransition = function() {
    return D.H.useTransition();
  }, Fe.version = "19.0.0", Fe;
}
var aa = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
aa.exports;
var yv;
function SO() {
  return yv || (yv = 1, function(r, e) {
    process.env.NODE_ENV !== "production" && function() {
      function t(x, V) {
        Object.defineProperty(i.prototype, x, {
          get: function() {
            console.warn(
              "%s(...) is deprecated in plain JavaScript React classes. %s",
              V[0],
              V[1]
            );
          }
        });
      }
      function n(x) {
        return x === null || typeof x != "object" ? null : (x = Gr && x[Gr] || x["@@iterator"], typeof x == "function" ? x : null);
      }
      function s(x, V) {
        x = (x = x.constructor) && (x.displayName || x.name) || "ReactClass";
        var te = x + "." + V;
        sr[te] || (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          V,
          x
        ), sr[te] = !0);
      }
      function i(x, V, te) {
        this.props = x, this.context = V, this.refs = pe, this.updater = te || R;
      }
      function a() {
      }
      function c(x, V, te) {
        this.props = x, this.context = V, this.refs = pe, this.updater = te || R;
      }
      function u(x) {
        return "" + x;
      }
      function h(x) {
        try {
          u(x);
          var V = !1;
        } catch {
          V = !0;
        }
        if (V) {
          V = console;
          var te = V.error, ae = typeof Symbol == "function" && Symbol.toStringTag && x[Symbol.toStringTag] || x.constructor.name || "Object";
          return te.call(
            V,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            ae
          ), u(x);
        }
      }
      function d(x) {
        if (x == null) return null;
        if (typeof x == "function")
          return x.$$typeof === ke ? null : x.displayName || x.name || null;
        if (typeof x == "string") return x;
        switch (x) {
          case We:
            return "Fragment";
          case Xe:
            return "Portal";
          case wt:
            return "Profiler";
          case bt:
            return "StrictMode";
          case it:
            return "Suspense";
          case Tt:
            return "SuspenseList";
        }
        if (typeof x == "object")
          switch (typeof x.tag == "number" && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), x.$$typeof) {
            case Ce:
              return (x.displayName || "Context") + ".Provider";
            case Vt:
              return (x._context.displayName || "Context") + ".Consumer";
            case qt:
              var V = x.render;
              return x = x.displayName, x || (x = V.displayName || V.name || "", x = x !== "" ? "ForwardRef(" + x + ")" : "ForwardRef"), x;
            case Tr:
              return V = x.displayName || null, V !== null ? V : d(x.type) || "Memo";
            case tt:
              V = x._payload, x = x._init;
              try {
                return d(x(V));
              } catch {
              }
          }
        return null;
      }
      function p(x) {
        return typeof x == "string" || typeof x == "function" || x === We || x === wt || x === bt || x === it || x === Tt || x === It || typeof x == "object" && x !== null && (x.$$typeof === tt || x.$$typeof === Tr || x.$$typeof === Ce || x.$$typeof === Vt || x.$$typeof === qt || x.$$typeof === xt || x.getModuleId !== void 0);
      }
      function g() {
      }
      function v() {
        if (Wt === 0) {
          Er = console.log, Qt = console.info, jr = console.warn, Kt = console.error, ls = console.group, us = console.groupCollapsed, Vn = console.groupEnd;
          var x = {
            configurable: !0,
            enumerable: !0,
            value: g,
            writable: !0
          };
          Object.defineProperties(console, {
            info: x,
            log: x,
            warn: x,
            error: x,
            group: x,
            groupCollapsed: x,
            groupEnd: x
          });
        }
        Wt++;
      }
      function b() {
        if (Wt--, Wt === 0) {
          var x = { configurable: !0, enumerable: !0, writable: !0 };
          Object.defineProperties(console, {
            log: he({}, x, { value: Er }),
            info: he({}, x, { value: Qt }),
            warn: he({}, x, { value: jr }),
            error: he({}, x, { value: Kt }),
            group: he({}, x, { value: ls }),
            groupCollapsed: he({}, x, { value: us }),
            groupEnd: he({}, x, { value: Vn })
          });
        }
        0 > Wt && console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
      }
      function _(x) {
        if (Tn === void 0)
          try {
            throw Error();
          } catch (te) {
            var V = te.stack.trim().match(/\n( *(at )?)/);
            Tn = V && V[1] || "", Ii = -1 < te.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < te.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return `
` + Tn + x + Ii;
      }
      function C(x, V) {
        if (!x || hs) return "";
        var te = un.get(x);
        if (te !== void 0) return te;
        hs = !0, te = Error.prepareStackTrace, Error.prepareStackTrace = void 0;
        var ae = null;
        ae = xe.H, xe.H = null, v();
        try {
          var _e = {
            DetermineComponentFrameRoot: function() {
              try {
                if (V) {
                  var pr = function() {
                    throw Error();
                  };
                  if (Object.defineProperty(pr.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  }), typeof Reflect == "object" && Reflect.construct) {
                    try {
                      Reflect.construct(pr, []);
                    } catch (kr) {
                      var ji = kr;
                    }
                    Reflect.construct(x, [], pr);
                  } else {
                    try {
                      pr.call();
                    } catch (kr) {
                      ji = kr;
                    }
                    x.call(pr.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (kr) {
                    ji = kr;
                  }
                  (pr = x()) && typeof pr.catch == "function" && pr.catch(function() {
                  });
                }
              } catch (kr) {
                if (kr && ji && typeof kr.stack == "string")
                  return [kr.stack, ji.stack];
              }
              return [null, null];
            }
          };
          _e.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var Ee = Object.getOwnPropertyDescriptor(
            _e.DetermineComponentFrameRoot,
            "name"
          );
          Ee && Ee.configurable && Object.defineProperty(
            _e.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var Se = _e.DetermineComponentFrameRoot(), rt = Se[0], Qe = Se[1];
          if (rt && Qe) {
            var gt = rt.split(`
`), ir = Qe.split(`
`);
            for (Se = Ee = 0; Ee < gt.length && !gt[Ee].includes(
              "DetermineComponentFrameRoot"
            ); )
              Ee++;
            for (; Se < ir.length && !ir[Se].includes(
              "DetermineComponentFrameRoot"
            ); )
              Se++;
            if (Ee === gt.length || Se === ir.length)
              for (Ee = gt.length - 1, Se = ir.length - 1; 1 <= Ee && 0 <= Se && gt[Ee] !== ir[Se]; )
                Se--;
            for (; 1 <= Ee && 0 <= Se; Ee--, Se--)
              if (gt[Ee] !== ir[Se]) {
                if (Ee !== 1 || Se !== 1)
                  do
                    if (Ee--, Se--, 0 > Se || gt[Ee] !== ir[Se]) {
                      var zn = `
` + gt[Ee].replace(
                        " at new ",
                        " at "
                      );
                      return x.displayName && zn.includes("<anonymous>") && (zn = zn.replace("<anonymous>", x.displayName)), typeof x == "function" && un.set(x, zn), zn;
                    }
                  while (1 <= Ee && 0 <= Se);
                break;
              }
          }
        } finally {
          hs = !1, xe.H = ae, b(), Error.prepareStackTrace = te;
        }
        return gt = (gt = x ? x.displayName || x.name : "") ? _(gt) : "", typeof x == "function" && un.set(x, gt), gt;
      }
      function T(x) {
        if (x == null) return "";
        if (typeof x == "function") {
          var V = x.prototype;
          return C(
            x,
            !(!V || !V.isReactComponent)
          );
        }
        if (typeof x == "string") return _(x);
        switch (x) {
          case it:
            return _("Suspense");
          case Tt:
            return _("SuspenseList");
        }
        if (typeof x == "object")
          switch (x.$$typeof) {
            case qt:
              return x = C(x.render, !1), x;
            case Tr:
              return T(x.type);
            case tt:
              V = x._payload, x = x._init;
              try {
                return T(x(V));
              } catch {
              }
          }
        return "";
      }
      function k() {
        var x = xe.A;
        return x === null ? null : x.getOwner();
      }
      function M(x) {
        if (zt.call(x, "key")) {
          var V = Object.getOwnPropertyDescriptor(x, "key").get;
          if (V && V.isReactWarning) return !1;
        }
        return x.key !== void 0;
      }
      function A(x, V) {
        function te() {
          Do || (Do = !0, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            V
          ));
        }
        te.isReactWarning = !0, Object.defineProperty(x, "key", {
          get: te,
          configurable: !0
        });
      }
      function D() {
        var x = d(this.type);
        return jo[x] || (jo[x] = !0, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        )), x = this.props.ref, x !== void 0 ? x : null;
      }
      function F(x, V, te, ae, _e, Ee) {
        return te = Ee.ref, x = {
          $$typeof: ue,
          type: x,
          key: V,
          props: Ee,
          _owner: _e
        }, (te !== void 0 ? te : null) !== null ? Object.defineProperty(x, "ref", {
          enumerable: !1,
          get: D
        }) : Object.defineProperty(x, "ref", { enumerable: !1, value: null }), x._store = {}, Object.defineProperty(x._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: 0
        }), Object.defineProperty(x, "_debugInfo", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: null
        }), Object.freeze && (Object.freeze(x.props), Object.freeze(x)), x;
      }
      function U(x, V) {
        return V = F(
          x.type,
          V,
          void 0,
          void 0,
          x._owner,
          x.props
        ), V._store.validated = x._store.validated, V;
      }
      function B(x, V) {
        if (typeof x == "object" && x && x.$$typeof !== Pi) {
          if (Ge(x))
            for (var te = 0; te < x.length; te++) {
              var ae = x[te];
              X(ae) && Y(ae, V);
            }
          else if (X(x))
            x._store && (x._store.validated = 1);
          else if (te = n(x), typeof te == "function" && te !== x.entries && (te = te.call(x), te !== x))
            for (; !(x = te.next()).done; )
              X(x.value) && Y(x.value, V);
        }
      }
      function X(x) {
        return typeof x == "object" && x !== null && x.$$typeof === ue;
      }
      function Y(x, V) {
        if (x._store && !x._store.validated && x.key == null && (x._store.validated = 1, V = Z(V), !Di[V])) {
          Di[V] = !0;
          var te = "";
          x && x._owner != null && x._owner !== k() && (te = null, typeof x._owner.tag == "number" ? te = d(x._owner.type) : typeof x._owner.name == "string" && (te = x._owner.name), te = " It was passed a child from " + te + ".");
          var ae = xe.getCurrentStack;
          xe.getCurrentStack = function() {
            var _e = T(x.type);
            return ae && (_e += ae() || ""), _e;
          }, console.error(
            'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
            V,
            te
          ), xe.getCurrentStack = ae;
        }
      }
      function Z(x) {
        var V = "", te = k();
        return te && (te = d(te.type)) && (V = `

Check the render method of \`` + te + "`."), V || (x = d(x)) && (V = `

Check the top-level render call using <` + x + ">."), V;
      }
      function G(x) {
        var V = { "=": "=0", ":": "=2" };
        return "$" + x.replace(/[=:]/g, function(te) {
          return V[te];
        });
      }
      function K(x, V) {
        return typeof x == "object" && x !== null && x.key != null ? (h(x.key), G("" + x.key)) : V.toString(36);
      }
      function oe() {
      }
      function ve(x) {
        switch (x.status) {
          case "fulfilled":
            return x.value;
          case "rejected":
            throw x.reason;
          default:
            switch (typeof x.status == "string" ? x.then(oe, oe) : (x.status = "pending", x.then(
              function(V) {
                x.status === "pending" && (x.status = "fulfilled", x.value = V);
              },
              function(V) {
                x.status === "pending" && (x.status = "rejected", x.reason = V);
              }
            )), x.status) {
              case "fulfilled":
                return x.value;
              case "rejected":
                throw x.reason;
            }
        }
        throw x;
      }
      function Q(x, V, te, ae, _e) {
        var Ee = typeof x;
        (Ee === "undefined" || Ee === "boolean") && (x = null);
        var Se = !1;
        if (x === null) Se = !0;
        else
          switch (Ee) {
            case "bigint":
            case "string":
            case "number":
              Se = !0;
              break;
            case "object":
              switch (x.$$typeof) {
                case ue:
                case Xe:
                  Se = !0;
                  break;
                case tt:
                  return Se = x._init, Q(
                    Se(x._payload),
                    V,
                    te,
                    ae,
                    _e
                  );
              }
          }
        if (Se) {
          Se = x, _e = _e(Se);
          var rt = ae === "" ? "." + K(Se, 0) : ae;
          return Ge(_e) ? (te = "", rt != null && (te = rt.replace(Vs, "$&/") + "/"), Q(_e, V, te, "", function(gt) {
            return gt;
          })) : _e != null && (X(_e) && (_e.key != null && (Se && Se.key === _e.key || h(_e.key)), te = U(
            _e,
            te + (_e.key == null || Se && Se.key === _e.key ? "" : ("" + _e.key).replace(
              Vs,
              "$&/"
            ) + "/") + rt
          ), ae !== "" && Se != null && X(Se) && Se.key == null && Se._store && !Se._store.validated && (te._store.validated = 2), _e = te), V.push(_e)), 1;
        }
        if (Se = 0, rt = ae === "" ? "." : ae + ":", Ge(x))
          for (var Qe = 0; Qe < x.length; Qe++)
            ae = x[Qe], Ee = rt + K(ae, Qe), Se += Q(
              ae,
              V,
              te,
              Ee,
              _e
            );
        else if (Qe = n(x), typeof Qe == "function")
          for (Qe === x.entries && (Ri || console.warn(
            "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
          ), Ri = !0), x = Qe.call(x), Qe = 0; !(ae = x.next()).done; )
            ae = ae.value, Ee = rt + K(ae, Qe++), Se += Q(
              ae,
              V,
              te,
              Ee,
              _e
            );
        else if (Ee === "object") {
          if (typeof x.then == "function")
            return Q(
              ve(x),
              V,
              te,
              ae,
              _e
            );
          throw V = String(x), Error(
            "Objects are not valid as a React child (found: " + (V === "[object Object]" ? "object with keys {" + Object.keys(x).join(", ") + "}" : V) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return Se;
      }
      function ge(x, V, te) {
        if (x == null) return x;
        var ae = [], _e = 0;
        return Q(x, ae, "", "", function(Ee) {
          return V.call(te, Ee, _e++);
        }), ae;
      }
      function de(x) {
        if (x._status === -1) {
          var V = x._result;
          V = V(), V.then(
            function(te) {
              (x._status === 0 || x._status === -1) && (x._status = 1, x._result = te);
            },
            function(te) {
              (x._status === 0 || x._status === -1) && (x._status = 2, x._result = te);
            }
          ), x._status === -1 && (x._status = 0, x._result = V);
        }
        if (x._status === 1)
          return V = x._result, V === void 0 && console.error(
            `lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`,
            V
          ), "default" in V || console.error(
            `lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`,
            V
          ), V.default;
        throw x._result;
      }
      function ne() {
        var x = xe.H;
        return x === null && console.error(
          `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
        ), x;
      }
      function I() {
      }
      function W(x) {
        if (Zt === null)
          try {
            var V = ("require" + Math.random()).slice(0, 7);
            Zt = (r && r[V]).call(
              r,
              "timers"
            ).setImmediate;
          } catch {
            Zt = function(ae) {
              Ue === !1 && (Ue = !0, typeof MessageChannel > "u" && console.error(
                "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
              ));
              var _e = new MessageChannel();
              _e.port1.onmessage = ae, _e.port2.postMessage(void 0);
            };
          }
        return Zt(x);
      }
      function ce(x) {
        return 1 < x.length && typeof AggregateError == "function" ? new AggregateError(x) : x[0];
      }
      function fe(x, V) {
        V !== fr - 1 && console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        ), fr = V;
      }
      function be(x, V, te) {
        var ae = xe.actQueue;
        if (ae !== null)
          if (ae.length !== 0)
            try {
              ye(ae), W(function() {
                return be(x, V, te);
              });
              return;
            } catch (_e) {
              xe.thrownErrors.push(_e);
            }
          else xe.actQueue = null;
        0 < xe.thrownErrors.length ? (ae = ce(xe.thrownErrors), xe.thrownErrors.length = 0, te(ae)) : V(x);
      }
      function ye(x) {
        if (!Lo) {
          Lo = !0;
          var V = 0;
          try {
            for (; V < x.length; V++) {
              var te = x[V];
              do {
                xe.didUsePromise = !1;
                var ae = te(!1);
                if (ae !== null) {
                  if (xe.didUsePromise) {
                    x[V] = te, x.splice(0, V);
                    return;
                  }
                  te = ae;
                } else break;
              } while (!0);
            }
            x.length = 0;
          } catch (_e) {
            x.splice(0, V + 1), xe.thrownErrors.push(_e);
          } finally {
            Lo = !1;
          }
        }
      }
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var ue = Symbol.for("react.transitional.element"), Xe = Symbol.for("react.portal"), We = Symbol.for("react.fragment"), bt = Symbol.for("react.strict_mode"), wt = Symbol.for("react.profiler"), Vt = Symbol.for("react.consumer"), Ce = Symbol.for("react.context"), qt = Symbol.for("react.forward_ref"), it = Symbol.for("react.suspense"), Tt = Symbol.for("react.suspense_list"), Tr = Symbol.for("react.memo"), tt = Symbol.for("react.lazy"), It = Symbol.for("react.offscreen"), Gr = Symbol.iterator, sr = {}, R = {
        isMounted: function() {
          return !1;
        },
        enqueueForceUpdate: function(x) {
          s(x, "forceUpdate");
        },
        enqueueReplaceState: function(x) {
          s(x, "replaceState");
        },
        enqueueSetState: function(x) {
          s(x, "setState");
        }
      }, he = Object.assign, pe = {};
      Object.freeze(pe), i.prototype.isReactComponent = {}, i.prototype.setState = function(x, V) {
        if (typeof x != "object" && typeof x != "function" && x != null)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, x, V, "setState");
      }, i.prototype.forceUpdate = function(x) {
        this.updater.enqueueForceUpdate(this, x, "forceUpdate");
      };
      var De = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      }, Je;
      for (Je in De)
        De.hasOwnProperty(Je) && t(Je, De[Je]);
      a.prototype = i.prototype, De = c.prototype = new a(), De.constructor = c, he(De, i.prototype), De.isPureReactComponent = !0;
      var Ge = Array.isArray, ke = Symbol.for("react.client.reference"), xe = {
        H: null,
        A: null,
        T: null,
        S: null,
        actQueue: null,
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1,
        didUsePromise: !1,
        thrownErrors: [],
        getCurrentStack: null
      }, zt = Object.prototype.hasOwnProperty, xt = Symbol.for("react.client.reference"), Wt = 0, Er, Qt, jr, Kt, ls, us, Vn;
      g.__reactDisabledLog = !0;
      var Tn, Ii, hs = !1, un = new (typeof WeakMap == "function" ? WeakMap : Map)(), Pi = Symbol.for("react.client.reference"), Do, Ro, jo = {}, Di = {}, Ri = !1, Vs = /\/+/g, qe = typeof reportError == "function" ? reportError : function(x) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
          var V = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message: typeof x == "object" && x !== null && typeof x.message == "string" ? String(x.message) : String(x),
            error: x
          });
          if (!window.dispatchEvent(V)) return;
        } else if (typeof process == "object" && typeof process.emit == "function") {
          process.emit("uncaughtException", x);
          return;
        }
        console.error(x);
      }, Ue = !1, Zt = null, fr = 0, zs = !1, Lo = !1, qa = typeof queueMicrotask == "function" ? function(x) {
        queueMicrotask(function() {
          return queueMicrotask(x);
        });
      } : W;
      e.Children = {
        map: ge,
        forEach: function(x, V, te) {
          ge(
            x,
            function() {
              V.apply(this, arguments);
            },
            te
          );
        },
        count: function(x) {
          var V = 0;
          return ge(x, function() {
            V++;
          }), V;
        },
        toArray: function(x) {
          return ge(x, function(V) {
            return V;
          }) || [];
        },
        only: function(x) {
          if (!X(x))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return x;
        }
      }, e.Component = i, e.Fragment = We, e.Profiler = wt, e.PureComponent = c, e.StrictMode = bt, e.Suspense = it, e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = xe, e.act = function(x) {
        var V = xe.actQueue, te = fr;
        fr++;
        var ae = xe.actQueue = V !== null ? V : [], _e = !1;
        try {
          var Ee = x();
        } catch (Qe) {
          xe.thrownErrors.push(Qe);
        }
        if (0 < xe.thrownErrors.length)
          throw fe(V, te), x = ce(xe.thrownErrors), xe.thrownErrors.length = 0, x;
        if (Ee !== null && typeof Ee == "object" && typeof Ee.then == "function") {
          var Se = Ee;
          return qa(function() {
            _e || zs || (zs = !0, console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
          }), {
            then: function(Qe, gt) {
              _e = !0, Se.then(
                function(ir) {
                  if (fe(V, te), te === 0) {
                    try {
                      ye(ae), W(function() {
                        return be(
                          ir,
                          Qe,
                          gt
                        );
                      });
                    } catch (pr) {
                      xe.thrownErrors.push(pr);
                    }
                    if (0 < xe.thrownErrors.length) {
                      var zn = ce(
                        xe.thrownErrors
                      );
                      xe.thrownErrors.length = 0, gt(zn);
                    }
                  } else Qe(ir);
                },
                function(ir) {
                  fe(V, te), 0 < xe.thrownErrors.length && (ir = ce(
                    xe.thrownErrors
                  ), xe.thrownErrors.length = 0), gt(ir);
                }
              );
            }
          };
        }
        var rt = Ee;
        if (fe(V, te), te === 0 && (ye(ae), ae.length !== 0 && qa(function() {
          _e || zs || (zs = !0, console.error(
            "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
          ));
        }), xe.actQueue = null), 0 < xe.thrownErrors.length)
          throw x = ce(xe.thrownErrors), xe.thrownErrors.length = 0, x;
        return {
          then: function(Qe, gt) {
            _e = !0, te === 0 ? (xe.actQueue = ae, W(function() {
              return be(
                rt,
                Qe,
                gt
              );
            })) : Qe(rt);
          }
        };
      }, e.cache = function(x) {
        return function() {
          return x.apply(null, arguments);
        };
      }, e.cloneElement = function(x, V, te) {
        if (x == null)
          throw Error(
            "The argument must be a React element, but you passed " + x + "."
          );
        var ae = he({}, x.props), _e = x.key, Ee = x._owner;
        if (V != null) {
          var Se;
          e: {
            if (zt.call(V, "ref") && (Se = Object.getOwnPropertyDescriptor(
              V,
              "ref"
            ).get) && Se.isReactWarning) {
              Se = !1;
              break e;
            }
            Se = V.ref !== void 0;
          }
          Se && (Ee = k()), M(V) && (h(V.key), _e = "" + V.key);
          for (rt in V)
            !zt.call(V, rt) || rt === "key" || rt === "__self" || rt === "__source" || rt === "ref" && V.ref === void 0 || (ae[rt] = V[rt]);
        }
        var rt = arguments.length - 2;
        if (rt === 1) ae.children = te;
        else if (1 < rt) {
          Se = Array(rt);
          for (var Qe = 0; Qe < rt; Qe++)
            Se[Qe] = arguments[Qe + 2];
          ae.children = Se;
        }
        for (ae = F(x.type, _e, void 0, void 0, Ee, ae), _e = 2; _e < arguments.length; _e++)
          B(arguments[_e], ae.type);
        return ae;
      }, e.createContext = function(x) {
        return x = {
          $$typeof: Ce,
          _currentValue: x,
          _currentValue2: x,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        }, x.Provider = x, x.Consumer = {
          $$typeof: Vt,
          _context: x
        }, x._currentRenderer = null, x._currentRenderer2 = null, x;
      }, e.createElement = function(x, V, te) {
        if (p(x))
          for (var ae = 2; ae < arguments.length; ae++)
            B(arguments[ae], x);
        else {
          if (ae = "", (x === void 0 || typeof x == "object" && x !== null && Object.keys(x).length === 0) && (ae += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), x === null) var _e = "null";
          else
            Ge(x) ? _e = "array" : x !== void 0 && x.$$typeof === ue ? (_e = "<" + (d(x.type) || "Unknown") + " />", ae = " Did you accidentally export a JSX literal instead of a component?") : _e = typeof x;
          console.error(
            "React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",
            _e,
            ae
          );
        }
        var Ee;
        if (ae = {}, _e = null, V != null)
          for (Ee in Ro || !("__self" in V) || "key" in V || (Ro = !0, console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )), M(V) && (h(V.key), _e = "" + V.key), V)
            zt.call(V, Ee) && Ee !== "key" && Ee !== "__self" && Ee !== "__source" && (ae[Ee] = V[Ee]);
        var Se = arguments.length - 2;
        if (Se === 1) ae.children = te;
        else if (1 < Se) {
          for (var rt = Array(Se), Qe = 0; Qe < Se; Qe++)
            rt[Qe] = arguments[Qe + 2];
          Object.freeze && Object.freeze(rt), ae.children = rt;
        }
        if (x && x.defaultProps)
          for (Ee in Se = x.defaultProps, Se)
            ae[Ee] === void 0 && (ae[Ee] = Se[Ee]);
        return _e && A(
          ae,
          typeof x == "function" ? x.displayName || x.name || "Unknown" : x
        ), F(x, _e, void 0, void 0, k(), ae);
      }, e.createRef = function() {
        var x = { current: null };
        return Object.seal(x), x;
      }, e.forwardRef = function(x) {
        x != null && x.$$typeof === Tr ? console.error(
          "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
        ) : typeof x != "function" ? console.error(
          "forwardRef requires a render function but was given %s.",
          x === null ? "null" : typeof x
        ) : x.length !== 0 && x.length !== 2 && console.error(
          "forwardRef render functions accept exactly two parameters: props and ref. %s",
          x.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
        ), x != null && x.defaultProps != null && console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
        var V = { $$typeof: qt, render: x }, te;
        return Object.defineProperty(V, "displayName", {
          enumerable: !1,
          configurable: !0,
          get: function() {
            return te;
          },
          set: function(ae) {
            te = ae, x.name || x.displayName || (Object.defineProperty(x, "name", { value: ae }), x.displayName = ae);
          }
        }), V;
      }, e.isValidElement = X, e.lazy = function(x) {
        return {
          $$typeof: tt,
          _payload: { _status: -1, _result: x },
          _init: de
        };
      }, e.memo = function(x, V) {
        p(x) || console.error(
          "memo: The first argument must be a component. Instead received: %s",
          x === null ? "null" : typeof x
        ), V = {
          $$typeof: Tr,
          type: x,
          compare: V === void 0 ? null : V
        };
        var te;
        return Object.defineProperty(V, "displayName", {
          enumerable: !1,
          configurable: !0,
          get: function() {
            return te;
          },
          set: function(ae) {
            te = ae, x.name || x.displayName || (Object.defineProperty(x, "name", { value: ae }), x.displayName = ae);
          }
        }), V;
      }, e.startTransition = function(x) {
        var V = xe.T, te = {};
        xe.T = te, te._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var ae = x(), _e = xe.S;
          _e !== null && _e(te, ae), typeof ae == "object" && ae !== null && typeof ae.then == "function" && ae.then(I, qe);
        } catch (Ee) {
          qe(Ee);
        } finally {
          V === null && te._updatedFibers && (x = te._updatedFibers.size, te._updatedFibers.clear(), 10 < x && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          )), xe.T = V;
        }
      }, e.unstable_useCacheRefresh = function() {
        return ne().useCacheRefresh();
      }, e.use = function(x) {
        return ne().use(x);
      }, e.useActionState = function(x, V, te) {
        return ne().useActionState(
          x,
          V,
          te
        );
      }, e.useCallback = function(x, V) {
        return ne().useCallback(x, V);
      }, e.useContext = function(x) {
        var V = ne();
        return x.$$typeof === Vt && console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        ), V.useContext(x);
      }, e.useDebugValue = function(x, V) {
        return ne().useDebugValue(x, V);
      }, e.useDeferredValue = function(x, V) {
        return ne().useDeferredValue(x, V);
      }, e.useEffect = function(x, V) {
        return ne().useEffect(x, V);
      }, e.useId = function() {
        return ne().useId();
      }, e.useImperativeHandle = function(x, V, te) {
        return ne().useImperativeHandle(x, V, te);
      }, e.useInsertionEffect = function(x, V) {
        return ne().useInsertionEffect(x, V);
      }, e.useLayoutEffect = function(x, V) {
        return ne().useLayoutEffect(x, V);
      }, e.useMemo = function(x, V) {
        return ne().useMemo(x, V);
      }, e.useOptimistic = function(x, V) {
        return ne().useOptimistic(x, V);
      }, e.useReducer = function(x, V, te) {
        return ne().useReducer(x, V, te);
      }, e.useRef = function(x) {
        return ne().useRef(x);
      }, e.useState = function(x) {
        return ne().useState(x);
      }, e.useSyncExternalStore = function(x, V, te) {
        return ne().useSyncExternalStore(
          x,
          V,
          te
        );
      }, e.useTransition = function() {
        return ne().useTransition();
      }, e.version = "19.0.0", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }(aa, aa.exports)), aa.exports;
}
process.env.NODE_ENV === "production" ? Sd.exports = _O() : Sd.exports = SO();
var m = Sd.exports;
const Ie = /* @__PURE__ */ xy(m), CO = /* @__PURE__ */ wO({
  __proto__: null,
  default: Ie
}, [m]);
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bv;
function TO() {
  return bv || (bv = 1, process.env.NODE_ENV !== "production" && function() {
    function r(R) {
      if (R == null) return null;
      if (typeof R == "function")
        return R.$$typeof === de ? null : R.displayName || R.name || null;
      if (typeof R == "string") return R;
      switch (R) {
        case F:
          return "Fragment";
        case D:
          return "Portal";
        case B:
          return "Profiler";
        case U:
          return "StrictMode";
        case G:
          return "Suspense";
        case K:
          return "SuspenseList";
      }
      if (typeof R == "object")
        switch (typeof R.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), R.$$typeof) {
          case Y:
            return (R.displayName || "Context") + ".Provider";
          case X:
            return (R._context.displayName || "Context") + ".Consumer";
          case Z:
            var he = R.render;
            return R = R.displayName, R || (R = he.displayName || he.name || "", R = R !== "" ? "ForwardRef(" + R + ")" : "ForwardRef"), R;
          case oe:
            return he = R.displayName || null, he !== null ? he : r(R.type) || "Memo";
          case ve:
            he = R._payload, R = R._init;
            try {
              return r(R(he));
            } catch {
            }
        }
      return null;
    }
    function e(R) {
      return "" + R;
    }
    function t(R) {
      try {
        e(R);
        var he = !1;
      } catch {
        he = !0;
      }
      if (he) {
        he = console;
        var pe = he.error, De = typeof Symbol == "function" && Symbol.toStringTag && R[Symbol.toStringTag] || R.constructor.name || "Object";
        return pe.call(
          he,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          De
        ), e(R);
      }
    }
    function n() {
    }
    function s() {
      if (be === 0) {
        ye = console.log, ue = console.info, Xe = console.warn, We = console.error, bt = console.group, wt = console.groupCollapsed, Vt = console.groupEnd;
        var R = {
          configurable: !0,
          enumerable: !0,
          value: n,
          writable: !0
        };
        Object.defineProperties(console, {
          info: R,
          log: R,
          warn: R,
          error: R,
          group: R,
          groupCollapsed: R,
          groupEnd: R
        });
      }
      be++;
    }
    function i() {
      if (be--, be === 0) {
        var R = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: W({}, R, { value: ye }),
          info: W({}, R, { value: ue }),
          warn: W({}, R, { value: Xe }),
          error: W({}, R, { value: We }),
          group: W({}, R, { value: bt }),
          groupCollapsed: W({}, R, { value: wt }),
          groupEnd: W({}, R, { value: Vt })
        });
      }
      0 > be && console.error(
        "disabledDepth fell below zero. This is a bug in React. Please file an issue."
      );
    }
    function a(R) {
      if (Ce === void 0)
        try {
          throw Error();
        } catch (pe) {
          var he = pe.stack.trim().match(/\n( *(at )?)/);
          Ce = he && he[1] || "", qt = -1 < pe.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < pe.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + Ce + R + qt;
    }
    function c(R, he) {
      if (!R || it) return "";
      var pe = Tt.get(R);
      if (pe !== void 0) return pe;
      it = !0, pe = Error.prepareStackTrace, Error.prepareStackTrace = void 0;
      var De = null;
      De = ne.H, ne.H = null, s();
      try {
        var Je = {
          DetermineComponentFrameRoot: function() {
            try {
              if (he) {
                var Qt = function() {
                  throw Error();
                };
                if (Object.defineProperty(Qt.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Qt, []);
                  } catch (Kt) {
                    var jr = Kt;
                  }
                  Reflect.construct(R, [], Qt);
                } else {
                  try {
                    Qt.call();
                  } catch (Kt) {
                    jr = Kt;
                  }
                  R.call(Qt.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (Kt) {
                  jr = Kt;
                }
                (Qt = R()) && typeof Qt.catch == "function" && Qt.catch(function() {
                });
              }
            } catch (Kt) {
              if (Kt && jr && typeof Kt.stack == "string")
                return [Kt.stack, jr.stack];
            }
            return [null, null];
          }
        };
        Je.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var Ge = Object.getOwnPropertyDescriptor(
          Je.DetermineComponentFrameRoot,
          "name"
        );
        Ge && Ge.configurable && Object.defineProperty(
          Je.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var ke = Je.DetermineComponentFrameRoot(), xe = ke[0], zt = ke[1];
        if (xe && zt) {
          var xt = xe.split(`
`), Wt = zt.split(`
`);
          for (ke = Ge = 0; Ge < xt.length && !xt[Ge].includes(
            "DetermineComponentFrameRoot"
          ); )
            Ge++;
          for (; ke < Wt.length && !Wt[ke].includes(
            "DetermineComponentFrameRoot"
          ); )
            ke++;
          if (Ge === xt.length || ke === Wt.length)
            for (Ge = xt.length - 1, ke = Wt.length - 1; 1 <= Ge && 0 <= ke && xt[Ge] !== Wt[ke]; )
              ke--;
          for (; 1 <= Ge && 0 <= ke; Ge--, ke--)
            if (xt[Ge] !== Wt[ke]) {
              if (Ge !== 1 || ke !== 1)
                do
                  if (Ge--, ke--, 0 > ke || xt[Ge] !== Wt[ke]) {
                    var Er = `
` + xt[Ge].replace(
                      " at new ",
                      " at "
                    );
                    return R.displayName && Er.includes("<anonymous>") && (Er = Er.replace("<anonymous>", R.displayName)), typeof R == "function" && Tt.set(R, Er), Er;
                  }
                while (1 <= Ge && 0 <= ke);
              break;
            }
        }
      } finally {
        it = !1, ne.H = De, i(), Error.prepareStackTrace = pe;
      }
      return xt = (xt = R ? R.displayName || R.name : "") ? a(xt) : "", typeof R == "function" && Tt.set(R, xt), xt;
    }
    function u(R) {
      if (R == null) return "";
      if (typeof R == "function") {
        var he = R.prototype;
        return c(
          R,
          !(!he || !he.isReactComponent)
        );
      }
      if (typeof R == "string") return a(R);
      switch (R) {
        case G:
          return a("Suspense");
        case K:
          return a("SuspenseList");
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case Z:
            return R = c(R.render, !1), R;
          case oe:
            return u(R.type);
          case ve:
            he = R._payload, R = R._init;
            try {
              return u(R(he));
            } catch {
            }
        }
      return "";
    }
    function h() {
      var R = ne.A;
      return R === null ? null : R.getOwner();
    }
    function d(R) {
      if (I.call(R, "key")) {
        var he = Object.getOwnPropertyDescriptor(R, "key").get;
        if (he && he.isReactWarning) return !1;
      }
      return R.key !== void 0;
    }
    function p(R, he) {
      function pe() {
        tt || (tt = !0, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          he
        ));
      }
      pe.isReactWarning = !0, Object.defineProperty(R, "key", {
        get: pe,
        configurable: !0
      });
    }
    function g() {
      var R = r(this.type);
      return It[R] || (It[R] = !0, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      )), R = this.props.ref, R !== void 0 ? R : null;
    }
    function v(R, he, pe, De, Je, Ge) {
      return pe = Ge.ref, R = {
        $$typeof: A,
        type: R,
        key: he,
        props: Ge,
        _owner: Je
      }, (pe !== void 0 ? pe : null) !== null ? Object.defineProperty(R, "ref", {
        enumerable: !1,
        get: g
      }) : Object.defineProperty(R, "ref", { enumerable: !1, value: null }), R._store = {}, Object.defineProperty(R._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      }), Object.defineProperty(R, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      }), Object.freeze && (Object.freeze(R.props), Object.freeze(R)), R;
    }
    function b(R, he, pe, De, Je, Ge) {
      if (typeof R == "string" || typeof R == "function" || R === F || R === B || R === U || R === G || R === K || R === Q || typeof R == "object" && R !== null && (R.$$typeof === ve || R.$$typeof === oe || R.$$typeof === Y || R.$$typeof === X || R.$$typeof === Z || R.$$typeof === ce || R.getModuleId !== void 0)) {
        var ke = he.children;
        if (ke !== void 0)
          if (De)
            if (fe(ke)) {
              for (De = 0; De < ke.length; De++)
                _(ke[De], R);
              Object.freeze && Object.freeze(ke);
            } else
              console.error(
                "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
              );
          else _(ke, R);
      } else
        ke = "", (R === void 0 || typeof R == "object" && R !== null && Object.keys(R).length === 0) && (ke += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), R === null ? De = "null" : fe(R) ? De = "array" : R !== void 0 && R.$$typeof === A ? (De = "<" + (r(R.type) || "Unknown") + " />", ke = " Did you accidentally export a JSX literal instead of a component?") : De = typeof R, console.error(
          "React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",
          De,
          ke
        );
      if (I.call(he, "key")) {
        ke = r(R);
        var xe = Object.keys(he).filter(function(xt) {
          return xt !== "key";
        });
        De = 0 < xe.length ? "{key: someKey, " + xe.join(": ..., ") + ": ...}" : "{key: someKey}", Gr[ke + De] || (xe = 0 < xe.length ? "{" + xe.join(": ..., ") + ": ...}" : "{}", console.error(
          `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
          De,
          ke,
          xe,
          ke
        ), Gr[ke + De] = !0);
      }
      if (ke = null, pe !== void 0 && (t(pe), ke = "" + pe), d(he) && (t(he.key), ke = "" + he.key), "key" in he) {
        pe = {};
        for (var zt in he)
          zt !== "key" && (pe[zt] = he[zt]);
      } else pe = he;
      return ke && p(
        pe,
        typeof R == "function" ? R.displayName || R.name || "Unknown" : R
      ), v(R, ke, Ge, Je, h(), pe);
    }
    function _(R, he) {
      if (typeof R == "object" && R && R.$$typeof !== Tr) {
        if (fe(R))
          for (var pe = 0; pe < R.length; pe++) {
            var De = R[pe];
            C(De) && T(De, he);
          }
        else if (C(R))
          R._store && (R._store.validated = 1);
        else if (R === null || typeof R != "object" ? pe = null : (pe = ge && R[ge] || R["@@iterator"], pe = typeof pe == "function" ? pe : null), typeof pe == "function" && pe !== R.entries && (pe = pe.call(R), pe !== R))
          for (; !(R = pe.next()).done; )
            C(R.value) && T(R.value, he);
      }
    }
    function C(R) {
      return typeof R == "object" && R !== null && R.$$typeof === A;
    }
    function T(R, he) {
      if (R._store && !R._store.validated && R.key == null && (R._store.validated = 1, he = k(he), !sr[he])) {
        sr[he] = !0;
        var pe = "";
        R && R._owner != null && R._owner !== h() && (pe = null, typeof R._owner.tag == "number" ? pe = r(R._owner.type) : typeof R._owner.name == "string" && (pe = R._owner.name), pe = " It was passed a child from " + pe + ".");
        var De = ne.getCurrentStack;
        ne.getCurrentStack = function() {
          var Je = u(R.type);
          return De && (Je += De() || ""), Je;
        }, console.error(
          'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
          he,
          pe
        ), ne.getCurrentStack = De;
      }
    }
    function k(R) {
      var he = "", pe = h();
      return pe && (pe = r(pe.type)) && (he = `

Check the render method of \`` + pe + "`."), he || (R = r(R)) && (he = `

Check the top-level render call using <` + R + ">."), he;
    }
    var M = m, A = Symbol.for("react.transitional.element"), D = Symbol.for("react.portal"), F = Symbol.for("react.fragment"), U = Symbol.for("react.strict_mode"), B = Symbol.for("react.profiler"), X = Symbol.for("react.consumer"), Y = Symbol.for("react.context"), Z = Symbol.for("react.forward_ref"), G = Symbol.for("react.suspense"), K = Symbol.for("react.suspense_list"), oe = Symbol.for("react.memo"), ve = Symbol.for("react.lazy"), Q = Symbol.for("react.offscreen"), ge = Symbol.iterator, de = Symbol.for("react.client.reference"), ne = M.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, I = Object.prototype.hasOwnProperty, W = Object.assign, ce = Symbol.for("react.client.reference"), fe = Array.isArray, be = 0, ye, ue, Xe, We, bt, wt, Vt;
    n.__reactDisabledLog = !0;
    var Ce, qt, it = !1, Tt = new (typeof WeakMap == "function" ? WeakMap : Map)(), Tr = Symbol.for("react.client.reference"), tt, It = {}, Gr = {}, sr = {};
    ea.Fragment = F, ea.jsx = function(R, he, pe, De, Je) {
      return b(R, he, pe, !1, De, Je);
    }, ea.jsxs = function(R, he, pe, De, Je) {
      return b(R, he, pe, !0, De, Je);
    };
  }()), ea;
}
process.env.NODE_ENV === "production" ? _d.exports = xO() : _d.exports = TO();
var w = _d.exports;
function wv(r, e) {
  if (typeof r == "function")
    return r(e);
  r != null && (r.current = e);
}
function _y(...r) {
  return (e) => {
    let t = !1;
    const n = r.map((s) => {
      const i = wv(s, e);
      return !t && typeof i == "function" && (t = !0), i;
    });
    if (t)
      return () => {
        for (let s = 0; s < n.length; s++) {
          const i = n[s];
          typeof i == "function" ? i() : wv(r[s], null);
        }
      };
  };
}
function xr(...r) {
  return m.useCallback(_y(...r), r);
}
var ao = m.forwardRef((r, e) => {
  const { children: t, ...n } = r, s = m.Children.toArray(t), i = s.find(kO);
  if (i) {
    const a = i.props.children, c = s.map((u) => u === i ? m.Children.count(a) > 1 ? m.Children.only(null) : m.isValidElement(a) ? a.props.children : null : u);
    return /* @__PURE__ */ w.jsx(Cd, { ...n, ref: e, children: m.isValidElement(a) ? m.cloneElement(a, void 0, c) : null });
  }
  return /* @__PURE__ */ w.jsx(Cd, { ...n, ref: e, children: t });
});
ao.displayName = "Slot";
var Cd = m.forwardRef((r, e) => {
  const { children: t, ...n } = r;
  if (m.isValidElement(t)) {
    const s = MO(t), i = OO(n, t.props);
    return t.type !== m.Fragment && (i.ref = e ? _y(e, s) : s), m.cloneElement(t, i);
  }
  return m.Children.count(t) > 1 ? m.Children.only(null) : null;
});
Cd.displayName = "SlotClone";
var EO = ({ children: r }) => /* @__PURE__ */ w.jsx(w.Fragment, { children: r });
function kO(r) {
  return m.isValidElement(r) && r.type === EO;
}
function OO(r, e) {
  const t = { ...e };
  for (const n in e) {
    const s = r[n], i = e[n];
    /^on[A-Z]/.test(n) ? s && i ? t[n] = (...c) => {
      i(...c), s(...c);
    } : s && (t[n] = s) : n === "style" ? t[n] = { ...s, ...i } : n === "className" && (t[n] = [s, i].filter(Boolean).join(" "));
  }
  return { ...r, ...t };
}
function MO(r) {
  let e = Object.getOwnPropertyDescriptor(r.props, "ref")?.get, t = e && "isReactWarning" in e && e.isReactWarning;
  return t ? r.ref : (e = Object.getOwnPropertyDescriptor(r, "ref")?.get, t = e && "isReactWarning" in e && e.isReactWarning, t ? r.props.ref : r.props.ref || r.ref);
}
var AO = ao;
function Sy(r) {
  var e, t, n = "";
  if (typeof r == "string" || typeof r == "number") n += r;
  else if (typeof r == "object") if (Array.isArray(r)) {
    var s = r.length;
    for (e = 0; e < s; e++) r[e] && (t = Sy(r[e])) && (n && (n += " "), n += t);
  } else for (t in r) r[t] && (n && (n += " "), n += t);
  return n;
}
function Cy() {
  for (var r, e, t = 0, n = "", s = arguments.length; t < s; t++) (r = arguments[t]) && (e = Sy(r)) && (n && (n += " "), n += e);
  return n;
}
const xv = (r) => typeof r == "boolean" ? `${r}` : r === 0 ? "0" : r, _v = Cy, IO = (r, e) => (t) => {
  var n;
  if (e?.variants == null) return _v(r, t?.class, t?.className);
  const { variants: s, defaultVariants: i } = e, a = Object.keys(s).map((h) => {
    const d = t?.[h], p = i?.[h];
    if (d === null) return null;
    const g = xv(d) || xv(p);
    return s[h][g];
  }), c = t && Object.entries(t).reduce((h, d) => {
    let [p, g] = d;
    return g === void 0 || (h[p] = g), h;
  }, {}), u = e == null || (n = e.compoundVariants) === null || n === void 0 ? void 0 : n.reduce((h, d) => {
    let { class: p, className: g, ...v } = d;
    return Object.entries(v).every((b) => {
      let [_, C] = b;
      return Array.isArray(C) ? C.includes({
        ...i,
        ...c
      }[_]) : {
        ...i,
        ...c
      }[_] === C;
    }) ? [
      ...h,
      p,
      g
    ] : h;
  }, []);
  return _v(r, a, u, t?.class, t?.className);
}, kf = "-", PO = (r) => {
  const e = RO(r), {
    conflictingClassGroups: t,
    conflictingClassGroupModifiers: n
  } = r;
  return {
    getClassGroupId: (a) => {
      const c = a.split(kf);
      return c[0] === "" && c.length !== 1 && c.shift(), Ty(c, e) || DO(a);
    },
    getConflictingClassGroupIds: (a, c) => {
      const u = t[a] || [];
      return c && n[a] ? [...u, ...n[a]] : u;
    }
  };
}, Ty = (r, e) => {
  if (r.length === 0)
    return e.classGroupId;
  const t = r[0], n = e.nextPart.get(t), s = n ? Ty(r.slice(1), n) : void 0;
  if (s)
    return s;
  if (e.validators.length === 0)
    return;
  const i = r.join(kf);
  return e.validators.find(({
    validator: a
  }) => a(i))?.classGroupId;
}, Sv = /^\[(.+)\]$/, DO = (r) => {
  if (Sv.test(r)) {
    const e = Sv.exec(r)[1], t = e?.substring(0, e.indexOf(":"));
    if (t)
      return "arbitrary.." + t;
  }
}, RO = (r) => {
  const {
    theme: e,
    prefix: t
  } = r, n = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return LO(Object.entries(r.classGroups), t).forEach(([i, a]) => {
    Td(a, n, i, e);
  }), n;
}, Td = (r, e, t, n) => {
  r.forEach((s) => {
    if (typeof s == "string") {
      const i = s === "" ? e : Cv(e, s);
      i.classGroupId = t;
      return;
    }
    if (typeof s == "function") {
      if (jO(s)) {
        Td(s(n), e, t, n);
        return;
      }
      e.validators.push({
        validator: s,
        classGroupId: t
      });
      return;
    }
    Object.entries(s).forEach(([i, a]) => {
      Td(a, Cv(e, i), t, n);
    });
  });
}, Cv = (r, e) => {
  let t = r;
  return e.split(kf).forEach((n) => {
    t.nextPart.has(n) || t.nextPart.set(n, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), t = t.nextPart.get(n);
  }), t;
}, jO = (r) => r.isThemeGetter, LO = (r, e) => e ? r.map(([t, n]) => {
  const s = n.map((i) => typeof i == "string" ? e + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(([a, c]) => [e + a, c])) : i);
  return [t, s];
}) : r, FO = (r) => {
  if (r < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  const s = (i, a) => {
    t.set(i, a), e++, e > r && (e = 0, n = t, t = /* @__PURE__ */ new Map());
  };
  return {
    get(i) {
      let a = t.get(i);
      if (a !== void 0)
        return a;
      if ((a = n.get(i)) !== void 0)
        return s(i, a), a;
    },
    set(i, a) {
      t.has(i) ? t.set(i, a) : s(i, a);
    }
  };
}, Ey = "!", NO = (r) => {
  const {
    separator: e,
    experimentalParseClassName: t
  } = r, n = e.length === 1, s = e[0], i = e.length, a = (c) => {
    const u = [];
    let h = 0, d = 0, p;
    for (let C = 0; C < c.length; C++) {
      let T = c[C];
      if (h === 0) {
        if (T === s && (n || c.slice(C, C + i) === e)) {
          u.push(c.slice(d, C)), d = C + i;
          continue;
        }
        if (T === "/") {
          p = C;
          continue;
        }
      }
      T === "[" ? h++ : T === "]" && h--;
    }
    const g = u.length === 0 ? c : c.substring(d), v = g.startsWith(Ey), b = v ? g.substring(1) : g, _ = p && p > d ? p - d : void 0;
    return {
      modifiers: u,
      hasImportantModifier: v,
      baseClassName: b,
      maybePostfixModifierPosition: _
    };
  };
  return t ? (c) => t({
    className: c,
    parseClassName: a
  }) : a;
}, BO = (r) => {
  if (r.length <= 1)
    return r;
  const e = [];
  let t = [];
  return r.forEach((n) => {
    n[0] === "[" ? (e.push(...t.sort(), n), t = []) : t.push(n);
  }), e.push(...t.sort()), e;
}, VO = (r) => ({
  cache: FO(r.cacheSize),
  parseClassName: NO(r),
  ...PO(r)
}), zO = /\s+/, WO = (r, e) => {
  const {
    parseClassName: t,
    getClassGroupId: n,
    getConflictingClassGroupIds: s
  } = e, i = [], a = r.trim().split(zO);
  let c = "";
  for (let u = a.length - 1; u >= 0; u -= 1) {
    const h = a[u], {
      modifiers: d,
      hasImportantModifier: p,
      baseClassName: g,
      maybePostfixModifierPosition: v
    } = t(h);
    let b = !!v, _ = n(b ? g.substring(0, v) : g);
    if (!_) {
      if (!b) {
        c = h + (c.length > 0 ? " " + c : c);
        continue;
      }
      if (_ = n(g), !_) {
        c = h + (c.length > 0 ? " " + c : c);
        continue;
      }
      b = !1;
    }
    const C = BO(d).join(":"), T = p ? C + Ey : C, k = T + _;
    if (i.includes(k))
      continue;
    i.push(k);
    const M = s(_, b);
    for (let A = 0; A < M.length; ++A) {
      const D = M[A];
      i.push(T + D);
    }
    c = h + (c.length > 0 ? " " + c : c);
  }
  return c;
};
function HO() {
  let r = 0, e, t, n = "";
  for (; r < arguments.length; )
    (e = arguments[r++]) && (t = ky(e)) && (n && (n += " "), n += t);
  return n;
}
const ky = (r) => {
  if (typeof r == "string")
    return r;
  let e, t = "";
  for (let n = 0; n < r.length; n++)
    r[n] && (e = ky(r[n])) && (t && (t += " "), t += e);
  return t;
};
function UO(r, ...e) {
  let t, n, s, i = a;
  function a(u) {
    const h = e.reduce((d, p) => p(d), r());
    return t = VO(h), n = t.cache.get, s = t.cache.set, i = c, c(u);
  }
  function c(u) {
    const h = n(u);
    if (h)
      return h;
    const d = WO(u, t);
    return s(u, d), d;
  }
  return function() {
    return i(HO.apply(null, arguments));
  };
}
const pt = (r) => {
  const e = (t) => t[r] || [];
  return e.isThemeGetter = !0, e;
}, Oy = /^\[(?:([a-z-]+):)?(.+)\]$/i, $O = /^\d+\/\d+$/, YO = /* @__PURE__ */ new Set(["px", "full", "screen"]), XO = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, GO = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, qO = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, KO = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, ZO = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Zn = (r) => so(r) || YO.has(r) || $O.test(r), xs = (r) => po(r, "length", iM), so = (r) => !!r && !Number.isNaN(Number(r)), $h = (r) => po(r, "number", so), ta = (r) => !!r && Number.isInteger(Number(r)), JO = (r) => r.endsWith("%") && so(r.slice(0, -1)), Ne = (r) => Oy.test(r), _s = (r) => XO.test(r), QO = /* @__PURE__ */ new Set(["length", "size", "percentage"]), eM = (r) => po(r, QO, My), tM = (r) => po(r, "position", My), rM = /* @__PURE__ */ new Set(["image", "url"]), nM = (r) => po(r, rM, aM), sM = (r) => po(r, "", oM), ra = () => !0, po = (r, e, t) => {
  const n = Oy.exec(r);
  return n ? n[1] ? typeof e == "string" ? n[1] === e : e.has(n[1]) : t(n[2]) : !1;
}, iM = (r) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  GO.test(r) && !qO.test(r)
), My = () => !1, oM = (r) => KO.test(r), aM = (r) => ZO.test(r), cM = () => {
  const r = pt("colors"), e = pt("spacing"), t = pt("blur"), n = pt("brightness"), s = pt("borderColor"), i = pt("borderRadius"), a = pt("borderSpacing"), c = pt("borderWidth"), u = pt("contrast"), h = pt("grayscale"), d = pt("hueRotate"), p = pt("invert"), g = pt("gap"), v = pt("gradientColorStops"), b = pt("gradientColorStopPositions"), _ = pt("inset"), C = pt("margin"), T = pt("opacity"), k = pt("padding"), M = pt("saturate"), A = pt("scale"), D = pt("sepia"), F = pt("skew"), U = pt("space"), B = pt("translate"), X = () => ["auto", "contain", "none"], Y = () => ["auto", "hidden", "clip", "visible", "scroll"], Z = () => ["auto", Ne, e], G = () => [Ne, e], K = () => ["", Zn, xs], oe = () => ["auto", so, Ne], ve = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], Q = () => ["solid", "dashed", "dotted", "double", "none"], ge = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], de = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], ne = () => ["", "0", Ne], I = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], W = () => [so, Ne];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [ra],
      spacing: [Zn, xs],
      blur: ["none", "", _s, Ne],
      brightness: W(),
      borderColor: [r],
      borderRadius: ["none", "", "full", _s, Ne],
      borderSpacing: G(),
      borderWidth: K(),
      contrast: W(),
      grayscale: ne(),
      hueRotate: W(),
      invert: ne(),
      gap: G(),
      gradientColorStops: [r],
      gradientColorStopPositions: [JO, xs],
      inset: Z(),
      margin: Z(),
      opacity: W(),
      padding: G(),
      saturate: W(),
      scale: W(),
      sepia: ne(),
      skew: W(),
      space: G(),
      translate: G()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", Ne]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [_s]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": I()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": I()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...ve(), Ne]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: Y()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": Y()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": Y()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: X()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": X()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": X()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [_]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [_]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [_]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [_]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [_]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [_]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [_]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [_]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [_]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", ta, Ne]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: Z()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", Ne]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ne()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ne()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", ta, Ne]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [ra]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", ta, Ne]
        }, Ne]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": oe()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": oe()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [ra]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [ta, Ne]
        }, Ne]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": oe()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": oe()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", Ne]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", Ne]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [g]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [g]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [g]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...de()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...de(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...de(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [k]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [k]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [k]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [k]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [k]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [k]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [k]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [k]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [k]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [C]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [C]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [C]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [C]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [C]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [C]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [C]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [C]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [C]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [U]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [U]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Ne, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [Ne, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [Ne, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [_s]
        }, _s]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [Ne, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [Ne, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [Ne, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [Ne, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", _s, xs]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", $h]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [ra]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Ne]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", so, $h]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Zn, Ne]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Ne]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", Ne]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [r]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [T]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [r]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [T]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...Q(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", Zn, xs]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", Zn, Ne]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [r]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: G()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Ne]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Ne]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [T]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...ve(), tM]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", eM]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, nM]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [r]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [b]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [b]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [b]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [v]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [v]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [v]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [i]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [i]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [i]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [i]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [i]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [i]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [i]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [i]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [i]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [i]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [i]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [i]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [i]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [i]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [i]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [c]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [c]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [c]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [c]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [c]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [c]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [c]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [c]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [c]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [T]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...Q(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [c]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [c]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [T]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: Q()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [s]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [s]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [s]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [s]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [s]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [s]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [s]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [s]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [s]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [s]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...Q()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Zn, Ne]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [Zn, xs]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [r]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: K()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [r]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [T]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [Zn, xs]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [r]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", _s, sM]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [ra]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [T]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...ge(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": ge()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [t]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [n]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [u]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", _s, Ne]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [h]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [d]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [p]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [M]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [D]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [t]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [n]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [u]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [h]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [d]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [p]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [T]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [M]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [D]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [a]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [a]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [a]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Ne]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: W()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", Ne]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: W()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", Ne]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [A]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [A]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [A]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [ta, Ne]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [B]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [B]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [F]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [F]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Ne]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", r]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Ne]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [r]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": G()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": G()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": G()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": G()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": G()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": G()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": G()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": G()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": G()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": G()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": G()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": G()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": G()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": G()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": G()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": G()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": G()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": G()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Ne]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [r, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Zn, xs, $h]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [r, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, lM = /* @__PURE__ */ UO(cM);
function _i(...r) {
  return lM(Cy(r));
}
function qF(r, e = {}) {
  const { decimals: t = 0, sizeType: n = "normal" } = e, s = ["Bytes", "KB", "MB", "GB", "TB"], i = ["Bytes", "KiB", "MiB", "GiB", "TiB"];
  if (r === 0) return "0 Byte";
  const a = Math.floor(Math.log(r) / Math.log(1024));
  return `${(r / Math.pow(1024, a)).toFixed(t)} ${n === "accurate" ? i[a] ?? "Bytest" : s[a] ?? "Bytes"}`;
}
const uM = IO(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), br = m.forwardRef(
  ({ className: r, variant: e, size: t, asChild: n = !1, ...s }, i) => {
    const a = n ? ao : "button";
    return /* @__PURE__ */ w.jsx(
      a,
      {
        className: _i(uM({ variant: e, size: t, className: r })),
        ref: i,
        ...s
      }
    );
  }
);
br.displayName = "Button";
function Of(r, [e, t]) {
  return Math.min(t, Math.max(e, r));
}
function Ot(r, e, { checkForDefaultPrevented: t = !0 } = {}) {
  return function(s) {
    if (r?.(s), t === !1 || !s.defaultPrevented)
      return e?.(s);
  };
}
function Ra(r, e = []) {
  let t = [];
  function n(i, a) {
    const c = m.createContext(a), u = t.length;
    t = [...t, a];
    const h = (p) => {
      const { scope: g, children: v, ...b } = p, _ = g?.[r]?.[u] || c, C = m.useMemo(() => b, Object.values(b));
      return /* @__PURE__ */ w.jsx(_.Provider, { value: C, children: v });
    };
    h.displayName = i + "Provider";
    function d(p, g) {
      const v = g?.[r]?.[u] || c, b = m.useContext(v);
      if (b) return b;
      if (a !== void 0) return a;
      throw new Error(`\`${p}\` must be used within \`${i}\``);
    }
    return [h, d];
  }
  const s = () => {
    const i = t.map((a) => m.createContext(a));
    return function(c) {
      const u = c?.[r] || i;
      return m.useMemo(
        () => ({ [`__scope${r}`]: { ...c, [r]: u } }),
        [c, u]
      );
    };
  };
  return s.scopeName = r, [n, hM(s, ...e)];
}
function hM(...r) {
  const e = r[0];
  if (r.length === 1) return e;
  const t = () => {
    const n = r.map((s) => ({
      useScope: s(),
      scopeName: s.scopeName
    }));
    return function(i) {
      const a = n.reduce((c, { useScope: u, scopeName: h }) => {
        const p = u(i)[`__scope${h}`];
        return { ...c, ...p };
      }, {});
      return m.useMemo(() => ({ [`__scope${e.scopeName}`]: a }), [a]);
    };
  };
  return t.scopeName = e.scopeName, t;
}
function Mn(r) {
  const e = m.useRef(r);
  return m.useEffect(() => {
    e.current = r;
  }), m.useMemo(() => (...t) => e.current?.(...t), []);
}
function Mf({
  prop: r,
  defaultProp: e,
  onChange: t = () => {
  }
}) {
  const [n, s] = dM({ defaultProp: e, onChange: t }), i = r !== void 0, a = i ? r : n, c = Mn(t), u = m.useCallback(
    (h) => {
      if (i) {
        const p = typeof h == "function" ? h(r) : h;
        p !== r && c(p);
      } else
        s(h);
    },
    [i, r, s, c]
  );
  return [a, u];
}
function dM({
  defaultProp: r,
  onChange: e
}) {
  const t = m.useState(r), [n] = t, s = m.useRef(n), i = Mn(e);
  return m.useEffect(() => {
    s.current !== n && (i(n), s.current = n);
  }, [n, s, i]), t;
}
var fM = m.createContext(void 0);
function Xl(r) {
  const e = m.useContext(fM);
  return r || e || "ltr";
}
function pM(r) {
  const e = m.useRef({ value: r, previous: r });
  return m.useMemo(() => (e.current.value !== r && (e.current.previous = e.current.value, e.current.value = r), e.current.previous), [r]);
}
var xa = globalThis?.document ? m.useLayoutEffect : () => {
};
function gM(r) {
  const [e, t] = m.useState(void 0);
  return xa(() => {
    if (r) {
      t({ width: r.offsetWidth, height: r.offsetHeight });
      const n = new ResizeObserver((s) => {
        if (!Array.isArray(s) || !s.length)
          return;
        const i = s[0];
        let a, c;
        if ("borderBoxSize" in i) {
          const u = i.borderBoxSize, h = Array.isArray(u) ? u[0] : u;
          a = h.inlineSize, c = h.blockSize;
        } else
          a = r.offsetWidth, c = r.offsetHeight;
        t({ width: a, height: c });
      });
      return n.observe(r, { box: "border-box" }), () => n.unobserve(r);
    } else
      t(void 0);
  }, [r]), e;
}
var Ed = { exports: {} }, cr = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Tv;
function mM() {
  if (Tv) return cr;
  Tv = 1;
  var r = m;
  function e(u) {
    var h = "https://react.dev/errors/" + u;
    if (1 < arguments.length) {
      h += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var d = 2; d < arguments.length; d++)
        h += "&args[]=" + encodeURIComponent(arguments[d]);
    }
    return "Minified React error #" + u + "; visit " + h + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function t() {
  }
  var n = {
    d: {
      f: t,
      r: function() {
        throw Error(e(522));
      },
      D: t,
      C: t,
      L: t,
      m: t,
      X: t,
      S: t,
      M: t
    },
    p: 0,
    findDOMNode: null
  }, s = Symbol.for("react.portal");
  function i(u, h, d) {
    var p = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: s,
      key: p == null ? null : "" + p,
      children: u,
      containerInfo: h,
      implementation: d
    };
  }
  var a = r.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function c(u, h) {
    if (u === "font") return "";
    if (typeof h == "string")
      return h === "use-credentials" ? h : "";
  }
  return cr.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = n, cr.createPortal = function(u, h) {
    var d = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!h || h.nodeType !== 1 && h.nodeType !== 9 && h.nodeType !== 11)
      throw Error(e(299));
    return i(u, h, null, d);
  }, cr.flushSync = function(u) {
    var h = a.T, d = n.p;
    try {
      if (a.T = null, n.p = 2, u) return u();
    } finally {
      a.T = h, n.p = d, n.d.f();
    }
  }, cr.preconnect = function(u, h) {
    typeof u == "string" && (h ? (h = h.crossOrigin, h = typeof h == "string" ? h === "use-credentials" ? h : "" : void 0) : h = null, n.d.C(u, h));
  }, cr.prefetchDNS = function(u) {
    typeof u == "string" && n.d.D(u);
  }, cr.preinit = function(u, h) {
    if (typeof u == "string" && h && typeof h.as == "string") {
      var d = h.as, p = c(d, h.crossOrigin), g = typeof h.integrity == "string" ? h.integrity : void 0, v = typeof h.fetchPriority == "string" ? h.fetchPriority : void 0;
      d === "style" ? n.d.S(
        u,
        typeof h.precedence == "string" ? h.precedence : void 0,
        {
          crossOrigin: p,
          integrity: g,
          fetchPriority: v
        }
      ) : d === "script" && n.d.X(u, {
        crossOrigin: p,
        integrity: g,
        fetchPriority: v,
        nonce: typeof h.nonce == "string" ? h.nonce : void 0
      });
    }
  }, cr.preinitModule = function(u, h) {
    if (typeof u == "string")
      if (typeof h == "object" && h !== null) {
        if (h.as == null || h.as === "script") {
          var d = c(
            h.as,
            h.crossOrigin
          );
          n.d.M(u, {
            crossOrigin: d,
            integrity: typeof h.integrity == "string" ? h.integrity : void 0,
            nonce: typeof h.nonce == "string" ? h.nonce : void 0
          });
        }
      } else h == null && n.d.M(u);
  }, cr.preload = function(u, h) {
    if (typeof u == "string" && typeof h == "object" && h !== null && typeof h.as == "string") {
      var d = h.as, p = c(d, h.crossOrigin);
      n.d.L(u, d, {
        crossOrigin: p,
        integrity: typeof h.integrity == "string" ? h.integrity : void 0,
        nonce: typeof h.nonce == "string" ? h.nonce : void 0,
        type: typeof h.type == "string" ? h.type : void 0,
        fetchPriority: typeof h.fetchPriority == "string" ? h.fetchPriority : void 0,
        referrerPolicy: typeof h.referrerPolicy == "string" ? h.referrerPolicy : void 0,
        imageSrcSet: typeof h.imageSrcSet == "string" ? h.imageSrcSet : void 0,
        imageSizes: typeof h.imageSizes == "string" ? h.imageSizes : void 0,
        media: typeof h.media == "string" ? h.media : void 0
      });
    }
  }, cr.preloadModule = function(u, h) {
    if (typeof u == "string")
      if (h) {
        var d = c(h.as, h.crossOrigin);
        n.d.m(u, {
          as: typeof h.as == "string" && h.as !== "script" ? h.as : void 0,
          crossOrigin: d,
          integrity: typeof h.integrity == "string" ? h.integrity : void 0
        });
      } else n.d.m(u);
  }, cr.requestFormReset = function(u) {
    n.d.r(u);
  }, cr.unstable_batchedUpdates = function(u, h) {
    return u(h);
  }, cr.useFormState = function(u, h, d) {
    return a.H.useFormState(u, h, d);
  }, cr.useFormStatus = function() {
    return a.H.useHostTransitionStatus();
  }, cr.version = "19.0.0", cr;
}
var lr = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ev;
function vM() {
  return Ev || (Ev = 1, process.env.NODE_ENV !== "production" && function() {
    function r() {
    }
    function e(p) {
      return "" + p;
    }
    function t(p, g, v) {
      var b = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      try {
        e(b);
        var _ = !1;
      } catch {
        _ = !0;
      }
      return _ && (console.error(
        "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
        typeof Symbol == "function" && Symbol.toStringTag && b[Symbol.toStringTag] || b.constructor.name || "Object"
      ), e(b)), {
        $$typeof: h,
        key: b == null ? null : "" + b,
        children: p,
        containerInfo: g,
        implementation: v
      };
    }
    function n(p, g) {
      if (p === "font") return "";
      if (typeof g == "string")
        return g === "use-credentials" ? g : "";
    }
    function s(p) {
      return p === null ? "`null`" : p === void 0 ? "`undefined`" : p === "" ? "an empty string" : 'something with type "' + typeof p + '"';
    }
    function i(p) {
      return p === null ? "`null`" : p === void 0 ? "`undefined`" : p === "" ? "an empty string" : typeof p == "string" ? JSON.stringify(p) : typeof p == "number" ? "`" + p + "`" : 'something with type "' + typeof p + '"';
    }
    function a() {
      var p = d.H;
      return p === null && console.error(
        `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
      ), p;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var c = m, u = {
      d: {
        f: r,
        r: function() {
          throw Error(
            "Invalid form element. requestFormReset must be passed a form that was rendered by React."
          );
        },
        D: r,
        C: r,
        L: r,
        m: r,
        X: r,
        S: r,
        M: r
      },
      p: 0,
      findDOMNode: null
    }, h = Symbol.for("react.portal"), d = c.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    typeof Map == "function" && Map.prototype != null && typeof Map.prototype.forEach == "function" && typeof Set == "function" && Set.prototype != null && typeof Set.prototype.clear == "function" && typeof Set.prototype.forEach == "function" || console.error(
      "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
    ), lr.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = u, lr.createPortal = function(p, g) {
      var v = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!g || g.nodeType !== 1 && g.nodeType !== 9 && g.nodeType !== 11)
        throw Error("Target container is not a DOM element.");
      return t(p, g, null, v);
    }, lr.flushSync = function(p) {
      var g = d.T, v = u.p;
      try {
        if (d.T = null, u.p = 2, p)
          return p();
      } finally {
        d.T = g, u.p = v, u.d.f() && console.error(
          "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
        );
      }
    }, lr.preconnect = function(p, g) {
      typeof p == "string" && p ? g != null && typeof g != "object" ? console.error(
        "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
        i(g)
      ) : g != null && typeof g.crossOrigin != "string" && console.error(
        "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
        s(g.crossOrigin)
      ) : console.error(
        "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
        s(p)
      ), typeof p == "string" && (g ? (g = g.crossOrigin, g = typeof g == "string" ? g === "use-credentials" ? g : "" : void 0) : g = null, u.d.C(p, g));
    }, lr.prefetchDNS = function(p) {
      if (typeof p != "string" || !p)
        console.error(
          "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          s(p)
        );
      else if (1 < arguments.length) {
        var g = arguments[1];
        typeof g == "object" && g.hasOwnProperty("crossOrigin") ? console.error(
          "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
          i(g)
        ) : console.error(
          "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
          i(g)
        );
      }
      typeof p == "string" && u.d.D(p);
    }, lr.preinit = function(p, g) {
      if (typeof p == "string" && p ? g == null || typeof g != "object" ? console.error(
        "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
        i(g)
      ) : g.as !== "style" && g.as !== "script" && console.error(
        'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
        i(g.as)
      ) : console.error(
        "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
        s(p)
      ), typeof p == "string" && g && typeof g.as == "string") {
        var v = g.as, b = n(v, g.crossOrigin), _ = typeof g.integrity == "string" ? g.integrity : void 0, C = typeof g.fetchPriority == "string" ? g.fetchPriority : void 0;
        v === "style" ? u.d.S(
          p,
          typeof g.precedence == "string" ? g.precedence : void 0,
          {
            crossOrigin: b,
            integrity: _,
            fetchPriority: C
          }
        ) : v === "script" && u.d.X(p, {
          crossOrigin: b,
          integrity: _,
          fetchPriority: C,
          nonce: typeof g.nonce == "string" ? g.nonce : void 0
        });
      }
    }, lr.preinitModule = function(p, g) {
      var v = "";
      if (typeof p == "string" && p || (v += " The `href` argument encountered was " + s(p) + "."), g !== void 0 && typeof g != "object" ? v += " The `options` argument encountered was " + s(g) + "." : g && "as" in g && g.as !== "script" && (v += " The `as` option encountered was " + i(g.as) + "."), v)
        console.error(
          "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
          v
        );
      else
        switch (v = g && typeof g.as == "string" ? g.as : "script", v) {
          case "script":
            break;
          default:
            v = i(v), console.error(
              'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
              v,
              p
            );
        }
      typeof p == "string" && (typeof g == "object" && g !== null ? (g.as == null || g.as === "script") && (v = n(
        g.as,
        g.crossOrigin
      ), u.d.M(p, {
        crossOrigin: v,
        integrity: typeof g.integrity == "string" ? g.integrity : void 0,
        nonce: typeof g.nonce == "string" ? g.nonce : void 0
      })) : g == null && u.d.M(p));
    }, lr.preload = function(p, g) {
      var v = "";
      if (typeof p == "string" && p || (v += " The `href` argument encountered was " + s(p) + "."), g == null || typeof g != "object" ? v += " The `options` argument encountered was " + s(g) + "." : typeof g.as == "string" && g.as || (v += " The `as` option encountered was " + s(g.as) + "."), v && console.error(
        'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
        v
      ), typeof p == "string" && typeof g == "object" && g !== null && typeof g.as == "string") {
        v = g.as;
        var b = n(
          v,
          g.crossOrigin
        );
        u.d.L(p, v, {
          crossOrigin: b,
          integrity: typeof g.integrity == "string" ? g.integrity : void 0,
          nonce: typeof g.nonce == "string" ? g.nonce : void 0,
          type: typeof g.type == "string" ? g.type : void 0,
          fetchPriority: typeof g.fetchPriority == "string" ? g.fetchPriority : void 0,
          referrerPolicy: typeof g.referrerPolicy == "string" ? g.referrerPolicy : void 0,
          imageSrcSet: typeof g.imageSrcSet == "string" ? g.imageSrcSet : void 0,
          imageSizes: typeof g.imageSizes == "string" ? g.imageSizes : void 0,
          media: typeof g.media == "string" ? g.media : void 0
        });
      }
    }, lr.preloadModule = function(p, g) {
      var v = "";
      typeof p == "string" && p || (v += " The `href` argument encountered was " + s(p) + "."), g !== void 0 && typeof g != "object" ? v += " The `options` argument encountered was " + s(g) + "." : g && "as" in g && typeof g.as != "string" && (v += " The `as` option encountered was " + s(g.as) + "."), v && console.error(
        'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
        v
      ), typeof p == "string" && (g ? (v = n(
        g.as,
        g.crossOrigin
      ), u.d.m(p, {
        as: typeof g.as == "string" && g.as !== "script" ? g.as : void 0,
        crossOrigin: v,
        integrity: typeof g.integrity == "string" ? g.integrity : void 0
      })) : u.d.m(p));
    }, lr.requestFormReset = function(p) {
      u.d.r(p);
    }, lr.unstable_batchedUpdates = function(p, g) {
      return p(g);
    }, lr.useFormState = function(p, g, v) {
      return a().useFormState(p, g, v);
    }, lr.useFormStatus = function() {
      return a().useHostTransitionStatus();
    }, lr.version = "19.0.0", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), lr;
}
function Ay() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Ay);
    } catch (r) {
      console.error(r);
    }
  }
}
process.env.NODE_ENV === "production" ? (Ay(), Ed.exports = mM()) : Ed.exports = vM();
var kd = Ed.exports, yM = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], Cr = yM.reduce((r, e) => {
  const t = m.forwardRef((n, s) => {
    const { asChild: i, ...a } = n, c = i ? ao : e;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ w.jsx(c, { ...a, ref: s });
  });
  return t.displayName = `Primitive.${e}`, { ...r, [e]: t };
}, {});
function Iy(r) {
  const e = r + "CollectionProvider", [t, n] = Ra(e), [s, i] = t(
    e,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), a = (v) => {
    const { scope: b, children: _ } = v, C = Ie.useRef(null), T = Ie.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ w.jsx(s, { scope: b, itemMap: T, collectionRef: C, children: _ });
  };
  a.displayName = e;
  const c = r + "CollectionSlot", u = Ie.forwardRef(
    (v, b) => {
      const { scope: _, children: C } = v, T = i(c, _), k = xr(b, T.collectionRef);
      return /* @__PURE__ */ w.jsx(ao, { ref: k, children: C });
    }
  );
  u.displayName = c;
  const h = r + "CollectionItemSlot", d = "data-radix-collection-item", p = Ie.forwardRef(
    (v, b) => {
      const { scope: _, children: C, ...T } = v, k = Ie.useRef(null), M = xr(b, k), A = i(h, _);
      return Ie.useEffect(() => (A.itemMap.set(k, { ref: k, ...T }), () => void A.itemMap.delete(k))), /* @__PURE__ */ w.jsx(ao, { [d]: "", ref: M, children: C });
    }
  );
  p.displayName = h;
  function g(v) {
    const b = i(r + "CollectionConsumer", v);
    return Ie.useCallback(() => {
      const C = b.collectionRef.current;
      if (!C) return [];
      const T = Array.from(C.querySelectorAll(`[${d}]`));
      return Array.from(b.itemMap.values()).sort(
        (A, D) => T.indexOf(A.ref.current) - T.indexOf(D.ref.current)
      );
    }, [b.collectionRef, b.itemMap]);
  }
  return [
    { Provider: a, Slot: u, ItemSlot: p },
    g,
    n
  ];
}
var Py = ["PageUp", "PageDown"], Dy = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], Ry = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, go = "Slider", [Od, bM, wM] = Iy(go), [jy, KF] = Ra(go, [
  wM
]), [xM, Gl] = jy(go), Ly = m.forwardRef(
  (r, e) => {
    const {
      name: t,
      min: n = 0,
      max: s = 100,
      step: i = 1,
      orientation: a = "horizontal",
      disabled: c = !1,
      minStepsBetweenThumbs: u = 0,
      defaultValue: h = [n],
      value: d,
      onValueChange: p = () => {
      },
      onValueCommit: g = () => {
      },
      inverted: v = !1,
      form: b,
      ..._
    } = r, C = m.useRef(/* @__PURE__ */ new Set()), T = m.useRef(0), M = a === "horizontal" ? _M : SM, [A = [], D] = Mf({
      prop: d,
      defaultProp: h,
      onChange: (Z) => {
        [...C.current][T.current]?.focus(), p(Z);
      }
    }), F = m.useRef(A);
    function U(Z) {
      const G = OM(A, Z);
      Y(Z, G);
    }
    function B(Z) {
      Y(Z, T.current);
    }
    function X() {
      const Z = F.current[T.current];
      A[T.current] !== Z && g(A);
    }
    function Y(Z, G, { commit: K } = { commit: !1 }) {
      const oe = PM(i), ve = DM(Math.round((Z - n) / i) * i + n, oe), Q = Of(ve, [n, s]);
      D((ge = []) => {
        const de = EM(ge, Q, G);
        if (IM(de, u * i)) {
          T.current = de.indexOf(Q);
          const ne = String(de) !== String(ge);
          return ne && K && g(de), ne ? de : ge;
        } else
          return ge;
      });
    }
    return /* @__PURE__ */ w.jsx(
      xM,
      {
        scope: r.__scopeSlider,
        name: t,
        disabled: c,
        min: n,
        max: s,
        valueIndexToChangeRef: T,
        thumbs: C.current,
        values: A,
        orientation: a,
        form: b,
        children: /* @__PURE__ */ w.jsx(Od.Provider, { scope: r.__scopeSlider, children: /* @__PURE__ */ w.jsx(Od.Slot, { scope: r.__scopeSlider, children: /* @__PURE__ */ w.jsx(
          M,
          {
            "aria-disabled": c,
            "data-disabled": c ? "" : void 0,
            ..._,
            ref: e,
            onPointerDown: Ot(_.onPointerDown, () => {
              c || (F.current = A);
            }),
            min: n,
            max: s,
            inverted: v,
            onSlideStart: c ? void 0 : U,
            onSlideMove: c ? void 0 : B,
            onSlideEnd: c ? void 0 : X,
            onHomeKeyDown: () => !c && Y(n, 0, { commit: !0 }),
            onEndKeyDown: () => !c && Y(s, A.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: Z, direction: G }) => {
              if (!c) {
                const ve = Py.includes(Z.key) || Z.shiftKey && Dy.includes(Z.key) ? 10 : 1, Q = T.current, ge = A[Q], de = i * ve * G;
                Y(ge + de, Q, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
Ly.displayName = go;
var [Fy, Ny] = jy(go, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), _M = m.forwardRef(
  (r, e) => {
    const {
      min: t,
      max: n,
      dir: s,
      inverted: i,
      onSlideStart: a,
      onSlideMove: c,
      onSlideEnd: u,
      onStepKeyDown: h,
      ...d
    } = r, [p, g] = m.useState(null), v = xr(e, (M) => g(M)), b = m.useRef(void 0), _ = Xl(s), C = _ === "ltr", T = C && !i || !C && i;
    function k(M) {
      const A = b.current || p.getBoundingClientRect(), D = [0, A.width], U = Af(D, T ? [t, n] : [n, t]);
      return b.current = A, U(M - A.left);
    }
    return /* @__PURE__ */ w.jsx(
      Fy,
      {
        scope: r.__scopeSlider,
        startEdge: T ? "left" : "right",
        endEdge: T ? "right" : "left",
        direction: T ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ w.jsx(
          By,
          {
            dir: _,
            "data-orientation": "horizontal",
            ...d,
            ref: v,
            style: {
              ...d.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (M) => {
              const A = k(M.clientX);
              a?.(A);
            },
            onSlideMove: (M) => {
              const A = k(M.clientX);
              c?.(A);
            },
            onSlideEnd: () => {
              b.current = void 0, u?.();
            },
            onStepKeyDown: (M) => {
              const D = Ry[T ? "from-left" : "from-right"].includes(M.key);
              h?.({ event: M, direction: D ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), SM = m.forwardRef(
  (r, e) => {
    const {
      min: t,
      max: n,
      inverted: s,
      onSlideStart: i,
      onSlideMove: a,
      onSlideEnd: c,
      onStepKeyDown: u,
      ...h
    } = r, d = m.useRef(null), p = xr(e, d), g = m.useRef(void 0), v = !s;
    function b(_) {
      const C = g.current || d.current.getBoundingClientRect(), T = [0, C.height], M = Af(T, v ? [n, t] : [t, n]);
      return g.current = C, M(_ - C.top);
    }
    return /* @__PURE__ */ w.jsx(
      Fy,
      {
        scope: r.__scopeSlider,
        startEdge: v ? "bottom" : "top",
        endEdge: v ? "top" : "bottom",
        size: "height",
        direction: v ? 1 : -1,
        children: /* @__PURE__ */ w.jsx(
          By,
          {
            "data-orientation": "vertical",
            ...h,
            ref: p,
            style: {
              ...h.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (_) => {
              const C = b(_.clientY);
              i?.(C);
            },
            onSlideMove: (_) => {
              const C = b(_.clientY);
              a?.(C);
            },
            onSlideEnd: () => {
              g.current = void 0, c?.();
            },
            onStepKeyDown: (_) => {
              const T = Ry[v ? "from-bottom" : "from-top"].includes(_.key);
              u?.({ event: _, direction: T ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), By = m.forwardRef(
  (r, e) => {
    const {
      __scopeSlider: t,
      onSlideStart: n,
      onSlideMove: s,
      onSlideEnd: i,
      onHomeKeyDown: a,
      onEndKeyDown: c,
      onStepKeyDown: u,
      ...h
    } = r, d = Gl(go, t);
    return /* @__PURE__ */ w.jsx(
      Cr.span,
      {
        ...h,
        ref: e,
        onKeyDown: Ot(r.onKeyDown, (p) => {
          p.key === "Home" ? (a(p), p.preventDefault()) : p.key === "End" ? (c(p), p.preventDefault()) : Py.concat(Dy).includes(p.key) && (u(p), p.preventDefault());
        }),
        onPointerDown: Ot(r.onPointerDown, (p) => {
          const g = p.target;
          g.setPointerCapture(p.pointerId), p.preventDefault(), d.thumbs.has(g) ? g.focus() : n(p);
        }),
        onPointerMove: Ot(r.onPointerMove, (p) => {
          p.target.hasPointerCapture(p.pointerId) && s(p);
        }),
        onPointerUp: Ot(r.onPointerUp, (p) => {
          const g = p.target;
          g.hasPointerCapture(p.pointerId) && (g.releasePointerCapture(p.pointerId), i(p));
        })
      }
    );
  }
), Vy = "SliderTrack", zy = m.forwardRef(
  (r, e) => {
    const { __scopeSlider: t, ...n } = r, s = Gl(Vy, t);
    return /* @__PURE__ */ w.jsx(
      Cr.span,
      {
        "data-disabled": s.disabled ? "" : void 0,
        "data-orientation": s.orientation,
        ...n,
        ref: e
      }
    );
  }
);
zy.displayName = Vy;
var Md = "SliderRange", Wy = m.forwardRef(
  (r, e) => {
    const { __scopeSlider: t, ...n } = r, s = Gl(Md, t), i = Ny(Md, t), a = m.useRef(null), c = xr(e, a), u = s.values.length, h = s.values.map(
      (g) => Uy(g, s.min, s.max)
    ), d = u > 1 ? Math.min(...h) : 0, p = 100 - Math.max(...h);
    return /* @__PURE__ */ w.jsx(
      Cr.span,
      {
        "data-orientation": s.orientation,
        "data-disabled": s.disabled ? "" : void 0,
        ...n,
        ref: c,
        style: {
          ...r.style,
          [i.startEdge]: d + "%",
          [i.endEdge]: p + "%"
        }
      }
    );
  }
);
Wy.displayName = Md;
var Ad = "SliderThumb", Hy = m.forwardRef(
  (r, e) => {
    const t = bM(r.__scopeSlider), [n, s] = m.useState(null), i = xr(e, (c) => s(c)), a = m.useMemo(
      () => n ? t().findIndex((c) => c.ref.current === n) : -1,
      [t, n]
    );
    return /* @__PURE__ */ w.jsx(CM, { ...r, ref: i, index: a });
  }
), CM = m.forwardRef(
  (r, e) => {
    const { __scopeSlider: t, index: n, name: s, ...i } = r, a = Gl(Ad, t), c = Ny(Ad, t), [u, h] = m.useState(null), d = xr(e, (k) => h(k)), p = u ? a.form || !!u.closest("form") : !0, g = gM(u), v = a.values[n], b = v === void 0 ? 0 : Uy(v, a.min, a.max), _ = kM(n, a.values.length), C = g?.[c.size], T = C ? MM(C, b, c.direction) : 0;
    return m.useEffect(() => {
      if (u)
        return a.thumbs.add(u), () => {
          a.thumbs.delete(u);
        };
    }, [u, a.thumbs]), /* @__PURE__ */ w.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [c.startEdge]: `calc(${b}% + ${T}px)`
        },
        children: [
          /* @__PURE__ */ w.jsx(Od.ItemSlot, { scope: r.__scopeSlider, children: /* @__PURE__ */ w.jsx(
            Cr.span,
            {
              role: "slider",
              "aria-label": r["aria-label"] || _,
              "aria-valuemin": a.min,
              "aria-valuenow": v,
              "aria-valuemax": a.max,
              "aria-orientation": a.orientation,
              "data-orientation": a.orientation,
              "data-disabled": a.disabled ? "" : void 0,
              tabIndex: a.disabled ? void 0 : 0,
              ...i,
              ref: d,
              style: v === void 0 ? { display: "none" } : r.style,
              onFocus: Ot(r.onFocus, () => {
                a.valueIndexToChangeRef.current = n;
              })
            }
          ) }),
          p && /* @__PURE__ */ w.jsx(
            TM,
            {
              name: s ?? (a.name ? a.name + (a.values.length > 1 ? "[]" : "") : void 0),
              form: a.form,
              value: v
            },
            n
          )
        ]
      }
    );
  }
);
Hy.displayName = Ad;
var TM = (r) => {
  const { value: e, ...t } = r, n = m.useRef(null), s = pM(e);
  return m.useEffect(() => {
    const i = n.current, a = window.HTMLInputElement.prototype, u = Object.getOwnPropertyDescriptor(a, "value").set;
    if (s !== e && u) {
      const h = new Event("input", { bubbles: !0 });
      u.call(i, e), i.dispatchEvent(h);
    }
  }, [s, e]), /* @__PURE__ */ w.jsx("input", { style: { display: "none" }, ...t, ref: n, defaultValue: e });
};
function EM(r = [], e, t) {
  const n = [...r];
  return n[t] = e, n.sort((s, i) => s - i);
}
function Uy(r, e, t) {
  const i = 100 / (t - e) * (r - e);
  return Of(i, [0, 100]);
}
function kM(r, e) {
  return e > 2 ? `Value ${r + 1} of ${e}` : e === 2 ? ["Minimum", "Maximum"][r] : void 0;
}
function OM(r, e) {
  if (r.length === 1) return 0;
  const t = r.map((s) => Math.abs(s - e)), n = Math.min(...t);
  return t.indexOf(n);
}
function MM(r, e, t) {
  const n = r / 2, i = Af([0, 50], [0, n]);
  return (n - i(e) * t) * t;
}
function AM(r) {
  return r.slice(0, -1).map((e, t) => r[t + 1] - e);
}
function IM(r, e) {
  if (e > 0) {
    const t = AM(r);
    return Math.min(...t) >= e;
  }
  return !0;
}
function Af(r, e) {
  return (t) => {
    if (r[0] === r[1] || e[0] === e[1]) return e[0];
    const n = (e[1] - e[0]) / (r[1] - r[0]);
    return e[0] + n * (t - r[0]);
  };
}
function PM(r) {
  return (String(r).split(".")[1] || "").length;
}
function DM(r, e) {
  const t = Math.pow(10, e);
  return Math.round(r * t) / t;
}
var $y = Ly, RM = zy, jM = Wy, LM = Hy;
const FM = m.forwardRef(({ className: r, ...e }, t) => /* @__PURE__ */ w.jsxs(
  $y,
  {
    ref: t,
    className: _i(
      "relative flex w-full touch-none select-none items-center",
      r
    ),
    ...e,
    children: [
      /* @__PURE__ */ w.jsx(RM, { className: "relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20", children: /* @__PURE__ */ w.jsx(jM, { className: "absolute h-full bg-primary" }) }),
      /* @__PURE__ */ w.jsx(LM, { className: "block h-4 w-4 cursor-pointer rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-0 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50" })
    ]
  }
));
FM.displayName = $y.displayName;
function NM(r, e) {
  return m.useReducer((t, n) => e[t][n] ?? t, r);
}
var mo = (r) => {
  const { present: e, children: t } = r, n = BM(e), s = typeof t == "function" ? t({ present: n.isPresent }) : m.Children.only(t), i = xr(n.ref, VM(s));
  return typeof t == "function" || n.isPresent ? m.cloneElement(s, { ref: i }) : null;
};
mo.displayName = "Presence";
function BM(r) {
  const [e, t] = m.useState(), n = m.useRef({}), s = m.useRef(r), i = m.useRef("none"), a = r ? "mounted" : "unmounted", [c, u] = NM(a, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return m.useEffect(() => {
    const h = Lc(n.current);
    i.current = c === "mounted" ? h : "none";
  }, [c]), xa(() => {
    const h = n.current, d = s.current;
    if (d !== r) {
      const g = i.current, v = Lc(h);
      r ? u("MOUNT") : v === "none" || h?.display === "none" ? u("UNMOUNT") : u(d && g !== v ? "ANIMATION_OUT" : "UNMOUNT"), s.current = r;
    }
  }, [r, u]), xa(() => {
    if (e) {
      let h;
      const d = e.ownerDocument.defaultView ?? window, p = (v) => {
        const _ = Lc(n.current).includes(v.animationName);
        if (v.target === e && _ && (u("ANIMATION_END"), !s.current)) {
          const C = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", h = d.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = C);
          });
        }
      }, g = (v) => {
        v.target === e && (i.current = Lc(n.current));
      };
      return e.addEventListener("animationstart", g), e.addEventListener("animationcancel", p), e.addEventListener("animationend", p), () => {
        d.clearTimeout(h), e.removeEventListener("animationstart", g), e.removeEventListener("animationcancel", p), e.removeEventListener("animationend", p);
      };
    } else
      u("ANIMATION_END");
  }, [e, u]), {
    isPresent: ["mounted", "unmountSuspended"].includes(c),
    ref: m.useCallback((h) => {
      h && (n.current = getComputedStyle(h)), t(h);
    }, [])
  };
}
function Lc(r) {
  return r?.animationName || "none";
}
function VM(r) {
  let e = Object.getOwnPropertyDescriptor(r.props, "ref")?.get, t = e && "isReactWarning" in e && e.isReactWarning;
  return t ? r.ref : (e = Object.getOwnPropertyDescriptor(r, "ref")?.get, t = e && "isReactWarning" in e && e.isReactWarning, t ? r.props.ref : r.props.ref || r.ref);
}
function zM(r, e) {
  return m.useReducer((t, n) => e[t][n] ?? t, r);
}
var If = "ScrollArea", [Yy, ZF] = Ra(If), [WM, ln] = Yy(If), Xy = m.forwardRef(
  (r, e) => {
    const {
      __scopeScrollArea: t,
      type: n = "hover",
      dir: s,
      scrollHideDelay: i = 600,
      ...a
    } = r, [c, u] = m.useState(null), [h, d] = m.useState(null), [p, g] = m.useState(null), [v, b] = m.useState(null), [_, C] = m.useState(null), [T, k] = m.useState(0), [M, A] = m.useState(0), [D, F] = m.useState(!1), [U, B] = m.useState(!1), X = xr(e, (Z) => u(Z)), Y = Xl(s);
    return /* @__PURE__ */ w.jsx(
      WM,
      {
        scope: t,
        type: n,
        dir: Y,
        scrollHideDelay: i,
        scrollArea: c,
        viewport: h,
        onViewportChange: d,
        content: p,
        onContentChange: g,
        scrollbarX: v,
        onScrollbarXChange: b,
        scrollbarXEnabled: D,
        onScrollbarXEnabledChange: F,
        scrollbarY: _,
        onScrollbarYChange: C,
        scrollbarYEnabled: U,
        onScrollbarYEnabledChange: B,
        onCornerWidthChange: k,
        onCornerHeightChange: A,
        children: /* @__PURE__ */ w.jsx(
          Cr.div,
          {
            dir: Y,
            ...a,
            ref: X,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": T + "px",
              "--radix-scroll-area-corner-height": M + "px",
              ...r.style
            }
          }
        )
      }
    );
  }
);
Xy.displayName = If;
var Gy = "ScrollAreaViewport", qy = m.forwardRef(
  (r, e) => {
    const { __scopeScrollArea: t, children: n, nonce: s, ...i } = r, a = ln(Gy, t), c = m.useRef(null), u = xr(e, c, a.onViewportChange);
    return /* @__PURE__ */ w.jsxs(w.Fragment, { children: [
      /* @__PURE__ */ w.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: s
        }
      ),
      /* @__PURE__ */ w.jsx(
        Cr.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...i,
          ref: u,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: a.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: a.scrollbarYEnabled ? "scroll" : "hidden",
            ...r.style
          },
          children: /* @__PURE__ */ w.jsx("div", { ref: a.onContentChange, style: { minWidth: "100%", display: "table" }, children: n })
        }
      )
    ] });
  }
);
qy.displayName = Gy;
var Bn = "ScrollAreaScrollbar", ql = m.forwardRef(
  (r, e) => {
    const { forceMount: t, ...n } = r, s = ln(Bn, r.__scopeScrollArea), { onScrollbarXEnabledChange: i, onScrollbarYEnabledChange: a } = s, c = r.orientation === "horizontal";
    return m.useEffect(() => (c ? i(!0) : a(!0), () => {
      c ? i(!1) : a(!1);
    }), [c, i, a]), s.type === "hover" ? /* @__PURE__ */ w.jsx(HM, { ...n, ref: e, forceMount: t }) : s.type === "scroll" ? /* @__PURE__ */ w.jsx(UM, { ...n, ref: e, forceMount: t }) : s.type === "auto" ? /* @__PURE__ */ w.jsx(Ky, { ...n, ref: e, forceMount: t }) : s.type === "always" ? /* @__PURE__ */ w.jsx(Pf, { ...n, ref: e }) : null;
  }
);
ql.displayName = Bn;
var HM = m.forwardRef((r, e) => {
  const { forceMount: t, ...n } = r, s = ln(Bn, r.__scopeScrollArea), [i, a] = m.useState(!1);
  return m.useEffect(() => {
    const c = s.scrollArea;
    let u = 0;
    if (c) {
      const h = () => {
        window.clearTimeout(u), a(!0);
      }, d = () => {
        u = window.setTimeout(() => a(!1), s.scrollHideDelay);
      };
      return c.addEventListener("pointerenter", h), c.addEventListener("pointerleave", d), () => {
        window.clearTimeout(u), c.removeEventListener("pointerenter", h), c.removeEventListener("pointerleave", d);
      };
    }
  }, [s.scrollArea, s.scrollHideDelay]), /* @__PURE__ */ w.jsx(mo, { present: t || i, children: /* @__PURE__ */ w.jsx(
    Ky,
    {
      "data-state": i ? "visible" : "hidden",
      ...n,
      ref: e
    }
  ) });
}), UM = m.forwardRef((r, e) => {
  const { forceMount: t, ...n } = r, s = ln(Bn, r.__scopeScrollArea), i = r.orientation === "horizontal", a = Zl(() => u("SCROLL_END"), 100), [c, u] = zM("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return m.useEffect(() => {
    if (c === "idle") {
      const h = window.setTimeout(() => u("HIDE"), s.scrollHideDelay);
      return () => window.clearTimeout(h);
    }
  }, [c, s.scrollHideDelay, u]), m.useEffect(() => {
    const h = s.viewport, d = i ? "scrollLeft" : "scrollTop";
    if (h) {
      let p = h[d];
      const g = () => {
        const v = h[d];
        p !== v && (u("SCROLL"), a()), p = v;
      };
      return h.addEventListener("scroll", g), () => h.removeEventListener("scroll", g);
    }
  }, [s.viewport, i, u, a]), /* @__PURE__ */ w.jsx(mo, { present: t || c !== "hidden", children: /* @__PURE__ */ w.jsx(
    Pf,
    {
      "data-state": c === "hidden" ? "hidden" : "visible",
      ...n,
      ref: e,
      onPointerEnter: Ot(r.onPointerEnter, () => u("POINTER_ENTER")),
      onPointerLeave: Ot(r.onPointerLeave, () => u("POINTER_LEAVE"))
    }
  ) });
}), Ky = m.forwardRef((r, e) => {
  const t = ln(Bn, r.__scopeScrollArea), { forceMount: n, ...s } = r, [i, a] = m.useState(!1), c = r.orientation === "horizontal", u = Zl(() => {
    if (t.viewport) {
      const h = t.viewport.offsetWidth < t.viewport.scrollWidth, d = t.viewport.offsetHeight < t.viewport.scrollHeight;
      a(c ? h : d);
    }
  }, 10);
  return co(t.viewport, u), co(t.content, u), /* @__PURE__ */ w.jsx(mo, { present: n || i, children: /* @__PURE__ */ w.jsx(
    Pf,
    {
      "data-state": i ? "visible" : "hidden",
      ...s,
      ref: e
    }
  ) });
}), Pf = m.forwardRef((r, e) => {
  const { orientation: t = "vertical", ...n } = r, s = ln(Bn, r.__scopeScrollArea), i = m.useRef(null), a = m.useRef(0), [c, u] = m.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), h = e1(c.viewport, c.content), d = {
    ...n,
    sizes: c,
    onSizesChange: u,
    hasThumb: h > 0 && h < 1,
    onThumbChange: (g) => i.current = g,
    onThumbPointerUp: () => a.current = 0,
    onThumbPointerDown: (g) => a.current = g
  };
  function p(g, v) {
    return KM(g, a.current, c, v);
  }
  return t === "horizontal" ? /* @__PURE__ */ w.jsx(
    $M,
    {
      ...d,
      ref: e,
      onThumbPositionChange: () => {
        if (s.viewport && i.current) {
          const g = s.viewport.scrollLeft, v = kv(g, c, s.dir);
          i.current.style.transform = `translate3d(${v}px, 0, 0)`;
        }
      },
      onWheelScroll: (g) => {
        s.viewport && (s.viewport.scrollLeft = g);
      },
      onDragScroll: (g) => {
        s.viewport && (s.viewport.scrollLeft = p(g, s.dir));
      }
    }
  ) : t === "vertical" ? /* @__PURE__ */ w.jsx(
    YM,
    {
      ...d,
      ref: e,
      onThumbPositionChange: () => {
        if (s.viewport && i.current) {
          const g = s.viewport.scrollTop, v = kv(g, c);
          i.current.style.transform = `translate3d(0, ${v}px, 0)`;
        }
      },
      onWheelScroll: (g) => {
        s.viewport && (s.viewport.scrollTop = g);
      },
      onDragScroll: (g) => {
        s.viewport && (s.viewport.scrollTop = p(g));
      }
    }
  ) : null;
}), $M = m.forwardRef((r, e) => {
  const { sizes: t, onSizesChange: n, ...s } = r, i = ln(Bn, r.__scopeScrollArea), [a, c] = m.useState(), u = m.useRef(null), h = xr(e, u, i.onScrollbarXChange);
  return m.useEffect(() => {
    u.current && c(getComputedStyle(u.current));
  }, [u]), /* @__PURE__ */ w.jsx(
    Jy,
    {
      "data-orientation": "horizontal",
      ...s,
      ref: h,
      sizes: t,
      style: {
        bottom: 0,
        left: i.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: i.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": Kl(t) + "px",
        ...r.style
      },
      onThumbPointerDown: (d) => r.onThumbPointerDown(d.x),
      onDragScroll: (d) => r.onDragScroll(d.x),
      onWheelScroll: (d, p) => {
        if (i.viewport) {
          const g = i.viewport.scrollLeft + d.deltaX;
          r.onWheelScroll(g), r1(g, p) && d.preventDefault();
        }
      },
      onResize: () => {
        u.current && i.viewport && a && n({
          content: i.viewport.scrollWidth,
          viewport: i.viewport.offsetWidth,
          scrollbar: {
            size: u.current.clientWidth,
            paddingStart: yl(a.paddingLeft),
            paddingEnd: yl(a.paddingRight)
          }
        });
      }
    }
  );
}), YM = m.forwardRef((r, e) => {
  const { sizes: t, onSizesChange: n, ...s } = r, i = ln(Bn, r.__scopeScrollArea), [a, c] = m.useState(), u = m.useRef(null), h = xr(e, u, i.onScrollbarYChange);
  return m.useEffect(() => {
    u.current && c(getComputedStyle(u.current));
  }, [u]), /* @__PURE__ */ w.jsx(
    Jy,
    {
      "data-orientation": "vertical",
      ...s,
      ref: h,
      sizes: t,
      style: {
        top: 0,
        right: i.dir === "ltr" ? 0 : void 0,
        left: i.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": Kl(t) + "px",
        ...r.style
      },
      onThumbPointerDown: (d) => r.onThumbPointerDown(d.y),
      onDragScroll: (d) => r.onDragScroll(d.y),
      onWheelScroll: (d, p) => {
        if (i.viewport) {
          const g = i.viewport.scrollTop + d.deltaY;
          r.onWheelScroll(g), r1(g, p) && d.preventDefault();
        }
      },
      onResize: () => {
        u.current && i.viewport && a && n({
          content: i.viewport.scrollHeight,
          viewport: i.viewport.offsetHeight,
          scrollbar: {
            size: u.current.clientHeight,
            paddingStart: yl(a.paddingTop),
            paddingEnd: yl(a.paddingBottom)
          }
        });
      }
    }
  );
}), [XM, Zy] = Yy(Bn), Jy = m.forwardRef((r, e) => {
  const {
    __scopeScrollArea: t,
    sizes: n,
    hasThumb: s,
    onThumbChange: i,
    onThumbPointerUp: a,
    onThumbPointerDown: c,
    onThumbPositionChange: u,
    onDragScroll: h,
    onWheelScroll: d,
    onResize: p,
    ...g
  } = r, v = ln(Bn, t), [b, _] = m.useState(null), C = xr(e, (X) => _(X)), T = m.useRef(null), k = m.useRef(""), M = v.viewport, A = n.content - n.viewport, D = Mn(d), F = Mn(u), U = Zl(p, 10);
  function B(X) {
    if (T.current) {
      const Y = X.clientX - T.current.left, Z = X.clientY - T.current.top;
      h({ x: Y, y: Z });
    }
  }
  return m.useEffect(() => {
    const X = (Y) => {
      const Z = Y.target;
      b?.contains(Z) && D(Y, A);
    };
    return document.addEventListener("wheel", X, { passive: !1 }), () => document.removeEventListener("wheel", X, { passive: !1 });
  }, [M, b, A, D]), m.useEffect(F, [n, F]), co(b, U), co(v.content, U), /* @__PURE__ */ w.jsx(
    XM,
    {
      scope: t,
      scrollbar: b,
      hasThumb: s,
      onThumbChange: Mn(i),
      onThumbPointerUp: Mn(a),
      onThumbPositionChange: F,
      onThumbPointerDown: Mn(c),
      children: /* @__PURE__ */ w.jsx(
        Cr.div,
        {
          ...g,
          ref: C,
          style: { position: "absolute", ...g.style },
          onPointerDown: Ot(r.onPointerDown, (X) => {
            X.button === 0 && (X.target.setPointerCapture(X.pointerId), T.current = b.getBoundingClientRect(), k.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", v.viewport && (v.viewport.style.scrollBehavior = "auto"), B(X));
          }),
          onPointerMove: Ot(r.onPointerMove, B),
          onPointerUp: Ot(r.onPointerUp, (X) => {
            const Y = X.target;
            Y.hasPointerCapture(X.pointerId) && Y.releasePointerCapture(X.pointerId), document.body.style.webkitUserSelect = k.current, v.viewport && (v.viewport.style.scrollBehavior = ""), T.current = null;
          })
        }
      )
    }
  );
}), vl = "ScrollAreaThumb", Df = m.forwardRef(
  (r, e) => {
    const { forceMount: t, ...n } = r, s = Zy(vl, r.__scopeScrollArea);
    return /* @__PURE__ */ w.jsx(mo, { present: t || s.hasThumb, children: /* @__PURE__ */ w.jsx(GM, { ref: e, ...n }) });
  }
), GM = m.forwardRef(
  (r, e) => {
    const { __scopeScrollArea: t, style: n, ...s } = r, i = ln(vl, t), a = Zy(vl, t), { onThumbPositionChange: c } = a, u = xr(
      e,
      (p) => a.onThumbChange(p)
    ), h = m.useRef(void 0), d = Zl(() => {
      h.current && (h.current(), h.current = void 0);
    }, 100);
    return m.useEffect(() => {
      const p = i.viewport;
      if (p) {
        const g = () => {
          if (d(), !h.current) {
            const v = ZM(p, c);
            h.current = v, c();
          }
        };
        return c(), p.addEventListener("scroll", g), () => p.removeEventListener("scroll", g);
      }
    }, [i.viewport, d, c]), /* @__PURE__ */ w.jsx(
      Cr.div,
      {
        "data-state": a.hasThumb ? "visible" : "hidden",
        ...s,
        ref: u,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...n
        },
        onPointerDownCapture: Ot(r.onPointerDownCapture, (p) => {
          const v = p.target.getBoundingClientRect(), b = p.clientX - v.left, _ = p.clientY - v.top;
          a.onThumbPointerDown({ x: b, y: _ });
        }),
        onPointerUp: Ot(r.onPointerUp, a.onThumbPointerUp)
      }
    );
  }
);
Df.displayName = vl;
var Rf = "ScrollAreaCorner", Qy = m.forwardRef(
  (r, e) => {
    const t = ln(Rf, r.__scopeScrollArea), n = !!(t.scrollbarX && t.scrollbarY);
    return t.type !== "scroll" && n ? /* @__PURE__ */ w.jsx(qM, { ...r, ref: e }) : null;
  }
);
Qy.displayName = Rf;
var qM = m.forwardRef((r, e) => {
  const { __scopeScrollArea: t, ...n } = r, s = ln(Rf, t), [i, a] = m.useState(0), [c, u] = m.useState(0), h = !!(i && c);
  return co(s.scrollbarX, () => {
    const d = s.scrollbarX?.offsetHeight || 0;
    s.onCornerHeightChange(d), u(d);
  }), co(s.scrollbarY, () => {
    const d = s.scrollbarY?.offsetWidth || 0;
    s.onCornerWidthChange(d), a(d);
  }), h ? /* @__PURE__ */ w.jsx(
    Cr.div,
    {
      ...n,
      ref: e,
      style: {
        width: i,
        height: c,
        position: "absolute",
        right: s.dir === "ltr" ? 0 : void 0,
        left: s.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...r.style
      }
    }
  ) : null;
});
function yl(r) {
  return r ? parseInt(r, 10) : 0;
}
function e1(r, e) {
  const t = r / e;
  return isNaN(t) ? 0 : t;
}
function Kl(r) {
  const e = e1(r.viewport, r.content), t = r.scrollbar.paddingStart + r.scrollbar.paddingEnd, n = (r.scrollbar.size - t) * e;
  return Math.max(n, 18);
}
function KM(r, e, t, n = "ltr") {
  const s = Kl(t), i = s / 2, a = e || i, c = s - a, u = t.scrollbar.paddingStart + a, h = t.scrollbar.size - t.scrollbar.paddingEnd - c, d = t.content - t.viewport, p = n === "ltr" ? [0, d] : [d * -1, 0];
  return t1([u, h], p)(r);
}
function kv(r, e, t = "ltr") {
  const n = Kl(e), s = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, i = e.scrollbar.size - s, a = e.content - e.viewport, c = i - n, u = t === "ltr" ? [0, a] : [a * -1, 0], h = Of(r, u);
  return t1([0, a], [0, c])(h);
}
function t1(r, e) {
  return (t) => {
    if (r[0] === r[1] || e[0] === e[1]) return e[0];
    const n = (e[1] - e[0]) / (r[1] - r[0]);
    return e[0] + n * (t - r[0]);
  };
}
function r1(r, e) {
  return r > 0 && r < e;
}
var ZM = (r, e = () => {
}) => {
  let t = { left: r.scrollLeft, top: r.scrollTop }, n = 0;
  return function s() {
    const i = { left: r.scrollLeft, top: r.scrollTop }, a = t.left !== i.left, c = t.top !== i.top;
    (a || c) && e(), t = i, n = window.requestAnimationFrame(s);
  }(), () => window.cancelAnimationFrame(n);
};
function Zl(r, e) {
  const t = Mn(r), n = m.useRef(0);
  return m.useEffect(() => () => window.clearTimeout(n.current), []), m.useCallback(() => {
    window.clearTimeout(n.current), n.current = window.setTimeout(t, e);
  }, [t, e]);
}
function co(r, e) {
  const t = Mn(e);
  xa(() => {
    let n = 0;
    if (r) {
      const s = new ResizeObserver(() => {
        cancelAnimationFrame(n), n = window.requestAnimationFrame(t);
      });
      return s.observe(r), () => {
        window.cancelAnimationFrame(n), s.unobserve(r);
      };
    }
  }, [r, t]);
}
var bl = Xy, Id = qy, Ov = ql, Mv = Df, JM = Qy;
const vo = m.forwardRef(({ className: r, children: e, ...t }, n) => /* @__PURE__ */ w.jsxs(
  bl,
  {
    ref: n,
    className: _i("relative overflow-hidden", r),
    ...t,
    children: [
      /* @__PURE__ */ w.jsx(Id, { className: "h-full w-full rounded-[inherit]", children: e }),
      /* @__PURE__ */ w.jsx(n1, {}),
      /* @__PURE__ */ w.jsx(JM, {})
    ]
  }
));
vo.displayName = bl.displayName;
const n1 = m.forwardRef(({ className: r, orientation: e = "vertical", ...t }, n) => /* @__PURE__ */ w.jsx(
  ql,
  {
    ref: n,
    orientation: e,
    className: _i(
      "flex touch-none select-none transition-colors",
      e === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      e === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      r
    ),
    ...t,
    children: /* @__PURE__ */ w.jsx(Df, { className: "relative flex-1 rounded-full bg-border" })
  }
));
n1.displayName = ql.displayName;
const Jl = ({
  children: r,
  renderCustomPreview: e,
  data: t = {},
  shouldDisplayPreview: n = !0
}) => {
  const [s, i] = m.useState(!1), [a, c] = m.useState({ x: 0, y: 0 }), u = m.useRef(null), h = (v) => {
    i(!0), v.dataTransfer.setDragImage(new Image(), 0, 0), v.dataTransfer.setData(JSON.stringify(t), JSON.stringify(t)), c({
      x: v.clientX,
      y: v.clientY
    });
  }, d = () => {
    i(!1);
  }, p = (v) => {
    s && c({
      x: v.clientX,
      y: v.clientY
    });
  }, g = m.cloneElement(r, {
    draggable: !0,
    onDragStart: h,
    onDragEnd: d,
    onDrag: p,
    style: {
      ...r.props.style
    }
  });
  return /* @__PURE__ */ w.jsxs(w.Fragment, { children: [
    g,
    s && n && e ? kd.createPortal(
      /* @__PURE__ */ w.jsx(
        "div",
        {
          ref: u,
          style: {
            position: "fixed",
            left: a.x,
            top: a.y,
            pointerEvents: "none",
            zIndex: 9999,
            transform: "translate(-50%, -50%)"
            // Center the preview
          },
          children: e
        }
      ),
      document.body
    ) : null
  ] });
};
var QM = CO.useId || (() => {
}), eA = 0;
function s1(r) {
  const [e, t] = m.useState(QM());
  return xa(() => {
    t((n) => n ?? String(eA++));
  }, [r]), e ? `radix-${e}` : "";
}
var Yh = "rovingFocusGroup.onEntryFocus", tA = { bubbles: !1, cancelable: !0 }, Ql = "RovingFocusGroup", [Pd, i1, rA] = Iy(Ql), [nA, o1] = Ra(
  Ql,
  [rA]
), [sA, iA] = nA(Ql), a1 = m.forwardRef(
  (r, e) => /* @__PURE__ */ w.jsx(Pd.Provider, { scope: r.__scopeRovingFocusGroup, children: /* @__PURE__ */ w.jsx(Pd.Slot, { scope: r.__scopeRovingFocusGroup, children: /* @__PURE__ */ w.jsx(oA, { ...r, ref: e }) }) })
);
a1.displayName = Ql;
var oA = m.forwardRef((r, e) => {
  const {
    __scopeRovingFocusGroup: t,
    orientation: n,
    loop: s = !1,
    dir: i,
    currentTabStopId: a,
    defaultCurrentTabStopId: c,
    onCurrentTabStopIdChange: u,
    onEntryFocus: h,
    preventScrollOnEntryFocus: d = !1,
    ...p
  } = r, g = m.useRef(null), v = xr(e, g), b = Xl(i), [_ = null, C] = Mf({
    prop: a,
    defaultProp: c,
    onChange: u
  }), [T, k] = m.useState(!1), M = Mn(h), A = i1(t), D = m.useRef(!1), [F, U] = m.useState(0);
  return m.useEffect(() => {
    const B = g.current;
    if (B)
      return B.addEventListener(Yh, M), () => B.removeEventListener(Yh, M);
  }, [M]), /* @__PURE__ */ w.jsx(
    sA,
    {
      scope: t,
      orientation: n,
      dir: b,
      loop: s,
      currentTabStopId: _,
      onItemFocus: m.useCallback(
        (B) => C(B),
        [C]
      ),
      onItemShiftTab: m.useCallback(() => k(!0), []),
      onFocusableItemAdd: m.useCallback(
        () => U((B) => B + 1),
        []
      ),
      onFocusableItemRemove: m.useCallback(
        () => U((B) => B - 1),
        []
      ),
      children: /* @__PURE__ */ w.jsx(
        Cr.div,
        {
          tabIndex: T || F === 0 ? -1 : 0,
          "data-orientation": n,
          ...p,
          ref: v,
          style: { outline: "none", ...r.style },
          onMouseDown: Ot(r.onMouseDown, () => {
            D.current = !0;
          }),
          onFocus: Ot(r.onFocus, (B) => {
            const X = !D.current;
            if (B.target === B.currentTarget && X && !T) {
              const Y = new CustomEvent(Yh, tA);
              if (B.currentTarget.dispatchEvent(Y), !Y.defaultPrevented) {
                const Z = A().filter((Q) => Q.focusable), G = Z.find((Q) => Q.active), K = Z.find((Q) => Q.id === _), ve = [G, K, ...Z].filter(
                  Boolean
                ).map((Q) => Q.ref.current);
                u1(ve, d);
              }
            }
            D.current = !1;
          }),
          onBlur: Ot(r.onBlur, () => k(!1))
        }
      )
    }
  );
}), c1 = "RovingFocusGroupItem", l1 = m.forwardRef(
  (r, e) => {
    const {
      __scopeRovingFocusGroup: t,
      focusable: n = !0,
      active: s = !1,
      tabStopId: i,
      ...a
    } = r, c = s1(), u = i || c, h = iA(c1, t), d = h.currentTabStopId === u, p = i1(t), { onFocusableItemAdd: g, onFocusableItemRemove: v } = h;
    return m.useEffect(() => {
      if (n)
        return g(), () => v();
    }, [n, g, v]), /* @__PURE__ */ w.jsx(
      Pd.ItemSlot,
      {
        scope: t,
        id: u,
        focusable: n,
        active: s,
        children: /* @__PURE__ */ w.jsx(
          Cr.span,
          {
            tabIndex: d ? 0 : -1,
            "data-orientation": h.orientation,
            ...a,
            ref: e,
            onMouseDown: Ot(r.onMouseDown, (b) => {
              n ? h.onItemFocus(u) : b.preventDefault();
            }),
            onFocus: Ot(r.onFocus, () => h.onItemFocus(u)),
            onKeyDown: Ot(r.onKeyDown, (b) => {
              if (b.key === "Tab" && b.shiftKey) {
                h.onItemShiftTab();
                return;
              }
              if (b.target !== b.currentTarget) return;
              const _ = lA(b, h.orientation, h.dir);
              if (_ !== void 0) {
                if (b.metaKey || b.ctrlKey || b.altKey || b.shiftKey) return;
                b.preventDefault();
                let T = p().filter((k) => k.focusable).map((k) => k.ref.current);
                if (_ === "last") T.reverse();
                else if (_ === "prev" || _ === "next") {
                  _ === "prev" && T.reverse();
                  const k = T.indexOf(b.currentTarget);
                  T = h.loop ? uA(T, k + 1) : T.slice(k + 1);
                }
                setTimeout(() => u1(T));
              }
            })
          }
        )
      }
    );
  }
);
l1.displayName = c1;
var aA = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function cA(r, e) {
  return e !== "rtl" ? r : r === "ArrowLeft" ? "ArrowRight" : r === "ArrowRight" ? "ArrowLeft" : r;
}
function lA(r, e, t) {
  const n = cA(r.key, t);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(n)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(n)))
    return aA[n];
}
function u1(r, e = !1) {
  const t = document.activeElement;
  for (const n of r)
    if (n === t || (n.focus({ preventScroll: e }), document.activeElement !== t)) return;
}
function uA(r, e) {
  return r.map((t, n) => r[(e + n) % r.length]);
}
var hA = a1, dA = l1, jf = "Tabs", [fA, JF] = Ra(jf, [
  o1
]), h1 = o1(), [pA, Lf] = fA(jf), d1 = m.forwardRef(
  (r, e) => {
    const {
      __scopeTabs: t,
      value: n,
      onValueChange: s,
      defaultValue: i,
      orientation: a = "horizontal",
      dir: c,
      activationMode: u = "automatic",
      ...h
    } = r, d = Xl(c), [p, g] = Mf({
      prop: n,
      onChange: s,
      defaultProp: i
    });
    return /* @__PURE__ */ w.jsx(
      pA,
      {
        scope: t,
        baseId: s1(),
        value: p,
        onValueChange: g,
        orientation: a,
        dir: d,
        activationMode: u,
        children: /* @__PURE__ */ w.jsx(
          Cr.div,
          {
            dir: d,
            "data-orientation": a,
            ...h,
            ref: e
          }
        )
      }
    );
  }
);
d1.displayName = jf;
var f1 = "TabsList", p1 = m.forwardRef(
  (r, e) => {
    const { __scopeTabs: t, loop: n = !0, ...s } = r, i = Lf(f1, t), a = h1(t);
    return /* @__PURE__ */ w.jsx(
      hA,
      {
        asChild: !0,
        ...a,
        orientation: i.orientation,
        dir: i.dir,
        loop: n,
        children: /* @__PURE__ */ w.jsx(
          Cr.div,
          {
            role: "tablist",
            "aria-orientation": i.orientation,
            ...s,
            ref: e
          }
        )
      }
    );
  }
);
p1.displayName = f1;
var g1 = "TabsTrigger", m1 = m.forwardRef(
  (r, e) => {
    const { __scopeTabs: t, value: n, disabled: s = !1, ...i } = r, a = Lf(g1, t), c = h1(t), u = b1(a.baseId, n), h = w1(a.baseId, n), d = n === a.value;
    return /* @__PURE__ */ w.jsx(
      dA,
      {
        asChild: !0,
        ...c,
        focusable: !s,
        active: d,
        children: /* @__PURE__ */ w.jsx(
          Cr.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": d,
            "aria-controls": h,
            "data-state": d ? "active" : "inactive",
            "data-disabled": s ? "" : void 0,
            disabled: s,
            id: u,
            ...i,
            ref: e,
            onMouseDown: Ot(r.onMouseDown, (p) => {
              !s && p.button === 0 && p.ctrlKey === !1 ? a.onValueChange(n) : p.preventDefault();
            }),
            onKeyDown: Ot(r.onKeyDown, (p) => {
              [" ", "Enter"].includes(p.key) && a.onValueChange(n);
            }),
            onFocus: Ot(r.onFocus, () => {
              const p = a.activationMode !== "manual";
              !d && !s && p && a.onValueChange(n);
            })
          }
        )
      }
    );
  }
);
m1.displayName = g1;
var v1 = "TabsContent", y1 = m.forwardRef(
  (r, e) => {
    const { __scopeTabs: t, value: n, forceMount: s, children: i, ...a } = r, c = Lf(v1, t), u = b1(c.baseId, n), h = w1(c.baseId, n), d = n === c.value, p = m.useRef(d);
    return m.useEffect(() => {
      const g = requestAnimationFrame(() => p.current = !1);
      return () => cancelAnimationFrame(g);
    }, []), /* @__PURE__ */ w.jsx(mo, { present: s || d, children: ({ present: g }) => /* @__PURE__ */ w.jsx(
      Cr.div,
      {
        "data-state": d ? "active" : "inactive",
        "data-orientation": c.orientation,
        role: "tabpanel",
        "aria-labelledby": u,
        hidden: !g,
        id: h,
        tabIndex: 0,
        ...a,
        ref: e,
        style: {
          ...r.style,
          animationDuration: p.current ? "0s" : void 0
        },
        children: g && i
      }
    ) });
  }
);
y1.displayName = v1;
function b1(r, e) {
  return `${r}-trigger-${e}`;
}
function w1(r, e) {
  return `${r}-content-${e}`;
}
var gA = d1, x1 = p1, _1 = m1, S1 = y1;
const mA = gA, C1 = m.forwardRef(({ className: r, ...e }, t) => /* @__PURE__ */ w.jsx(
  x1,
  {
    ref: t,
    className: _i(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      r
    ),
    ...e
  }
));
C1.displayName = x1.displayName;
const Dd = m.forwardRef(({ className: r, ...e }, t) => /* @__PURE__ */ w.jsx(
  _1,
  {
    ref: t,
    className: _i(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      r
    ),
    ...e
  }
));
Dd.displayName = _1.displayName;
const Rd = m.forwardRef(({ className: r, ...e }, t) => /* @__PURE__ */ w.jsx(
  S1,
  {
    ref: t,
    className: _i(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      r
    ),
    ...e
  }
));
Rd.displayName = S1.displayName;
const QF = "add", e8 = "track", t8 = "trackItems", r8 = "track:changed", n8 = "trackItems:changed", s8 = "state", i8 = "state:changed", vA = "add", T1 = "add:text", ja = "add:video", La = "add:audio", o8 = "add:placeholder", Fa = "add:image", a8 = "add:mask", c8 = "add:transition", l8 = "add:animation", u8 = "edit", h8 = "edit:object", d8 = "edit:text", f8 = "edit:shape", p8 = "enterEditMode", g8 = "player", yA = "player:play", bA = "player:pause", m8 = "player:seek", v8 = "player:seekTo", y8 = "player:seekBy", b8 = "player:togglePlay", wA = "active", w8 = "active:set", E1 = "active:delete", x8 = "active:paste", k1 = "active:clone", O1 = "active:split", _8 = "layer", S8 = "layer:locked", C8 = "layer:hidden", T8 = "layer:move", E8 = "layer:select", xA = "layer:selection", k8 = "layer:sendTo", O8 = "layer:rename", M8 = "layer:editingName", A8 = "layer:copy", I8 = "layer:paste", P8 = "layer:clone", D8 = "layer:split", R8 = "layer:cut", j8 = "layer:delete", _A = "history", M1 = "history:undo", A1 = "history:redo", L8 = "history:reset", SA = "scale", I1 = "scale:changed", CA = "drag", P1 = "drag:start", wl = "drag:end", TA = "timeline", D1 = "timeline:boundingChanged";
var jd = function(r, e) {
  return jd = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]);
  }, jd(r, e);
};
function yo(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  jd(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function Ld(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], n = 0;
  if (t) return t.call(r);
  if (r && typeof r.length == "number") return {
    next: function() {
      return r && n >= r.length && (r = void 0), { value: r && r[n++], done: !r };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Fd(r, e) {
  var t = typeof Symbol == "function" && r[Symbol.iterator];
  if (!t) return r;
  var n = t.call(r), s, i = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(s = n.next()).done; ) i.push(s.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      s && !s.done && (t = n.return) && t.call(n);
    } finally {
      if (a) throw a.error;
    }
  }
  return i;
}
function Nd(r, e, t) {
  if (t || arguments.length === 2) for (var n = 0, s = e.length, i; n < s; n++)
    (i || !(n in e)) && (i || (i = Array.prototype.slice.call(e, 0, n)), i[n] = e[n]);
  return r.concat(i || Array.prototype.slice.call(e));
}
function Rn(r) {
  return typeof r == "function";
}
function R1(r) {
  var e = function(n) {
    Error.call(n), n.stack = new Error().stack;
  }, t = r(e);
  return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t;
}
var Xh = R1(function(r) {
  return function(t) {
    r(this), this.message = t ? t.length + ` errors occurred during unsubscription:
` + t.map(function(n, s) {
      return s + 1 + ") " + n.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = t;
  };
});
function Bd(r, e) {
  if (r) {
    var t = r.indexOf(e);
    0 <= t && r.splice(t, 1);
  }
}
var eu = function() {
  function r(e) {
    this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return r.prototype.unsubscribe = function() {
    var e, t, n, s, i;
    if (!this.closed) {
      this.closed = !0;
      var a = this._parentage;
      if (a)
        if (this._parentage = null, Array.isArray(a))
          try {
            for (var c = Ld(a), u = c.next(); !u.done; u = c.next()) {
              var h = u.value;
              h.remove(this);
            }
          } catch (_) {
            e = { error: _ };
          } finally {
            try {
              u && !u.done && (t = c.return) && t.call(c);
            } finally {
              if (e) throw e.error;
            }
          }
        else
          a.remove(this);
      var d = this.initialTeardown;
      if (Rn(d))
        try {
          d();
        } catch (_) {
          i = _ instanceof Xh ? _.errors : [_];
        }
      var p = this._finalizers;
      if (p) {
        this._finalizers = null;
        try {
          for (var g = Ld(p), v = g.next(); !v.done; v = g.next()) {
            var b = v.value;
            try {
              Av(b);
            } catch (_) {
              i = i ?? [], _ instanceof Xh ? i = Nd(Nd([], Fd(i)), Fd(_.errors)) : i.push(_);
            }
          }
        } catch (_) {
          n = { error: _ };
        } finally {
          try {
            v && !v.done && (s = g.return) && s.call(g);
          } finally {
            if (n) throw n.error;
          }
        }
      }
      if (i)
        throw new Xh(i);
    }
  }, r.prototype.add = function(e) {
    var t;
    if (e && e !== this)
      if (this.closed)
        Av(e);
      else {
        if (e instanceof r) {
          if (e.closed || e._hasParent(this))
            return;
          e._addParent(this);
        }
        (this._finalizers = (t = this._finalizers) !== null && t !== void 0 ? t : []).push(e);
      }
  }, r.prototype._hasParent = function(e) {
    var t = this._parentage;
    return t === e || Array.isArray(t) && t.includes(e);
  }, r.prototype._addParent = function(e) {
    var t = this._parentage;
    this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e;
  }, r.prototype._removeParent = function(e) {
    var t = this._parentage;
    t === e ? this._parentage = null : Array.isArray(t) && Bd(t, e);
  }, r.prototype.remove = function(e) {
    var t = this._finalizers;
    t && Bd(t, e), e instanceof r && e._removeParent(this);
  }, r.EMPTY = function() {
    var e = new r();
    return e.closed = !0, e;
  }(), r;
}(), j1 = eu.EMPTY;
function L1(r) {
  return r instanceof eu || r && "closed" in r && Rn(r.remove) && Rn(r.add) && Rn(r.unsubscribe);
}
function Av(r) {
  Rn(r) ? r() : r.unsubscribe();
}
var EA = {
  Promise: void 0
}, kA = {
  setTimeout: function(r, e) {
    for (var t = [], n = 2; n < arguments.length; n++)
      t[n - 2] = arguments[n];
    return setTimeout.apply(void 0, Nd([r, e], Fd(t)));
  },
  clearTimeout: function(r) {
    return clearTimeout(r);
  },
  delegate: void 0
};
function OA(r) {
  kA.setTimeout(function() {
    throw r;
  });
}
function Iv() {
}
function hl(r) {
  r();
}
var Ff = function(r) {
  yo(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n.isStopped = !1, t ? (n.destination = t, L1(t) && t.add(n)) : n.destination = IA, n;
  }
  return e.create = function(t, n, s) {
    return new Vd(t, n, s);
  }, e.prototype.next = function(t) {
    this.isStopped || this._next(t);
  }, e.prototype.error = function(t) {
    this.isStopped || (this.isStopped = !0, this._error(t));
  }, e.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, r.prototype.unsubscribe.call(this), this.destination = null);
  }, e.prototype._next = function(t) {
    this.destination.next(t);
  }, e.prototype._error = function(t) {
    try {
      this.destination.error(t);
    } finally {
      this.unsubscribe();
    }
  }, e.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, e;
}(eu), MA = function() {
  function r(e) {
    this.partialObserver = e;
  }
  return r.prototype.next = function(e) {
    var t = this.partialObserver;
    if (t.next)
      try {
        t.next(e);
      } catch (n) {
        Fc(n);
      }
  }, r.prototype.error = function(e) {
    var t = this.partialObserver;
    if (t.error)
      try {
        t.error(e);
      } catch (n) {
        Fc(n);
      }
    else
      Fc(e);
  }, r.prototype.complete = function() {
    var e = this.partialObserver;
    if (e.complete)
      try {
        e.complete();
      } catch (t) {
        Fc(t);
      }
  }, r;
}(), Vd = function(r) {
  yo(e, r);
  function e(t, n, s) {
    var i = r.call(this) || this, a;
    return Rn(t) || !t ? a = {
      next: t ?? void 0,
      error: n ?? void 0,
      complete: s ?? void 0
    } : a = t, i.destination = new MA(a), i;
  }
  return e;
}(Ff);
function Fc(r) {
  OA(r);
}
function AA(r) {
  throw r;
}
var IA = {
  closed: !0,
  next: Iv,
  error: AA,
  complete: Iv
}, PA = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function DA(r) {
  return r;
}
function RA(r) {
  return r.length === 0 ? DA : r.length === 1 ? r[0] : function(t) {
    return r.reduce(function(n, s) {
      return s(n);
    }, t);
  };
}
var Pv = function() {
  function r(e) {
    e && (this._subscribe = e);
  }
  return r.prototype.lift = function(e) {
    var t = new r();
    return t.source = this, t.operator = e, t;
  }, r.prototype.subscribe = function(e, t, n) {
    var s = this, i = LA(e) ? e : new Vd(e, t, n);
    return hl(function() {
      var a = s, c = a.operator, u = a.source;
      i.add(c ? c.call(i, u) : u ? s._subscribe(i) : s._trySubscribe(i));
    }), i;
  }, r.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (t) {
      e.error(t);
    }
  }, r.prototype.forEach = function(e, t) {
    var n = this;
    return t = Dv(t), new t(function(s, i) {
      var a = new Vd({
        next: function(c) {
          try {
            e(c);
          } catch (u) {
            i(u), a.unsubscribe();
          }
        },
        error: i,
        complete: s
      });
      n.subscribe(a);
    });
  }, r.prototype._subscribe = function(e) {
    var t;
    return (t = this.source) === null || t === void 0 ? void 0 : t.subscribe(e);
  }, r.prototype[PA] = function() {
    return this;
  }, r.prototype.pipe = function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    return RA(e)(this);
  }, r.prototype.toPromise = function(e) {
    var t = this;
    return e = Dv(e), new e(function(n, s) {
      var i;
      t.subscribe(function(a) {
        return i = a;
      }, function(a) {
        return s(a);
      }, function() {
        return n(i);
      });
    });
  }, r.create = function(e) {
    return new r(e);
  }, r;
}();
function Dv(r) {
  var e;
  return (e = r ?? EA.Promise) !== null && e !== void 0 ? e : Promise;
}
function jA(r) {
  return r && Rn(r.next) && Rn(r.error) && Rn(r.complete);
}
function LA(r) {
  return r && r instanceof Ff || jA(r) && L1(r);
}
function FA(r) {
  return Rn(r?.lift);
}
function NA(r) {
  return function(e) {
    if (FA(e))
      return e.lift(function(t) {
        try {
          return r(t, this);
        } catch (n) {
          this.error(n);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function BA(r, e, t, n, s) {
  return new VA(r, e, t, n, s);
}
var VA = function(r) {
  yo(e, r);
  function e(t, n, s, i, a, c) {
    var u = r.call(this, t) || this;
    return u.onFinalize = a, u.shouldUnsubscribe = c, u._next = n ? function(h) {
      try {
        n(h);
      } catch (d) {
        t.error(d);
      }
    } : r.prototype._next, u._error = i ? function(h) {
      try {
        i(h);
      } catch (d) {
        t.error(d);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._error, u._complete = s ? function() {
      try {
        s();
      } catch (h) {
        t.error(h);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._complete, u;
  }
  return e.prototype.unsubscribe = function() {
    var t;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var n = this.closed;
      r.prototype.unsubscribe.call(this), !n && ((t = this.onFinalize) === null || t === void 0 || t.call(this));
    }
  }, e;
}(Ff), zA = R1(function(r) {
  return function() {
    r(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), Nf = function(r) {
  yo(e, r);
  function e() {
    var t = r.call(this) || this;
    return t.closed = !1, t.currentObservers = null, t.observers = [], t.isStopped = !1, t.hasError = !1, t.thrownError = null, t;
  }
  return e.prototype.lift = function(t) {
    var n = new Rv(this, this);
    return n.operator = t, n;
  }, e.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new zA();
  }, e.prototype.next = function(t) {
    var n = this;
    hl(function() {
      var s, i;
      if (n._throwIfClosed(), !n.isStopped) {
        n.currentObservers || (n.currentObservers = Array.from(n.observers));
        try {
          for (var a = Ld(n.currentObservers), c = a.next(); !c.done; c = a.next()) {
            var u = c.value;
            u.next(t);
          }
        } catch (h) {
          s = { error: h };
        } finally {
          try {
            c && !c.done && (i = a.return) && i.call(a);
          } finally {
            if (s) throw s.error;
          }
        }
      }
    });
  }, e.prototype.error = function(t) {
    var n = this;
    hl(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.hasError = n.isStopped = !0, n.thrownError = t;
        for (var s = n.observers; s.length; )
          s.shift().error(t);
      }
    });
  }, e.prototype.complete = function() {
    var t = this;
    hl(function() {
      if (t._throwIfClosed(), !t.isStopped) {
        t.isStopped = !0;
        for (var n = t.observers; n.length; )
          n.shift().complete();
      }
    });
  }, e.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(e.prototype, "observed", {
    get: function() {
      var t;
      return ((t = this.observers) === null || t === void 0 ? void 0 : t.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._trySubscribe = function(t) {
    return this._throwIfClosed(), r.prototype._trySubscribe.call(this, t);
  }, e.prototype._subscribe = function(t) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(t), this._innerSubscribe(t);
  }, e.prototype._innerSubscribe = function(t) {
    var n = this, s = this, i = s.hasError, a = s.isStopped, c = s.observers;
    return i || a ? j1 : (this.currentObservers = null, c.push(t), new eu(function() {
      n.currentObservers = null, Bd(c, t);
    }));
  }, e.prototype._checkFinalizedStatuses = function(t) {
    var n = this, s = n.hasError, i = n.thrownError, a = n.isStopped;
    s ? t.error(i) : a && t.complete();
  }, e.prototype.asObservable = function() {
    var t = new Pv();
    return t.source = this, t;
  }, e.create = function(t, n) {
    return new Rv(t, n);
  }, e;
}(Pv), Rv = function(r) {
  yo(e, r);
  function e(t, n) {
    var s = r.call(this) || this;
    return s.destination = t, s.source = n, s;
  }
  return e.prototype.next = function(t) {
    var n, s;
    (s = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null || s === void 0 || s.call(n, t);
  }, e.prototype.error = function(t) {
    var n, s;
    (s = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null || s === void 0 || s.call(n, t);
  }, e.prototype.complete = function() {
    var t, n;
    (n = (t = this.destination) === null || t === void 0 ? void 0 : t.complete) === null || n === void 0 || n.call(t);
  }, e.prototype._subscribe = function(t) {
    var n, s;
    return (s = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t)) !== null && s !== void 0 ? s : j1;
  }, e;
}(Nf), jv = function(r) {
  yo(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n._value = t, n;
  }
  return Object.defineProperty(e.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._subscribe = function(t) {
    var n = r.prototype._subscribe.call(this, t);
    return !n.closed && t.next(this._value), n;
  }, e.prototype.getValue = function() {
    var t = this, n = t.hasError, s = t.thrownError, i = t._value;
    if (n)
      throw s;
    return this._throwIfClosed(), i;
  }, e.prototype.next = function(t) {
    r.prototype.next.call(this, this._value = t);
  }, e;
}(Nf);
function ii(r, e) {
  return NA(function(t, n) {
    var s = 0;
    t.subscribe(BA(n, function(i) {
      return r.call(e, i, s++) && n.next(i);
    }));
  });
}
const F1 = new Nf(), WA = (r, e) => {
  F1.next({ key: r, value: e });
}, Ze = {
  subject: F1,
  dispatch: WA
}, rr = [];
for (let r = 0; r < 256; ++r)
  rr.push((r + 256).toString(16).slice(1));
function HA(r, e = 0) {
  return (rr[r[e + 0]] + rr[r[e + 1]] + rr[r[e + 2]] + rr[r[e + 3]] + "-" + rr[r[e + 4]] + rr[r[e + 5]] + "-" + rr[r[e + 6]] + rr[r[e + 7]] + "-" + rr[r[e + 8]] + rr[r[e + 9]] + "-" + rr[r[e + 10]] + rr[r[e + 11]] + rr[r[e + 12]] + rr[r[e + 13]] + rr[r[e + 14]] + rr[r[e + 15]]).toLowerCase();
}
let Gh;
const UA = new Uint8Array(16);
function $A() {
  if (!Gh) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Gh = crypto.getRandomValues.bind(crypto);
  }
  return Gh(UA);
}
const YA = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Lv = { randomUUID: YA };
function Yt(r, e, t) {
  if (Lv.randomUUID && !r)
    return Lv.randomUUID();
  r = r || {};
  const n = r.random ?? r.rng?.() ?? $A();
  if (n.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, HA(n);
}
var N1 = /* @__PURE__ */ ((r) => (r.IMAGE = "image", r.VIDEO = "video", r.AUDIO = "audio", r))(N1 || {});
const XA = (r) => {
  const [e, t] = m.useState(!1), [n, s] = m.useState(!1), i = m.useCallback((d) => {
    const p = { ...d, id: Yt() };
    switch (d.type) {
      case "image":
        Ze.dispatch(Fa, { payload: p });
        break;
      case "video":
        Ze.dispatch(ja, { payload: p });
        break;
      case "audio":
        Ze.dispatch(La, { payload: p });
        break;
    }
  }, []), a = m.useCallback(
    (d) => {
      d.preventDefault();
      try {
        const p = d.dataTransfer?.types[0], g = JSON.parse(p);
        if (!Object.values(N1).includes(g.type))
          return;
        s(!0), t(!0), r?.(!0);
      } catch (p) {
        console.error("Error parsing dragged data:", p);
      }
    },
    [r]
  ), c = m.useCallback(
    (d) => {
      d.preventDefault(), e && (s(!0), r?.(!0));
    },
    [e, r]
  ), u = m.useCallback(
    (d) => {
      if (n) {
        d.preventDefault(), s(!1), r?.(!1);
        try {
          const p = d.dataTransfer?.types[0], g = JSON.parse(
            d.dataTransfer.getData(p)
          );
          i(g);
        } catch (p) {
          console.error("Error parsing dropped data:", p);
        }
      }
    },
    [n, r, i]
  ), h = m.useCallback(
    (d) => {
      d.preventDefault(), d.currentTarget.contains(d.relatedTarget) || (s(!1), t(!1), r?.(!1));
    },
    [r]
  );
  return { onDragEnter: a, onDragOver: c, onDrop: u, onDragLeave: h, isDraggingOver: n };
}, GA = ({
  children: r,
  className: e,
  style: t,
  onDragStateChange: n,
  id: s
}) => {
  const { onDragEnter: i, onDragOver: a, onDrop: c, onDragLeave: u } = XA(n);
  return /* @__PURE__ */ w.jsx(
    "div",
    {
      id: s,
      onDragEnter: i,
      onDrop: c,
      onDragOver: a,
      onDragLeave: u,
      className: e,
      style: t,
      role: "region",
      "aria-label": "Droppable area for images, videos, and audio",
      children: r
    }
  );
}, F8 = ({
  size: r,
  children: e
}) => {
  const [t, n] = m.useState(!1);
  return /* @__PURE__ */ w.jsxs(
    GA,
    {
      id: "artboard",
      onDragStateChange: n,
      style: {
        width: r.width,
        height: r.height
      },
      className: "designcombo_scene pointer-events-auto mt-3.5 bg-black",
      children: [
        /* @__PURE__ */ w.jsx(
          "div",
          {
            style: {
              width: r.width,
              height: r.height
            },
            className: `pointer-events-none absolute z-50 mt-3.5 transition-colors duration-200 ease-in-out ${t ? "border-4 border-dashed border-white bg-white/[0.075]" : "bg-transparent"} shadow-[0_0_0_5000px_#1D1D1F]`
          }
        ),
        e
      ]
    }
  );
}, N8 = 100, B8 = 30, V8 = 18, z8 = 14, W8 = 30, H8 = 24, U8 = 16, qA = 12, $8 = "Regular", KA = "sans-serif", tu = 188, zd = 40, Y8 = 4e3, ZA = 1920, JA = 1080, QA = 60, e5 = 1e3 / QA, X8 = 2e6, G8 = 1e7, q8 = 48e3, K8 = 192e3, B1 = 2.3, Z8 = ZA / B1, J8 = JA / B1, Q8 = 184, e7 = 348, t7 = 512, r7 = 300, n7 = 0, s7 = 5e3, i7 = 1, o7 = 0, a7 = 0, c7 = 0, l7 = 359, u7 = 1, h7 = 0, d7 = !1, f7 = !1, p7 = 0, g7 = 2, m7 = 0.01, v7 = 1, y7 = 0, b7 = 3, w7 = 0.01, x7 = 1, _7 = 0, S7 = 1, C7 = 0.01, T7 = 0.5, E7 = -1e3, k7 = 1e3, O7 = 1, M7 = 1, A7 = 0, I7 = 1, P7 = 0.01, D7 = 1, R7 = 0, j7 = 1, L7 = 0.01, F7 = 0, N7 = 0.5, B7 = 10, V7 = 0.01, z7 = 1, W7 = 0, H7 = 1, U7 = 0.01, $7 = 1, Bf = 16, Fv = 80;
function t5(r) {
  if (!r) return "0";
  const e = r / tu, t = Math.trunc(e) % 60, n = Math.trunc(e / 60) % 60, s = Math.trunc(e / 3600) % 60, a = [
    Math.trunc(e / 216e3).toString(),
    s.toString(),
    n.toString(),
    t.toString()
  ];
  return e < 60 ? `${a[3].padStart(2, "0")}f` : e < 3600 ? `${a[2].padStart(1, "0")}s` : e < 216e3 ? `${a[1].padStart(2, "0")}:${a[2].padStart(
    2,
    "0"
  )}` : `${a[0].padStart(2, "0")}:${a[1].padStart(
    2,
    "0"
  )}:${a[2].padStart(2, "0")}`;
}
function Y7(r, e = !1) {
  if (!r) return "00:00";
  const n = 1e3 / 60;
  if (r < 1e3)
    return e ? `${Math.floor(r / n)}f` : `${(r / 1e3).toFixed(1)}s`;
  const s = Math.floor(r / 1e3);
  if (s < 60)
    return `${s}s`;
  const i = Math.floor(s / 60);
  if (i < 60) {
    const h = s % 60;
    return `${i.toString().padStart(2, "0")}:${h.toString().padStart(2, "0")}`;
  }
  const a = Math.floor(i / 60), c = i % 60, u = s % 60;
  return `${a.toString().padStart(2, "0")}:${c.toString().padStart(2, "0")}:${u.toString().padStart(2, "0")}`;
}
function xl(r, e) {
  return r.map((t) => ({
    ...t,
    items: t.items.filter((n) => !e.includes(n))
  }));
}
const r5 = ({ frame: r }, { fps: e }) => {
  const t = r / e, n = Math.floor(t / 3600), s = t % 3600, i = Math.floor(s / 60), a = Math.floor(s % 60), c = Math.floor(
    (s - Math.floor(s)) * 100
  );
  return n > 0 ? `${n}:${i.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}:${c.toString().padStart(2, "0")}` : `${i.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}:${c.toString().padStart(2, "0")}`;
}, n5 = ({ time: r }) => {
  const e = r / 1e3, t = Math.floor(e / 3600), n = e % 3600, s = Math.floor(n / 60), i = Math.floor(n % 60), a = Math.floor(
    (n - Math.floor(n)) * 100
  );
  return t > 0 ? `${t}:${s.toString().padStart(2, "0")}:${i.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}` : `${s.toString().padStart(2, "0")}:${i.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}`;
}, s5 = () => {
  const r = document.getElementById("video-current-time");
  return (r ? parseFloat(r.getAttribute("data-current-time") ?? "") : 0) * 1e3;
}, Ln = [
  {
    // 1x distance (minute 0 to minute 5, 5 segments).
    index: 0,
    unit: 18e3,
    zoom: 1 / 18e3,
    segments: 5
  },
  {
    // 1x distance (minute 0 to minute 3, 3 segments).
    index: 1,
    unit: 10800,
    zoom: 1 / 10800,
    segments: 3
  },
  {
    // 1x distance (minute 0 to minute 2, 2 segments).
    index: 2,
    unit: 7200,
    zoom: 1 / 7200,
    segments: 2
  },
  {
    // 1x distance (minute 0 to minute 1, 1 segment).
    index: 3,
    unit: 3600,
    zoom: 1 / 3600,
    segments: 1
  },
  {
    // 1x distance (second 0 to second 30, 2 segments).
    index: 4,
    unit: 1800,
    zoom: 1 / 1800,
    segments: 2
  },
  {
    // 1x distance (second 0 to second 15, 3 segments).
    index: 5,
    unit: 900,
    zoom: 1 / 900,
    segments: 3
  },
  {
    // 1x distance (second 0 to second 10, 2 segments).
    index: 6,
    unit: 600,
    zoom: 1 / 600,
    segments: 2
  },
  {
    // 1x distance (second 0 to second 5, 5 segments).
    index: 7,
    unit: 300,
    zoom: 1 / 300,
    segments: 5
  },
  {
    // 1x distance (second 0 to second 3, 3 segments).
    index: 8,
    unit: 180,
    zoom: 1 / 180,
    segments: 3
  },
  {
    // 1x distance (second 0 to second 2, 2 segments).
    index: 9,
    unit: 120,
    zoom: 1 / 120,
    segments: 10
  },
  {
    // 1x distance (second 0 to second 1, 1 segment).
    index: 10,
    unit: 60,
    zoom: 1 / 60,
    segments: 5
  },
  {
    // 1x distance (second 0 to second 1, 1 segment).
    index: 11,
    unit: 60,
    zoom: 1 / 60,
    segments: 5
  },
  {
    // 1x distance (frame 0 to frame 30, 2 segments).
    index: 12,
    unit: 30,
    zoom: 1 / 30,
    segments: 2
  },
  {
    // 1x distance (frame 0 to frame 15, 3 segments).
    index: 13,
    unit: 15,
    zoom: 1 / 15,
    segments: 3
  },
  {
    // 1x distance (frame 0 to frame 10, 2 segments).
    index: 14,
    unit: 10,
    zoom: 1 / 10,
    segments: 2
  },
  {
    // 1x distance (frame 0 to frame 5, 5 segments).
    index: 15,
    unit: 5,
    zoom: 1 / 5,
    segments: 5
  },
  {
    // 1x distance (frame 0 to frame 3, 3 segments).
    index: 16,
    unit: 3,
    zoom: 1 / 3,
    segments: 3
  },
  {
    // 1x distance (frame 0 to frame 2, 2 segments).
    index: 17,
    unit: 2,
    zoom: 1 / 2,
    segments: 5
  },
  {
    // 1x distance (frame 0 to frame 1, 1 segment).
    index: 18,
    unit: 1,
    zoom: 1,
    segments: 5
  },
  {
    // 2x distance (frame 0 to frame 1, 1 segment).
    index: 19,
    unit: 1,
    zoom: 2,
    segments: 5
  },
  {
    // 4x distance (frame 0 to frame 1, 1 segment).
    index: 20,
    unit: 1,
    zoom: 4,
    segments: 10
  }
];
function V1(r, e) {
  let t = -1, n = r.length - 1;
  for (; 1 + t < n; ) {
    const s = t + (n - t >> 1);
    e(r[s], s, r) ? n = s : t = s;
  }
  return n;
}
function X7(r, e = 1) {
  const t = () => {
    const u = Math.max(0, zd), d = document.getElementById(
      "designcombo-timeline-canvas"
    )?.offsetWidth ?? document.body.offsetWidth;
    return Math.max(1, d - u);
  }, n = () => typeof r == "number" ? Nt(r, e) : u5(r, e), s = t() / n(), i = e * s;
  return {
    segments: 5,
    index: V1(Ln, (c) => c.zoom > i),
    zoom: i,
    unit: 1 / i
  };
}
function G7(r) {
  return Ln[r];
}
function i5(r) {
  return o5(r) || Ln[0];
}
const o5 = (r) => {
  const e = Ln.filter(
    (n) => n.zoom < r.zoom
  );
  return e.length === 0 ? null : e.reduce(
    (n, s) => s.zoom > n.zoom ? s : n
  );
}, a5 = (r) => {
  const e = Ln.filter(
    (n) => n.zoom > r.zoom
  );
  return e.length === 0 ? null : e.reduce(
    (n, s) => s.zoom < n.zoom ? s : n
  );
};
function c5(r) {
  return a5(r) || Ln[Ln.length - 1];
}
function q7(r) {
  const e = Ln.at(-1), t = r === e, s = l5(r) - (t ? 1 : 2);
  return Math.max(0, s);
}
function l5(r) {
  const e = V1(Ln, (t) => t.zoom > r.zoom);
  return Math.min(Ln.length - 1, e);
}
function Nt(r, e = 1, t = 1) {
  const n = tu * e;
  return r * (60 / 1e3) * n / t;
}
function di(r, e = 1) {
  const t = tu * e;
  return r / t * e5;
}
function u5(r, e = 1) {
  return Nt(r, e);
}
const K7 = Math.floor(Math.random() * 1e3) + 1;
function z1(r, e = 1) {
  const t = [], n = Math.floor(e), s = (i, a) => {
    for (const c of i)
      Array.isArray(c) && a < n ? s(c, a + 1) : t.push(c);
  };
  return s(r, 0), t;
}
function W1(r, e) {
  const t = e.sort((s, i) => s.tempIndex - i.tempIndex), n = [];
  for (const s of t)
    s.tempIndex < 0 && n.push(s);
  n.push(r);
  for (const s of t)
    s.tempIndex >= 0 && n.push(s);
  return n;
}
const Nv = {
  id: "font_UwdNKSyVq2iiMiuHSRRsUIOu",
  family: "Roboto",
  fullName: "Roboto Bold",
  postScriptName: "Roboto-Bold",
  preview: "https://ik.imagekit.io/lh/fonts/v2/5zQgS86djScKA0ri67BBCqW7.png",
  style: "Roboto-Bold",
  url: "https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmWUlvAx05IsDqlA.ttf",
  category: "sans-serif",
  createdAt: "2023-06-20T04:42:55.909Z",
  updatedAt: "2023-06-20T04:42:55.909Z",
  userId: null
}, h5 = (r) => {
  const e = r.map(
    (t) => new FontFace(t.fontFamily, `url(${t.fontUrl})`).load()
    // .catch((error: unknown) => error),
  );
  return e.length === 0 ? Promise.resolve(!0) : new Promise((t, n) => {
    Promise.all(e).then((s) => {
      s.forEach((i) => {
        i instanceof FontFace && i.family && (document.fonts.add(i), t(!0));
      });
    }).catch((s) => {
      n(s);
    });
  });
}, Bv = (r) => {
  let e;
  const t = /* @__PURE__ */ new Set(), n = (h, d) => {
    const p = typeof h == "function" ? h(e) : h;
    if (!Object.is(p, e)) {
      const g = e;
      e = d ?? (typeof p != "object" || p === null) ? p : Object.assign({}, e, p), t.forEach((v) => v(e, g));
    }
  }, s = () => e, c = { setState: n, getState: s, getInitialState: () => u, subscribe: (h) => (t.add(h), () => t.delete(h)) }, u = e = r(n, s, c);
  return c;
}, d5 = (r) => r ? Bv(r) : Bv, f5 = (r) => r;
function p5(r, e = f5) {
  const t = Ie.useSyncExternalStore(
    r.subscribe,
    () => e(r.getState()),
    () => e(r.getInitialState())
  );
  return Ie.useDebugValue(t), t;
}
const Vv = (r) => {
  const e = d5(r), t = (n) => p5(e, n);
  return Object.assign(t, e), t;
}, H1 = (r) => r ? Vv(r) : Vv, fi = H1((r) => ({
  timeline: null,
  size: {
    width: 1080,
    height: 1920
  },
  duration: 5e3,
  fps: 30,
  scale: {
    // 1x distance (second 0 to second 5, 5 segments).
    index: 7,
    unit: 300,
    zoom: 1 / 300,
    segments: 5
  },
  scroll: {
    left: 0,
    top: 0
  },
  playerRef: null,
  activeIds: [],
  targetIds: [],
  tracks: [],
  trackItemIds: [],
  transitionIds: [],
  transitionsMap: {},
  trackItemDetailsMap: {},
  trackItemsMap: {},
  setTimeline: (e) => {
    r(() => ({
      timeline: e
    }));
  },
  setScale: (e) => {
    r(() => ({
      scale: e
    }));
  },
  setScroll: (e) => {
    r(() => ({
      scroll: e
    }));
  },
  setState: async (e) => {
    r({ ...e });
  },
  setPlayerRef: (e) => {
    r({ playerRef: e });
  }
}));
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const g5 = (r) => r.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), U1 = (...r) => r.filter((e, t, n) => !!e && e.trim() !== "" && n.indexOf(e) === t).join(" ").trim();
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var m5 = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const v5 = m.forwardRef(
  ({
    color: r = "currentColor",
    size: e = 24,
    strokeWidth: t = 2,
    absoluteStrokeWidth: n,
    className: s = "",
    children: i,
    iconNode: a,
    ...c
  }, u) => m.createElement(
    "svg",
    {
      ref: u,
      ...m5,
      width: e,
      height: e,
      stroke: r,
      strokeWidth: n ? Number(t) * 24 / Number(e) : t,
      className: U1("lucide", s),
      ...c
    },
    [
      ...a.map(([h, d]) => m.createElement(h, d)),
      ...Array.isArray(i) ? i : [i]
    ]
  )
);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Cn = (r, e) => {
  const t = m.forwardRef(
    ({ className: n, ...s }, i) => m.createElement(v5, {
      ref: i,
      iconNode: e,
      className: U1(`lucide-${g5(r)}`, n),
      ...s
    })
  );
  return t.displayName = `${r}`, t;
};
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const y5 = Cn("Music", [
  ["path", { d: "M9 18V5l12-2v13", key: "1jmyc2" }],
  ["circle", { cx: "6", cy: "18", r: "3", key: "fqmcym" }],
  ["circle", { cx: "18", cy: "16", r: "3", key: "1hluhg" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const b5 = Cn("Pause", [
  ["rect", { x: "14", y: "4", width: "4", height: "16", rx: "1", key: "zuxfzm" }],
  ["rect", { x: "6", y: "4", width: "4", height: "16", rx: "1", key: "1okwgv" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const w5 = Cn("Play", [
  ["polygon", { points: "6 3 20 12 6 21 6 3", key: "1oa8hb" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const x5 = Cn("SkipBack", [
  ["polygon", { points: "19 20 9 12 19 4 19 20", key: "o2sva" }],
  ["line", { x1: "5", x2: "5", y1: "19", y2: "5", key: "1ocqjk" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const _5 = Cn("SkipForward", [
  ["polygon", { points: "5 4 15 12 5 20 5 4", key: "16p6eg" }],
  ["line", { x1: "19", x2: "19", y1: "5", y2: "19", key: "futhcm" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const zv = Cn("SquareSplitHorizontal", [
  ["path", { d: "M8 19H5c-1 0-2-1-2-2V7c0-1 1-2 2-2h3", key: "lubmu8" }],
  ["path", { d: "M16 5h3c1 0 2 1 2 2v10c0 1-1 2-2 2h-3", key: "1ag34g" }],
  ["line", { x1: "12", x2: "12", y1: "4", y2: "20", key: "1tx1rr" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const S5 = Cn("Trash", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Wv = Cn("Upload", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "17 8 12 3 7 8", key: "t8dd8p" }],
  ["line", { x1: "12", x2: "12", y1: "3", y2: "15", key: "widbto" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const C5 = Cn("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const T5 = Cn("ZoomIn", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "11", x2: "11", y1: "8", y2: "14", key: "1vmskp" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const E5 = Cn("ZoomOut", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]), Vf = (r) => {
  const e = m.useCallback(
    (n) => {
      if (!r?.current)
        return () => {
        };
      const s = () => {
        n();
      };
      return r.current.addEventListener("frameupdate", s), () => {
        r.current && r.current.removeEventListener("frameupdate", s);
      };
    },
    [r]
  );
  return m.useSyncExternalStore(
    e,
    () => r?.current?.getCurrentFrame() ?? 0,
    () => 0
  );
}, ru = () => {
  const [r, e] = m.useState(!1);
  return m.useEffect(() => {
    const n = Ze.subject.pipe(
      ii(({ key: s }) => s.startsWith(CA))
    ).subscribe((s) => {
      s.key === P1 ? e(!0) : s.key === wl && e(!1);
    });
    return () => n.unsubscribe();
  }, []), r;
}, k5 = () => {
  const [r, e] = m.useState(!1), { duration: t, fps: n, scale: s, playerRef: i, activeIds: a } = fi(), c = Vf(i), u = () => {
    Ze.dispatch(E1);
  }, h = () => {
    Ze.dispatch(O1, {
      payload: {},
      options: {
        time: s5()
      }
    });
  }, d = (v) => {
    Ze.dispatch(I1, {
      payload: {
        scale: v
      }
    });
  }, p = () => {
    Ze.dispatch(yA);
  }, g = () => {
    Ze.dispatch(bA);
  };
  return m.useEffect(() => (i?.current?.addEventListener("play", () => {
    e(!0);
  }), i?.current?.addEventListener("pause", () => {
    e(!1);
  }), () => {
    i?.current?.removeEventListener("play", () => {
      e(!0);
    }), i?.current?.removeEventListener("pause", () => {
      e(!1);
    });
  }), [i]), /* @__PURE__ */ w.jsx(
    "div",
    {
      style: {
        position: "relative",
        height: "50px",
        boxShadow: "inset 0 1px 0 0 #27272a",
        flex: "none"
      },
      className: "bg-background",
      children: /* @__PURE__ */ w.jsx(
        "div",
        {
          style: {
            position: "absolute",
            height: 50,
            width: "100%",
            display: "flex",
            alignItems: "center"
          },
          children: /* @__PURE__ */ w.jsxs(
            "div",
            {
              style: {
                height: 36,
                width: "100%",
                display: "grid",
                gridTemplateColumns: "1fr 260px 1fr",
                alignItems: "center"
              },
              children: [
                /* @__PURE__ */ w.jsxs("div", { className: "flex px-2", children: [
                  /* @__PURE__ */ w.jsxs(
                    br,
                    {
                      disabled: !a.length,
                      onClick: u,
                      variant: "ghost",
                      size: "sm",
                      className: "flex items-center gap-1 px-2",
                      children: [
                        /* @__PURE__ */ w.jsx(S5, { size: 14 }),
                        " Delete"
                      ]
                    }
                  ),
                  /* @__PURE__ */ w.jsxs(
                    br,
                    {
                      disabled: !a.length,
                      onClick: h,
                      variant: "ghost",
                      size: "sm",
                      className: "flex items-center gap-1 px-2",
                      children: [
                        /* @__PURE__ */ w.jsx(zv, { size: 15 }),
                        " Split"
                      ]
                    }
                  ),
                  /* @__PURE__ */ w.jsxs(
                    br,
                    {
                      disabled: !a.length,
                      onClick: () => {
                        Ze.dispatch(k1);
                      },
                      variant: "ghost",
                      size: "sm",
                      className: "flex items-center gap-1 px-2",
                      children: [
                        /* @__PURE__ */ w.jsx(zv, { size: 15 }),
                        " Clone"
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ w.jsxs("div", { className: "flex items-center justify-center", children: [
                  /* @__PURE__ */ w.jsxs("div", { children: [
                    /* @__PURE__ */ w.jsx(
                      br,
                      {
                        onClick: u,
                        variant: "ghost",
                        size: "icon",
                        children: /* @__PURE__ */ w.jsx(x5, { size: 14 })
                      }
                    ),
                    /* @__PURE__ */ w.jsx(
                      br,
                      {
                        onClick: () => {
                          if (r)
                            return g();
                          p();
                        },
                        variant: "ghost",
                        size: "icon",
                        children: r ? /* @__PURE__ */ w.jsx(b5, { size: 14 }) : /* @__PURE__ */ w.jsx(w5, { size: 14 })
                      }
                    ),
                    /* @__PURE__ */ w.jsx(
                      br,
                      {
                        onClick: h,
                        variant: "ghost",
                        size: "icon",
                        children: /* @__PURE__ */ w.jsx(_5, { size: 14 })
                      }
                    )
                  ] }),
                  /* @__PURE__ */ w.jsxs(
                    "div",
                    {
                      className: "text-xs font-light",
                      style: {
                        display: "grid",
                        alignItems: "center",
                        gridTemplateColumns: "54px 4px 54px",
                        paddingTop: "2px",
                        justifyContent: "center"
                      },
                      children: [
                        /* @__PURE__ */ w.jsx(
                          "div",
                          {
                            className: "font-medium text-zinc-200",
                            style: {
                              display: "flex",
                              justifyContent: "center"
                            },
                            "data-current-time": c / n,
                            id: "video-current-time",
                            children: r5({ frame: c }, { fps: n })
                          }
                        ),
                        /* @__PURE__ */ w.jsx("span", { children: "/" }),
                        /* @__PURE__ */ w.jsx(
                          "div",
                          {
                            className: "text-muted-foreground",
                            style: {
                              display: "flex",
                              justifyContent: "center"
                            },
                            children: n5({ time: t })
                          }
                        )
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ w.jsx(
                  O5,
                  {
                    scale: s,
                    onChangeTimelineScale: d,
                    duration: t
                  }
                )
              ]
            }
          )
        }
      )
    }
  );
}, O5 = ({
  scale: r,
  onChangeTimelineScale: e,
  duration: t
}) => {
  const n = () => {
    const i = i5(r);
    e(i);
  }, s = () => {
    const i = c5(r);
    e(i);
  };
  return /* @__PURE__ */ w.jsx("div", { className: "flex items-center justify-end", children: /* @__PURE__ */ w.jsxs("div", { className: "flex border-l border-border pl-4 pr-2", children: [
    /* @__PURE__ */ w.jsx(
      br,
      {
        size: "icon",
        variant: "ghost",
        onClick: n,
        disabled: r.index === 0,
        children: /* @__PURE__ */ w.jsx(E5, { size: 16 })
      }
    ),
    /* @__PURE__ */ w.jsx(
      br,
      {
        size: "icon",
        variant: "ghost",
        onClick: s,
        disabled: r.index === 20,
        children: /* @__PURE__ */ w.jsx(T5, { size: 16 })
      }
    )
  ] }) });
}, M5 = [
  {
    id: "1",
    details: {
      src: "https://cdn.designcombo.dev/audio/Dawn%20of%20change.mp3",
      text: "Voiceover"
    },
    name: "Dawn of change",
    type: "audio",
    metadata: {
      author: "Roman Senyk"
    },
    display: { from: 3e3 }
  },
  {
    id: "2",
    details: {
      src: "https://cdn.designcombo.dev/audio/Hope.mp3"
    },
    name: "Hope",
    type: "audio",
    metadata: {
      author: "Hugo Dujardin"
    }
  },
  {
    id: "3",
    details: {
      src: "https://cdn.designcombo.dev/audio/Tenderness.mp3"
    },
    name: "Tenderness",
    type: "audio",
    metadata: {
      author: "Benjamin Tissot"
    }
  },
  {
    id: "4",
    details: {
      src: "https://cdn.designcombo.dev/audio/Piano%20Moment.mp3"
    },
    name: "Piano moment",
    type: "audio",
    metadata: {
      author: "Benjamin Tissot"
    }
  }
], A5 = [
  {
    id: "1",
    details: { src: "https://ik.imagekit.io/wombo/images/img1.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img1.jpg?tr=w-190",
    type: "image"
  },
  {
    id: "2",
    details: { src: "https://ik.imagekit.io/wombo/images/img2.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img2.jpg?tr=w-190",
    type: "image"
  },
  {
    id: "3",
    details: { src: "https://ik.imagekit.io/wombo/images/img3.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img3.jpg?tr=w-190",
    type: "image"
  },
  {
    id: "4",
    details: { src: "https://ik.imagekit.io/wombo/images/img4.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img4.jpg?tr=w-190",
    type: "image"
  },
  {
    id: "5",
    details: { src: "https://ik.imagekit.io/wombo/images/img5.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img5.jpg?tr=w-190",
    type: "image"
  },
  ,
  {
    id: "6",
    details: { src: "https://ik.imagekit.io/wombo/images/img6.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img6.jpg?tr=w-190",
    type: "image"
  },
  {
    id: "7",
    details: { src: "https://ik.imagekit.io/wombo/images/img7.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img7.jpg?tr=w-190",
    type: "image"
  }
], I5 = [
  {
    id: "1",
    details: {
      src: "https://cdn.designcombo.dev/videos/demo-video-1.mp4",
      text: "Scene"
    },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-1.png",
    duration: 17e3,
    display: { from: 3e3 }
  },
  {
    id: "2",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-2.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-2.png"
  },
  {
    id: "3",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-3.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-3.png",
    duration: 2e4
  },
  {
    id: "4",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-4.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-4.png",
    duration: 2e4
  },
  {
    id: "5",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-5.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-5.png",
    duration: 23e3
  },
  {
    id: "6",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-6.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-6.png",
    duration: 1e4
  },
  {
    id: "7",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-7.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-7.png",
    duration: 12e3
  },
  {
    id: "8",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-8.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-8.png",
    duration: 15e3
  },
  {
    id: "9",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-9.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-9.png",
    duration: 15e3
  },
  {
    id: "10",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-10.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-10.png",
    duration: 5e3
  },
  {
    id: "11",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-11.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-11.png",
    duration: 5e3
  }
], P5 = [
  {
    id: "1",
    kind: "none",
    duration: 0,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/transition-none.png",
    type: "transition"
  },
  {
    id: "2",
    kind: "fade",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/fade.webp",
    type: "transition"
  },
  {
    id: "3",
    kind: "slide",
    name: "slide up",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/slide-up.webp",
    type: "transition",
    direction: "from-bottom"
  },
  {
    id: "4",
    kind: "slide",
    name: "slide down",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/slide-down.webp",
    type: "transition",
    direction: "from-top"
  },
  {
    id: "5",
    kind: "slide",
    name: "slide left",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/slide-left.webp",
    type: "transition",
    direction: "from-right"
  },
  {
    id: "6",
    kind: "slide",
    name: "slide right",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/slide-right.webp",
    type: "transition",
    direction: "from-left"
  },
  {
    id: "7",
    kind: "wipe",
    name: "wipe up",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/wipe-up.webp",
    type: "transition",
    direction: "from-bottom"
  },
  {
    id: "8",
    kind: "wipe",
    name: "wipe down",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/wipe-down.webp",
    type: "transition",
    direction: "from-top"
  },
  {
    id: "9",
    kind: "wipe",
    name: "wipe left",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/wipe-left.webp",
    type: "transition",
    direction: "from-right"
  },
  {
    id: "10",
    kind: "wipe",
    name: "wipe right",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/wipe-right.webp",
    type: "transition",
    direction: "from-left"
  },
  {
    id: "11",
    kind: "flip",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/flip.webp",
    type: "transition"
  },
  {
    id: "12",
    kind: "clockWipe",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/clock-wipe.webp",
    type: "transition"
  },
  {
    id: "13",
    kind: "star",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/star.webp",
    type: "transition"
  },
  {
    id: "14",
    kind: "circle",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/circle.webp",
    type: "transition"
  },
  {
    id: "15",
    kind: "rectangle",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/rectangle.webp",
    type: "transition"
  }
], Z7 = [
  {
    id: "1",
    src: "https://ik.imagekit.io/snapmotion/upload-video-1.mp4",
    type: "video"
  },
  {
    id: "2",
    src: "https://ik.imagekit.io/snapmotion/upload-video-2.mp4",
    type: "video"
  },
  {
    id: "3",
    src: "https://ik.imagekit.io/snapmotion/upload-video-3.mp4",
    type: "video"
  }
], D5 = () => {
  const r = ru();
  return /* @__PURE__ */ w.jsxs("div", { className: "flex flex-1 flex-col overflow-auto", children: [
    /* @__PURE__ */ w.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Transitions" }),
    /* @__PURE__ */ w.jsx(vo, { children: /* @__PURE__ */ w.jsx("div", { className: "grid grid-cols-3 gap-2 px-4", children: P5.map((e, t) => /* @__PURE__ */ w.jsx(
      R5,
      {
        transition: e,
        shouldDisplayPreview: !r
      },
      t
    )) }) })
  ] });
}, R5 = ({
  transition: r,
  shouldDisplayPreview: e
}) => {
  const t = Ie.useMemo(
    () => ({
      backgroundImage: `url(${r.preview})`,
      backgroundSize: "cover",
      width: "70px",
      height: "70px"
    }),
    [r.preview]
  );
  return /* @__PURE__ */ w.jsx(
    Jl,
    {
      data: r,
      renderCustomPreview: /* @__PURE__ */ w.jsx("div", { style: t }),
      shouldDisplayPreview: e,
      children: /* @__PURE__ */ w.jsxs("div", { children: [
        /* @__PURE__ */ w.jsx("div", { children: /* @__PURE__ */ w.jsx(
          "div",
          {
            style: t,
            draggable: !1
          }
        ) }),
        /* @__PURE__ */ w.jsx("div", { className: "flex h-6 items-center overflow-ellipsis text-nowrap text-[12px] capitalize text-muted-foreground", children: r.name || r.type })
      ] })
    }
  );
}, j5 = () => {
  const r = () => {
    Ze.dispatch(T1, {
      payload: {
        id: Yt(),
        display: {
          from: 0,
          to: 5e3
        },
        details: {
          text: "Heading and some body",
          fontSize: 120,
          width: 600,
          fontUrl: Nv.url,
          fontFamily: Nv.postScriptName,
          color: "#ffffff",
          wordWrap: "break-word",
          textAlign: "center",
          borderWidth: 0,
          borderColor: "#000000",
          boxShadow: {
            color: "#ffffff",
            x: 0,
            y: 0,
            blur: 0
          }
        }
      },
      options: {}
    });
  };
  return /* @__PURE__ */ w.jsxs("div", { className: "flex flex-1 flex-col", children: [
    /* @__PURE__ */ w.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Text" }),
    /* @__PURE__ */ w.jsx("div", { className: "flex flex-col gap-2 px-4", children: /* @__PURE__ */ w.jsx(
      br,
      {
        draggable: !1,
        onClick: r,
        variant: "secondary",
        className: "w-full",
        children: "Add text"
      }
    ) })
  ] });
}, L5 = () => {
  const r = m.useRef(null), e = (n) => {
    t(n);
  }, t = async (n) => {
    const s = n[0].type;
    s.includes("audio") && Ze.dispatch(La, {
      payload: {
        id: Yt(),
        details: {
          src: URL.createObjectURL(n[0]),
          volume: 50
        }
      }
    }), s.includes("video") && Ze.dispatch(ja, {
      payload: {
        id: Yt(),
        display: {
          from: 2e3,
          to: 7e3
        },
        details: {
          src: URL.createObjectURL(n[0]),
          name: n[0].name
        }
      }
    }), s.includes("image") && Ze.dispatch(Fa, {
      payload: {
        id: Yt(),
        details: {
          src: URL.createObjectURL(n[0])
        }
      }
    });
  };
  return /* @__PURE__ */ w.jsxs("div", { className: "flex flex-1 flex-col", children: [
    /* @__PURE__ */ w.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Your media" }),
    /* @__PURE__ */ w.jsx(
      "input",
      {
        ref: r,
        id: "file-upload-handle",
        type: "file",
        accept: "audio/*,video/*,image/*",
        onChange: (n) => e(Array.from(n.target.files || [])),
        className: "hidden"
      }
    ),
    /* @__PURE__ */ w.jsx("div", { className: "px-4 py-2", children: /* @__PURE__ */ w.jsx("div", { children: /* @__PURE__ */ w.jsxs(
      mA,
      {
        defaultValue: "projects",
        className: "w-full",
        children: [
          /* @__PURE__ */ w.jsxs(C1, { className: "grid w-full grid-cols-2", children: [
            /* @__PURE__ */ w.jsx(Dd, { value: "projects", children: "Project" }),
            /* @__PURE__ */ w.jsx(Dd, { value: "workspace", children: "Workspace" })
          ] }),
          /* @__PURE__ */ w.jsxs(Rd, { value: "projects", children: [
            /* @__PURE__ */ w.jsxs(
              br,
              {
                onClick: () => {
                  r.current?.click();
                },
                className: "flex w-full gap-2",
                variant: "secondary",
                children: [
                  /* @__PURE__ */ w.jsx(Wv, { size: 16 }),
                  " Upload"
                ]
              }
            ),
            /* @__PURE__ */ w.jsx("div", {})
          ] }),
          /* @__PURE__ */ w.jsx(Rd, { value: "workspace", children: /* @__PURE__ */ w.jsxs(
            br,
            {
              onClick: () => {
                r.current?.click();
              },
              className: "flex w-full gap-2",
              variant: "secondary",
              children: [
                /* @__PURE__ */ w.jsx(Wv, { size: 16 }),
                " Upload"
              ]
            }
          ) })
        ]
      }
    ) }) }),
    /* @__PURE__ */ w.jsx(vo, { children: /* @__PURE__ */ w.jsx("div", { className: "masonry-sm px-4" }) })
  ] });
}, F5 = () => {
  const r = ru(), e = (t) => {
    Ze.dispatch(La, {
      payload: t,
      options: {}
    });
  };
  return /* @__PURE__ */ w.jsxs("div", { className: "flex flex-1 flex-col", children: [
    /* @__PURE__ */ w.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Audios" }),
    /* @__PURE__ */ w.jsx(vo, { children: /* @__PURE__ */ w.jsx("div", { className: "flex flex-col px-2", children: M5.map((t, n) => /* @__PURE__ */ w.jsx(
      N5,
      {
        shouldDisplayPreview: !r,
        handleAddAudio: e,
        audio: t
      },
      n
    )) }) })
  ] });
}, N5 = ({
  handleAddAudio: r,
  audio: e,
  shouldDisplayPreview: t
}) => {
  const n = Ie.useMemo(
    () => ({
      backgroundImage: "url(https://cdn.designcombo.dev/thumbnails/music-preview.png)",
      backgroundSize: "cover",
      width: "70px",
      height: "70px"
    }),
    []
  );
  return /* @__PURE__ */ w.jsx(
    Jl,
    {
      data: e,
      renderCustomPreview: /* @__PURE__ */ w.jsx("div", { style: n }),
      shouldDisplayPreview: t,
      children: /* @__PURE__ */ w.jsxs(
        "div",
        {
          draggable: !1,
          onClick: () => r(e),
          style: {
            display: "grid",
            gridTemplateColumns: "48px 1fr"
          },
          className: "flex cursor-pointer gap-4 px-2 py-1 text-sm hover:bg-zinc-800/70",
          children: [
            /* @__PURE__ */ w.jsx("div", { className: "flex h-12 items-center justify-center bg-zinc-800", children: /* @__PURE__ */ w.jsx(y5, { width: 16 }) }),
            /* @__PURE__ */ w.jsxs("div", { className: "flex flex-col justify-center", children: [
              /* @__PURE__ */ w.jsx("div", { children: e.name }),
              /* @__PURE__ */ w.jsx("div", { className: "text-zinc-400", children: e.metadata?.author })
            ] })
          ]
        }
      )
    }
  );
}, B5 = () => {
  const r = ru(), e = (t) => {
    Ze.dispatch(Fa, {
      payload: t,
      options: {
        trackId: "main"
      }
    });
  };
  return /* @__PURE__ */ w.jsxs("div", { className: "flex flex-1 flex-col", children: [
    /* @__PURE__ */ w.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Photos" }),
    /* @__PURE__ */ w.jsx(vo, { children: /* @__PURE__ */ w.jsx("div", { className: "masonry-sm px-4", children: A5.map((t, n) => /* @__PURE__ */ w.jsx(
      V5,
      {
        image: t,
        shouldDisplayPreview: !r,
        handleAddImage: e
      },
      n
    )) }) })
  ] });
}, V5 = ({
  handleAddImage: r,
  image: e,
  shouldDisplayPreview: t
}) => {
  const n = Ie.useMemo(
    () => ({
      backgroundImage: `url(${e.preview})`,
      backgroundSize: "cover",
      width: "80px",
      height: "80px"
    }),
    [e.preview]
  );
  return /* @__PURE__ */ w.jsx(
    Jl,
    {
      data: e,
      renderCustomPreview: /* @__PURE__ */ w.jsx("div", { style: n }),
      shouldDisplayPreview: t,
      children: /* @__PURE__ */ w.jsx(
        "div",
        {
          onClick: () => r({
            id: Yt(),
            details: {
              src: e.details.src
            }
          }),
          className: "flex w-full items-center justify-center overflow-hidden bg-background pb-2",
          children: /* @__PURE__ */ w.jsx(
            "img",
            {
              draggable: !1,
              src: e.preview,
              className: "h-full w-full rounded-md object-cover",
              alt: "image"
            }
          )
        }
      )
    }
  );
}, z5 = () => {
  const r = ru(), e = (t) => {
    Ze.dispatch(ja, {
      payload: t,
      options: {
        resourceId: "main"
      }
    });
  };
  return /* @__PURE__ */ w.jsxs("div", { className: "flex flex-1 flex-col", children: [
    /* @__PURE__ */ w.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Videos" }),
    /* @__PURE__ */ w.jsx(vo, { children: /* @__PURE__ */ w.jsx("div", { className: "masonry-sm px-4", children: I5.map((t, n) => /* @__PURE__ */ w.jsx(
      W5,
      {
        video: t,
        shouldDisplayPreview: !r,
        handleAddVideo: e
      },
      n
    )) }) })
  ] });
}, W5 = ({
  handleAddVideo: r,
  video: e,
  shouldDisplayPreview: t
}) => {
  const n = Ie.useMemo(
    () => ({
      backgroundImage: `url(${e.preview})`,
      backgroundSize: "cover",
      width: "80px",
      height: "80px"
    }),
    [e.preview]
  );
  return /* @__PURE__ */ w.jsx(
    Jl,
    {
      data: e,
      renderCustomPreview: /* @__PURE__ */ w.jsx(
        "div",
        {
          style: n,
          className: "draggable"
        }
      ),
      shouldDisplayPreview: t,
      children: /* @__PURE__ */ w.jsx(
        "div",
        {
          onClick: () => r({
            ...e,
            id: Yt(),
            details: {
              src: e.details.src,
              ...e.details
            }
          }),
          className: "flex w-full items-center justify-center overflow-hidden bg-background pb-2",
          children: /* @__PURE__ */ w.jsx(
            "img",
            {
              draggable: !1,
              src: e.preview,
              className: "h-full w-full rounded-md object-cover",
              alt: "image"
            }
          )
        }
      )
    }
  );
}, $1 = H1((r) => ({
  activeMenuItem: null,
  showMenuItem: !1,
  cropTarget: null,
  showControlItem: !1,
  showToolboxItem: !1,
  activeToolboxItem: null,
  setCropTarget: (e) => r({ cropTarget: e }),
  setActiveMenuItem: (e) => r({ activeMenuItem: e }),
  setShowMenuItem: (e) => r({ showMenuItem: e }),
  setShowControlItem: (e) => r({ showControlItem: e }),
  setShowToolboxItem: (e) => r({ showToolboxItem: e }),
  setActiveToolboxItem: (e) => r({ activeToolboxItem: e })
})), H5 = ({ children: r }) => {
  const { showMenuItem: e, setShowMenuItem: t } = $1(), n = () => {
    t(!1);
  };
  return /* @__PURE__ */ w.jsxs(
    "div",
    {
      style: {
        left: e ? "0" : "-100%",
        transition: "left 0.25s ease-in-out",
        zIndex: 200
      },
      className: "absolute top-1/2 mt-6 flex h-[calc(100%-32px-64px)] w-[340px] -translate-y-1/2 rounded-lg shadow-lg",
      children: [
        /* @__PURE__ */ w.jsx("div", { className: "w-[74px]" }),
        /* @__PURE__ */ w.jsxs("div", { className: "relative flex flex-1 bg-background/80 backdrop-blur-lg backdrop-filter", children: [
          /* @__PURE__ */ w.jsx(
            br,
            {
              variant: "ghost",
              className: "absolute right-2 top-2 h-8 w-8 text-muted-foreground",
              size: "icon",
              children: /* @__PURE__ */ w.jsx(
                C5,
                {
                  width: 16,
                  onClick: n
                }
              )
            }
          ),
          r
        ] })
      ]
    }
  );
}, U5 = () => {
  const { activeMenuItem: r } = $1();
  return r === "transitions" ? /* @__PURE__ */ w.jsx(D5, {}) : r === "texts" ? /* @__PURE__ */ w.jsx(j5, {}) : r === "videos" ? /* @__PURE__ */ w.jsx(z5, {}) : r === "audios" ? /* @__PURE__ */ w.jsx(F5, {}) : r === "images" ? /* @__PURE__ */ w.jsx(B5, {}) : r === "uploads" ? /* @__PURE__ */ w.jsx(L5, {}) : null;
}, J7 = () => /* @__PURE__ */ w.jsx(H5, { children: /* @__PURE__ */ w.jsx(U5, {}) }), Hv = {
  redo: ({ ...r }) => /* @__PURE__ */ w.jsx(
    "svg",
    {
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...r,
      children: /* @__PURE__ */ w.jsx(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M14.2957 4.15721C13.9052 3.76669 13.9052 3.13352 14.2957 2.743C14.6862 2.35247 15.3194 2.35247 15.7099 2.743L20.953 7.98603C21.1387 8.16758 21.2539 8.42087 21.2539 8.70108C21.2539 8.70111 21.2539 8.70114 21.2539 8.70117C21.2539 8.70431 21.2539 8.70744 21.2539 8.71057C21.2518 8.93273 21.1773 9.13757 21.0528 9.30262C21.0249 9.33973 20.9942 9.37505 20.961 9.40828L15.7099 14.6593C15.3194 15.0499 14.6862 15.0499 14.2957 14.6593C13.9052 14.2688 13.9052 13.6357 14.2957 13.2451L17.8398 9.70108H9.22665C8.59943 9.70108 7.97836 9.82462 7.39888 10.0646C6.81941 10.3047 6.29289 10.6565 5.84938 11.1C5.40587 11.5435 5.05406 12.07 4.81403 12.6495C4.57401 13.229 4.45047 13.85 4.45047 14.4773C4.45047 15.1045 4.57401 15.7256 4.81403 16.305C5.05406 16.8845 5.40587 17.411 5.84938 17.8545C6.29289 18.298 6.81941 18.6498 7.39888 18.8899C7.97836 19.1299 8.59943 19.2534 9.22665 19.2534H12.9024C13.4547 19.2534 13.9024 19.7012 13.9024 20.2534C13.9024 20.8057 13.4547 21.2534 12.9024 21.2534H9.22665C8.33679 21.2534 7.45564 21.0782 6.63352 20.7376C5.81139 20.3971 5.06439 19.898 4.43517 19.2687C3.80594 18.6395 3.30681 17.8925 2.96627 17.0704C2.62574 16.2483 2.45047 15.3671 2.45047 14.4773C2.45047 13.5874 2.62574 12.7063 2.96627 11.8841C3.30681 11.062 3.80594 10.315 4.43517 9.68578C5.06439 9.05655 5.81139 8.55742 6.63352 8.21689C7.45564 7.87635 8.33679 7.70108 9.22665 7.70108H17.8396L14.2957 4.15721Z",
          fill: "currentColor"
        }
      )
    }
  ),
  undo: ({ ...r }) => /* @__PURE__ */ w.jsx(
    "svg",
    {
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...r,
      children: /* @__PURE__ */ w.jsx(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M9.60387 4.30711C9.99439 3.91659 9.99439 3.28342 9.60387 2.8929C9.21334 2.50238 8.58018 2.50237 8.18965 2.8929L2.8925 8.19004C2.70497 8.37758 2.59961 8.63193 2.59961 8.89715C2.59961 9.16237 2.70497 9.41672 2.8925 9.60426L8.18965 14.9014C8.58018 15.2919 9.21334 15.2919 9.60387 14.9014C9.99439 14.5109 9.99439 13.8777 9.60387 13.4872L5.86478 9.7481H15.1044C15.7383 9.7481 16.366 9.87295 16.9516 10.1155C17.5372 10.3581 18.0693 10.7136 18.5176 11.1619C18.9658 11.6101 19.3213 12.1422 19.5639 12.7278C19.8065 13.3134 19.9313 13.9411 19.9313 14.575C19.9313 15.2088 19.8065 15.8365 19.5639 16.4221C19.3213 17.0077 18.9658 17.5398 18.5176 17.9881C18.0693 18.4363 17.5372 18.7918 16.9516 19.0344C16.366 19.277 15.7383 19.4018 15.1044 19.4018H11.3964C10.8442 19.4018 10.3964 19.8495 10.3964 20.4018C10.3964 20.9541 10.8442 21.4018 11.3964 21.4018H15.1044C16.001 21.4018 16.8887 21.2252 17.717 20.8822C18.5452 20.5391 19.2978 20.0362 19.9318 19.4023C20.5657 18.7683 21.0686 18.0158 21.4116 17.1875C21.7547 16.3592 21.9313 15.4715 21.9313 14.575C21.9313 13.6784 21.7547 12.7907 21.4116 11.9624C21.0686 11.1342 20.5657 10.3816 19.9318 9.74764C19.2978 9.11371 18.5452 8.61085 17.717 8.26777C16.8887 7.92469 16.001 7.7481 15.1044 7.7481H6.16287L9.60387 4.30711Z",
          fill: "currentColor"
        }
      )
    }
  )
};
function Q7() {
  const r = () => {
    Ze.dispatch(M1);
  }, e = () => {
    Ze.dispatch(A1);
  };
  return /* @__PURE__ */ w.jsx(
    "div",
    {
      style: {
        display: "grid",
        gridTemplateColumns: "320px 1fr 320px"
      },
      className: "pointer-events-none absolute left-0 right-0 top-0 z-[205] flex h-[72px] items-center px-2",
      children: /* @__PURE__ */ w.jsxs("div", { className: "pointer-events-auto flex h-14 items-center gap-2", children: [
        /* @__PURE__ */ w.jsx("div", { className: "flex h-12 w-12 items-center justify-center rounded-md bg-background" }),
        /* @__PURE__ */ w.jsxs("div", { className: "flex h-12 items-center bg-background px-1.5", children: [
          /* @__PURE__ */ w.jsx(
            br,
            {
              onClick: r,
              className: "text-muted-foreground",
              variant: "ghost",
              size: "icon",
              children: /* @__PURE__ */ w.jsx(Hv.undo, { width: 20 })
            }
          ),
          /* @__PURE__ */ w.jsx(
            br,
            {
              onClick: e,
              className: "text-muted-foreground",
              variant: "ghost",
              size: "icon",
              children: /* @__PURE__ */ w.jsx(Hv.redo, { width: 20 })
            }
          )
        ] })
      ] })
    }
  );
}
var $5 = Object.defineProperty, Y1 = (r, e) => {
  for (var t in e)
    $5(r, t, {
      get: e[t],
      enumerable: !0,
      configurable: !0,
      set: (n) => e[t] = () => n
    });
};
if (typeof m.createContext != "function") {
  const r = [
    'Remotion requires React.createContext, but it is "undefined".',
    'If you are in a React Server Component, turn it into a client component by adding "use client" at the top of the file.',
    "",
    "Before:",
    '  import {useCurrentFrame} from "remotion";',
    "",
    "After:",
    '  "use client";',
    '  import {useCurrentFrame} from "remotion";'
  ];
  throw new Error(r.join(`
`));
}
function Uv() {
  return ["NOD", "E_EN", "V"].join("");
}
var $v = () => ["e", "nv"].join(""), Bt = () => {
  const r = typeof window < "u" && window.remotion_isPlayer, e = typeof window < "u" && typeof window.process < "u" && typeof window.process.env < "u" && (window.process[$v()][Uv()] === "test" || window.process[$v()][Uv()] === "production" && typeof window < "u" && typeof window.remotion_puppeteerTimeout < "u");
  return {
    isStudio: typeof window < "u" && window.remotion_isStudio,
    isRendering: e,
    isPlayer: r
  };
}, Y5 = Ie.createElement, X1 = [], G1 = () => {
  if (!Bt().isStudio)
    return;
  const r = new Proxy(Y5, {
    apply(e, t, n) {
      if (X1.includes(n[0])) {
        const [s, i, ...a] = n, c = {
          ...i ?? {},
          stack: new Error().stack
        };
        return Reflect.apply(e, t, [s, c, ...a]);
      }
      return Reflect.apply(e, t, n);
    }
  });
  Ie.createElement = r;
}, Na = (r) => {
  X1.push(r), G1();
}, q1 = m.createContext(!1), X5 = ({
  children: r
}) => /* @__PURE__ */ w.jsx(q1.Provider, {
  value: !0,
  children: r
}), zf = () => m.useContext(q1);
function nu(r) {
  return !!r;
}
var Nc = "4.0.229", G5 = () => {
  if (typeof globalThis > "u")
    return;
  const r = globalThis.remotion_imported || typeof window < "u" && window.remotion_imported;
  if (r) {
    if (r === Nc)
      return;
    throw new TypeError(`🚨 Multiple versions of Remotion detected: ${[
      Nc,
      typeof r == "string" ? r : "an older version"
    ].filter(nu).join(" and ")}. This will cause things to break in an unexpected way.
Check that all your Remotion packages are on the same version. If your dependencies depend on Remotion, make them peer dependencies. You can also run \`npx remotion versions\` from your terminal to see which versions are mismatching.`);
  }
  globalThis.remotion_imported = Nc, typeof window < "u" && (window.remotion_imported = Nc);
}, q5 = (r, e) => {
  const { style: t, ...n } = r, s = m.useMemo(() => ({
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    width: "100%",
    height: "100%",
    display: "flex",
    flexDirection: "column",
    ...t
  }), [t]);
  return /* @__PURE__ */ w.jsx("div", {
    ref: e,
    style: s,
    ...n
  });
}, ha = m.forwardRef(q5), dr = m.createContext(null), bo = Ie.createContext({
  registerSequence: () => {
    throw new Error("SequenceManagerContext not initialized");
  },
  unregisterSequence: () => {
    throw new Error("SequenceManagerContext not initialized");
  },
  sequences: []
}), Ba = Ie.createContext({
  hidden: {},
  setHidden: () => {
    throw new Error("SequenceVisibilityToggle not initialized");
  }
}), K5 = ({ children: r }) => {
  const [e, t] = m.useState([]), [n, s] = m.useState({}), i = m.useCallback((h) => {
    t((d) => [...d, h]);
  }, []), a = m.useCallback((h) => {
    t((d) => d.filter((p) => p.id !== h));
  }, []), c = m.useMemo(() => ({
    registerSequence: i,
    sequences: e,
    unregisterSequence: a
  }), [i, e, a]), u = m.useMemo(() => ({
    hidden: n,
    setHidden: s
  }), [n]);
  return /* @__PURE__ */ w.jsx(bo.Provider, {
    value: c,
    children: /* @__PURE__ */ w.jsx(Ba.Provider, {
      value: u,
      children: r
    })
  });
}, wo = m.createContext({
  getNonce: () => 0,
  fastRefreshes: 0
}), Wf = () => {
  const r = m.useContext(wo), [e, t] = m.useState(() => r.getNonce()), n = m.useRef(r);
  return m.useEffect(() => {
    n.current !== r && (n.current = r, t(r.getNonce));
  }, [r]), e;
}, K1 = {};
Y1(K1, {
  useTimelineSetFrame: () => lb,
  useTimelinePosition: () => Si,
  usePlayingState: () => Yf,
  persistCurrentFrame: () => ob,
  getInitialFrameState: () => ab,
  getFrameForComposition: () => cb,
  TimelineContext: () => bn,
  SetTimelineContext: () => xo
});
var Rs = m.createContext({
  compositions: [],
  registerComposition: () => {
  },
  unregisterComposition: () => {
  },
  registerFolder: () => {
  },
  unregisterFolder: () => {
  },
  setCurrentCompositionMetadata: () => {
  },
  updateCompositionDefaultProps: () => {
  },
  folders: [],
  currentCompositionMetadata: null,
  canvasContent: null,
  setCanvasContent: () => {
  }
}), su = m.createContext({
  props: {},
  updateProps: () => {
    throw new Error("Not implemented");
  },
  resetUnsaved: () => {
    throw new Error("Not implemented");
  }
}), Z1 = Ie.createRef(), J1 = ({ children: r }) => {
  const [e, t] = Ie.useState({}), n = m.useCallback(({
    defaultProps: a,
    id: c,
    newProps: u
  }) => {
    t((h) => ({
      ...h,
      [c]: typeof u == "function" ? u(h[c] ?? a) : u
    }));
  }, []), s = m.useCallback(() => {
    t({});
  }, []);
  m.useImperativeHandle(Z1, () => ({
    getProps: () => e,
    setProps: t
  }), [e]);
  const i = m.useMemo(() => ({ props: e, updateProps: n, resetUnsaved: s }), [e, s, n]);
  return /* @__PURE__ */ w.jsx(su.Provider, {
    value: i,
    children: r
  });
}, Z5 = {
  "%3A": ":",
  "%2F": "/",
  "%3F": "?",
  "%23": "#",
  "%5B": "[",
  "%5D": "]",
  "%40": "@",
  "%21": "!",
  "%24": "$",
  "%26": "&",
  "%27": "'",
  "%28": "(",
  "%29": ")",
  "%2A": "*",
  "%2B": "+",
  "%2C": ",",
  "%3B": ";"
}, Yv = {}, J5 = (r) => {
  Yv[r] || (console.warn(r), Yv[r] = !0);
}, Q5 = (r) => {
  for (const e of Object.keys(Z5))
    if (r.includes(e))
      return { containsHex: !0, hexCode: e };
  return { containsHex: !1 };
}, Wd = (r) => r.startsWith("/") ? Wd(r.substring(1)) : r, eI = (r) => {
  if (typeof window < "u" && window.remotion_staticBase) {
    if (r.startsWith(window.remotion_staticBase))
      throw new Error(`The value "${r}" is already prefixed with the static base ${window.remotion_staticBase}. You don't need to call staticFile() on it.`);
    return `${window.remotion_staticBase}/${Wd(r)}`;
  }
  return `/${Wd(r)}`;
}, tI = (r) => r.split("/").map((s) => encodeURIComponent(s)).join("/"), rI = (r) => {
  if (r === null)
    throw new TypeError("null was passed to staticFile()");
  if (typeof r > "u")
    throw new TypeError("undefined was passed to staticFile()");
  if (r.startsWith("http://") || r.startsWith("https://"))
    throw new TypeError(`staticFile() does not support remote URLs - got "${r}". Instead, pass the URL without wrapping it in staticFile(). See: https://remotion.dev/docs/staticfile-remote-urls`);
  if (r.startsWith("..") || r.startsWith("./"))
    throw new TypeError(`staticFile() does not support relative paths - got "${r}". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);
  if (r.startsWith("/Users") || r.startsWith("/home") || r.startsWith("/tmp") || r.startsWith("/etc") || r.startsWith("/opt") || r.startsWith("/var") || r.startsWith("C:") || r.startsWith("D:") || r.startsWith("E:"))
    throw new TypeError(`staticFile() does not support absolute paths - got "${r}". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);
  if (r.startsWith("public/"))
    throw new TypeError(`Do not include the public/ prefix when using staticFile() - got "${r}". See: https://remotion.dev/docs/staticfile-relative-paths`);
  const e = Q5(r);
  e.containsHex && J5(`WARNING: You seem to pass an already encoded path (path contains ${e.hexCode}). Since Remotion 4.0, the encoding is done by staticFile() itself. You may want to remove a encodeURIComponent() wrapping.`);
  const t = tI(r), n = eI(t);
  return n.startsWith("/") ? n : `/${n}`;
}, Hd = "remotion-date:", Ud = "remotion-file:", nI = ({
  data: r,
  indent: e,
  staticBase: t
}) => {
  let n = !1, s = !1, i = !1, a = !1;
  try {
    return { serializedString: JSON.stringify(r, function(u, h) {
      const d = this[u];
      return d instanceof Date ? (n = !0, `${Hd}${d.toISOString()}`) : d instanceof Map ? (i = !0, h) : d instanceof Set ? (a = !0, h) : typeof d == "string" && t !== null && d.startsWith(t) ? (s = !0, `${Ud}${d.replace(t + "/", "")}`) : h;
    }, e), customDateUsed: n, customFileUsed: s, mapUsed: i, setUsed: a };
  } catch (c) {
    throw new Error("Could not serialize the passed input props to JSON: " + c.message);
  }
}, Q1 = (r) => JSON.parse(r, (e, t) => typeof t == "string" && t.startsWith(Hd) ? new Date(t.replace(Hd, "")) : typeof t == "string" && t.startsWith(Ud) ? rI(t.replace(Ud, "")) : t), Qs = (r) => Bt().isStudio ? Q1(nI({
  data: r,
  indent: 2,
  staticBase: window.remotion_staticBase
}).serializedString) : r, Xv = !1, sI = () => {
  Xv || (Xv = !0, console.warn("Called `getInputProps()` on the server. This function is not available server-side and has returned an empty object."), console.warn("To hide this warning, don't call this function on the server:"), console.warn("  typeof window === 'undefined' ? {} : getInputProps()"));
}, eb = () => {
  if (typeof window > "u")
    return sI(), {};
  if (Bt().isPlayer)
    throw new Error("You cannot call `getInputProps()` from a <Player>. Instead, the props are available as React props from component that you passed as `component` prop.");
  const r = window.remotion_inputProps;
  return r ? Q1(r) : {};
}, Gv = [
  "h264",
  "h265",
  "vp8",
  "vp9",
  "mp3",
  "aac",
  "wav",
  "prores",
  "h264-mkv",
  "h264-ts",
  "gif"
];
function iI(r, e) {
  if (!(typeof r > "u")) {
    if (typeof r != "string")
      throw new TypeError(`The "defaultCodec" prop ${e} must be a string, but you passed a value of type ${typeof r}.`);
    if (!Gv.includes(r))
      throw new Error(`The "defaultCodec" prop ${e} must be one of ${Gv.join(", ")}, but you passed ${r}.`);
  }
}
function _l(r, e, t) {
  if (typeof r != "number")
    throw new Error(`The "${e}" prop ${t} must be a number, but you passed a value of type ${typeof r}`);
  if (isNaN(r))
    throw new TypeError(`The "${e}" prop ${t} must not be NaN, but is NaN.`);
  if (!Number.isFinite(r))
    throw new TypeError(`The "${e}" prop ${t} must be finite, but is ${r}.`);
  if (r % 1 !== 0)
    throw new TypeError(`The "${e}" prop ${t} must be an integer, but is ${r}.`);
  if (r <= 0)
    throw new TypeError(`The "${e}" prop ${t} must be positive, but got ${r}.`);
}
function Hf(r, e) {
  const { allowFloats: t, component: n } = e;
  if (typeof r > "u")
    throw new Error(`The "durationInFrames" prop ${n} is missing.`);
  if (typeof r != "number")
    throw new Error(`The "durationInFrames" prop ${n} must be a number, but you passed a value of type ${typeof r}`);
  if (r <= 0)
    throw new TypeError(`The "durationInFrames" prop ${n} must be positive, but got ${r}.`);
  if (!t && r % 1 !== 0)
    throw new TypeError(`The "durationInFrames" prop ${n} must be an integer, but got ${r}.`);
  if (!Number.isFinite(r))
    throw new TypeError(`The "durationInFrames" prop ${n} must be finite, but got ${r}.`);
}
function tb(r, e, t) {
  if (typeof r != "number")
    throw new Error(`"fps" must be a number, but you passed a value of type ${typeof r} ${e}`);
  if (!Number.isFinite(r))
    throw new Error(`"fps" must be a finite, but you passed ${r} ${e}`);
  if (isNaN(r))
    throw new Error(`"fps" must not be NaN, but got ${r} ${e}`);
  if (r <= 0)
    throw new TypeError(`"fps" must be positive, but got ${r} ${e}`);
}
var qv = ({
  calculated: r,
  compositionId: e,
  compositionFps: t,
  compositionHeight: n,
  compositionWidth: s,
  compositionDurationInFrames: i
}) => {
  const a = `calculated by calculateMetadata() for the composition "${e}"`, c = `of the "<Composition />" component with the id "${e}"`, u = r?.width ?? s ?? void 0;
  _l(u, "width", r?.width ? a : c);
  const h = r?.height ?? n ?? void 0;
  _l(h, "height", r?.height ? a : c);
  const d = r?.fps ?? t ?? null;
  tb(d, r?.fps ? a : c);
  const p = r?.durationInFrames ?? i ?? null;
  Hf(p, {
    allowFloats: !1,
    component: `of the "<Composition />" component with the id "${e}"`
  });
  const g = r?.defaultCodec;
  return iI(g, a), { width: u, height: h, fps: d, durationInFrames: p, defaultCodec: g };
}, rb = ({
  calculateMetadata: r,
  signal: e,
  defaultProps: t,
  originalProps: n,
  compositionId: s,
  compositionDurationInFrames: i,
  compositionFps: a,
  compositionHeight: c,
  compositionWidth: u
}) => {
  const h = r ? r({
    defaultProps: t,
    props: n,
    abortSignal: e,
    compositionId: s
  }) : null;
  if (h !== null && typeof h == "object" && "then" in h)
    return h.then((p) => {
      const { height: g, width: v, durationInFrames: b, fps: _, defaultCodec: C } = qv({
        calculated: p,
        compositionDurationInFrames: i,
        compositionFps: a,
        compositionHeight: c,
        compositionWidth: u,
        compositionId: s
      });
      return {
        width: v,
        height: g,
        fps: _,
        durationInFrames: b,
        id: s,
        defaultProps: Qs(t),
        props: Qs(p.props ?? n),
        defaultCodec: C ?? null
      };
    });
  const d = qv({
    calculated: h,
    compositionDurationInFrames: i,
    compositionFps: a,
    compositionHeight: c,
    compositionWidth: u,
    compositionId: s
  });
  return h === null ? {
    ...d,
    id: s,
    defaultProps: Qs(t ?? {}),
    props: Qs(n),
    defaultCodec: null
  } : {
    ...d,
    id: s,
    defaultProps: Qs(t ?? {}),
    props: Qs(h.props ?? n),
    defaultCodec: h.defaultCodec ?? null
  };
}, oI = (r) => {
  try {
    return {
      type: "success",
      result: rb(r)
    };
  } catch (e) {
    return {
      type: "error",
      error: e
    };
  }
}, iu = m.createContext(null), nb = m.createRef(), sb = (r) => !!r.calculateMetadata, aI = "remotion.propsUpdatedExternally", ib = ({ children: r }) => {
  const [e, t] = m.useState(null), { compositions: n, canvasContent: s, currentCompositionMetadata: i } = m.useContext(Rs), { fastRefreshes: a } = m.useContext(wo), c = m.useMemo(() => n.find((B) => s && s.type === "composition" && s.compositionId === B.id), [s, n]), u = n.find((B) => B.id === e), { props: h } = m.useContext(su), d = m.useMemo(() => typeof window > "u" || Bt().isPlayer ? {} : eb() ?? {}, []), [p, g] = m.useState({}), v = m.useMemo(() => c ? h[c.id] ?? {} : {}, [h, c]), b = m.useMemo(() => u ? h[u.id] ?? {} : {}, [h, u]), _ = !!i, C = m.useCallback(({
    calculateMetadata: B,
    combinedProps: X,
    compositionDurationInFrames: Y,
    compositionFps: Z,
    compositionHeight: G,
    compositionId: K,
    compositionWidth: oe,
    defaultProps: ve
  }) => {
    const Q = new AbortController();
    if (_)
      return Q;
    const { signal: ge } = Q, de = oI({
      compositionId: K,
      calculateMetadata: B,
      originalProps: X,
      signal: ge,
      defaultProps: ve,
      compositionDurationInFrames: Y,
      compositionFps: Z,
      compositionHeight: G,
      compositionWidth: oe
    });
    if (de.type === "error")
      return g((I) => ({
        ...I,
        [K]: {
          type: "error",
          error: de.error
        }
      })), Q;
    const ne = de.result;
    return typeof ne == "object" && "then" in ne ? (g((I) => {
      const W = I[K];
      return W?.type === "success" || W?.type === "success-and-refreshing" ? {
        ...I,
        [K]: {
          type: "success-and-refreshing",
          result: W.result
        }
      } : {
        ...I,
        [K]: {
          type: "loading"
        }
      };
    }), ne.then((I) => {
      Q.signal.aborted || g((W) => ({
        ...W,
        [K]: {
          type: "success",
          result: I
        }
      }));
    }).catch((I) => {
      Q.signal.aborted || g((W) => ({
        ...W,
        [K]: {
          type: "error",
          error: I
        }
      }));
    })) : g((I) => ({
      ...I,
      [K]: {
        type: "success",
        result: ne
      }
    })), Q;
  }, [_]), T = s?.type === "composition" ? s.compositionId : null;
  m.useImperativeHandle(nb, () => ({
    setCurrentRenderModalComposition: (B) => {
      t(B);
    },
    reloadCurrentlySelectedComposition: () => {
      if (!T)
        return;
      const B = n.find((G) => G.id === T);
      if (!B)
        throw new Error(`Could not find composition with id ${T}`);
      const X = h[T] ?? {}, Y = {
        ...B.defaultProps ?? {},
        ...X ?? {}
      }, Z = {
        ...Y,
        ...d ?? {}
      };
      C({
        defaultProps: Y,
        calculateMetadata: B.calculateMetadata,
        combinedProps: Z,
        compositionDurationInFrames: B.durationInFrames ?? null,
        compositionFps: B.fps ?? null,
        compositionHeight: B.height ?? null,
        compositionWidth: B.width ?? null,
        compositionId: B.id
      });
    }
  }), [
    h,
    n,
    T,
    C,
    d
  ]);
  const k = c?.id === u?.id, M = m.useMemo(() => ({
    ...c?.defaultProps ?? {},
    ...v ?? {}
  }), [c?.defaultProps, v]), A = m.useMemo(() => ({
    ...M,
    ...d ?? {}
  }), [M, d]), D = c && sb(c), F = typeof window < "u" && window.remotion_ignoreFastRefreshUpdate && a <= window.remotion_ignoreFastRefreshUpdate;
  m.useEffect(() => {
    if (!F && D) {
      const B = C({
        calculateMetadata: c.calculateMetadata,
        combinedProps: A,
        compositionDurationInFrames: c.durationInFrames ?? null,
        compositionFps: c.fps ?? null,
        compositionHeight: c.height ?? null,
        compositionWidth: c.width ?? null,
        defaultProps: M,
        compositionId: c.id
      });
      return () => {
        B.abort();
      };
    }
  }, [
    D,
    M,
    C,
    A,
    c?.calculateMetadata,
    c?.durationInFrames,
    c?.fps,
    c?.height,
    c?.id,
    c?.width,
    F
  ]), m.useEffect(() => {
    F || window.dispatchEvent(new CustomEvent("remotion.propsUpdatedExternally"));
  }, [a]), m.useEffect(() => {
    if (u && !k) {
      const B = {
        ...u.defaultProps ?? {},
        ...b ?? {},
        ...d ?? {}
      }, X = C({
        calculateMetadata: u.calculateMetadata,
        compositionDurationInFrames: u.durationInFrames ?? null,
        compositionFps: u.fps ?? null,
        compositionHeight: u.height ?? null,
        compositionId: u.id,
        compositionWidth: u.width ?? null,
        defaultProps: M,
        combinedProps: B
      });
      return () => {
        X.abort();
      };
    }
  }, [
    M,
    C,
    d,
    k,
    u,
    b
  ]);
  const U = m.useMemo(() => {
    const B = n.filter((X) => X.calculateMetadata === null);
    return {
      ...p,
      ...B.reduce((X, Y) => ({
        ...X,
        [Y.id]: {
          type: "success",
          result: { ...Y, defaultProps: Y.defaultProps ?? {} }
        }
      }), {})
    };
  }, [n, p]);
  return /* @__PURE__ */ w.jsx(iu.Provider, {
    value: U,
    children: r
  });
}, Uf = (r) => {
  const e = m.useContext(iu), { props: t } = m.useContext(su), { compositions: n, canvasContent: s, currentCompositionMetadata: i } = m.useContext(Rs), a = s?.type === "composition" ? s.compositionId : null, c = r ?? a, u = n.find((d) => d.id === c), h = m.useMemo(() => u ? t[u.id] ?? {} : {}, [t, u]);
  return m.useMemo(() => u ? i ? {
    type: "success",
    result: {
      ...i,
      id: u.id,
      props: i.props,
      defaultProps: u.defaultProps ?? {},
      defaultCodec: i.defaultCodec
    }
  } : sb(u) ? e[u.id] ? e[u.id] : null : (Hf(u.durationInFrames, {
    allowFloats: !1,
    component: `in <Composition id="${u.id}">`
  }), tb(u.fps, `in <Composition id="${u.id}">`), _l(u.width, "width", `in <Composition id="${u.id}">`), _l(u.height, "height", `in <Composition id="${u.id}">`), {
    type: "success",
    result: {
      width: u.width,
      height: u.height,
      fps: u.fps,
      id: u.id,
      durationInFrames: u.durationInFrames,
      defaultProps: u.defaultProps ?? {},
      props: {
        ...u.defaultProps ?? {},
        ...h ?? {},
        ...typeof window > "u" || Bt().isPlayer ? {} : eb() ?? {}
      },
      defaultCodec: null
    }
  }) : null, [u, e, i, h]);
}, ou = () => {
  const { canvasContent: r, compositions: e, currentCompositionMetadata: t } = m.useContext(Rs), n = e.find((i) => r?.type === "composition" && i.id === r.compositionId), s = Uf(n?.id ?? null);
  return m.useMemo(() => !s || s.type === "error" || s.type === "loading" || !n ? null : {
    ...s.result,
    defaultProps: n.defaultProps ?? {},
    id: n.id,
    ...t ?? {},
    component: n.component
  }, [t, s, n]);
}, bn = m.createContext({
  frame: {},
  playing: !1,
  playbackRate: 1,
  rootId: "",
  imperativePlaying: {
    current: !1
  },
  setPlaybackRate: () => {
    throw new Error("default");
  },
  audioAndVideoTags: { current: [] }
}), xo = m.createContext({
  setFrame: () => {
    throw new Error("default");
  },
  setPlaying: () => {
    throw new Error("default");
  }
}), $f = () => "remotion.time-all", ob = (r) => {
  localStorage.setItem($f(), JSON.stringify(r));
}, ab = () => {
  const r = localStorage.getItem($f()) ?? "{}";
  return JSON.parse(r);
}, cb = (r) => {
  const e = localStorage.getItem($f()) ?? "{}", t = JSON.parse(e);
  return t[r] !== void 0 ? Number(t[r]) : typeof window > "u" ? 0 : window.remotion_initialFrame ?? 0;
}, Si = () => {
  const r = ou(), e = m.useContext(bn);
  if (!r)
    return typeof window > "u" ? 0 : window.remotion_initialFrame ?? 0;
  const t = e.frame[r.id] ?? (Bt().isPlayer ? 0 : cb(r.id));
  return Math.min(r.durationInFrames - 1, t);
}, lb = () => {
  const { setFrame: r } = m.useContext(xo);
  return r;
}, Yf = () => {
  const { playing: r, imperativePlaying: e } = m.useContext(bn), { setPlaying: t } = m.useContext(xo);
  return m.useMemo(() => [r, t, e], [e, r, t]);
}, Ci = m.createContext(!1), $d = ({ children: r }) => /* @__PURE__ */ w.jsx(Ci.Provider, {
  value: !0,
  children: r
}), au = () => {
  const r = m.useContext(dr), e = r?.width ?? null, t = r?.height ?? null, n = r?.durationInFrames ?? null, s = ou();
  return m.useMemo(() => {
    if (!s)
      return null;
    const {
      id: i,
      durationInFrames: a,
      fps: c,
      height: u,
      width: h,
      defaultProps: d,
      props: p,
      defaultCodec: g
    } = s;
    return {
      id: i,
      width: e ?? h,
      height: t ?? u,
      fps: c,
      durationInFrames: n ?? a,
      defaultProps: d,
      props: p,
      defaultCodec: g
    };
  }, [n, t, e, s]);
}, js = () => {
  const r = au(), e = m.useContext(Ci), t = zf();
  if (!r)
    throw typeof window < "u" && window.remotion_isPlayer || t ? new Error([
      "No video config found. Likely reasons:",
      "- You are probably calling useVideoConfig() from outside the component passed to <Player />. See https://www.remotion.dev/docs/player/examples for how to set up the Player correctly.",
      "- You have multiple versions of Remotion installed which causes the React context to get lost."
    ].join("-")) : new Error("No video config found. You are probably calling useVideoConfig() from a component which has not been registered as a <Composition />. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions for more information.");
  if (!e)
    throw new Error("Called useVideoConfig() outside a Remotion composition.");
  return r;
}, Ls = () => {
  if (!m.useContext(Ci))
    throw Bt().isPlayer ? new Error("useCurrentFrame can only be called inside a component that was passed to <Player>. See: https://www.remotion.dev/docs/player/examples") : new Error("useCurrentFrame() can only be called inside a component that was registered as a composition. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions");
  const e = Si(), t = m.useContext(dr), n = t ? t.cumulatedFrom + t.relativeFrom : 0;
  return e - n;
}, cI = ({
  frame: r,
  children: e,
  active: t = !0
}) => {
  const n = Ls(), s = js();
  if (typeof r > "u")
    throw new Error("The <Freeze /> component requires a 'frame' prop, but none was passed.");
  if (typeof r != "number")
    throw new Error(`The 'frame' prop of <Freeze /> must be a number, but is of type ${typeof r}`);
  if (Number.isNaN(r))
    throw new Error("The 'frame' prop of <Freeze /> must be a real number, but it is NaN.");
  if (!Number.isFinite(r))
    throw new Error(`The 'frame' prop of <Freeze /> must be a finite number, but it is ${r}.`);
  const i = m.useMemo(() => {
    if (typeof t == "boolean")
      return t;
    if (typeof t == "function")
      return t(n);
  }, [t, n]), a = m.useContext(bn), u = m.useContext(dr)?.relativeFrom ?? 0, h = m.useMemo(() => i ? {
    ...a,
    playing: !1,
    imperativePlaying: {
      current: !1
    },
    frame: {
      [s.id]: r + u
    }
  } : a, [i, a, s.id, r, u]);
  return /* @__PURE__ */ w.jsx(bn.Provider, {
    value: h,
    children: e
  });
}, lI = ({
  from: r = 0,
  durationInFrames: e = 1 / 0,
  children: t,
  name: n,
  height: s,
  width: i,
  showInTimeline: a = !0,
  _remotionInternalLoopDisplay: c,
  _remotionInternalStack: u,
  _remotionInternalPremountDisplay: h,
  ...d
}, p) => {
  const { layout: g = "absolute-fill" } = d, [v] = m.useState(() => String(Math.random())), b = m.useContext(dr), { rootId: _ } = m.useContext(bn), C = b ? b.cumulatedFrom + b.relativeFrom : 0, T = Wf();
  if (g !== "absolute-fill" && g !== "none")
    throw new TypeError(`The layout prop of <Sequence /> expects either "absolute-fill" or "none", but you passed: ${g}`);
  if (g === "none" && typeof d.style < "u")
    throw new TypeError('If layout="none", you may not pass a style.');
  if (typeof e != "number")
    throw new TypeError(`You passed to durationInFrames an argument of type ${typeof e}, but it must be a number.`);
  if (e <= 0)
    throw new TypeError(`durationInFrames must be positive, but got ${e}`);
  if (typeof r != "number")
    throw new TypeError(`You passed to the "from" props of your <Sequence> an argument of type ${typeof r}, but it must be a number.`);
  if (!Number.isFinite(r))
    throw new TypeError(`The "from" prop of a sequence must be finite, but got ${r}.`);
  const k = Si(), M = js(), A = b ? Math.min(b.durationInFrames - r, e) : e, D = Math.max(0, Math.min(M.durationInFrames - r, A)), { registerSequence: F, unregisterSequence: U } = m.useContext(bo), { hidden: B } = m.useContext(Ba), X = m.useMemo(() => b?.premounting ?? !!d._remotionInternalIsPremounting, [d._remotionInternalIsPremounting, b?.premounting]), Y = m.useMemo(() => ({
    cumulatedFrom: C,
    relativeFrom: r,
    durationInFrames: D,
    parentFrom: b?.relativeFrom ?? 0,
    id: v,
    height: s ?? b?.height ?? null,
    width: i ?? b?.width ?? null,
    premounting: X
  }), [
    C,
    r,
    D,
    b,
    v,
    s,
    i,
    X
  ]), Z = m.useMemo(() => n ?? "", [n]);
  m.useEffect(() => {
    if (Bt().isStudio)
      return F({
        from: r,
        duration: D,
        id: v,
        displayName: Z,
        parent: b?.id ?? null,
        type: "sequence",
        rootId: _,
        showInTimeline: a,
        nonce: T,
        loopDisplay: c,
        stack: u ?? null,
        premountDisplay: h ?? null
      }), () => {
        U(v);
      };
  }, [
    e,
    v,
    n,
    F,
    Z,
    U,
    b?.id,
    D,
    _,
    r,
    a,
    T,
    c,
    u,
    h
  ]);
  const G = Math.ceil(C + r + e - 1), K = k < C + r || k > G ? null : t, oe = d.layout === "none" ? void 0 : d.style, ve = m.useMemo(() => ({
    flexDirection: void 0,
    ...i ? { width: i } : {},
    ...s ? { height: s } : {},
    ...oe ?? {}
  }), [s, oe, i]);
  if (p !== null && g === "none")
    throw new TypeError('It is not supported to pass both a `ref` and `layout="none"` to <Sequence />.');
  return B[v] ?? !1 ? null : /* @__PURE__ */ w.jsx(dr.Provider, {
    value: Y,
    children: K === null ? null : d.layout === "none" ? K : /* @__PURE__ */ w.jsx(ha, {
      ref: p,
      style: ve,
      className: d.className,
      children: K
    })
  });
}, uI = m.forwardRef(lI), hI = (r, e) => {
  const t = Ls();
  if (r.layout === "none")
    throw new Error('`<Sequence>` with `premountFor` prop does not support layout="none"');
  const { style: n, from: s = 0, premountFor: i = 0, ...a } = r, c = t < s && t >= s - i, u = m.useMemo(() => ({
    ...n,
    opacity: c ? 0 : 1,
    pointerEvents: c ? "none" : n?.pointerEvents ?? void 0
  }), [c, n]);
  return /* @__PURE__ */ w.jsx(cI, {
    frame: s,
    active: c,
    children: /* @__PURE__ */ w.jsx(In, {
      ref: e,
      from: s,
      style: u,
      _remotionInternalPremountDisplay: i,
      _remotionInternalIsPremounting: c,
      ...a
    })
  });
}, dI = m.forwardRef(hI), fI = (r, e) => r.layout !== "none" && r.premountFor && !Bt().isRendering ? /* @__PURE__ */ w.jsx(dI, {
  ...r,
  ref: e
}) : /* @__PURE__ */ w.jsx(uI, {
  ...r,
  ref: e
}), In = m.forwardRef(fI), pI = (r) => {
  if (typeof r != "string")
    throw new TypeError(`The "filename" must be a string, but you passed a value of type ${typeof r}`);
  if (r.trim() === "")
    throw new Error("The `filename` must not be empty");
  if (!r.match(/^([0-9a-zA-Z-!_.*'()/:&$@=;+,?]+)/g))
    throw new Error('The `filename` must match "/^([0-9a-zA-Z-!_.*\'()/:&$@=;+,?]+)/g". Use forward slashes only, even on Windows.');
}, gI = (r) => {
  if (typeof r != "string" && !(r instanceof Uint8Array))
    throw new TypeError(`The "content" must be a string or Uint8Array, but you passed a value of type ${typeof r}`);
  if (typeof r == "string" && r.trim() === "")
    throw new Error("The `content` must not be empty");
}, ub = (r) => {
  r.type === "artifact" && (pI(r.filename), gI(r.content));
}, Ti = m.createContext({
  registerRenderAsset: () => {
  },
  unregisterRenderAsset: () => {
  },
  renderAssets: []
}), mI = ({ children: r }) => {
  const [e, t] = m.useState([]), n = m.useCallback((a) => {
    ub(a), t((c) => [...c, a]);
  }, []), s = m.useCallback((a) => {
    t((c) => c.filter((u) => u.id !== a));
  }, []);
  m.useLayoutEffect(() => {
    typeof window < "u" && (window.remotion_collectAssets = () => (t([]), e));
  }, [e]);
  const i = m.useMemo(() => ({
    registerRenderAsset: n,
    unregisterRenderAsset: s,
    renderAssets: e
  }), [e, n, s]);
  return /* @__PURE__ */ w.jsx(Ti.Provider, {
    value: i,
    children: r
  });
}, is = (r) => typeof window > "u" ? r : new URL(r, window.origin).href, hb = ({
  endAt: r,
  mediaDuration: e,
  playbackRate: t,
  startFrom: n
}) => {
  let s = e;
  typeof r < "u" && (s = r), typeof n < "u" && (s -= n);
  const i = s / t;
  return Math.floor(i);
};
function _a(r) {
  let e;
  throw vI(r) ? (e = r, e.stack || (e.stack = new Error(e.message).stack)) : typeof r == "string" ? e = Error(r) : e = Error("Rendering was cancelled"), window.remotion_cancelledError = e.stack, e;
}
var vI = (r) => r instanceof Error ? !0 : !(r === null || typeof r != "object" || !("stack" in r) || typeof r.stack != "string" || !("message" in r) || typeof r.message != "string"), db = m.createContext(null), yI = () => Ie.useContext(db), cu = ({ durationInFrames: r, times: e = 1 / 0, children: t, name: n, ...s }) => {
  const i = Ls(), { durationInFrames: a } = js();
  if (Hf(r, {
    component: "of the <Loop /> component",
    allowFloats: !0
  }), typeof e != "number")
    throw new TypeError(`You passed to "times" an argument of type ${typeof e}, but it must be a number.`);
  if (e !== 1 / 0 && e % 1 !== 0)
    throw new TypeError(`The "times" prop of a loop must be an integer, but got ${e}.`);
  if (e < 0)
    throw new TypeError(`The "times" prop of a loop must be at least 0, but got ${e}`);
  const c = Math.ceil(a / r), u = Math.min(c, e), h = s.layout === "none" ? void 0 : s.style, d = r * (u - 1), g = Math.floor(i / r) * r, v = Math.min(g, d), b = m.useMemo(() => ({
    numberOfTimes: u,
    startOffset: -v,
    durationInFrames: r
  }), [u, r, v]), _ = m.useMemo(() => ({
    iteration: Math.floor(i / r),
    durationInFrames: r
  }), [i, r]);
  return /* @__PURE__ */ w.jsx(db.Provider, {
    value: _,
    children: /* @__PURE__ */ w.jsx(In, {
      durationInFrames: r,
      from: v,
      name: n ?? "<Loop>",
      _remotionInternalLoopDisplay: b,
      layout: s.layout,
      style: h,
      children: t
    })
  });
};
cu.useLoop = yI;
var lu = m.createContext({}), Kv = {}, qh = [], fb = ({ children: r }) => {
  const [e, t] = m.useState(() => Kv);
  return m.useEffect(() => {
    const n = () => {
      t(Kv);
    };
    return qh.push(n), () => {
      qh = qh.filter((s) => s !== n);
    };
  }, []), /* @__PURE__ */ w.jsx(lu.Provider, {
    value: e,
    children: r
  });
}, _o = (r) => m.useContext(lu)[r] ?? r, Xf = (r, e) => {
  if (typeof r.volume != "number" && typeof r.volume != "function" && typeof r.volume < "u")
    throw new TypeError(`You have passed a volume of type ${typeof r.volume} to your <${e} /> component. Volume must be a number or a function with the signature '(frame: number) => number' undefined.`);
  if (typeof r.volume == "number" && r.volume < 0)
    throw new TypeError(`You have passed a volume below 0 to your <${e} /> component. Volume must be between 0 and 1`);
  if (typeof r.playbackRate != "number" && typeof r.playbackRate < "u")
    throw new TypeError(`You have passed a playbackRate of type ${typeof r.playbackRate} to your <${e} /> component. Playback rate must a real number or undefined.`);
  if (typeof r.playbackRate == "number" && (isNaN(r.playbackRate) || !Number.isFinite(r.playbackRate) || r.playbackRate <= 0))
    throw new TypeError(`You have passed a playbackRate of ${r.playbackRate} to your <${e} /> component. Playback rate must be a real number above 0.`);
}, Gf = (r, e) => {
  if (typeof r < "u") {
    if (typeof r != "number")
      throw new TypeError(`type of startFrom prop must be a number, instead got type ${typeof r}.`);
    if (isNaN(r) || r === 1 / 0)
      throw new TypeError("startFrom prop can not be NaN or Infinity.");
    if (r < 0)
      throw new TypeError(`startFrom must be greater than equal to 0 instead got ${r}.`);
  }
  if (typeof e < "u") {
    if (typeof e != "number")
      throw new TypeError(`type of endAt prop must be a number, instead got type ${typeof e}.`);
    if (isNaN(e))
      throw new TypeError("endAt prop can not be NaN.");
    if (e <= 0)
      throw new TypeError(`endAt must be a positive number, instead got ${e}.`);
  }
  if (e < r)
    throw new TypeError("endAt prop must be greater than startFrom prop.");
}, bI = (r, e) => {
  switch (e.type) {
    case "got-duration": {
      const t = is(e.src);
      return r[t] === e.durationInSeconds ? r : {
        ...r,
        [t]: e.durationInSeconds
      };
    }
    default:
      return r;
  }
}, qf = m.createContext({
  durations: {},
  setDurations: () => {
    throw new Error("context missing");
  }
}), pb = ({ children: r }) => {
  const [e, t] = m.useReducer(bI, {}), n = m.useMemo(() => ({
    durations: e,
    setDurations: t
  }), [e]);
  return /* @__PURE__ */ w.jsx(qf.Provider, {
    value: n,
    children: r
  });
};
function Zv(r) {
  let e = r + 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function wI(r) {
  let e = 0, t = 0, n = 0;
  for (e = 0; e < r.length; e++)
    t = r.charCodeAt(e), n = (n << 5) - n + t, n |= 0;
  return n;
}
var Ei = (r, e) => {
  if (r === null)
    return Math.random();
  if (typeof r == "string")
    return Zv(wI(r));
  if (typeof r == "number")
    return Zv(r * 1e10);
  throw new Error("random() argument must be a number or a string");
}, So = () => {
  const r = m.useContext(dr);
  return Math.min(0, r?.relativeFrom ?? 0);
}, Va = (r) => {
  const e = cu.useLoop(), t = Ls(), n = So();
  return r === "repeat" || e === null ? t + n : t + n + e.durationInFrames * e.iteration;
}, xI = (r) => {
  if (/data:|blob:/.test(r.substring(0, 5)))
    return "Data URL";
  const e = r.split("/").map((t) => t.split("\\")).flat(1);
  return e[e.length - 1];
}, Sl = (r, e, t) => {
  const { current: n } = r;
  if (!n)
    return;
  const s = n.play();
  s.catch && s.catch((i) => {
    if (n && !i.message.includes("request was interrupted by a call to pause") && !i.message.includes("The operation was aborted.") && !i.message.includes("The fetching process for the media resource was aborted by the user agent") && !i.message.includes("request was interrupted by a new load request") && !i.message.includes("because the media was removed from the document") && !(i.message.includes("user didn't interact with the document") && n.muted) && (console.log(`Could not play ${e} due to following error: `, i), !n.muted)) {
      if (t) {
        t();
        return;
      }
      console.log("The video will be muted and we'll retry playing it."), e === "video" && Bt().isPlayer && console.log("Use onAutoPlayError() to handle this error yourself."), n.muted = !0, n.play();
    }
  });
}, Co = ({
  frame: r,
  volume: e,
  mediaVolume: t = 1,
  allowAmplificationDuringRender: n
}) => {
  const s = n ? 1 / 0 : 1;
  if (typeof e == "number")
    return Math.min(s, e * t);
  if (typeof e > "u")
    return Number(t);
  const i = e(r) * t;
  if (typeof i != "number")
    throw new TypeError(`You passed in a a function to the volume prop but it did not return a number but a value of type ${typeof i} for frame ${r}`);
  if (Number.isNaN(i))
    throw new TypeError(`You passed in a function to the volume prop but it returned NaN for frame ${r}.`);
  if (!Number.isFinite(i))
    throw new TypeError(`You passed in a function to the volume prop but it returned a non-finite number for frame ${r}.`);
  return Math.max(0, Math.min(s, i));
}, Jv = {}, _I = (r) => {
  Jv[r] || (console.warn(r), Jv[r] = !0);
}, gb = ({
  volume: r,
  mediaVolume: e,
  mediaRef: t,
  src: n,
  mediaType: s,
  playbackRate: i,
  displayName: a,
  id: c,
  stack: u,
  showInTimeline: h,
  premountDisplay: d,
  onAutoPlayError: p
}) => {
  const g = js(), { rootId: v, audioAndVideoTags: b } = m.useContext(bn), _ = m.useContext(dr), C = _ ? _.relativeFrom + _.cumulatedFrom : 0, [T] = Yf(), k = So(), { registerSequence: M, unregisterSequence: A } = m.useContext(bo), [D] = m.useState(() => r), F = Wf(), U = _ ? Math.min(_.durationInFrames, g.durationInFrames) : g.durationInFrames, B = typeof r == "function", X = m.useMemo(() => typeof r == "number" ? r : new Array(Math.floor(Math.max(0, U + k))).fill(!0).map((Y, Z) => Co({
    frame: Z + k,
    volume: r,
    mediaVolume: e,
    allowAmplificationDuringRender: !1
  })).join(","), [U, k, r, e]);
  m.useEffect(() => {
    typeof r == "number" && r !== D && _I(`Remotion: The ${s} with src ${n} has changed it's volume. Prefer the callback syntax for setting volume to get better timeline display: https://www.remotion.dev/docs/using-audio/#controlling-volume`);
  }, [D, s, n, r]), m.useEffect(() => {
    if (t.current) {
      if (!n)
        throw new Error("No src passed");
      if (!(!Bt().isStudio && window.process?.env?.NODE_ENV !== "test") && h)
        return M({
          type: s,
          src: n,
          id: c,
          duration: U,
          from: 0,
          parent: _?.id ?? null,
          displayName: a ?? xI(n),
          rootId: v,
          volume: X,
          showInTimeline: !0,
          nonce: F,
          startMediaFrom: 0 - k,
          doesVolumeChange: B,
          loopDisplay: void 0,
          playbackRate: i,
          stack: u,
          premountDisplay: d
        }), () => {
          A(c);
        };
    }
  }, [
    C,
    U,
    c,
    _,
    n,
    M,
    v,
    A,
    g,
    X,
    B,
    F,
    t,
    s,
    k,
    i,
    a,
    u,
    h,
    d
  ]), m.useEffect(() => {
    const Y = {
      id: c,
      play: () => {
        if (T)
          return Sl(t, s, p);
      }
    };
    return b.current.push(Y), () => {
      b.current = b.current.filter((Z) => Z.id !== c);
    };
  }, [b, c, t, s, p, T]);
}, SI = () => {
  const [r, e] = m.useState([]), [t, n] = m.useState([]), [s, i] = m.useState([]), a = m.useRef(!1), c = m.useCallback((d) => (e((p) => [...p, d]), {
    unblock: () => {
      e((p) => {
        const g = p.filter((v) => v !== d);
        return g.length === p.length ? p : g;
      });
    }
  }), []), u = m.useCallback((d) => (n((p) => [...p, d]), {
    remove: () => {
      n((p) => p.filter((g) => g !== d));
    }
  }), []), h = m.useCallback((d) => (i((p) => [...p, d]), {
    remove: () => {
      i((p) => p.filter((g) => g !== d));
    }
  }), []);
  return m.useEffect(() => {
    r.length > 0 && t.forEach((d) => d());
  }, [r]), m.useEffect(() => {
    r.length === 0 && s.forEach((d) => d());
  }, [r]), m.useMemo(() => ({ addBlock: c, listenForBuffering: u, listenForResume: h, buffering: a }), [c, a, u, h]);
}, To = Ie.createContext(null), mb = ({ children: r }) => {
  const e = SI();
  return /* @__PURE__ */ w.jsx(To.Provider, {
    value: e,
    children: r
  });
}, CI = (r) => {
  const [e, t] = m.useState(r.buffering.current);
  return m.useEffect(() => {
    const n = () => {
      t(!0);
    }, s = () => {
      t(!1);
    };
    return r.listenForBuffering(n), r.listenForResume(s), () => {
      r.listenForBuffering(() => {
      }), r.listenForResume(() => {
      });
    };
  }, [r]), e;
}, Kf = () => {
  const r = m.useContext(To), e = r ? r.addBlock : null;
  return m.useMemo(() => ({
    delayPlayback: () => {
      if (!e)
        throw new Error("Tried to enable the buffering state, but a Remotion context was not found. This API can only be called in a component that was passed to the Remotion Player or a <Composition>. Or you might have experienced a version mismatch - run `npx remotion versions` and ensure all packages have the same version. This error is thrown by the buffer state https://remotion.dev/docs/player/buffer-state");
      const { unblock: t } = e({
        id: String(Math.random())
      });
      return { unblock: t };
    }
  }), [e]);
}, TI = ({
  mediaRef: r,
  mediaType: e,
  onVariableFpsVideoDetected: t,
  pauseWhenBuffering: n
}) => {
  const s = m.useRef(!1), { delayPlayback: i } = Kf(), a = m.useCallback((c) => {
    if (e !== "video" || !n)
      return;
    const u = r.current;
    if (!u || !u.requestVideoFrameCallback)
      return;
    s.current = !0;
    const h = i(), d = () => {
      h.unblock(), u.removeEventListener("ended", d, {
        once: !0
      }), u.removeEventListener("pause", d, {
        once: !0
      }), s.current = !1;
    }, p = () => {
      d();
    };
    u.requestVideoFrameCallback((g, v) => {
      Math.abs(v.mediaTime - c) > 0.5 && t(), d();
    }), u.addEventListener("ended", p, { once: !0 }), u.addEventListener("pause", p, { once: !0 }), u.addEventListener("canplay", p, {
      once: !0
    });
  }, [
    i,
    r,
    e,
    t,
    n
  ]);
  return m.useMemo(() => ({
    isBuffering: () => s.current,
    bufferUntilFirstFrame: a
  }), [a]);
}, EI = ({
  element: r,
  shouldBuffer: e,
  isPremounting: t
}) => {
  const n = Kf(), [s, i] = m.useState(!1);
  return m.useEffect(() => {
    let a = [];
    const { current: c } = r;
    if (!c || !e || t)
      return;
    const u = () => {
      a.forEach((p) => p()), a = [], i(!1);
    }, h = () => {
      i(!0);
      const { unblock: p } = n.delayPlayback(), g = () => {
        u(), d();
      }, v = () => {
        u(), d();
      };
      c.addEventListener("canplay", g, {
        once: !0
      }), a.push(() => {
        c.removeEventListener("canplay", g);
      }), c.addEventListener("error", v, {
        once: !0
      }), a.push(() => {
        c.removeEventListener("error", v);
      }), a.push(() => {
        p();
      });
    }, d = () => {
      c.readyState < c.HAVE_FUTURE_DATA ? (h(), navigator.userAgent.includes("Firefox/") || c.load()) : (c.addEventListener("waiting", h), a.push(() => {
        c.removeEventListener("waiting", h);
      }));
    };
    return d(), () => {
      u();
    };
  }, [n, r, t, e]), s;
}, kI = ({
  mediaRef: r,
  mediaType: e,
  lastSeek: t,
  onVariableFpsVideoDetected: n
}) => {
  const s = m.useRef(null);
  return m.useEffect(() => {
    const { current: i } = r;
    if (i)
      s.current = i.currentTime;
    else {
      s.current = null;
      return;
    }
    if (e !== "video") {
      s.current = null;
      return;
    }
    const a = i;
    if (!a.requestVideoFrameCallback)
      return;
    let c = () => {
    };
    const u = () => {
      if (!a)
        return;
      const h = a.requestVideoFrameCallback((d, p) => {
        if (s.current !== null) {
          const g = Math.abs(s.current - p.mediaTime), v = Math.abs(t.current === null ? 1 / 0 : p.mediaTime - t.current);
          g > 0.5 && v > 0.5 && p.mediaTime > s.current && n();
        }
        s.current = p.mediaTime, u();
      });
      c = () => {
        a.cancelVideoFrameCallback(h), c = () => {
        };
      };
    };
    return u(), () => {
      c();
    };
  }, [t, r, e, n]), s;
};
function OI(r, e, t, n) {
  const { extrapolateLeft: s, extrapolateRight: i, easing: a } = n;
  let c = r;
  const [u, h] = e, [d, p] = t;
  if (c < u) {
    if (s === "identity")
      return c;
    if (s === "clamp")
      c = u;
    else if (s === "wrap") {
      const g = h - u;
      c = ((c - u) % g + g) % g + u;
    }
  }
  if (c > h) {
    if (i === "identity")
      return c;
    if (i === "clamp")
      c = h;
    else if (i === "wrap") {
      const g = h - u;
      c = ((c - u) % g + g) % g + u;
    }
  }
  return d === p ? d : (c = (c - u) / (h - u), c = a(c), c = c * (p - d) + d, c);
}
function MI(r, e) {
  let t;
  for (t = 1; t < e.length - 1 && !(e[t] >= r); ++t)
    ;
  return t - 1;
}
function AI(r) {
  for (let e = 1; e < r.length; ++e)
    if (!(r[e] > r[e - 1]))
      throw new Error(`inputRange must be strictly monotonically increasing but got [${r.join(",")}]`);
}
function Qv(r, e) {
  if (e.length < 2)
    throw new Error(r + " must have at least 2 elements");
  for (const t of e) {
    if (typeof t != "number")
      throw new Error(`${r} must contain only numbers`);
    if (!Number.isFinite(t))
      throw new Error(`${r} must contain only finite numbers, but got [${e.join(",")}]`);
  }
}
function vb(r, e, t, n) {
  if (typeof r > "u")
    throw new Error("input can not be undefined");
  if (typeof e > "u")
    throw new Error("inputRange can not be undefined");
  if (typeof t > "u")
    throw new Error("outputRange can not be undefined");
  if (e.length !== t.length)
    throw new Error("inputRange (" + e.length + ") and outputRange (" + t.length + ") must have the same length");
  Qv("inputRange", e), Qv("outputRange", t), AI(e);
  const s = n?.easing ?? ((u) => u);
  let i = "extend";
  n?.extrapolateLeft !== void 0 && (i = n.extrapolateLeft);
  let a = "extend";
  if (n?.extrapolateRight !== void 0 && (a = n.extrapolateRight), typeof r != "number")
    throw new TypeError("Cannot interpolate an input which is not a number");
  const c = MI(r, e);
  return OI(r, [e[c], e[c + 1]], [t[c], t[c + 1]], {
    easing: s,
    extrapolateLeft: i,
    extrapolateRight: a
  });
}
var yb = ({
  frame: r,
  playbackRate: e,
  startFrom: t
}) => vb(r, [-1, t, t + 1], [-1, t, t + e]), bb = ({
  fps: r,
  frame: e,
  playbackRate: t,
  startFrom: n
}) => {
  const s = yb({
    frame: e,
    playbackRate: t,
    startFrom: n
  }), i = 1e3 / r;
  return s * i / 1e3;
}, wb = (r, e) => Math.round(r / e * 100) / 100, uu = () => {
  if (typeof window > "u")
    return !1;
  const r = /iP(ad|od|hone)/i.test(window.navigator.userAgent), e = /AppleWebKit/.test(window.navigator.userAgent);
  return r && e;
}, II = (r) => uu() && r.startsWith("blob:"), Yd = ({
  actualFrom: r,
  fps: e
}) => wb(Math.max(0, -r), e), Xd = ({
  duration: r,
  fps: e
}) => wb(r, e), PI = ({
  actualSrc: r,
  actualFrom: e,
  duration: t,
  fps: n
}) => {
  if (II(r) || r.startsWith("data:") || !!new URL(r, (typeof window > "u" ? null : window.location.href) ?? "http://localhost:3000").hash || !Number.isFinite(e))
    return r;
  const i = `${r}#t=${Yd({ actualFrom: e, fps: n })}`;
  return Number.isFinite(t) ? `${i},${Xd({ duration: t, fps: n })}` : i;
}, DI = ({
  prevStartFrom: r,
  newStartFrom: e,
  prevDuration: t,
  newDuration: n,
  fps: s
}) => {
  const i = Yd({ actualFrom: r, fps: s }), a = Yd({ actualFrom: e, fps: s }), c = Xd({ duration: t, fps: s }), u = Xd({ duration: n, fps: s });
  return !(a < i || u > c);
}, RI = ({
  actualSrc: r,
  actualFrom: e,
  duration: t,
  fps: n
}) => {
  const s = m.useRef(e), i = m.useRef(t), a = m.useRef(r);
  return (!DI({
    prevStartFrom: s.current,
    newStartFrom: e,
    prevDuration: i.current,
    newDuration: t,
    fps: n
  }) || r !== a.current) && (s.current = e, i.current = t, a.current = r), PI({
    actualSrc: a.current,
    actualFrom: s.current,
    duration: i.current,
    fps: n
  });
}, e0 = {}, jI = (r, e) => {
  if (r === null || r.seekable.length === 0 || r.seekable.length > 1 || e0[r.src])
    return;
  const t = { start: r.seekable.start(0), end: r.seekable.end(0) };
  if (t.start === 0 && t.end === 0) {
    const n = [
      `The media ${r.src} cannot be seeked. This could be one of few reasons:`,
      "1) The media resource was replaced while the video is playing but it was not loaded yet.",
      "2) The media does not support seeking.",
      "3) The media was loaded with security headers prventing it from being included.",
      "Please see https://remotion.dev/docs/non-seekable-media for assistance."
    ].join(`
`);
    if (e === "console-error")
      console.error(n);
    else if (e === "console-warning")
      console.warn(`The media ${r.src} does not support seeking. The video will render fine, but may not play correctly in the Remotion Studio and in the <Player>. See https://remotion.dev/docs/non-seekable-media for an explanation.`);
    else
      throw new Error(n);
    e0[r.src] = !0;
  }
}, Zf = 0.45, Kh = (r, e) => {
  if (!r.current)
    return;
  const t = uu() ? Number(e.toFixed(1)) : e;
  r.current.currentTime = t;
}, xb = ({
  mediaRef: r,
  src: e,
  mediaType: t,
  playbackRate: n,
  onlyWarnForMediaSeekingError: s,
  acceptableTimeshift: i,
  pauseWhenBuffering: a,
  isPremounting: c,
  debugSeeking: u,
  onAutoPlayError: h
}) => {
  const { playbackRate: d } = m.useContext(bn), p = Ls(), g = Si(), [v] = Yf(), b = m.useContext(To), { fps: _ } = js(), C = So(), T = m.useRef(null), k = m.useRef(null);
  if (!b)
    throw new Error("useMediaPlayback must be used inside a <BufferingContext>");
  const M = m.useRef({}), A = m.useCallback(() => {
    e && (u && console.log(`Detected ${e} as a variable FPS video. Disabling buffering while seeking.`), M.current[e] = !0);
  }, [u, e]), D = kI({
    mediaRef: r,
    mediaType: t,
    lastSeek: k,
    onVariableFpsVideoDetected: A
  }), F = bb({
    frame: p,
    playbackRate: n,
    startFrom: -C,
    fps: _
  }), U = EI({
    element: r,
    shouldBuffer: a,
    isPremounting: c
  }), { bufferUntilFirstFrame: B, isBuffering: X } = TI({
    mediaRef: r,
    mediaType: t,
    onVariableFpsVideoDetected: A,
    pauseWhenBuffering: a
  }), Y = n * d, Z = r.current?.duration ? Math.min(r.current.duration, i ?? Zf) : i, G = CI(b);
  m.useEffect(() => {
    if (!v) {
      r.current?.pause();
      return;
    }
    const K = U || X();
    G && !K && r.current?.pause();
  }, [X, U, G, r, v]), m.useEffect(() => {
    const K = t === "audio" ? "<Audio>" : "<Video>";
    if (!r.current)
      throw new Error(`No ${t} ref found`);
    if (!e)
      throw new Error(`No 'src' attribute was passed to the ${K} element.`);
    const oe = Math.max(0, Y);
    r.current.playbackRate !== oe && (r.current.playbackRate = oe);
    const { duration: ve } = r.current, Q = !Number.isNaN(ve) && Number.isFinite(ve) ? Math.min(ve, F) : F, ge = r.current.currentTime, de = D.current ?? null, ne = M.current[e], I = Math.abs(Q - ge), W = de ? Math.abs(Q - de) : null, ce = W && !ne ? W : I;
    if (u && console.log({
      mediaTagTime: ge,
      rvcTime: de,
      shouldBeTime: Q,
      state: r.current.readyState,
      playing: !r.current.paused,
      isVariableFpsVideo: ne
    }), ce > Z && T.current !== Q) {
      u && console.log("Seeking", {
        shouldBeTime: Q,
        isTime: ge,
        rvcTime: de,
        timeShift: ce,
        isVariableFpsVideo: ne
      }), Kh(r, Q), k.current = Q, T.current = Q, v && !ne && (Y > 0 && B(Q), r.current.paused && Sl(r, t, h)), s || jI(r.current, s ? "console-warning" : "console-error");
      return;
    }
    const fe = v ? 0.15 : 1e-5, be = Math.abs(r.current.currentTime - Q) > fe, ye = U || X(), ue = b.buffering.current && !ye;
    if (!v || ue) {
      be && (Kh(r, Q), k.current = Q);
      return;
    }
    (r.current.paused && !r.current.ended || g === 0) && (be && (Kh(r, Q), k.current = Q), Sl(r, t, h), ne || Y > 0 && B(Q));
  }, [
    g,
    Z,
    B,
    b.buffering,
    D,
    u,
    F,
    X,
    U,
    r,
    t,
    s,
    Y,
    v,
    e,
    h
  ]);
}, _b = (r) => {
  const [e, t] = m.useState(1);
  return m.useEffect(() => {
    const n = r.current;
    if (!n)
      return;
    const s = () => {
      t(n.volume);
    };
    return n.addEventListener("volumechange", s), () => n.removeEventListener("volumechange", s);
  }, [r]), m.useEffect(() => {
    const n = r.current;
    n && n.volume !== e && t(n.volume);
  }, [e, r]), e;
}, LI = 1e-5, Jf = (r, e) => Math.abs(r - e) < LI, Sb = ({
  volumePropFrame: r,
  actualVolume: e,
  volume: t,
  mediaVolume: n,
  mediaRef: s
}) => {
  m.useEffect(() => {
    const i = Co({
      frame: r,
      volume: t,
      mediaVolume: n,
      allowAmplificationDuringRender: !1
    });
    !Jf(i, e) && s.current && (s.current.volume = i);
  }, [e, r, s, t, n]);
}, Qf = m.createContext({
  mediaMuted: !1,
  mediaVolume: 1
}), ep = m.createContext({
  setMediaMuted: () => {
    throw new Error("default");
  },
  setMediaVolume: () => {
    throw new Error("default");
  }
}), tp = () => {
  const { mediaVolume: r } = m.useContext(Qf), { setMediaVolume: e } = m.useContext(ep);
  return m.useMemo(() => [r, e], [r, e]);
}, rp = () => {
  const { mediaMuted: r } = m.useContext(Qf), { setMediaMuted: e } = m.useContext(ep);
  return m.useMemo(() => [r, e], [r, e]);
}, t0 = "data:audio/mp3;base64,/+MYxAAJcAV8AAgAABn//////+/gQ5BAMA+D4Pg+BAQBAEAwD4Pg+D4EBAEAQDAPg++hYBH///hUFQVBUFREDQNHmf///////+MYxBUGkAGIMAAAAP/29Xt6lUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxDUAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV", FI = (r, e) => {
  const t = Object.keys(r).sort(), n = Object.keys(e).sort();
  if (t.length !== n.length)
    return !1;
  for (let s = 0; s < t.length; s++)
    if (t[s] !== n[s] || r[t[s]] !== e[n[s]])
      return !1;
  return !0;
}, NI = (r, e, t) => r === "src" && !t.startsWith("data:") && !e.startsWith("data:") ? new URL(t, window.origin).toString() !== new URL(e, window.origin).toString() : t !== e, hu = m.createContext(null), Cb = ({ children: r, numberOfAudioTags: e, component: t }) => {
  const n = m.useRef([]), [s] = m.useState(e);
  if (e !== s)
    throw new Error("The number of shared audio tags has changed dynamically. Once you have set this property, you cannot change it afterwards.");
  const i = m.useMemo(() => new Array(e).fill(!0).map(() => ({ id: Math.random(), ref: m.createRef() })), [e]), a = m.useRef(new Array(e).fill(!1)), c = m.useCallback(() => {
    i.forEach(({ ref: b, id: _ }) => {
      const C = n.current?.find((k) => k.id === _), { current: T } = b;
      if (T) {
        if (C === void 0) {
          T.src = t0;
          return;
        }
        if (!C)
          throw new TypeError("Expected audio data to be there");
        Object.keys(C.props).forEach((k) => {
          NI(k, C.props[k], T[k]) && (T[k] = C.props[k]);
        });
      }
    });
  }, [i]), u = m.useCallback((b, _) => {
    const C = n.current?.find((F) => F.audioId === _);
    if (C)
      return C;
    const T = a.current.findIndex((F) => F === !1);
    if (T === -1)
      throw new Error(`Tried to simultaneously mount ${e + 1} <Audio /> tags at the same time. With the current settings, the maximum amount of <Audio /> tags is limited to ${e} at the same time. Remotion pre-mounts silent audio tags to help avoid browser autoplay restrictions. See https://remotion.dev/docs/player/autoplay#use-the-numberofsharedaudiotags-property for more information on how to increase this limit.`);
    const { id: k, ref: M } = i[T], A = [...a.current];
    A[T] = k, a.current = A;
    const D = {
      props: b,
      id: k,
      el: M,
      audioId: _
    };
    return n.current?.push(D), c(), D;
  }, [e, i, c]), h = m.useCallback((b) => {
    const _ = [...a.current], C = i.findIndex((T) => T.id === b);
    if (C === -1)
      throw new TypeError("Error occured in ");
    _[C] = !1, a.current = _, n.current = n.current?.filter((T) => T.id !== b), c();
  }, [i, c]), d = m.useCallback(({
    aud: b,
    audioId: _,
    id: C
  }) => {
    let T = !1;
    n.current = n.current?.map((k) => k.id === C ? FI(b, k.props) ? k : (T = !0, {
      ...k,
      props: b,
      audioId: _
    }) : k), T && c();
  }, [c]), p = m.useCallback(() => {
    i.forEach((b) => {
      Sl(b.ref, "audio", null);
    });
  }, [i]), g = m.useMemo(() => ({
    registerAudio: u,
    unregisterAudio: h,
    updateAudio: d,
    playAllAudios: p,
    numberOfAudioTags: e
  }), [
    e,
    p,
    u,
    h,
    d
  ]), v = m.useCallback(() => {
    a.current = new Array(e).fill(!1), n.current = [], c();
  }, [e, c]);
  return m.useEffect(() => () => {
    v();
  }, [t, v]), /* @__PURE__ */ w.jsxs(hu.Provider, {
    value: g,
    children: [
      i.map(({ id: b, ref: _ }) => /* @__PURE__ */ w.jsx("audio", {
        ref: _,
        preload: "metadata",
        src: t0
      }, b)),
      r
    ]
  });
}, BI = (r, e) => {
  const t = m.useContext(hu), [n] = m.useState(() => t && t.numberOfAudioTags > 0 ? t.registerAudio(r, e) : {
    el: Ie.createRef(),
    id: Math.random(),
    props: r,
    audioId: e
  }), s = Ie.useInsertionEffect ?? Ie.useLayoutEffect;
  return typeof document < "u" && (s(() => {
    t && t.numberOfAudioTags > 0 && t.updateAudio({ id: n.id, aud: r, audioId: e });
  }, [r, t, n.id, e]), s(() => () => {
    t && t.numberOfAudioTags > 0 && t.unregisterAudio(n.id);
  }, [t, n.id])), n;
}, VI = (r, e) => {
  const [t] = m.useState(r.shouldPreMountAudioTags);
  if (r.shouldPreMountAudioTags !== t)
    throw new Error("Cannot change the behavior for pre-mounting audio tags dynamically.");
  const {
    volume: n,
    muted: s,
    playbackRate: i,
    shouldPreMountAudioTags: a,
    src: c,
    onDuration: u,
    acceptableTimeShiftInSeconds: h,
    _remotionInternalNeedsDurationCalculation: d,
    _remotionInternalNativeLoopPassed: p,
    _remotionInternalStack: g,
    _remotionDebugSeeking: v,
    allowAmplificationDuringRender: b,
    name: _,
    pauseWhenBuffering: C,
    showInTimeline: T,
    loopVolumeCurveBehavior: k,
    stack: M,
    ...A
  } = r, [D] = tp(), [F] = rp(), U = Va(k ?? "repeat"), { hidden: B } = m.useContext(Ba);
  if (!c)
    throw new TypeError("No 'src' was passed to <Audio>.");
  const X = _o(c), Y = m.useContext(dr), [Z] = m.useState(() => String(Math.random())), G = B[Z] ?? !1, K = Co({
    frame: U,
    volume: n,
    mediaVolume: D,
    allowAmplificationDuringRender: !1
  }), oe = m.useMemo(() => ({
    muted: s || F || G || K <= 0,
    src: X,
    loop: p,
    ...A
  }), [
    p,
    G,
    F,
    s,
    A,
    X,
    K
  ]), ve = m.useMemo(() => `audio-${Ei(c ?? "")}-${Y?.relativeFrom}-${Y?.cumulatedFrom}-${Y?.durationInFrames}-muted:${r.muted}-loop:${r.loop}`, [
    c,
    Y?.relativeFrom,
    Y?.cumulatedFrom,
    Y?.durationInFrames,
    r.muted,
    r.loop
  ]), Q = BI(oe, ve).el, ge = _b(Q);
  Sb({
    volumePropFrame: U,
    actualVolume: ge,
    volume: n,
    mediaVolume: D,
    mediaRef: Q
  }), gb({
    volume: n,
    mediaVolume: D,
    mediaRef: Q,
    src: c,
    mediaType: "audio",
    playbackRate: i ?? 1,
    displayName: _ ?? null,
    id: Z,
    stack: g,
    showInTimeline: T,
    premountDisplay: null,
    onAutoPlayError: null
  }), xb({
    mediaRef: Q,
    src: c,
    mediaType: "audio",
    playbackRate: i ?? 1,
    onlyWarnForMediaSeekingError: !1,
    acceptableTimeshift: h ?? Zf,
    isPremounting: !!Y?.premounting,
    pauseWhenBuffering: C,
    debugSeeking: v,
    onAutoPlayError: null
  }), m.useImperativeHandle(e, () => Q.current, [Q]);
  const de = m.useRef();
  return de.current = u, m.useEffect(() => {
    const { current: ne } = Q;
    if (!ne)
      return;
    if (ne.duration) {
      de.current?.(ne.src, ne.duration);
      return;
    }
    const I = () => {
      de.current?.(ne.src, ne.duration);
    };
    return ne.addEventListener("loadedmetadata", I), () => {
      ne.removeEventListener("loadedmetadata", I);
    };
  }, [Q, c]), t ? null : /* @__PURE__ */ w.jsx("audio", {
    ref: Q,
    preload: "metadata",
    ...oe
  });
}, zI = m.forwardRef(VI);
typeof window < "u" && (window.remotion_renderReady = !1);
var dl = [];
typeof window < "u" && (window.remotion_delayRenderTimeouts = {});
var WI = "The delayRender was called:", HI = "Retries left: ", UI = "- Rendering the frame will be retried.", r0 = 3e4, Es = (r, e) => {
  if (typeof r != "string" && typeof r < "u")
    throw new Error("The label parameter of delayRender() must be a string or undefined, got: " + JSON.stringify(r));
  const t = Math.random();
  dl.push(t);
  const n = Error().stack?.replace(/^Error/g, "") ?? "";
  if (Bt().isRendering) {
    const s = (e?.timeoutInMilliseconds ?? (typeof window > "u" ? r0 : window.remotion_puppeteerTimeout ?? r0)) - 2e3;
    if (typeof window < "u") {
      const i = (e?.retries ?? 0) - (window.remotion_attempt - 1);
      window.remotion_delayRenderTimeouts[t] = {
        label: r ?? null,
        timeout: setTimeout(() => {
          const a = [
            "A delayRender()",
            r ? `"${r}"` : null,
            `was called but not cleared after ${s}ms. See https://remotion.dev/docs/timeout for help.`,
            i > 0 ? HI + i : null,
            i > 0 ? UI : null,
            WI,
            n
          ].filter(nu).join(" ");
          _a(Error(a));
        }, s)
      };
    }
  }
  return typeof window < "u" && (window.remotion_renderReady = !1), t;
}, kt = (r) => {
  if (typeof r > "u")
    throw new TypeError("The continueRender() method must be called with a parameter that is the return value of delayRender(). No value was passed.");
  if (typeof r != "number")
    throw new TypeError("The parameter passed into continueRender() must be the return value of delayRender() which is a number. Got: " + JSON.stringify(r));
  dl = dl.filter((e) => e === r ? (Bt().isRendering && (clearTimeout(window.remotion_delayRenderTimeouts[r].timeout), delete window.remotion_delayRenderTimeouts[r]), !1) : !0), dl.length === 0 && typeof window < "u" && (window.remotion_renderReady = !0);
}, $I = (r, e) => {
  const t = m.useRef(null), {
    volume: n,
    playbackRate: s,
    allowAmplificationDuringRender: i,
    onDuration: a,
    toneFrequency: c,
    _remotionInternalNeedsDurationCalculation: u,
    _remotionInternalNativeLoopPassed: h,
    acceptableTimeShiftInSeconds: d,
    name: p,
    onError: g,
    delayRenderRetries: v,
    delayRenderTimeoutInMilliseconds: b,
    loopVolumeCurveBehavior: _,
    pauseWhenBuffering: C,
    ...T
  } = r, k = Si(), M = Va(_ ?? "repeat"), A = Ls(), D = m.useContext(dr), { registerRenderAsset: F, unregisterRenderAsset: U } = m.useContext(Ti), B = m.useMemo(() => `audio-${Ei(r.src ?? "")}-${D?.relativeFrom}-${D?.cumulatedFrom}-${D?.durationInFrames}`, [
    r.src,
    D?.relativeFrom,
    D?.cumulatedFrom,
    D?.durationInFrames
  ]), X = Co({
    volume: n,
    frame: M,
    mediaVolume: 1,
    allowAmplificationDuringRender: i ?? !1
  });
  m.useImperativeHandle(e, () => t.current, []), m.useEffect(() => {
    if (!r.src)
      throw new Error("No src passed");
    if (window.remotion_audioEnabled && !r.muted && !(X <= 0))
      return F({
        type: "audio",
        src: is(r.src),
        id: B,
        frame: k,
        volume: X,
        mediaFrame: A,
        playbackRate: r.playbackRate ?? 1,
        allowAmplificationDuringRender: i ?? !1,
        toneFrequency: c ?? null,
        audioStartFrame: Math.max(0, -(D?.relativeFrom ?? 0))
      }), () => U(B);
  }, [
    r.muted,
    r.src,
    F,
    k,
    B,
    U,
    X,
    M,
    A,
    s,
    r.playbackRate,
    i,
    c,
    D?.relativeFrom
  ]);
  const { src: Y } = r, Z = e || u;
  return m.useLayoutEffect(() => {
    if (window.process?.env?.NODE_ENV === "test" || !Z)
      return;
    const G = Es("Loading <Audio> duration with src=" + Y, {
      retries: v ?? void 0,
      timeoutInMilliseconds: b ?? void 0
    }), { current: K } = t, oe = () => {
      K?.duration && a(K.src, K.duration), kt(G);
    };
    return K?.duration ? (a(K.src, K.duration), kt(G)) : K?.addEventListener("loadedmetadata", oe, { once: !0 }), () => {
      K?.removeEventListener("loadedmetadata", oe), kt(G);
    };
  }, [
    Y,
    a,
    Z,
    v,
    b
  ]), Z ? /* @__PURE__ */ w.jsx("audio", {
    ref: t,
    ...T
  }) : null;
}, YI = m.forwardRef($I), XI = (r, e) => {
  const t = m.useContext(hu), {
    startFrom: n,
    endAt: s,
    name: i,
    stack: a,
    pauseWhenBuffering: c,
    showInTimeline: u,
    _remotionDebugSeeking: h,
    ...d
  } = r, { loop: p, ...g } = r, { fps: v } = js(), b = Bt(), { durations: _, setDurations: C } = m.useContext(qf);
  if (typeof r.src != "string")
    throw new TypeError(`The \`<Audio>\` tag requires a string for \`src\`, but got ${JSON.stringify(r.src)} instead.`);
  const T = _o(r.src), k = m.useCallback((D) => {
    console.log(D.currentTarget.error);
    const F = `Could not play audio with src ${T}: ${D.currentTarget.error}. See https://remotion.dev/docs/media-playback-error for help.`;
    p ? _a(new Error(F)) : console.warn(F);
  }, [p, T]), M = m.useCallback((D, F) => {
    C({ type: "got-duration", durationInSeconds: F, src: D });
  }, [C]), A = _[is(T)] ?? _[is(r.src)];
  if (p && A !== void 0) {
    if (!Number.isFinite(A))
      return /* @__PURE__ */ w.jsx(da, {
        ...g,
        ref: e,
        _remotionInternalNativeLoopPassed: !0
      });
    const D = A * v;
    return /* @__PURE__ */ w.jsx(cu, {
      layout: "none",
      durationInFrames: hb({
        endAt: s,
        mediaDuration: D,
        playbackRate: r.playbackRate ?? 1,
        startFrom: n
      }),
      children: /* @__PURE__ */ w.jsx(da, {
        ...g,
        ref: e,
        _remotionInternalNativeLoopPassed: !0
      })
    });
  }
  if (typeof n < "u" || typeof s < "u") {
    Gf(n, s);
    const D = n ?? 0, F = s ?? 1 / 0;
    return /* @__PURE__ */ w.jsx(In, {
      layout: "none",
      from: 0 - D,
      showInTimeline: !1,
      durationInFrames: F,
      name: i,
      children: /* @__PURE__ */ w.jsx(da, {
        _remotionInternalNeedsDurationCalculation: !!p,
        pauseWhenBuffering: c ?? !1,
        ...d,
        ref: e
      })
    });
  }
  return Xf(r, "Audio"), b.isRendering ? /* @__PURE__ */ w.jsx(YI, {
    onDuration: M,
    ...r,
    ref: e,
    onError: k,
    _remotionInternalNeedsDurationCalculation: !!p
  }) : /* @__PURE__ */ w.jsx(zI, {
    _remotionInternalNativeLoopPassed: r._remotionInternalNativeLoopPassed ?? !1,
    _remotionDebugSeeking: h ?? !1,
    _remotionInternalStack: a ?? null,
    shouldPreMountAudioTags: t !== null && t.numberOfAudioTags > 0,
    ...r,
    ref: e,
    onError: k,
    onDuration: M,
    pauseWhenBuffering: c ?? !1,
    _remotionInternalNeedsDurationCalculation: !!p,
    showInTimeline: u ?? !0
  });
}, da = m.forwardRef(XI);
Na(da);
var GI = m.createContext({
  folderName: null,
  parentName: null
}), qI = {
  transform: "rotate(90deg)"
}, n0 = 40, KI = {
  color: "white",
  fontSize: 14,
  fontFamily: "sans-serif"
}, ZI = {
  justifyContent: "center",
  alignItems: "center"
}, JI = () => /* @__PURE__ */ w.jsxs(ha, {
  style: ZI,
  id: "remotion-comp-loading",
  children: [
    /* @__PURE__ */ w.jsx("style", {
      type: "text/css",
      children: `
				@keyframes anim {
					from {
						opacity: 0
					}
					to {
						opacity: 1
					}
				}
				#remotion-comp-loading {
					animation: anim 2s;
					animation-fill-mode: forwards;
				}
			`
    }),
    /* @__PURE__ */ w.jsx("svg", {
      width: n0,
      height: n0,
      viewBox: "-100 -100 400 400",
      style: qI,
      children: /* @__PURE__ */ w.jsx("path", {
        fill: "#555",
        stroke: "#555",
        strokeWidth: "100",
        strokeLinejoin: "round",
        d: "M 2 172 a 196 100 0 0 0 195 5 A 196 240 0 0 0 100 2.259 A 196 240 0 0 0 2 172 z"
      })
    }),
    /* @__PURE__ */ w.jsxs("p", {
      style: KI,
      children: [
        "Resolving ",
        "<Suspense>",
        "..."
      ]
    })
  ]
}), Wr = null, Gd = () => {
  if (!Wr) {
    if (typeof document > "u")
      throw new Error("Tried to call an API that only works in the browser from outside the browser");
    Wr = document.createElement("div"), Wr.style.position = "absolute", Wr.style.top = "0px", Wr.style.left = "0px", Wr.style.right = "0px", Wr.style.bottom = "0px", Wr.style.width = "100%", Wr.style.height = "100%", Wr.style.display = "flex", Wr.style.flexDirection = "column";
    const r = document.createElement("div");
    r.style.position = "fixed", r.style.top = "-999999px", r.appendChild(Wr), document.body.appendChild(r);
  }
  return Wr;
}, Tb = (r) => m.useMemo(() => {
  if ("lazyComponent" in r && typeof r.lazyComponent < "u")
    return Ie.lazy(r.lazyComponent);
  if ("component" in r)
    return typeof document > "u" ? r.component : Ie.lazy(() => Promise.resolve({ default: r.component }));
  throw new Error("You must pass either 'component' or 'lazyComponent'");
}, [r.component, r.lazyComponent]), Eb = () => /^([a-zA-Z0-9-\u4E00-\u9FFF])+$/g, kb = (r) => r.match(Eb()), QI = (r) => {
  if (!kb(r))
    throw new Error(`Composition id can only contain a-z, A-Z, 0-9, CJK characters and -. You passed ${r}`);
}, eP = `Composition ID must match ${String(Eb())}`, tP = (r, e, t) => {
  if (r) {
    if (typeof r != "object")
      throw new Error(`"${e}" must be an object, but you passed a value of type ${typeof r}`);
    if (Array.isArray(r))
      throw new Error(`"${e}" must be an object, an array was passed ${t ? `for composition "${t}"` : ""}`);
  }
}, rP = () => (m.useEffect(() => {
  const r = Es("Waiting for Root component to unsuspend");
  return () => kt(r);
}, []), null), s0 = ({
  width: r,
  height: e,
  fps: t,
  durationInFrames: n,
  id: s,
  defaultProps: i,
  schema: a,
  ...c
}) => {
  const { registerComposition: u, unregisterComposition: h } = m.useContext(Rs), d = ou(), p = Tb(c), g = Wf(), v = zf(), b = Bt();
  if (m.useContext(Ci))
    throw v ? new Error("<Composition> was mounted inside the `component` that was passed to the <Player>. See https://remotion.dev/docs/wrong-composition-mount for help.") : new Error("<Composition> mounted inside another composition. See https://remotion.dev/docs/wrong-composition-mount for help.");
  const { folderName: C, parentName: T } = m.useContext(GI);
  m.useEffect(() => {
    if (!s)
      throw new Error("No id for composition passed.");
    return QI(s), tP(i, "defaultProps", s), u({
      durationInFrames: n ?? void 0,
      fps: t ?? void 0,
      height: e ?? void 0,
      width: r ?? void 0,
      id: s,
      folderName: C,
      component: p,
      defaultProps: Qs(i ?? {}),
      nonce: g,
      parentFolderName: T,
      schema: a ?? null,
      calculateMetadata: c.calculateMetadata ?? null
    }), () => {
      h(s);
    };
  }, [
    n,
    t,
    e,
    p,
    s,
    C,
    i,
    u,
    h,
    r,
    g,
    T,
    a,
    c.calculateMetadata
  ]);
  const k = Uf(s);
  if (b.isStudio && d && d.component === p) {
    const M = p;
    return k === null || k.type !== "success" ? null : kd.createPortal(/* @__PURE__ */ w.jsx($d, {
      children: /* @__PURE__ */ w.jsx(m.Suspense, {
        fallback: /* @__PURE__ */ w.jsx(JI, {}),
        children: /* @__PURE__ */ w.jsx(M, {
          ...k.result.props ?? {}
        })
      })
    }), Gd());
  }
  if (b.isRendering && d && d.component === p) {
    const M = p;
    return k === null || k.type !== "success" ? null : kd.createPortal(/* @__PURE__ */ w.jsx($d, {
      children: /* @__PURE__ */ w.jsx(m.Suspense, {
        fallback: /* @__PURE__ */ w.jsx(rP, {}),
        children: /* @__PURE__ */ w.jsx(M, {
          ...k.result.props ?? {}
        })
      })
    }), Gd());
  }
  return null;
}, Ob = Ie.createRef(), nP = ({ children: r, numberOfAudioTags: e }) => {
  const [t, n] = m.useState([]), s = m.useRef(t), [i, a] = m.useState([]), [c, u] = m.useState(null), [h, d] = m.useState(null), p = m.useCallback((M) => {
    n((A) => {
      const D = M(A);
      return s.current = D, D;
    });
  }, []), g = m.useCallback((M) => {
    p((A) => {
      if (A.find((F) => F.id === M.id))
        throw new Error(`Multiple composition with id ${M.id} are registered.`);
      return [...A, M].slice().sort((F, U) => F.nonce - U.nonce);
    });
  }, [p]), v = m.useCallback((M) => {
    n((A) => A.filter((D) => D.id !== M));
  }, []), b = m.useCallback((M, A) => {
    a((D) => [
      ...D,
      {
        name: M,
        parent: A
      }
    ]);
  }, []), _ = m.useCallback((M, A) => {
    a((D) => D.filter((F) => !(F.name === M && F.parent === A)));
  }, []);
  m.useImperativeHandle(Ob, () => ({
    getCompositions: () => s.current
  }), []);
  const C = t.find((M) => c?.type === "composition" ? M.id === c.compositionId : null), T = m.useCallback((M, A) => {
    n((D) => D.map((U) => U.id === M ? {
      ...U,
      defaultProps: A
    } : U));
  }, []), k = m.useMemo(() => ({
    compositions: t,
    registerComposition: g,
    unregisterComposition: v,
    folders: i,
    registerFolder: b,
    unregisterFolder: _,
    currentCompositionMetadata: h,
    setCurrentCompositionMetadata: d,
    canvasContent: c,
    setCanvasContent: u,
    updateCompositionDefaultProps: T
  }), [
    t,
    g,
    v,
    i,
    b,
    _,
    h,
    c,
    T
  ]);
  return /* @__PURE__ */ w.jsx(Rs.Provider, {
    value: k,
    children: /* @__PURE__ */ w.jsx(K5, {
      children: /* @__PURE__ */ w.jsx(mI, {
        children: /* @__PURE__ */ w.jsx(ib, {
          children: /* @__PURE__ */ w.jsx(Cb, {
            numberOfAudioTags: e,
            component: C?.component ?? null,
            children: r
          })
        })
      })
    })
  });
}, sP = ({
  onLoad: r,
  onError: e,
  delayRenderRetries: t,
  delayRenderTimeoutInMilliseconds: n,
  ...s
}, i) => {
  const [a] = m.useState(() => Es(`Loading <IFrame> with source ${s.src}`, {
    retries: t ?? void 0,
    timeoutInMilliseconds: n ?? void 0
  })), c = m.useCallback((h) => {
    kt(a), r?.(h);
  }, [a, r]), u = m.useCallback((h) => {
    kt(a), e ? e(h) : console.error("Error loading iframe:", h, "Handle the event using the onError() prop to make this message disappear.");
  }, [a, e]);
  return /* @__PURE__ */ w.jsx("iframe", {
    ...s,
    ref: i,
    onError: u,
    onLoad: c
  });
};
m.forwardRef(sP);
function iP(r) {
  return 1e3 * 2 ** (r - 1);
}
var oP = ({
  onError: r,
  maxRetries: e = 2,
  src: t,
  pauseWhenLoading: n,
  delayRenderRetries: s,
  delayRenderTimeoutInMilliseconds: i,
  onImageFrame: a,
  ...c
}, u) => {
  const h = m.useRef(null), d = m.useRef({}), { delayPlayback: p } = Kf(), g = m.useContext(dr);
  if (!t)
    throw new Error('No "src" prop was passed to <Img>.');
  m.useImperativeHandle(u, () => h.current, []);
  const v = _o(t), b = m.useCallback((C) => {
    if (!h.current)
      return;
    const T = h.current.src;
    setTimeout(() => {
      if (!h.current)
        return;
      const k = h.current?.src;
      k === T && (h.current.removeAttribute("src"), h.current.setAttribute("src", k));
    }, C);
  }, []), _ = m.useCallback((C) => {
    if (d.current) {
      if (d.current[h.current?.src] = (d.current[h.current?.src] ?? 0) + 1, r && (d.current[h.current?.src] ?? 0) > e) {
        r(C);
        return;
      }
      if ((d.current[h.current?.src] ?? 0) <= e) {
        const T = iP(d.current[h.current?.src] ?? 0);
        console.warn(`Could not load image with source ${h.current?.src}, retrying again in ${T}ms`), b(T);
        return;
      }
      _a("Error loading image with src: " + h.current?.src);
    }
  }, [e, r, b]);
  if (typeof window < "u") {
    const C = !!g?.premounting;
    m.useLayoutEffect(() => {
      if (window.process?.env?.NODE_ENV === "test") {
        h.current && (h.current.src = v);
        return;
      }
      const T = Es("Loading <Img> with src=" + v, {
        retries: s ?? void 0,
        timeoutInMilliseconds: i ?? void 0
      }), k = n && !C ? p().unblock : () => {
      }, { current: M } = h;
      let A = !1;
      const D = () => {
        A || ((d.current[h.current?.src] ?? 0) > 0 && (delete d.current[h.current?.src], console.info(`Retry successful - ${h.current?.src} is now loaded`)), M && (M.src = v, a?.(M)), k(), kt(T));
      }, F = new Image();
      return F.src = v, F.decode().then(D).catch((U) => {
        console.warn(U), F.complete ? D() : F.addEventListener("load", D);
      }), () => {
        A = !0, F.removeEventListener("load", D), k(), kt(T);
      };
    }, [
      v,
      p,
      s,
      i,
      n,
      C,
      a
    ]);
  }
  return /* @__PURE__ */ w.jsx("img", {
    ...c,
    ref: h,
    onError: _
  });
}, Mb = m.forwardRef(oP), Ab = {};
Y1(Ab, {
  makeDefaultPreviewCSS: () => cP,
  injectCSS: () => aP,
  OFFTHREAD_VIDEO_CLASS_NAME: () => Cl
});
var i0 = {}, aP = (r) => {
  if (typeof document > "u" || i0[r])
    return;
  const e = document.head || document.getElementsByTagName("head")[0], t = document.createElement("style");
  t.appendChild(document.createTextNode(r)), e.prepend(t), i0[r] = !0;
}, Cl = "__remotion_offthreadvideo", cP = (r, e) => r ? `
    ${r} * {
      box-sizing: border-box;
    }
    ${r} *:-webkit-full-screen {
      width: 100%;
      height: 100%;
    }
    ${r} .${Cl} {
      object-fit: contain;
    }
  ` : `
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
	    background-color: ${e};
    }
    .${Cl} {
      object-fit: contain;
    }
    `, Ib = "__remotion-studio-container", lP = () => document.getElementById(Ib), uP = null, Zh = [], hP = () => uP, dP = (r) => (Zh.push(r), () => {
  Zh = Zh.filter((e) => e !== r);
}), fP = ({ children: r, numberOfAudioTags: e }) => {
  const [t] = m.useState(() => String(Ei(null))), [n, s] = m.useState(() => ab()), [i, a] = m.useState(!1), c = m.useRef(!1), [u, h] = m.useState(0), [d, p] = m.useState(1), g = m.useRef([]);
  typeof window < "u" && m.useLayoutEffect(() => {
    window.remotion_setFrame = (C, T, k) => {
      window.remotion_attempt = k;
      const M = Es(`Setting the current frame to ${C}`);
      let A = !0;
      s((D) => (D[T] ?? window.remotion_initialFrame) === C ? (A = !1, D) : {
        ...D,
        [T]: C
      }), A ? requestAnimationFrame(() => kt(M)) : kt(M);
    }, window.remotion_isPlayer = !1;
  }, []);
  const v = m.useMemo(() => ({
    frame: n,
    playing: i,
    imperativePlaying: c,
    rootId: t,
    playbackRate: d,
    setPlaybackRate: p,
    audioAndVideoTags: g
  }), [n, d, i, t]), b = m.useMemo(() => ({
    setFrame: s,
    setPlaying: a
  }), []), _ = m.useMemo(() => {
    let C = 0;
    return {
      getNonce: () => C++,
      fastRefreshes: u
    };
  }, [u]);
  return m.useEffect(() => {
    typeof __webpack_module__ < "u" && __webpack_module__.hot && __webpack_module__.hot.addStatusHandler((C) => {
      C === "idle" && h((T) => T + 1);
    });
  }, []), /* @__PURE__ */ w.jsx(wo.Provider, {
    value: _,
    children: /* @__PURE__ */ w.jsx(bn.Provider, {
      value: v,
      children: /* @__PURE__ */ w.jsx(xo.Provider, {
        value: b,
        children: /* @__PURE__ */ w.jsx(J1, {
          children: /* @__PURE__ */ w.jsx(fb, {
            children: /* @__PURE__ */ w.jsx(nP, {
              numberOfAudioTags: e,
              children: /* @__PURE__ */ w.jsx(pb, {
                children: /* @__PURE__ */ w.jsx(mb, {
                  children: r
                })
              })
            })
          })
        })
      })
    })
  });
}, pP = () => {
  if (Bt().isRendering) {
    const r = window.remotion_envVariables;
    return r ? { ...JSON.parse(r), NODE_ENV: "production" } : {};
  }
  return {
    NODE_ENV: "production"
  };
}, gP = () => {
  const r = pP();
  window.process || (window.process = {}), window.process.env || (window.process.env = {}), Object.keys(r).forEach((e) => {
    window.process.env[e] = r[e];
  });
}, mP = Ie.createContext(null), vP = m.createContext({
  setSize: () => {
  },
  size: { size: "auto", translation: { x: 0, y: 0 } }
}), yP = ({
  canvasSize: r,
  compositionHeight: e,
  compositionWidth: t,
  previewSize: n
}) => {
  const s = r.height / e, i = r.width / t, a = Math.min(s, i);
  return n === "auto" ? a : Number(n);
}, bP = "remotion_staticFilesChanged";
function wP() {
  const r = Ie.useContext(Rs), e = Ie.useContext(bn), t = Ie.useContext(xo), n = Ie.useContext(dr), s = Ie.useContext(wo), i = Ie.useContext(Ci), a = Ie.useContext(lu), c = Ie.useContext(iu), u = Ie.useContext(Ti), h = Ie.useContext(bo), d = Ie.useContext(To);
  return m.useMemo(() => ({
    compositionManagerCtx: r,
    timelineContext: e,
    setTimelineContext: t,
    sequenceContext: n,
    nonceContext: s,
    canUseRemotionHooksContext: i,
    preloadContext: a,
    resolveCompositionContext: c,
    renderAssetManagerContext: u,
    sequenceManagerContext: h,
    bufferManagerContext: d
  }), [
    r,
    s,
    n,
    t,
    e,
    i,
    a,
    c,
    u,
    h,
    d
  ]);
}
var xP = (r) => {
  const { children: e, contexts: t } = r;
  return /* @__PURE__ */ w.jsx(Ci.Provider, {
    value: t.canUseRemotionHooksContext,
    children: /* @__PURE__ */ w.jsx(wo.Provider, {
      value: t.nonceContext,
      children: /* @__PURE__ */ w.jsx(lu.Provider, {
        value: t.preloadContext,
        children: /* @__PURE__ */ w.jsx(Rs.Provider, {
          value: t.compositionManagerCtx,
          children: /* @__PURE__ */ w.jsx(bo.Provider, {
            value: t.sequenceManagerContext,
            children: /* @__PURE__ */ w.jsx(Ti.Provider, {
              value: t.renderAssetManagerContext,
              children: /* @__PURE__ */ w.jsx(iu.Provider, {
                value: t.resolveCompositionContext,
                children: /* @__PURE__ */ w.jsx(bn.Provider, {
                  value: t.timelineContext,
                  children: /* @__PURE__ */ w.jsx(xo.Provider, {
                    value: t.setTimelineContext,
                    children: /* @__PURE__ */ w.jsx(dr.Provider, {
                      value: t.sequenceContext,
                      children: /* @__PURE__ */ w.jsx(To.Provider, {
                        value: t.bufferManagerContext,
                        children: e
                      })
                    })
                  })
                })
              })
            })
          })
        })
      })
    })
  });
}, Pe = {
  useUnsafeVideoConfig: au,
  Timeline: K1,
  CompositionManager: Rs,
  SequenceManager: bo,
  SequenceVisibilityToggleContext: Ba,
  RemotionRoot: fP,
  useVideo: ou,
  getRoot: hP,
  useMediaVolumeState: tp,
  useMediaMutedState: rp,
  useLazyComponent: Tb,
  truthy: nu,
  SequenceContext: dr,
  useRemotionContexts: wP,
  RemotionContextProvider: xP,
  CSSUtils: Ab,
  setupEnvVariables: gP,
  MediaVolumeContext: Qf,
  SetMediaVolumeContext: ep,
  getRemotionEnvironment: Bt,
  SharedAudioContext: hu,
  SharedAudioContextProvider: Cb,
  invalidCompositionErrorMessage: eP,
  isCompositionIdValid: kb,
  getPreviewDomElement: lP,
  compositionsRef: Ob,
  portalNode: Gd,
  waitForRoot: dP,
  CanUseRemotionHooksProvider: $d,
  CanUseRemotionHooks: Ci,
  PrefetchProvider: fb,
  DurationsContextProvider: pb,
  IsPlayerContextProvider: X5,
  useIsPlayer: zf,
  EditorPropsProvider: J1,
  EditorPropsContext: su,
  usePreload: _o,
  NonceContext: wo,
  resolveVideoConfig: rb,
  useResolvedVideoConfig: Uf,
  resolveCompositionsRef: nb,
  ResolveCompositionConfig: ib,
  REMOTION_STUDIO_CONTAINER_ELEMENT: Ib,
  RenderAssetManager: Ti,
  persistCurrentFrame: ob,
  useTimelineSetFrame: lb,
  isIosSafari: uu,
  WATCH_REMOTION_STATIC_FILES: bP,
  addSequenceStackTraces: Na,
  useMediaStartsAt: So,
  BufferingProvider: mb,
  BufferingContextReact: To,
  enableSequenceStackTraces: G1,
  CurrentScaleContext: mP,
  PreviewSizeContext: vP,
  calculateScale: yP,
  editorPropsProviderRef: Z1,
  PROPS_UPDATED_EXTERNALLY: aI,
  validateRenderAsset: ub
}, _P = ({
  src: r,
  transparent: e,
  currentTime: t,
  toneMapped: n
}) => `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(is(r))}&time=${encodeURIComponent(t)}&transparent=${String(e)}&toneMapped=${String(n)}`, Pb = m.createContext(!1), SP = ({ children: r }) => /* @__PURE__ */ w.jsx(Pb.Provider, {
  value: !1,
  children: r
}), CP = () => {
  if (!Ie.useContext(Pb))
    throw new Error("This component must be inside a <Series /> component.");
}, TP = ({ children: r }, e) => (CP(), /* @__PURE__ */ w.jsx(SP, {
  children: r
})), EP = m.forwardRef(TP);
Na(EP);
var kP = ({
  onError: r,
  volume: e,
  playbackRate: t,
  src: n,
  muted: s,
  allowAmplificationDuringRender: i,
  transparent: a = !1,
  toneMapped: c = !0,
  toneFrequency: u,
  name: h,
  loopVolumeCurveBehavior: d,
  delayRenderRetries: p,
  delayRenderTimeoutInMilliseconds: g,
  onVideoFrame: v,
  ...b
}) => {
  const _ = Si(), C = Ls(), T = Va(d ?? "repeat"), k = au(), M = m.useContext(dr), A = So(), { registerRenderAsset: D, unregisterRenderAsset: F } = m.useContext(Ti);
  if (!n)
    throw new TypeError("No `src` was passed to <OffthreadVideo>.");
  const U = m.useMemo(() => `offthreadvideo-${Ei(n ?? "")}-${M?.cumulatedFrom}-${M?.relativeFrom}-${M?.durationInFrames}`, [
    n,
    M?.cumulatedFrom,
    M?.relativeFrom,
    M?.durationInFrames
  ]);
  if (!k)
    throw new Error("No video config found");
  const B = Co({
    volume: e,
    frame: T,
    mediaVolume: 1,
    allowAmplificationDuringRender: i ?? !1
  });
  m.useEffect(() => {
    if (!n)
      throw new Error("No src passed");
    if (window.remotion_audioEnabled && !s && !(B <= 0))
      return D({
        type: "video",
        src: is(n),
        id: U,
        frame: _,
        volume: B,
        mediaFrame: C,
        playbackRate: t ?? 1,
        allowAmplificationDuringRender: i ?? !1,
        toneFrequency: u ?? null,
        audioStartFrame: Math.max(0, -(M?.relativeFrom ?? 0))
      }), () => F(U);
  }, [
    s,
    n,
    D,
    U,
    F,
    B,
    C,
    _,
    t,
    i,
    u,
    M?.relativeFrom
  ]);
  const X = m.useMemo(() => yb({
    frame: C,
    playbackRate: t || 1,
    startFrom: -A
  }) / k.fps, [C, A, t, k.fps]), Y = m.useMemo(() => _P({
    src: n,
    currentTime: X,
    transparent: a,
    toneMapped: c
  }), [c, X, n, a]), [Z, G] = m.useState(null);
  m.useLayoutEffect(() => {
    if (!window.remotion_videoEnabled)
      return;
    const Q = [];
    G(null);
    const ge = new AbortController(), de = Es(`Fetching ${Y} from server`, {
      retries: p ?? void 0,
      timeoutInMilliseconds: g ?? void 0
    });
    return (async () => {
      try {
        const I = await fetch(Y, {
          signal: ge.signal
        });
        if (I.status !== 200) {
          if (I.status === 500) {
            const fe = await I.json();
            if (fe.error) {
              const be = fe.error.replace(/^Error: /, "");
              throw new Error(be);
            }
          }
          throw new Error(`Server returned status ${I.status} while fetching ${Y}`);
        }
        const W = await I.blob(), ce = URL.createObjectURL(W);
        Q.push(() => URL.revokeObjectURL(ce)), G({
          src: ce,
          handle: de
        });
      } catch (I) {
        if (I.message.includes("aborted")) {
          kt(de);
          return;
        }
        if (ge.signal.aborted) {
          kt(de);
          return;
        }
        I.message.includes("Failed to fetch") && (I = new Error(`Failed to fetch ${Y}. This could be caused by Chrome rejecting the request because the disk space is low. Consider increasing the disk size of your environment.`, { cause: I })), r ? r(I) : _a(I);
      }
    })(), Q.push(() => {
      ge.signal.aborted || ge.abort();
    }), () => {
      Q.forEach((I) => I());
    };
  }, [
    Y,
    p,
    g,
    r
  ]);
  const K = m.useCallback(() => {
    r ? r?.(new Error("Failed to load image with src " + Z)) : _a("Failed to load image with src " + Z);
  }, [Z, r]), oe = m.useMemo(() => [Cl, b.className].filter(nu).join(" "), [b.className]), ve = m.useCallback((Q) => {
    v && v(Q);
  }, [v]);
  return !Z || !window.remotion_videoEnabled ? null : (kt(Z.handle), /* @__PURE__ */ w.jsx(Mb, {
    src: Z.src,
    className: oe,
    delayRenderRetries: p,
    delayRenderTimeoutInMilliseconds: g,
    onImageFrame: ve,
    ...b,
    onError: K
  }));
}, OP = ({
  ref: r,
  onVideoFrame: e
}) => {
  m.useEffect(() => {
    const { current: t } = r;
    if (!t || !e)
      return;
    let n = 0;
    const s = () => {
      r.current && (e(r.current), n = r.current.requestVideoFrameCallback(s));
    };
    return s(), () => {
      t.cancelVideoFrameCallback(n);
    };
  }, [e, r]);
}, MP = (r, e) => {
  const t = m.useRef(null), {
    volume: n,
    muted: s,
    playbackRate: i,
    onlyWarnForMediaSeekingError: a,
    src: c,
    onDuration: u,
    acceptableTimeShift: h,
    acceptableTimeShiftInSeconds: d,
    toneFrequency: p,
    name: g,
    _remotionInternalNativeLoopPassed: v,
    _remotionInternalStack: b,
    _remotionDebugSeeking: _,
    style: C,
    pauseWhenBuffering: T,
    showInTimeline: k,
    loopVolumeCurveBehavior: M,
    onError: A,
    onAutoPlayError: D,
    onVideoFrame: F,
    crossOrigin: U,
    ...B
  } = r, X = Va(M ?? "repeat"), { fps: Y, durationInFrames: Z } = js(), G = m.useContext(dr), { hidden: K } = m.useContext(Ba), [oe] = m.useState(() => String(Math.random())), ve = K[oe] ?? !1;
  if (typeof h < "u")
    throw new Error("acceptableTimeShift has been removed. Use acceptableTimeShiftInSeconds instead.");
  const Q = _b(t), [ge] = tp(), [de] = rp();
  gb({
    mediaRef: t,
    volume: n,
    mediaVolume: ge,
    mediaType: "video",
    src: c,
    playbackRate: r.playbackRate ?? 1,
    displayName: g ?? null,
    id: oe,
    stack: b,
    showInTimeline: k,
    premountDisplay: null,
    onAutoPlayError: D ?? null
  }), Sb({
    volumePropFrame: X,
    actualVolume: Q,
    volume: n,
    mediaVolume: ge,
    mediaRef: t
  }), xb({
    mediaRef: t,
    src: c,
    mediaType: "video",
    playbackRate: r.playbackRate ?? 1,
    onlyWarnForMediaSeekingError: a,
    acceptableTimeshift: d ?? Zf,
    isPremounting: !!G?.premounting,
    pauseWhenBuffering: T,
    debugSeeking: _,
    onAutoPlayError: D ?? null
  });
  const ne = G ? G.relativeFrom : 0, I = G ? Math.min(G.durationInFrames, Z) : Z, W = RI({
    actualSrc: _o(c),
    actualFrom: ne,
    duration: I,
    fps: Y
  });
  m.useImperativeHandle(e, () => t.current, []), m.useEffect(() => {
    const { current: ye } = t;
    if (!ye)
      return;
    const ue = () => {
      if (ye.error) {
        if (console.error("Error occurred in video", ye?.error), A) {
          const Xe = new Error(`Code ${ye.error.code}: ${ye.error.message}`);
          A(Xe);
          return;
        }
        throw new Error(`The browser threw an error while playing the video ${c}: Code ${ye.error.code} - ${ye?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);
      } else {
        if (A) {
          const Xe = new Error(`The browser threw an error while playing the video ${c}`);
          A(Xe);
          return;
        }
        throw new Error("The browser threw an error while playing the video");
      }
    };
    return ye.addEventListener("error", ue, { once: !0 }), () => {
      ye.removeEventListener("error", ue);
    };
  }, [A, c]);
  const ce = m.useRef();
  ce.current = u, OP({ ref: t, onVideoFrame: F }), m.useEffect(() => {
    const { current: ye } = t;
    if (!ye)
      return;
    if (ye.duration) {
      ce.current?.(c, ye.duration);
      return;
    }
    const ue = () => {
      ce.current?.(c, ye.duration);
    };
    return ye.addEventListener("loadedmetadata", ue), () => {
      ye.removeEventListener("loadedmetadata", ue);
    };
  }, [c]), m.useEffect(() => {
    const { current: ye } = t;
    ye && (uu() ? ye.preload = "metadata" : ye.preload = "auto");
  }, []);
  const fe = m.useMemo(() => ({
    ...C,
    opacity: ve ? 0 : C?.opacity ?? 1
  }), [ve, C]), be = U ?? (F ? "anonymous" : void 0);
  return /* @__PURE__ */ w.jsx("video", {
    ref: t,
    muted: s || de,
    playsInline: !0,
    src: W,
    loop: v,
    style: fe,
    disableRemotePlayback: !0,
    crossOrigin: be,
    ...B
  });
}, Db = m.forwardRef(MP), Rb = (r) => {
  const {
    startFrom: e,
    endAt: t,
    name: n,
    pauseWhenBuffering: s,
    stack: i,
    showInTimeline: a,
    ...c
  } = r, u = Bt(), h = m.useCallback(() => {
  }, []);
  if (typeof r.src != "string")
    throw new TypeError(`The \`<OffthreadVideo>\` tag requires a string for \`src\`, but got ${JSON.stringify(r.src)} instead.`);
  if (r.imageFormat)
    throw new TypeError("The `<OffthreadVideo>` tag does no longer accept `imageFormat`. Use the `transparent` prop if you want to render a transparent video.");
  if (typeof e < "u" || typeof t < "u") {
    Gf(e, t);
    const T = e ?? 0, k = t ?? 1 / 0;
    return /* @__PURE__ */ w.jsx(In, {
      layout: "none",
      from: 0 - T,
      showInTimeline: !1,
      durationInFrames: k,
      name: n,
      children: /* @__PURE__ */ w.jsx(Rb, {
        pauseWhenBuffering: s ?? !1,
        ...c
      })
    });
  }
  if (Xf(r, "Video"), u.isRendering)
    return /* @__PURE__ */ w.jsx(kP, {
      ...c
    });
  const {
    transparent: d,
    toneMapped: p,
    _remotionDebugSeeking: g,
    onAutoPlayError: v,
    onVideoFrame: b,
    crossOrigin: _,
    ...C
  } = c;
  return /* @__PURE__ */ w.jsx(Db, {
    _remotionInternalStack: i ?? null,
    _remotionInternalNativeLoopPassed: !1,
    _remotionDebugSeeking: g ?? !1,
    onDuration: h,
    onlyWarnForMediaSeekingError: !0,
    pauseWhenBuffering: s ?? !1,
    showInTimeline: a ?? !0,
    onAutoPlayError: v ?? void 0,
    onVideoFrame: b ?? null,
    crossOrigin: _,
    ...C
  });
}, o0 = (r) => Math.round(r * 1e5) / 1e5, Jh = (r, e) => {
  if (Jf(r.currentTime, e))
    return {
      wait: Promise.resolve(e),
      cancel: () => {
      }
    };
  r.currentTime = e;
  let t, n = null;
  const s = new Promise((a) => {
    t = r.requestVideoFrameCallback((c, u) => {
      const h = u.expectedDisplayTime - c;
      if (h <= 0) {
        a(u.mediaTime);
        return;
      }
      setTimeout(() => {
        a(u.mediaTime);
      }, h + 150);
    });
  }), i = new Promise((a) => {
    const c = () => {
      a();
    };
    r.addEventListener("seeked", c, {
      once: !0
    }), n = () => {
      r.removeEventListener("seeked", c);
    };
  });
  return {
    wait: Promise.all([s, i]).then(([a]) => a),
    cancel: () => {
      n?.(), r.cancelVideoFrameCallback(t);
    }
  };
}, AP = (r, e, t) => {
  const n = 1 / t / 2;
  let s = () => {
  };
  return Number.isFinite(r.duration) && r.currentTime >= r.duration && e >= r.duration ? {
    prom: Promise.resolve(),
    cancel: () => {
    }
  } : {
    prom: new Promise((a, c) => {
      const u = Jh(r, e + n);
      u.wait.then((h) => {
        if (Math.abs(e - h) <= n)
          return a();
        const p = e > h ? 1 : -1, g = Jh(r, h + n * p);
        s = g.cancel, g.wait.then((v) => {
          const b = Math.abs(e - v);
          if (o0(b) <= o0(n))
            return a();
          const _ = Jh(r, e + n);
          return s = _.cancel, _.wait.then(() => {
            a();
          }).catch((C) => {
            c(C);
          });
        }).catch((v) => {
          c(v);
        });
      }), s = u.cancel;
    }),
    cancel: () => {
      s();
    }
  };
}, IP = ({
  onError: r,
  volume: e,
  allowAmplificationDuringRender: t,
  playbackRate: n,
  onDuration: s,
  toneFrequency: i,
  name: a,
  acceptableTimeShiftInSeconds: c,
  delayRenderRetries: u,
  delayRenderTimeoutInMilliseconds: h,
  loopVolumeCurveBehavior: d,
  ...p
}, g) => {
  const v = Si(), b = Ls(), _ = Va(d ?? "repeat"), C = au(), T = m.useRef(null), k = m.useContext(dr), M = So(), A = Bt(), { registerRenderAsset: D, unregisterRenderAsset: F } = m.useContext(Ti), U = m.useMemo(() => `video-${Ei(p.src ?? "")}-${k?.cumulatedFrom}-${k?.relativeFrom}-${k?.durationInFrames}`, [
    p.src,
    k?.cumulatedFrom,
    k?.relativeFrom,
    k?.durationInFrames
  ]);
  if (!C)
    throw new Error("No video config found");
  const B = Co({
    volume: e,
    frame: _,
    mediaVolume: 1,
    allowAmplificationDuringRender: t ?? !1
  });
  m.useEffect(() => {
    if (!p.src)
      throw new Error("No src passed");
    if (!p.muted && !(B <= 0) && window.remotion_audioEnabled)
      return D({
        type: "video",
        src: is(p.src),
        id: U,
        frame: v,
        volume: B,
        mediaFrame: b,
        playbackRate: n ?? 1,
        allowAmplificationDuringRender: t ?? !1,
        toneFrequency: i ?? null,
        audioStartFrame: Math.max(0, -(k?.relativeFrom ?? 0))
      }), () => F(U);
  }, [
    p.muted,
    p.src,
    D,
    U,
    F,
    B,
    b,
    v,
    n,
    t,
    i,
    k?.relativeFrom
  ]), m.useImperativeHandle(g, () => T.current, []), m.useEffect(() => {
    if (!window.remotion_videoEnabled)
      return;
    const { current: Y } = T;
    if (!Y)
      return;
    const Z = bb({
      frame: b,
      playbackRate: n || 1,
      startFrom: -M,
      fps: C.fps
    }), G = Es(`Rendering <Video /> with src="${p.src}" at time ${Z}`, {
      retries: u ?? void 0,
      timeoutInMilliseconds: h ?? void 0
    });
    if (window.process?.env?.NODE_ENV === "test") {
      kt(G);
      return;
    }
    if (Jf(Y.currentTime, Z)) {
      if (Y.readyState >= 2) {
        kt(G);
        return;
      }
      const Q = () => {
        kt(G);
      };
      return Y.addEventListener("loadeddata", Q, { once: !0 }), () => {
        Y.removeEventListener("loadeddata", Q);
      };
    }
    const K = () => {
      kt(G);
    }, oe = AP(Y, Z, C.fps);
    oe.prom.then(() => {
      kt(G);
    }), Y.addEventListener("ended", K, { once: !0 });
    const ve = () => {
      if (Y?.error) {
        if (console.error("Error occurred in video", Y?.error), r)
          return;
        throw new Error(`The browser threw an error while playing the video ${p.src}: Code ${Y.error.code} - ${Y?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);
      } else
        throw new Error("The browser threw an error");
    };
    return Y.addEventListener("error", ve, { once: !0 }), () => {
      oe.cancel(), Y.removeEventListener("ended", K), Y.removeEventListener("error", ve), kt(G);
    };
  }, [
    _,
    p.src,
    n,
    C.fps,
    b,
    M,
    r,
    u,
    h
  ]);
  const { src: X } = p;
  return A.isRendering && m.useLayoutEffect(() => {
    if (window.process?.env?.NODE_ENV === "test")
      return;
    const Y = Es("Loading <Video> duration with src=" + X, {
      retries: u ?? void 0,
      timeoutInMilliseconds: h ?? void 0
    }), { current: Z } = T, G = () => {
      Z?.duration && s(X, Z.duration), kt(Y);
    };
    return Z?.duration ? (s(X, Z.duration), kt(Y)) : Z?.addEventListener("loadedmetadata", G, { once: !0 }), () => {
      Z?.removeEventListener("loadedmetadata", G), kt(Y);
    };
  }, [X, s, u, h]), /* @__PURE__ */ w.jsx("video", {
    ref: T,
    disableRemotePlayback: !0,
    ...p
  });
}, PP = m.forwardRef(IP), DP = (r, e) => {
  const {
    startFrom: t,
    endAt: n,
    name: s,
    pauseWhenBuffering: i,
    stack: a,
    _remotionInternalNativeLoopPassed: c,
    showInTimeline: u,
    onAutoPlayError: h,
    ...d
  } = r, { loop: p, _remotionDebugSeeking: g, ...v } = r, { fps: b } = js(), _ = Bt(), { durations: C, setDurations: T } = m.useContext(qf);
  if (typeof e == "string")
    throw new Error("string refs are not supported");
  if (typeof r.src != "string")
    throw new TypeError(`The \`<Video>\` tag requires a string for \`src\`, but got ${JSON.stringify(r.src)} instead.`);
  const k = _o(r.src), M = m.useCallback((F, U) => {
    T({ type: "got-duration", durationInSeconds: U, src: F });
  }, [T]), A = m.useCallback(() => {
  }, []), D = C[is(k)] ?? C[is(r.src)];
  if (p && D !== void 0) {
    if (!Number.isFinite(D))
      return /* @__PURE__ */ w.jsx(fl, {
        ...v,
        ref: e,
        _remotionInternalNativeLoopPassed: !0
      });
    const F = D * b;
    return /* @__PURE__ */ w.jsx(cu, {
      durationInFrames: hb({
        endAt: n,
        mediaDuration: F,
        playbackRate: r.playbackRate ?? 1,
        startFrom: t
      }),
      layout: "none",
      name: s,
      children: /* @__PURE__ */ w.jsx(fl, {
        ...v,
        ref: e,
        _remotionInternalNativeLoopPassed: !0
      })
    });
  }
  if (typeof t < "u" || typeof n < "u") {
    Gf(t, n);
    const F = t ?? 0, U = n ?? 1 / 0;
    return /* @__PURE__ */ w.jsx(In, {
      layout: "none",
      from: 0 - F,
      showInTimeline: !1,
      durationInFrames: U,
      name: s,
      children: /* @__PURE__ */ w.jsx(fl, {
        pauseWhenBuffering: i ?? !1,
        ...d,
        ref: e
      })
    });
  }
  return Xf(r, "Video"), _.isRendering ? /* @__PURE__ */ w.jsx(PP, {
    onDuration: M,
    onVideoFrame: A ?? null,
    ...d,
    ref: e
  }) : /* @__PURE__ */ w.jsx(Db, {
    onlyWarnForMediaSeekingError: !1,
    ...d,
    ref: e,
    onVideoFrame: null,
    pauseWhenBuffering: i ?? !1,
    onDuration: M,
    _remotionInternalStack: a ?? null,
    _remotionInternalNativeLoopPassed: c ?? !1,
    _remotionDebugSeeking: g ?? !1,
    showInTimeline: u ?? !0,
    onAutoPlayError: h ?? void 0
  });
}, fl = m.forwardRef(DP);
Na(fl);
G5();
var RP = {}, jP = new Proxy(RP, {
  get(r, e) {
    return e === "Bundling" || e === "Rendering" || e === "Log" || e === "Puppeteer" || e === "Output" ? jP : () => {
      console.warn("⚠️  The CLI configuration has been extracted from Remotion Core."), console.warn("Update the import from the config file:"), console.warn(), console.warn("- Delete:"), console.warn('import {Config} from "remotion";'), console.warn("+ Replace:"), console.warn('import {Config} from "@remotion/cli/config";'), console.warn(), console.warn("For more information, see https://www.remotion.dev/docs/4-0-migration."), process.exit(1);
    };
  }
});
Na(In);
typeof window < "u" && (window.remotion_renderReady = !1);
typeof window < "u" && (window.remotion_delayRenderTimeouts = {});
var LP = (r, e, t) => {
  if (r) {
    if (typeof r != "object")
      throw new Error(`"${e}" must be an object, but you passed a value of type ${typeof r}`);
    if (Array.isArray(r))
      throw new Error(`"${e}" must be an object, an array was passed ${t ? `for composition "${t}"` : ""}`);
  }
};
function FP(r, e, t) {
  if (typeof r != "number")
    throw new Error(`The "${e}" prop ${t} must be a number, but you passed a value of type ${typeof r}`);
  if (isNaN(r))
    throw new TypeError(`The "${e}" prop ${t} must not be NaN, but is NaN.`);
  if (!Number.isFinite(r))
    throw new TypeError(`The "${e}" prop ${t} must be finite, but is ${r}.`);
  if (r % 1 !== 0)
    throw new TypeError(`The "${e}" prop ${t} must be an integer, but is ${r}.`);
  if (r <= 0)
    throw new TypeError(`The "${e}" prop ${t} must be positive, but got ${r}.`);
}
function NP(r, e) {
  const { allowFloats: t, component: n } = e;
  if (typeof r > "u")
    throw new Error(`The "durationInFrames" prop ${n} is missing.`);
  if (typeof r != "number")
    throw new Error(`The "durationInFrames" prop ${n} must be a number, but you passed a value of type ${typeof r}`);
  if (r <= 0)
    throw new TypeError(`The "durationInFrames" prop ${n} must be positive, but got ${r}.`);
  if (!t && r % 1 !== 0)
    throw new TypeError(`The "durationInFrames" prop ${n} must be an integer, but got ${r}.`);
  if (!Number.isFinite(r))
    throw new TypeError(`The "durationInFrames" prop ${n} must be finite, but got ${r}.`);
}
function BP(r, e, t) {
  if (typeof r != "number")
    throw new Error(`"fps" must be a number, but you passed a value of type ${typeof r} ${e}`);
  if (!Number.isFinite(r))
    throw new Error(`"fps" must be a finite, but you passed ${r} ${e}`);
  if (isNaN(r))
    throw new Error(`"fps" must not be NaN, but got ${r} ${e}`);
  if (r <= 0)
    throw new TypeError(`"fps" must be positive, but got ${r} ${e}`);
  if (t && r > 50)
    throw new TypeError("The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif");
}
var du = {
  validateFps: BP,
  validateDimension: FP,
  validateDurationInFrames: NP,
  validateDefaultAndInputProps: LP
}, nr = 25, qd = 16, VP = () => /* @__PURE__ */ w.jsx("svg", {
  width: nr,
  height: nr,
  viewBox: "0 0 25 25",
  fill: "none",
  children: /* @__PURE__ */ w.jsx("path", {
    d: "M8 6.375C7.40904 8.17576 7.06921 10.2486 7.01438 12.3871C6.95955 14.5255 7.19163 16.6547 7.6875 18.5625C9.95364 18.2995 12.116 17.6164 14.009 16.5655C15.902 15.5147 17.4755 14.124 18.6088 12.5C17.5158 10.8949 15.9949 9.51103 14.1585 8.45082C12.3222 7.3906 10.2174 6.68116 8 6.375Z",
    fill: "white",
    stroke: "white",
    strokeWidth: "6.25",
    strokeLinejoin: "round"
  })
}), zP = () => /* @__PURE__ */ w.jsxs("svg", {
  viewBox: "0 0 100 100",
  width: nr,
  height: nr,
  children: [
    /* @__PURE__ */ w.jsx("rect", {
      x: "25",
      y: "20",
      width: "20",
      height: "60",
      fill: "#fff",
      ry: "5",
      rx: "5"
    }),
    /* @__PURE__ */ w.jsx("rect", {
      x: "55",
      y: "20",
      width: "20",
      height: "60",
      fill: "#fff",
      ry: "5",
      rx: "5"
    })
  ]
}), WP = ({
  isFullscreen: r
}) => {
  const n = r ? 0 : 3, s = r ? 6 * 1.6 : 6 / 2, i = r ? 6 * 1.6 : 6 * 2;
  return /* @__PURE__ */ w.jsxs("svg", {
    viewBox: "0 0 32 32",
    height: qd,
    width: qd,
    children: [
      /* @__PURE__ */ w.jsx("path", {
        d: `
				M ${n} ${i}
				L ${s} ${s}
				L ${i} ${n}
				`,
        stroke: "#fff",
        strokeWidth: 6,
        fill: "none"
      }),
      /* @__PURE__ */ w.jsx("path", {
        d: `
				M ${32 - n} ${i}
				L ${32 - s} ${s}
				L ${32 - i} ${n}
				`,
        stroke: "#fff",
        strokeWidth: 6,
        fill: "none"
      }),
      /* @__PURE__ */ w.jsx("path", {
        d: `
				M ${n} ${32 - i}
				L ${s} ${32 - s}
				L ${i} ${32 - n}
				`,
        stroke: "#fff",
        strokeWidth: 6,
        fill: "none"
      }),
      /* @__PURE__ */ w.jsx("path", {
        d: `
				M ${32 - n} ${32 - i}
				L ${32 - s} ${32 - s}
				L ${32 - i} ${32 - n}
				`,
        stroke: "#fff",
        strokeWidth: 6,
        fill: "none"
      })
    ]
  });
}, HP = () => /* @__PURE__ */ w.jsx("svg", {
  width: nr,
  height: nr,
  viewBox: "0 0 24 24",
  children: /* @__PURE__ */ w.jsx("path", {
    d: "M3.63 3.63a.996.996 0 000 1.41L7.29 8.7 7 9H4c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h3l3.29 3.29c.63.63 1.71.18 1.71-.71v-4.17l4.18 4.18c-.49.37-1.02.68-1.6.91-.36.15-.58.53-.58.92 0 .72.73 1.18 1.39.91.8-.33 1.55-.77 2.22-1.31l1.34 1.34a.996.996 0 101.41-1.41L5.05 3.63c-.39-.39-1.02-.39-1.42 0zM19 12c0 .82-.15 1.61-.41 2.34l1.53 1.53c.56-1.17.88-2.48.88-3.87 0-3.83-2.4-7.11-5.78-8.4-.59-.23-1.22.23-1.22.86v.19c0 .38.25.71.61.85C17.18 6.54 19 9.06 19 12zm-8.71-6.29l-.17.17L12 7.76V6.41c0-.89-1.08-1.33-1.71-.7zM16.5 12A4.5 4.5 0 0014 7.97v1.79l2.48 2.48c.01-.08.02-.16.02-.24z",
    fill: "#fff"
  })
}), UP = () => /* @__PURE__ */ w.jsx("svg", {
  width: nr,
  height: nr,
  viewBox: "0 0 24 24",
  children: /* @__PURE__ */ w.jsx("path", {
    d: "M3 10v4c0 .55.45 1 1 1h3l3.29 3.29c.63.63 1.71.18 1.71-.71V6.41c0-.89-1.08-1.34-1.71-.71L7 9H4c-.55 0-1 .45-1 1zm13.5 2A4.5 4.5 0 0014 7.97v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 4.45v.2c0 .38.25.71.6.85C17.18 6.53 19 9.06 19 12s-1.82 5.47-4.4 6.5c-.36.14-.6.47-.6.85v.2c0 .63.63 1.07 1.21.85C18.6 19.11 21 15.84 21 12s-2.4-7.11-5.79-8.4c-.58-.23-1.21.22-1.21.85z",
    fill: "#fff"
  })
}), a0 = "__remotion_buffering_indicator", c0 = "__remotion_buffering_animation", $P = {
  width: nr,
  height: nr,
  overflow: "hidden",
  lineHeight: "normal",
  fontSize: "inherit"
}, YP = {
  width: 14,
  height: 14,
  overflow: "hidden",
  lineHeight: "normal",
  fontSize: "inherit"
}, XP = ({ type: r }) => {
  const e = r === "player" ? $P : YP;
  return /* @__PURE__ */ w.jsxs(w.Fragment, {
    children: [
      /* @__PURE__ */ w.jsx("style", {
        type: "text/css",
        children: `
				@keyframes ${c0} {
          0% {
            rotate: 0deg;
          }
          100% {
            rotate: 360deg;
          }
        }
        
        .${a0} {
            animation: ${c0} 1s linear infinite;
        }        
			`
      }),
      /* @__PURE__ */ w.jsx("div", {
        style: e,
        children: /* @__PURE__ */ w.jsx("svg", {
          viewBox: r === "player" ? "0 0 22 22" : "0 0 18 18",
          style: e,
          className: a0,
          children: /* @__PURE__ */ w.jsx("path", {
            d: r === "player" ? "M 11 4 A 7 7 0 0 1 15.1145 16.66312" : "M 9 2 A 7 7 0 0 1 13.1145 14.66312",
            stroke: "white",
            strokeLinecap: "round",
            fill: "none",
            strokeWidth: 3
          })
        })
      })
    ]
  });
}, GP = ({
  currentSize: r,
  width: e,
  height: t,
  compositionWidth: n,
  compositionHeight: s
}) => e !== void 0 && t === void 0 ? {
  aspectRatio: [n, s].join("/")
} : t !== void 0 && e === void 0 ? {
  aspectRatio: [n, s].join("/")
} : r ? {
  width: n,
  height: s
} : {
  width: n,
  height: s
}, jb = ({
  previewSize: r,
  compositionWidth: e,
  compositionHeight: t,
  canvasSize: n
}) => {
  const s = Pe.calculateScale({
    canvasSize: n,
    compositionHeight: t,
    compositionWidth: e,
    previewSize: r
  }), i = 0 - (1 - s) / 2, a = i * e, c = i * t, u = e * s, h = t * s, d = n.width / 2 - u / 2, p = n.height / 2 - h / 2;
  return {
    centerX: d,
    centerY: p,
    xCorrection: a,
    yCorrection: c,
    scale: s
  };
}, Lb = ({
  config: r,
  style: e,
  canvasSize: t,
  overflowVisible: n,
  layout: s
}) => r ? {
  position: "relative",
  overflow: n ? "visible" : "hidden",
  ...GP({
    compositionHeight: r.height,
    compositionWidth: r.width,
    currentSize: t,
    height: e?.height,
    width: e?.width
  }),
  opacity: s ? 1 : 0,
  ...e
} : {}, Fb = ({
  config: r,
  canvasSize: e,
  layout: t,
  scale: n,
  overflowVisible: s
}) => !r || !e || !t ? {} : {
  position: "absolute",
  width: r.width,
  height: r.height,
  display: "flex",
  transform: `scale(${n})`,
  marginLeft: t.xCorrection,
  marginTop: t.yCorrection,
  overflow: s ? "visible" : "hidden"
}, Nb = ({
  layout: r,
  scale: e,
  config: t,
  overflowVisible: n
}) => {
  if (!r || !t)
    return {};
  const { centerX: s, centerY: i } = r;
  return {
    width: t.width * e,
    height: t.height * e,
    display: "flex",
    flexDirection: "column",
    position: "absolute",
    left: s,
    top: i,
    overflow: n ? "visible" : "hidden"
  };
}, Bb = Ie.createContext(void 0), Vb = Ie.createContext(void 0);
class qP {
  listeners = {
    ended: [],
    error: [],
    pause: [],
    play: [],
    ratechange: [],
    scalechange: [],
    seeked: [],
    timeupdate: [],
    frameupdate: [],
    fullscreenchange: [],
    volumechange: [],
    mutechange: [],
    waiting: [],
    resume: []
  };
  addEventListener(e, t) {
    this.listeners[e].push(t);
  }
  removeEventListener(e, t) {
    this.listeners[e] = this.listeners[e].filter((n) => n !== t);
  }
  dispatchEvent(e, t) {
    this.listeners[e].forEach((n) => {
      n({ detail: t });
    });
  }
  dispatchSeek(e) {
    this.dispatchEvent("seeked", {
      frame: e
    });
  }
  dispatchVolumeChange(e) {
    this.dispatchEvent("volumechange", {
      volume: e
    });
  }
  dispatchPause() {
    this.dispatchEvent("pause", void 0);
  }
  dispatchPlay() {
    this.dispatchEvent("play", void 0);
  }
  dispatchEnded() {
    this.dispatchEvent("ended", void 0);
  }
  dispatchRateChange(e) {
    this.dispatchEvent("ratechange", {
      playbackRate: e
    });
  }
  dispatchScaleChange(e) {
    this.dispatchEvent("scalechange", {
      scale: e
    });
  }
  dispatchError(e) {
    this.dispatchEvent("error", {
      error: e
    });
  }
  dispatchTimeUpdate(e) {
    this.dispatchEvent("timeupdate", e);
  }
  dispatchFrameUpdate(e) {
    this.dispatchEvent("frameupdate", e);
  }
  dispatchFullscreenChange(e) {
    this.dispatchEvent("fullscreenchange", e);
  }
  dispatchMuteChange(e) {
    this.dispatchEvent("mutechange", e);
  }
  dispatchWaiting(e) {
    this.dispatchEvent("waiting", e);
  }
  dispatchResume(e) {
    this.dispatchEvent("resume", e);
  }
}
class KP {
  listeners = {
    error: [],
    waiting: [],
    resume: []
  };
  addEventListener(e, t) {
    this.listeners[e].push(t);
  }
  removeEventListener(e, t) {
    this.listeners[e] = this.listeners[e].filter((n) => n !== t);
  }
  dispatchEvent(e, t) {
    this.listeners[e].forEach((n) => {
      n({ detail: t });
    });
  }
  dispatchError(e) {
    this.dispatchEvent("error", {
      error: e
    });
  }
  dispatchWaiting(e) {
    this.dispatchEvent("waiting", e);
  }
  dispatchResume(e) {
    this.dispatchEvent("resume", e);
  }
}
var zb = (r) => {
  const e = m.useContext(Pe.BufferingContextReact);
  if (!e)
    throw new Error("BufferingContextReact not found");
  m.useEffect(() => {
    const t = e.listenForBuffering(() => {
      e.buffering.current = !0, r.dispatchWaiting({});
    }), n = e.listenForResume(() => {
      e.buffering.current = !1, r.dispatchResume({});
    });
    return () => {
      t.remove(), n.remove();
    };
  }, [e, r]);
}, ZP = ({ children: r, currentPlaybackRate: e }) => {
  const [t] = m.useState(() => new qP());
  if (!m.useContext(Pe.BufferingContextReact))
    throw new Error("BufferingContextReact not found");
  return m.useEffect(() => {
    e && t.dispatchRateChange(e);
  }, [t, e]), zb(t), /* @__PURE__ */ w.jsx(Bb.Provider, {
    value: t,
    children: r
  });
}, np = (r, e) => {
  const [t, n] = m.useState(!1);
  return m.useEffect(() => {
    const { current: s } = r;
    if (!s)
      return;
    let i;
    const a = () => {
      e && (clearTimeout(i), i = setTimeout(() => {
        n(!1);
      }, e === !0 ? 3e3 : e));
    }, c = () => {
      n(!0), a();
    }, u = () => {
      n(!1), clearTimeout(i);
    }, h = () => {
      n(!0), a();
    };
    return s.addEventListener("mouseenter", c), s.addEventListener("mouseleave", u), s.addEventListener("mousemove", h), () => {
      s.removeEventListener("mouseenter", c), s.removeEventListener("mouseleave", u), s.removeEventListener("mousemove", h), clearTimeout(i);
    };
  }, [e, r]), t;
}, fu = () => {
  const [r, e, t] = Pe.Timeline.usePlayingState(), [n, s] = m.useState(!1), i = Pe.Timeline.useTimelinePosition(), a = m.useRef(i), c = Pe.Timeline.useTimelineSetFrame(), u = Pe.Timeline.useTimelineSetFrame(), h = m.useContext(Pe.SharedAudioContext), { audioAndVideoTags: d } = m.useContext(Pe.Timeline.TimelineContext), p = m.useRef(i);
  p.current = i;
  const g = Pe.useVideo(), v = Pe.useUnsafeVideoConfig(), b = m.useContext(Bb), _ = (v?.durationInFrames ?? 1) - 1, C = i === _, T = i === 0;
  if (!b)
    throw new TypeError("Expected Player event emitter context");
  const k = m.useContext(Pe.BufferingContextReact);
  if (!k)
    throw new Error("Missing the buffering context. Most likely you have a Remotion version mismatch.");
  const { buffering: M } = k, A = m.useCallback((G) => {
    g?.id && u((K) => ({ ...K, [g.id]: G })), p.current = G, b.dispatchSeek(G);
  }, [b, u, g?.id]), D = m.useCallback((G) => {
    t.current || (s(!0), C && A(0), h && h.numberOfAudioTags > 0 && G && h.playAllAudios(), d.current.forEach((K) => K.play()), t.current = !0, e(!0), a.current = p.current, b.dispatchPlay());
  }, [
    t,
    C,
    h,
    e,
    b,
    A,
    d
  ]), F = m.useCallback(() => {
    t.current && (t.current = !1, e(!1), b.dispatchPause());
  }, [b, t, e]), U = m.useCallback(() => {
    t.current && (t.current = !1, p.current = a.current, v && (u((G) => ({
      ...G,
      [v.id]: a.current
    })), e(!1), b.dispatchPause()));
  }, [v, b, t, e, u]), B = g?.id, X = m.useCallback((G) => {
    if (!B)
      return null;
    t.current || c((K) => {
      const oe = K[B] ?? window.remotion_initialFrame ?? 0;
      return {
        ...K,
        [B]: Math.max(0, oe - G)
      };
    });
  }, [t, c, B]), Y = m.useCallback((G) => {
    if (!B)
      return null;
    t.current || c((K) => {
      const oe = K[B] ?? window.remotion_initialFrame ?? 0;
      return {
        ...K,
        [B]: Math.min(_, oe + G)
      };
    });
  }, [B, t, _, c]);
  return m.useMemo(() => ({
    frameBack: X,
    frameForward: Y,
    isLastFrame: C,
    emitter: b,
    playing: r,
    play: D,
    pause: F,
    seek: A,
    isFirstFrame: T,
    getCurrentFrame: () => p.current,
    isPlaying: () => t.current,
    isBuffering: () => M.current,
    pauseAndReturnToPlayStart: U,
    hasPlayed: n,
    remotionInternal_currentFrameRef: p
  }), [
    X,
    Y,
    C,
    b,
    r,
    D,
    F,
    A,
    T,
    U,
    n,
    t,
    M
  ]);
}, JP = ({
  browserMediaControlsBehavior: r,
  videoConfig: e,
  playbackRate: t
}) => {
  const { playing: n, pause: s, play: i, emitter: a, getCurrentFrame: c, seek: u } = fu();
  m.useEffect(() => {
    navigator.mediaSession && r.mode !== "do-nothing" && (n ? navigator.mediaSession.playbackState = "playing" : navigator.mediaSession.playbackState = "paused");
  }, [r.mode, n]), m.useEffect(() => {
    if (!navigator.mediaSession || r.mode === "do-nothing")
      return;
    const h = () => {
      e && navigator.mediaSession && navigator.mediaSession.setPositionState({
        duration: e.durationInFrames / e.fps,
        playbackRate: t,
        position: c() / e.fps
      });
    };
    return a.addEventListener("timeupdate", h), () => {
      a.removeEventListener("timeupdate", h);
    };
  }, [
    r.mode,
    a,
    c,
    t,
    e
  ]), m.useEffect(() => {
    if (navigator.mediaSession && r.mode !== "do-nothing")
      return navigator.mediaSession.setActionHandler("play", () => {
        r.mode === "register-media-session" && i();
      }), navigator.mediaSession.setActionHandler("pause", () => {
        r.mode === "register-media-session" && s();
      }), navigator.mediaSession.setActionHandler("seekto", (h) => {
        r.mode === "register-media-session" && h.seekTime !== void 0 && e && u(Math.round(h.seekTime * e.fps));
      }), navigator.mediaSession.setActionHandler("seekbackward", () => {
        r.mode === "register-media-session" && e && u(Math.max(0, Math.round((c() - 10) * e.fps)));
      }), navigator.mediaSession.setActionHandler("seekforward", () => {
        r.mode === "register-media-session" && e && u(Math.max(e.durationInFrames - 1, Math.round((c() + 10) * e.fps)));
      }), navigator.mediaSession.setActionHandler("previoustrack", () => {
        r.mode === "register-media-session" && u(0);
      }), () => {
        navigator.mediaSession.metadata = null, navigator.mediaSession.setActionHandler("play", null), navigator.mediaSession.setActionHandler("pause", null), navigator.mediaSession.setActionHandler("seekto", null), navigator.mediaSession.setActionHandler("seekbackward", null), navigator.mediaSession.setActionHandler("seekforward", null), navigator.mediaSession.setActionHandler("previoustrack", null);
      };
  }, [
    r.mode,
    c,
    s,
    i,
    u,
    e
  ]);
}, QP = ({
  time: r,
  currentFrame: e,
  playbackSpeed: t,
  fps: n,
  actualLastFrame: s,
  actualFirstFrame: i,
  framesAdvanced: a,
  shouldLoop: c
}) => {
  const h = (t < 0 ? Math.ceil : Math.floor)(r * t / (1e3 / n)) - a, d = h + e, p = e > s || e < i, g = d > s || d < i, v = !c && g && !p;
  return t > 0 ? g ? {
    nextFrame: i,
    framesToAdvance: h,
    hasEnded: v
  } : { nextFrame: d, framesToAdvance: h, hasEnded: v } : g ? { nextFrame: s, framesToAdvance: h, hasEnded: v } : { nextFrame: d, framesToAdvance: h, hasEnded: v };
}, l0 = () => typeof document > "u" ? !1 : document.visibilityState === "hidden", eD = () => {
  const r = m.useRef(l0());
  return m.useEffect(() => {
    const e = () => {
      r.current = l0();
    };
    return document.addEventListener("visibilitychange", e), () => {
      document.removeEventListener("visibilitychange", e);
    };
  }, []), r;
}, tD = ({
  loop: r,
  playbackRate: e,
  moveToBeginningWhenEnded: t,
  inFrame: n,
  outFrame: s,
  frameRef: i,
  browserMediaControlsBehavior: a
}) => {
  const c = Pe.useUnsafeVideoConfig(), u = Pe.Timeline.useTimelinePosition(), { playing: h, pause: d, emitter: p } = fu(), g = Pe.Timeline.useTimelineSetFrame(), v = m.useRef(null), b = eD(), _ = m.useRef(null), C = m.useContext(Pe.BufferingContextReact);
  if (!C)
    throw new Error("Missing the buffering context. Most likely you have a Remotion version mismatch.");
  JP({
    browserMediaControlsBehavior: a,
    playbackRate: e,
    videoConfig: c
  }), m.useEffect(() => {
    const T = C.listenForBuffering(() => {
      v.current = performance.now();
    }), k = C.listenForResume(() => {
      v.current = null;
    });
    return () => {
      T.remove(), k.remove();
    };
  }, [C]), m.useEffect(() => {
    if (!c || !h)
      return;
    let T = !1, k = null, M = performance.now(), A = 0;
    const D = () => {
      k !== null && (k.type === "raf" ? cancelAnimationFrame(k.id) : clearTimeout(k.id));
    }, F = () => {
      T = !0, D();
    }, U = () => {
      const Y = performance.now() - M, Z = s ?? c.durationInFrames - 1, G = n ?? 0, K = i.current, { nextFrame: oe, framesToAdvance: ve, hasEnded: Q } = QP({
        time: Y,
        currentFrame: K,
        playbackSpeed: e,
        fps: c.fps,
        actualFirstFrame: G,
        actualLastFrame: Z,
        framesAdvanced: A,
        shouldLoop: r
      });
      if (A += ve, oe !== i.current && (!Q || t) && g((ge) => ({ ...ge, [c.id]: oe })), Q) {
        F(), d(), p.dispatchEnded();
        return;
      }
      T || B();
    }, B = () => {
      if (v.current) {
        const Y = C.listenForResume(() => {
          Y.remove(), !T && (M = performance.now(), A = 0, U());
        });
        return;
      }
      b.current ? k = {
        type: "timeout",
        id: setTimeout(U, 1e3 / c.fps)
      } : k = { type: "raf", id: requestAnimationFrame(U) };
    };
    B();
    const X = () => {
      document.visibilityState !== "visible" && (D(), U());
    };
    return window.addEventListener("visibilitychange", X), () => {
      window.removeEventListener("visibilitychange", X), F();
    };
  }, [
    c,
    r,
    d,
    h,
    g,
    p,
    e,
    n,
    s,
    t,
    b,
    i,
    v,
    C
  ]), m.useEffect(() => {
    const T = setInterval(() => {
      _.current !== i.current && (p.dispatchTimeUpdate({ frame: i.current }), _.current = i.current);
    }, 250);
    return () => clearInterval(T);
  }, [p, i]), m.useEffect(() => {
    p.dispatchFrameUpdate({ frame: u });
  }, [p, u]);
}, Qh = [], sp = (r, e) => {
  const [t, n] = m.useState(() => {
    if (!r.current)
      return null;
    const a = r.current.getClientRects();
    return a[0] ? {
      width: a[0].width,
      height: a[0].height,
      left: a[0].x,
      top: a[0].y,
      windowSize: {
        height: window.innerHeight,
        width: window.innerWidth
      }
    } : null;
  }), s = m.useMemo(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((a) => {
    const { contentRect: c, target: u } = a[0], h = u.getClientRects();
    if (!h?.[0]) {
      n(null);
      return;
    }
    const d = c.width === 0 ? 1 : h[0].width / c.width, p = e.shouldApplyCssTransforms ? h[0].width : h[0].width * (1 / d), g = e.shouldApplyCssTransforms ? h[0].height : h[0].height * (1 / d);
    n({
      width: p,
      height: g,
      left: h[0].x,
      top: h[0].y,
      windowSize: {
        height: window.innerHeight,
        width: window.innerWidth
      }
    });
  }), [e.shouldApplyCssTransforms]), i = m.useCallback(() => {
    if (!r.current)
      return;
    const a = r.current.getClientRects();
    if (!a[0]) {
      n(null);
      return;
    }
    n((c) => c && c.width === a[0].width && c.height === a[0].height && c.left === a[0].x && c.top === a[0].y && c.windowSize.height === window.innerHeight && c.windowSize.width === window.innerWidth ? c : {
      width: a[0].width,
      height: a[0].height,
      left: a[0].x,
      top: a[0].y,
      windowSize: {
        height: window.innerHeight,
        width: window.innerWidth
      }
    });
  }, [r]);
  return m.useEffect(() => {
    if (!s)
      return;
    const { current: a } = r;
    return a && s.observe(a), () => {
      a && s.unobserve(a);
    };
  }, [s, r, i]), m.useEffect(() => {
    if (e.triggerOnWindowResize)
      return window.addEventListener("resize", i), () => {
        window.removeEventListener("resize", i);
      };
  }, [e.triggerOnWindowResize, i]), m.useEffect(() => (Qh.push(i), () => {
    Qh = Qh.filter((a) => a !== i);
  }), [i]), m.useMemo(() => t ? { ...t, refresh: i } : null, [t, i]);
}, u0 = ({ playing: r, buffering: e }) => r && e ? /* @__PURE__ */ w.jsx(XP, {
  type: "player"
}) : r ? /* @__PURE__ */ w.jsx(zP, {}) : /* @__PURE__ */ w.jsx(VP, {}), Ki = 12, h0 = 5, rD = ({
  volume: r,
  isVertical: e,
  onBlur: t,
  inputRef: n,
  setVolume: s
}) => {
  const i = m.useMemo(() => {
    const g = {
      paddingLeft: 5,
      height: nr,
      width: oi,
      display: "inline-flex",
      alignItems: "center"
    };
    return e ? {
      ...g,
      position: "absolute",
      transform: `rotate(-90deg) translateX(${oi / 2 + nr / 2}px)`
    } : {
      ...g
    };
  }, [e]), a = typeof Ie.useId > "u" ? "volume-slider" : Ie.useId(), [c] = m.useState(() => `__remotion-volume-slider-${Ei(a)}`.replace(".", "")), u = m.useCallback((p) => {
    s(parseFloat(p.target.value));
  }, [s]), h = m.useMemo(() => {
    const p = {
      WebkitAppearance: "none",
      backgroundColor: "rgba(255, 255, 255, 0.5)",
      borderRadius: h0 / 2,
      cursor: "pointer",
      height: h0,
      width: oi,
      backgroundImage: `linear-gradient(
				to right,
				white ${r * 100}%, rgba(255, 255, 255, 0) ${r * 100}%
			)`
    };
    return e ? {
      ...p,
      bottom: nr + oi / 2
    } : p;
  }, [e, r]), d = `
	.${c}::-webkit-slider-thumb {
		-webkit-appearance: none;
		background-color: white;
		border-radius: ${Ki / 2}px;
		box-shadow: 0 0 2px black;
		height: ${Ki}px;
		width: ${Ki}px;
	}

	.${c}::-moz-range-thumb {
		-webkit-appearance: none;
		background-color: white;
		border-radius: ${Ki / 2}px;
		box-shadow: 0 0 2px black;
		height: ${Ki}px;
		width: ${Ki}px;
	}
`;
  return /* @__PURE__ */ w.jsxs("div", {
    style: i,
    children: [
      /* @__PURE__ */ w.jsx("style", {
        dangerouslySetInnerHTML: {
          __html: d
        }
      }),
      /* @__PURE__ */ w.jsx("input", {
        ref: n,
        "aria-label": "Change volume",
        className: c,
        max: 1,
        min: 0,
        onBlur: t,
        onChange: u,
        step: 0.01,
        type: "range",
        value: r,
        style: h
      })
    ]
  });
}, nD = (r) => /* @__PURE__ */ w.jsx(rD, {
  ...r
}), oi = 100, sD = ({ displayVerticalVolumeSlider: r, renderMuteButton: e, renderVolumeSlider: t }) => {
  const [n, s] = Pe.useMediaMutedState(), [i, a] = Pe.useMediaVolumeState(), [c, u] = m.useState(!1), h = m.useRef(null), d = m.useRef(null), p = np(h, !1), g = m.useCallback(() => {
    setTimeout(() => {
      d.current && document.activeElement !== d.current && u(!1);
    }, 10);
  }, []), v = i === 0, b = m.useCallback(() => {
    if (v) {
      a(1), s(!1);
      return;
    }
    s((A) => !A);
  }, [v, s, a]), _ = m.useMemo(() => ({
    display: "inline-flex",
    background: "none",
    border: "none",
    justifyContent: "center",
    alignItems: "center",
    touchAction: "none",
    ...r && { position: "relative" }
  }), [r]), C = m.useMemo(() => ({
    display: "inline",
    width: nr,
    height: nr,
    cursor: "pointer",
    appearance: "none",
    background: "none",
    border: "none",
    padding: 0
  }), []), T = m.useCallback(({ muted: A, volume: D }) => {
    const F = A || D === 0;
    return /* @__PURE__ */ w.jsx("button", {
      "aria-label": F ? "Unmute sound" : "Mute sound",
      title: F ? "Unmute sound" : "Mute sound",
      onClick: b,
      onBlur: g,
      onFocus: () => u(!0),
      style: C,
      type: "button",
      children: F ? /* @__PURE__ */ w.jsx(HP, {}) : /* @__PURE__ */ w.jsx(UP, {})
    });
  }, [g, b, C]), k = m.useMemo(() => e ? e({ muted: n, volume: i }) : T({ muted: n, volume: i }), [n, i, T, e]), M = m.useMemo(() => (c || p) && !n && !Pe.isIosSafari() ? (t ?? nD)({
    isVertical: r,
    volume: i,
    onBlur: () => u(!1),
    inputRef: d,
    setVolume: a
  }) : null, [
    r,
    c,
    p,
    n,
    i,
    t,
    a
  ]);
  return /* @__PURE__ */ w.jsxs("div", {
    ref: h,
    style: _,
    children: [
      k,
      M
    ]
  });
};
function iD(r) {
  const [e, t] = m.useState(r), n = m.useRef(null);
  return m.useEffect(() => {
    const s = (i) => {
      n.current && !n.current.contains(i.target) && t(!1);
    };
    return document.addEventListener("pointerup", s, !0), () => {
      document.removeEventListener("pointerup", s, !0);
    };
  }, []), { ref: n, isComponentVisible: e, setIsComponentVisible: t };
}
var oD = 35, aD = 70, cD = {
  height: 30,
  paddingRight: 15,
  paddingLeft: 12,
  display: "flex",
  flexDirection: "row",
  alignItems: "center"
}, lD = {
  width: 22,
  display: "flex",
  alignItems: "center"
}, uD = {
  width: 14,
  height: 14,
  color: "black"
}, hD = () => /* @__PURE__ */ w.jsx("svg", {
  viewBox: "0 0 512 512",
  style: uD,
  children: /* @__PURE__ */ w.jsx("path", {
    fill: "currentColor",
    d: "M435.848 83.466L172.804 346.51l-96.652-96.652c-4.686-4.686-12.284-4.686-16.971 0l-28.284 28.284c-4.686 4.686-4.686 12.284 0 16.971l133.421 133.421c4.686 4.686 12.284 4.686 16.971 0l299.813-299.813c4.686-4.686 4.686-12.284 0-16.971l-28.284-28.284c-4.686-4.686-12.284-4.686-16.97 0z"
  })
}), dD = ({ rate: r, onSelect: e, selectedRate: t, keyboardSelectedRate: n }) => {
  const s = m.useCallback((p) => {
    p.stopPropagation(), p.preventDefault(), e(r);
  }, [e, r]), [i, a] = m.useState(!1), c = m.useCallback(() => {
    a(!0);
  }, []), u = m.useCallback(() => {
    a(!1);
  }, []), h = n === r, d = m.useMemo(() => ({
    ...cD,
    backgroundColor: i || h ? "#eee" : "transparent"
  }), [i, h]);
  return /* @__PURE__ */ w.jsxs("div", {
    onMouseEnter: c,
    onMouseLeave: u,
    tabIndex: 0,
    style: d,
    onClick: s,
    children: [
      /* @__PURE__ */ w.jsx("div", {
        style: lD,
        children: r === t ? /* @__PURE__ */ w.jsx(hD, {}) : null
      }),
      r.toFixed(1),
      "x"
    ]
  }, r);
}, fD = ({ setIsComponentVisible: r, playbackRates: e, canvasSize: t }) => {
  const { setPlaybackRate: n, playbackRate: s } = m.useContext(Pe.Timeline.TimelineContext), [i, a] = m.useState(s);
  m.useEffect(() => {
    const h = (d) => {
      if (d.preventDefault(), d.key === "ArrowUp") {
        const p = e.findIndex((g) => g === i);
        if (p === 0)
          return;
        a(p === -1 ? e[0] : e[p - 1]);
      } else if (d.key === "ArrowDown") {
        const p = e.findIndex((g) => g === i);
        if (p === e.length - 1)
          return;
        a(p === -1 ? e[e.length - 1] : e[p + 1]);
      } else d.key === "Enter" && (n(i), r(!1));
    };
    return window.addEventListener("keydown", h), () => {
      window.removeEventListener("keydown", h);
    };
  }, [
    e,
    i,
    n,
    r
  ]);
  const c = m.useCallback((h) => {
    n(h), r(!1);
  }, [r, n]), u = m.useMemo(() => ({
    position: "absolute",
    right: 0,
    width: 125,
    maxHeight: t.height - aD - oD,
    bottom: 35,
    background: "#fff",
    borderRadius: 4,
    overflow: "auto",
    color: "black",
    textAlign: "left"
  }), [t.height]);
  return /* @__PURE__ */ w.jsx("div", {
    style: u,
    children: e.map((h) => /* @__PURE__ */ w.jsx(dD, {
      selectedRate: s,
      onSelect: c,
      rate: h,
      keyboardSelectedRate: i
    }, h))
  });
}, pD = {
  fontSize: 13,
  fontWeight: "bold",
  color: "white",
  border: "2px solid white",
  borderRadius: 20,
  paddingLeft: 8,
  paddingRight: 8,
  paddingTop: 2,
  paddingBottom: 2
}, Kd = {
  appearance: "none",
  backgroundColor: "transparent",
  border: "none",
  cursor: "pointer",
  paddingLeft: 0,
  paddingRight: 0,
  paddingTop: 6,
  paddingBottom: 6,
  height: 37,
  display: "inline-flex",
  marginBottom: 0,
  marginTop: 0,
  alignItems: "center"
}, gD = {
  ...Kd,
  position: "relative"
}, mD = ({ playbackRates: r, canvasSize: e }) => {
  const { ref: t, isComponentVisible: n, setIsComponentVisible: s } = iD(!1), { playbackRate: i } = m.useContext(Pe.Timeline.TimelineContext), a = m.useCallback((c) => {
    c.stopPropagation(), c.preventDefault(), s((u) => !u);
  }, [s]);
  return /* @__PURE__ */ w.jsx("div", {
    ref: t,
    children: /* @__PURE__ */ w.jsxs("button", {
      type: "button",
      "aria-label": "Change playback rate",
      style: gD,
      onClick: a,
      children: [
        /* @__PURE__ */ w.jsxs("div", {
          style: pD,
          children: [
            i,
            "x"
          ]
        }),
        n && /* @__PURE__ */ w.jsx(fD, {
          canvasSize: e,
          playbackRates: r,
          setIsComponentVisible: s
        })
      ]
    })
  });
}, d0 = (r, e, t) => Math.round(vb(r, [0, t], [0, e - 1], {
  extrapolateLeft: "clamp",
  extrapolateRight: "clamp"
})), eo = 5, na = 12, Zd = 4, vD = {
  userSelect: "none",
  WebkitUserSelect: "none",
  paddingTop: Zd,
  paddingBottom: Zd,
  boxSizing: "border-box",
  cursor: "pointer",
  position: "relative",
  touchAction: "none"
}, yD = {
  height: eo,
  backgroundColor: "rgba(255, 255, 255, 0.25)",
  width: "100%",
  borderRadius: eo / 2
}, bD = (r) => {
  let e = r;
  for (; e.parentElement; )
    e = e.parentElement;
  return e;
}, wD = ({ durationInFrames: r, onSeekEnd: e, onSeekStart: t, inFrame: n, outFrame: s }) => {
  const i = m.useRef(null), a = np(i, !1), c = sp(i, {
    triggerOnWindowResize: !0,
    shouldApplyCssTransforms: !0
  }), { seek: u, play: h, pause: d, playing: p } = fu(), g = Pe.Timeline.useTimelinePosition(), [v, b] = m.useState({
    dragging: !1
  }), _ = c?.width ?? 0, C = m.useCallback((F) => {
    if (F.button !== 0)
      return;
    const U = i.current?.getBoundingClientRect().left, B = d0(F.clientX - U, r, _);
    d(), u(B), b({
      dragging: !0,
      wasPlaying: p
    }), t();
  }, [r, _, d, u, p, t]), T = m.useCallback((F) => {
    if (!c)
      throw new Error("Player has no size");
    if (!v.dragging)
      return;
    const U = i.current?.getBoundingClientRect().left, B = d0(F.clientX - U, r, c.width);
    u(B);
  }, [v.dragging, r, u, c]), k = m.useCallback(() => {
    b({
      dragging: !1
    }), v.dragging && (v.wasPlaying ? h() : d(), e());
  }, [v, e, d, h]);
  m.useEffect(() => {
    if (!v.dragging)
      return;
    const F = bD(i.current);
    return F.addEventListener("pointermove", T), F.addEventListener("pointerup", k), () => {
      F.removeEventListener("pointermove", T), F.removeEventListener("pointerup", k);
    };
  }, [v.dragging, T, k]);
  const M = m.useMemo(() => ({
    height: na,
    width: na,
    borderRadius: na / 2,
    position: "absolute",
    top: Zd - na / 2 + 5 / 2,
    backgroundColor: "white",
    left: Math.max(0, g / Math.max(1, r - 1) * _ - na / 2),
    boxShadow: "0 0 2px black",
    opacity: Number(a)
  }), [a, r, g, _]), A = m.useMemo(() => ({
    height: eo,
    backgroundColor: "rgba(255, 255, 255, 1)",
    width: (g - (n ?? 0)) / (r - 1) * 100 + "%",
    marginLeft: (n ?? 0) / (r - 1) * 100 + "%",
    borderRadius: eo / 2
  }), [r, g, n]), D = m.useMemo(() => ({
    height: eo,
    backgroundColor: "rgba(255, 255, 255, 0.25)",
    width: ((s ?? r - 1) - (n ?? 0)) / (r - 1) * 100 + "%",
    marginLeft: (n ?? 0) / (r - 1) * 100 + "%",
    borderRadius: eo / 2,
    position: "absolute"
  }), [r, n, s]);
  return /* @__PURE__ */ w.jsxs("div", {
    ref: i,
    onPointerDown: C,
    style: vD,
    children: [
      /* @__PURE__ */ w.jsxs("div", {
        style: yD,
        children: [
          /* @__PURE__ */ w.jsx("div", {
            style: D
          }),
          /* @__PURE__ */ w.jsx("div", {
            style: A
          })
        ]
      }),
      /* @__PURE__ */ w.jsx("div", {
        style: M
      })
    ]
  });
}, f0 = (r) => {
  const e = Math.floor(r / 60), t = Math.floor(r - e * 60);
  return `${String(e)}:${String(t).padStart(2, "0")}`;
}, xD = 10, Jd = 12, _D = ({
  allowFullscreen: r,
  playerWidth: e
}) => m.useMemo(() => {
  const n = nr, s = nr, i = r ? qd : 0, a = s + n + i + Jd * 2 + xD * 2, c = e - a, u = Math.max(c, 0), h = u - oi, p = (h < oi ? u : h) + a + oi, g = e < p;
  return {
    maxTimeLabelWidth: u === 0 ? null : u,
    displayVerticalVolumeSlider: g
  };
}, [r, e]), SD = [
  0,
  0.013,
  0.049,
  0.104,
  0.175,
  0.259,
  0.352,
  0.45,
  0.55,
  0.648,
  0.741,
  0.825,
  0.896,
  0.951,
  0.987
], CD = [
  0,
  8.1,
  15.5,
  22.5,
  29,
  35.3,
  41.2,
  47.1,
  52.9,
  58.8,
  64.7,
  71,
  77.5,
  84.5,
  91.9
], TD = 1 / 0.7, ED = {
  boxSizing: "border-box",
  position: "absolute",
  bottom: 0,
  width: "100%",
  paddingTop: 40,
  paddingBottom: 10,
  backgroundImage: `linear-gradient(to bottom,${SD.map((r, e) => `hsla(0, 0%, 0%, ${r}) ${CD[e] * TD}%`).join(", ")}, hsl(0, 0%, 0%) 100%)`,
  backgroundSize: "auto 145px",
  display: "flex",
  paddingRight: Jd,
  paddingLeft: Jd,
  flexDirection: "column",
  transition: "opacity 0.3s"
}, kD = {
  display: "flex",
  flexDirection: "row",
  width: "100%",
  alignItems: "center",
  justifyContent: "center",
  userSelect: "none",
  WebkitUserSelect: "none"
}, OD = {
  display: "flex",
  flexDirection: "row",
  userSelect: "none",
  WebkitUserSelect: "none",
  alignItems: "center"
}, Bc = {
  width: 12
}, MD = {
  height: 8
}, AD = {
  flex: 1
}, ID = {}, PD = ({
  durationInFrames: r,
  isFullscreen: e,
  fps: t,
  player: n,
  showVolumeControls: s,
  onFullscreenButtonClick: i,
  allowFullscreen: a,
  onExitFullscreenButtonClick: c,
  spaceKeyToPlayOrPause: u,
  onSeekEnd: h,
  onSeekStart: d,
  inFrame: p,
  outFrame: g,
  initiallyShowControls: v,
  canvasSize: b,
  renderPlayPauseButton: _,
  renderFullscreenButton: C,
  alwaysShowControls: T,
  showPlaybackRateControl: k,
  containerRef: M,
  buffering: A,
  hideControlsWhenPointerDoesntMove: D,
  onPointerDown: F,
  onDoubleClick: U,
  renderMuteButton: B,
  renderVolumeSlider: X
}) => {
  const Y = m.useRef(null), Z = Pe.Timeline.useTimelinePosition(), [G, K] = m.useState(!1), oe = np(M, D), { maxTimeLabelWidth: ve, displayVerticalVolumeSlider: Q } = _D({
    allowFullscreen: a,
    playerWidth: b?.width ?? 0
  }), [ge, de] = m.useState(() => {
    if (typeof v == "boolean")
      return v;
    if (typeof v == "number") {
      if (v % 1 !== 0)
        throw new Error("initiallyShowControls must be an integer or a boolean");
      if (Number.isNaN(v))
        throw new Error("initiallyShowControls must not be NaN");
      if (!Number.isFinite(v))
        throw new Error("initiallyShowControls must be finite");
      if (v <= 0)
        throw new Error("initiallyShowControls must be a positive integer");
      return v;
    }
    throw new TypeError("initiallyShowControls must be a number or a boolean");
  }), ne = m.useMemo(() => {
    const ue = oe || !n.playing || ge || T;
    return {
      ...ED,
      opacity: Number(ue)
    };
  }, [oe, ge, n.playing, T]);
  m.useEffect(() => {
    Y.current && u && Y.current.focus({
      preventScroll: !0
    });
  }, [n.playing, u]), m.useEffect(() => {
    K((typeof document < "u" && (document.fullscreenEnabled || document.webkitFullscreenEnabled)) ?? !1);
  }, []), m.useEffect(() => {
    if (ge === !1)
      return;
    const Xe = setTimeout(() => {
      de(!1);
    }, ge === !0 ? 2e3 : ge);
    return () => {
      clearInterval(Xe);
    };
  }, [ge]);
  const I = m.useMemo(() => ({
    color: "white",
    fontFamily: "sans-serif",
    fontSize: 14,
    maxWidth: ve === null ? void 0 : ve,
    overflow: "hidden",
    textOverflow: "ellipsis"
  }), [ve]), W = m.useMemo(() => {
    if (k === !0)
      return [0.5, 0.8, 1, 1.2, 1.5, 1.8, 2, 2.5, 3];
    if (Array.isArray(k)) {
      for (const ue of k) {
        if (typeof ue != "number")
          throw new Error("Every item in showPlaybackRateControl must be a number");
        if (ue <= 0)
          throw new Error("Every item in showPlaybackRateControl must be positive");
      }
      return k;
    }
    return null;
  }, [k]), ce = m.useRef(null), fe = m.useRef(null), be = m.useCallback((ue) => {
    (ue.target === ce.current || ue.target === fe.current) && F?.(ue);
  }, [F]), ye = m.useCallback((ue) => {
    (ue.target === ce.current || ue.target === fe.current) && U?.(ue);
  }, [U]);
  return /* @__PURE__ */ w.jsxs("div", {
    ref: ce,
    style: ne,
    onPointerDown: be,
    onDoubleClick: ye,
    children: [
      /* @__PURE__ */ w.jsxs("div", {
        ref: fe,
        style: kD,
        children: [
          /* @__PURE__ */ w.jsxs("div", {
            style: OD,
            children: [
              /* @__PURE__ */ w.jsx("button", {
                ref: Y,
                type: "button",
                style: Kd,
                onClick: n.playing ? n.pause : n.play,
                "aria-label": n.playing ? "Pause video" : "Play video",
                title: n.playing ? "Pause video" : "Play video",
                children: _ === null ? /* @__PURE__ */ w.jsx(u0, {
                  buffering: A,
                  playing: n.playing
                }) : _({
                  playing: n.playing,
                  isBuffering: A
                }) ?? /* @__PURE__ */ w.jsx(u0, {
                  buffering: A,
                  playing: n.playing
                })
              }),
              s ? /* @__PURE__ */ w.jsxs(w.Fragment, {
                children: [
                  /* @__PURE__ */ w.jsx("div", {
                    style: Bc
                  }),
                  /* @__PURE__ */ w.jsx(sD, {
                    renderMuteButton: B,
                    renderVolumeSlider: X,
                    displayVerticalVolumeSlider: Q
                  })
                ]
              }) : null,
              /* @__PURE__ */ w.jsx("div", {
                style: Bc
              }),
              /* @__PURE__ */ w.jsxs("div", {
                style: I,
                children: [
                  f0(Z / t),
                  " / ",
                  f0(r / t)
                ]
              }),
              /* @__PURE__ */ w.jsx("div", {
                style: Bc
              })
            ]
          }),
          /* @__PURE__ */ w.jsx("div", {
            style: AD
          }),
          W && b && /* @__PURE__ */ w.jsx(mD, {
            canvasSize: b,
            playbackRates: W
          }),
          W && G && a ? /* @__PURE__ */ w.jsx("div", {
            style: Bc
          }) : null,
          /* @__PURE__ */ w.jsx("div", {
            style: ID,
            children: G && a ? /* @__PURE__ */ w.jsx("button", {
              type: "button",
              "aria-label": e ? "Exit fullscreen" : "Enter Fullscreen",
              title: e ? "Exit fullscreen" : "Enter Fullscreen",
              style: Kd,
              onClick: e ? c : i,
              children: C === null ? /* @__PURE__ */ w.jsx(WP, {
                isFullscreen: e
              }) : C({ isFullscreen: e })
            }) : null
          })
        ]
      }),
      /* @__PURE__ */ w.jsx("div", {
        style: MD
      }),
      /* @__PURE__ */ w.jsx(wD, {
        onSeekEnd: h,
        onSeekStart: d,
        durationInFrames: r,
        inFrame: p,
        outFrame: g
      })
    ]
  });
}, DD = {
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  flex: 1,
  height: "100%",
  width: "100%"
};
class Wb extends Ie.Component {
  state = { hasError: null };
  static getDerivedStateFromError(e) {
    return { hasError: e };
  }
  componentDidCatch(e) {
    this.props.onError(e);
  }
  render() {
    return this.state.hasError ? /* @__PURE__ */ w.jsx("div", {
      style: DD,
      children: this.props.errorFallback({
        error: this.state.hasError
      })
    }) : this.props.children;
  }
}
var ip = "__remotion-player", Hb = typeof document > "u", RD = (r) => {
  let e = !1;
  return {
    promise: new Promise((n, s) => {
      r.then((i) => {
        if (e) {
          s({ isCanceled: e, value: i });
          return;
        }
        n(i);
      }).catch((i) => {
        s({ isCanceled: e, error: i });
      });
    }),
    cancel: () => {
      e = !0;
    }
  };
}, jD = (r) => new Promise((e) => setTimeout(e, r)), LD = () => {
  const r = m.useRef([]), e = m.useCallback((i) => {
    r.current = [...r.current, i];
  }, []), t = m.useCallback((i) => {
    r.current = r.current.filter((a) => a !== i);
  }, []), n = m.useCallback(() => r.current.map((i) => i.cancel()), []);
  return m.useMemo(() => ({
    appendPendingPromise: e,
    removePendingPromise: t,
    clearPendingPromises: n
  }), [e, n, t]);
}, FD = (r, e, t) => {
  const n = LD(), s = m.useCallback(async (u) => {
    if (u instanceof PointerEvent ? u.pointerType === "touch" : u.nativeEvent.pointerType === "touch") {
      r(u);
      return;
    }
    n.clearPendingPromises();
    const h = RD(jD(200));
    n.appendPendingPromise(h);
    try {
      await h.promise, n.removePendingPromise(h), r(u);
    } catch (d) {
      const p = d;
      if (n.removePendingPromise(h), !p.isCanceled)
        throw p.error;
    }
  }, [n, r]), i = m.useCallback(() => {
    document.addEventListener("pointerup", (u) => {
      s(u);
    }, {
      once: !0
    });
  }, [s]), a = m.useCallback(() => {
    n.clearPendingPromises(), e();
  }, [n, e]);
  return m.useMemo(() => t ? { handlePointerDown: i, handleDoubleClick: a } : { handlePointerDown: r, handleDoubleClick: () => {
  } }, [t, a, i, r]);
}, Qd = Ie.version.split(".")[0];
if (Qd === "0")
  throw new Error(`Version ${Qd} of "react" is not supported by Remotion`);
var ND = parseInt(Qd, 10) >= 18, BD = ({
  controls: r,
  style: e,
  loop: t,
  autoPlay: n,
  allowFullscreen: s,
  inputProps: i,
  clickToPlay: a,
  showVolumeControls: c,
  doubleClickToFullscreen: u,
  spaceKeyToPlayOrPause: h,
  errorFallback: d,
  playbackRate: p,
  renderLoading: g,
  renderPoster: v,
  className: b,
  moveToBeginningWhenEnded: _,
  showPosterWhenUnplayed: C,
  showPosterWhenEnded: T,
  showPosterWhenPaused: k,
  showPosterWhenBuffering: M,
  inFrame: A,
  outFrame: D,
  initiallyShowControls: F,
  renderFullscreen: U,
  renderPlayPauseButton: B,
  renderMuteButton: X,
  renderVolumeSlider: Y,
  alwaysShowControls: Z,
  showPlaybackRateControl: G,
  posterFillMode: K,
  bufferStateDelayInMilliseconds: oe,
  hideControlsWhenPointerDoesntMove: ve,
  overflowVisible: Q,
  browserMediaControlsBehavior: ge
}, de) => {
  const ne = Pe.useUnsafeVideoConfig(), I = Pe.useVideo(), W = m.useRef(null), ce = sp(W, {
    triggerOnWindowResize: !1,
    shouldApplyCssTransforms: !1
  }), [fe, be] = m.useState(!1), [ye, ue] = m.useState(n), [Xe, We] = m.useState(() => !1), [bt, wt] = m.useState(!1), Vt = m.useMemo(() => typeof document > "u" ? !1 : !!(document.fullscreenEnabled || document.webkitFullscreenEnabled), []), Ce = fu();
  tD({
    loop: t,
    playbackRate: p,
    moveToBeginningWhenEnded: _,
    inFrame: A,
    outFrame: D,
    frameRef: Ce.remotionInternal_currentFrameRef,
    browserMediaControlsBehavior: ge
  }), m.useEffect(() => {
    fe && !Ce.playing && (be(!1), Ce.play());
  }, [fe, Ce]), m.useEffect(() => {
    const { current: qe } = W;
    if (!qe)
      return;
    const Ue = () => {
      const Zt = document.fullscreenElement === qe || document.webkitFullscreenElement === qe;
      We(Zt);
    };
    return document.addEventListener("fullscreenchange", Ue), document.addEventListener("webkitfullscreenchange", Ue), () => {
      document.removeEventListener("fullscreenchange", Ue), document.removeEventListener("webkitfullscreenchange", Ue);
    };
  }, []);
  const qt = m.useCallback((qe) => {
    Ce.isPlaying() ? Ce.pause() : Ce.play(qe);
  }, [Ce]), it = m.useCallback(() => {
    if (!s)
      throw new Error("allowFullscreen is false");
    if (!Vt)
      throw new Error("Browser doesnt support fullscreen");
    if (!W.current)
      throw new Error("No player ref found");
    W.current.webkitRequestFullScreen ? W.current.webkitRequestFullScreen() : W.current.requestFullscreen();
  }, [s, Vt]), Tt = m.useCallback(() => {
    document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.exitFullscreen();
  }, []);
  m.useEffect(() => {
    const { current: qe } = W;
    if (!qe)
      return;
    const Ue = () => {
      const Zt = document.webkitFullscreenElement ?? document.fullscreenElement;
      Zt && Zt === W.current ? Ce.emitter.dispatchFullscreenChange({
        isFullscreen: !0
      }) : Ce.emitter.dispatchFullscreenChange({
        isFullscreen: !1
      });
    };
    return qe.addEventListener("webkitfullscreenchange", Ue), qe.addEventListener("fullscreenchange", Ue), () => {
      qe.removeEventListener("webkitfullscreenchange", Ue), qe.removeEventListener("fullscreenchange", Ue);
    };
  }, [Ce.emitter]);
  const Tr = ne?.durationInFrames ?? 1, tt = m.useMemo(() => !ne || !ce ? null : jb({
    canvasSize: ce,
    compositionHeight: ne.height,
    compositionWidth: ne.width,
    previewSize: "auto"
  }), [ce, ne]), It = tt?.scale ?? 1, Gr = m.useRef(!1);
  m.useEffect(() => {
    if (!Gr.current) {
      Gr.current = !0;
      return;
    }
    Ce.emitter.dispatchScaleChange(It);
  }, [Ce.emitter, It]);
  const { setMediaVolume: sr, setMediaMuted: R } = m.useContext(Pe.SetMediaVolumeContext), { mediaMuted: he, mediaVolume: pe } = m.useContext(Pe.MediaVolumeContext);
  m.useEffect(() => {
    Ce.emitter.dispatchVolumeChange(pe);
  }, [Ce.emitter, pe]);
  const De = he || pe === 0;
  m.useEffect(() => {
    Ce.emitter.dispatchMuteChange({
      isMuted: De
    });
  }, [Ce.emitter, De]);
  const [Je, Ge] = m.useState(!1);
  m.useEffect(() => {
    let qe = null, Ue = !1;
    const Zt = () => {
      Ue = !1, requestAnimationFrame(() => {
        oe === 0 ? Ge(!0) : qe = setTimeout(() => {
          Ue || Ge(!0);
        }, oe);
      });
    }, fr = () => {
      requestAnimationFrame(() => {
        Ue = !0, Ge(!1), qe && clearTimeout(qe);
      });
    };
    return Ce.emitter.addEventListener("waiting", Zt), Ce.emitter.addEventListener("resume", fr), () => {
      Ce.emitter.removeEventListener("waiting", Zt), Ce.emitter.removeEventListener("resume", fr), Ge(!1), qe && clearTimeout(qe), Ue = !0;
    };
  }, [oe, Ce.emitter]), m.useImperativeHandle(de, () => {
    const qe = {
      play: Ce.play,
      pause: () => {
        be(!1), Ce.pause();
      },
      toggle: qt,
      getContainerNode: () => W.current,
      getCurrentFrame: Ce.getCurrentFrame,
      isPlaying: Ce.isPlaying,
      seekTo: (Ue) => {
        const Zt = Tr - 1, fr = Math.max(0, Math.min(Zt, Ue));
        Ce.isPlaying() && (be(fr !== Zt || t), Ce.pause()), fr === Zt && !t && Ce.emitter.dispatchEnded(), Ce.seek(fr);
      },
      isFullscreen: () => {
        const { current: Ue } = W;
        return Ue ? document.fullscreenElement === Ue || document.webkitFullscreenElement === Ue : !1;
      },
      requestFullscreen: it,
      exitFullscreen: Tt,
      getVolume: () => he ? 0 : pe,
      setVolume: (Ue) => {
        if (typeof Ue != "number")
          throw new TypeError(`setVolume() takes a number, got value of type ${typeof Ue}`);
        if (isNaN(Ue))
          throw new TypeError("setVolume() got a number that is NaN. Volume must be between 0 and 1.");
        if (Ue < 0 || Ue > 1)
          throw new TypeError(`setVolume() got a number that is out of range. Must be between 0 and 1, got ${typeof Ue}`);
        sr(Ue);
      },
      isMuted: () => De,
      mute: () => {
        R(!0);
      },
      unmute: () => {
        R(!1);
      },
      getScale: () => It,
      pauseAndReturnToPlayStart: () => {
        Ce.pauseAndReturnToPlayStart();
      }
    };
    return Object.assign(Ce.emitter, qe);
  }, [
    Tr,
    Tt,
    t,
    he,
    De,
    pe,
    Ce,
    it,
    R,
    sr,
    qt,
    It
  ]);
  const ke = I ? I.component : null, xe = m.useMemo(() => Lb({
    canvasSize: ce,
    config: ne,
    style: e,
    overflowVisible: Q,
    layout: tt
  }), [ce, ne, tt, Q, e]), zt = m.useMemo(() => Nb({ config: ne, layout: tt, scale: It, overflowVisible: Q }), [ne, tt, Q, It]), xt = m.useMemo(() => Fb({
    canvasSize: ce,
    config: ne,
    layout: tt,
    scale: It,
    overflowVisible: Q
  }), [ce, ne, tt, Q, It]), Wt = m.useCallback((qe) => {
    Ce.pause(), Ce.emitter.dispatchError(qe);
  }, [Ce]), Er = m.useCallback((qe) => {
    qe.stopPropagation(), it();
  }, [it]), Qt = m.useCallback((qe) => {
    qe.stopPropagation(), Tt();
  }, [Tt]), jr = m.useCallback((qe) => {
    (qe instanceof MouseEvent ? qe.button === 2 : qe.nativeEvent.button) || qt(qe);
  }, [qt]), Kt = m.useCallback(() => {
    wt(!0);
  }, []), ls = m.useCallback(() => {
    wt(!1);
  }, []), us = m.useCallback(() => {
    Xe ? Tt() : it();
  }, [Tt, Xe, it]), { handlePointerDown: Vn, handleDoubleClick: Tn } = FD(jr, us, u && s && Vt);
  m.useEffect(() => {
    ye && (Ce.play(), ue(!1));
  }, [ye, Ce]);
  const Ii = m.useMemo(() => g ? g({
    height: xe.height,
    width: xe.width,
    isBuffering: Je
  }) : null, [xe.height, xe.width, g, Je]), hs = m.useMemo(() => ({
    type: "scale",
    scale: It
  }), [It]);
  if (!ne)
    return null;
  const un = v ? v({
    height: K === "player-size" ? xe.height : ne.height,
    width: K === "player-size" ? xe.width : ne.width,
    isBuffering: Je
  }) : null;
  if (un === void 0)
    throw new TypeError("renderPoster() must return a React element, but undefined was returned");
  const Pi = un && [
    k && !Ce.isPlaying() && !bt,
    T && Ce.isLastFrame && !Ce.isPlaying(),
    C && !Ce.hasPlayed && !Ce.isPlaying(),
    M && Je && Ce.isPlaying()
  ].some(Boolean), { left: Do, top: Ro, width: jo, height: Di, ...Ri } = zt, Vs = /* @__PURE__ */ w.jsxs(w.Fragment, {
    children: [
      /* @__PURE__ */ w.jsx("div", {
        style: zt,
        onPointerDown: a ? Vn : void 0,
        onDoubleClick: u ? Tn : void 0,
        children: /* @__PURE__ */ w.jsxs("div", {
          style: xt,
          className: ip,
          children: [
            ke ? /* @__PURE__ */ w.jsx(Wb, {
              onError: Wt,
              errorFallback: d,
              children: /* @__PURE__ */ w.jsx(Pe.CurrentScaleContext.Provider, {
                value: hs,
                children: /* @__PURE__ */ w.jsx(ke, {
                  ...I?.props ?? {},
                  ...i ?? {}
                })
              })
            }) : null,
            Pi && K === "composition-size" ? /* @__PURE__ */ w.jsx("div", {
              style: {
                ...Ri,
                width: ne.width,
                height: ne.height
              },
              onPointerDown: a ? Vn : void 0,
              onDoubleClick: u ? Tn : void 0,
              children: un
            }) : null
          ]
        })
      }),
      Pi && K === "player-size" ? /* @__PURE__ */ w.jsx("div", {
        style: zt,
        onPointerDown: a ? Vn : void 0,
        onDoubleClick: u ? Tn : void 0,
        children: un
      }) : null,
      r ? /* @__PURE__ */ w.jsx(PD, {
        fps: ne.fps,
        durationInFrames: ne.durationInFrames,
        player: Ce,
        containerRef: W,
        onFullscreenButtonClick: Er,
        isFullscreen: Xe,
        allowFullscreen: s,
        showVolumeControls: c,
        onExitFullscreenButtonClick: Qt,
        spaceKeyToPlayOrPause: h,
        onSeekEnd: ls,
        onSeekStart: Kt,
        inFrame: A,
        outFrame: D,
        initiallyShowControls: F,
        canvasSize: ce,
        renderFullscreenButton: U,
        renderPlayPauseButton: B,
        alwaysShowControls: Z,
        showPlaybackRateControl: G,
        buffering: Je,
        hideControlsWhenPointerDoesntMove: ve,
        onDoubleClick: u ? Tn : void 0,
        onPointerDown: a ? Vn : void 0,
        renderMuteButton: X,
        renderVolumeSlider: Y
      }) : null
    ]
  });
  return Hb && !ND ? /* @__PURE__ */ w.jsx("div", {
    ref: W,
    style: xe,
    className: b,
    children: Vs
  }) : /* @__PURE__ */ w.jsx("div", {
    ref: W,
    style: xe,
    className: b,
    children: /* @__PURE__ */ w.jsx(m.Suspense, {
      fallback: Ii,
      children: Vs
    })
  });
}, VD = m.forwardRef(BD), Ub = "remotion.volumePreference", zD = (r) => {
  if (!(typeof window > "u"))
    try {
      window.localStorage.setItem(Ub, String(r));
    } catch (e) {
      console.log("Could not persist volume", e);
    }
}, WD = () => {
  if (typeof window > "u")
    return 1;
  try {
    const r = window.localStorage.getItem(Ub);
    return r ? Number(r) : 1;
  } catch {
    return 1;
  }
}, op = "player-comp", $b = ({
  children: r,
  timelineContext: e,
  fps: t,
  compositionHeight: n,
  compositionWidth: s,
  durationInFrames: i,
  component: a,
  numberOfSharedAudioTags: c,
  initiallyMuted: u
}) => {
  const h = m.useMemo(() => ({
    compositions: [
      {
        component: a,
        durationInFrames: i,
        height: n,
        width: s,
        fps: t,
        id: op,
        nonce: 777,
        folderName: null,
        parentFolderName: null,
        schema: null,
        calculateMetadata: null
      }
    ],
    folders: [],
    registerFolder: () => {
    },
    unregisterFolder: () => {
    },
    registerComposition: () => {
    },
    unregisterComposition: () => {
    },
    currentCompositionMetadata: null,
    setCurrentCompositionMetadata: () => {
    },
    canvasContent: { type: "composition", compositionId: "player-comp" },
    setCanvasContent: () => {
    },
    updateCompositionDefaultProps: () => {
    }
  }), [a, i, n, s, t]), [d, p] = m.useState(() => u), [g, v] = m.useState(() => WD()), b = m.useMemo(() => ({
    mediaMuted: d,
    mediaVolume: g
  }), [d, g]), _ = m.useCallback((T) => {
    v(T), zD(T);
  }, []), C = m.useMemo(() => ({
    setMediaMuted: p,
    setMediaVolume: _
  }), [_]);
  return /* @__PURE__ */ w.jsx(Pe.CanUseRemotionHooksProvider, {
    children: /* @__PURE__ */ w.jsx(Pe.Timeline.TimelineContext.Provider, {
      value: e,
      children: /* @__PURE__ */ w.jsx(Pe.CompositionManager.Provider, {
        value: h,
        children: /* @__PURE__ */ w.jsx(Pe.ResolveCompositionConfig, {
          children: /* @__PURE__ */ w.jsx(Pe.PrefetchProvider, {
            children: /* @__PURE__ */ w.jsx(Pe.DurationsContextProvider, {
              children: /* @__PURE__ */ w.jsx(Pe.MediaVolumeContext.Provider, {
                value: b,
                children: /* @__PURE__ */ w.jsx(Pe.SetMediaVolumeContext.Provider, {
                  value: C,
                  children: /* @__PURE__ */ w.jsx(Pe.SharedAudioContextProvider, {
                    numberOfAudioTags: c,
                    component: a,
                    children: /* @__PURE__ */ w.jsx(Pe.BufferingProvider, {
                      children: r
                    })
                  })
                })
              })
            })
          })
        })
      })
    })
  });
}, p0 = (r, e) => {
  if (typeof r > "u" || r === null)
    return r ?? null;
  if (typeof r != "number")
    throw new TypeError(`"${e}" must be a number, but is ${JSON.stringify(r)}`);
  if (Number.isNaN(r))
    throw new TypeError(`"${e}" must not be NaN, but is ${JSON.stringify(r)}`);
  if (!Number.isFinite(r))
    throw new TypeError(`"${e}" must be finite, but is ${JSON.stringify(r)}`);
  if (r % 1 !== 0)
    throw new TypeError(`"${e}" must be an integer, but is ${JSON.stringify(r)}`);
  return r;
}, HD = ({
  inFrame: r,
  durationInFrames: e,
  outFrame: t
}) => {
  const n = p0(r, "inFrame"), s = p0(t, "outFrame");
  if (!(n === null && s === null)) {
    if (n !== null && n > e - 1)
      throw new Error("inFrame must be less than (durationInFrames - 1), but is " + n);
    if (s !== null && s > e - 1)
      throw new Error("outFrame must be less than (durationInFrames - 1), but is " + s);
    if (n !== null && n < 0)
      throw new Error("inFrame must be greater than 0, but is " + n);
    if (s !== null && s <= 0)
      throw new Error(`outFrame must be greater than 0, but is ${s}. If you want to render a single frame, use <Thumbnail /> instead.`);
    if (s !== null && n !== null && s <= n)
      throw new Error("outFrame must be greater than inFrame, but is " + s + " <= " + n);
  }
}, UD = ({
  initialFrame: r,
  durationInFrames: e
}) => {
  if (typeof e != "number")
    throw new Error(`\`durationInFrames\` must be a number, but is ${JSON.stringify(e)}`);
  if (!(typeof r > "u")) {
    if (typeof r != "number")
      throw new Error(`\`initialFrame\` must be a number, but is ${JSON.stringify(r)}`);
    if (Number.isNaN(r))
      throw new Error("`initialFrame` must be a number, but is NaN");
    if (!Number.isFinite(r))
      throw new Error("`initialFrame` must be a number, but is Infinity");
    if (r % 1 !== 0)
      throw new Error(`\`initialFrame\` must be an integer, but is ${JSON.stringify(r)}`);
    if (r > e - 1)
      throw new Error(`\`initialFrame\` must be less or equal than \`durationInFrames - 1\`, but is ${JSON.stringify(r)}`);
  }
}, $D = (r) => {
  if (r !== void 0) {
    if (r > 4)
      throw new Error(`The highest possible playback rate is 4. You passed: ${r}`);
    if (r < -4)
      throw new Error(`The lowest possible playback rate is -4. You passed: ${r}`);
    if (r === 0)
      throw new Error("A playback rate of 0 is not supported.");
  }
}, YD = du.validateFps, g0 = du.validateDimension, XD = du.validateDurationInFrames, GD = du.validateDefaultAndInputProps, qD = (r) => "component" in r ? r.component : null, KD = ({
  durationInFrames: r,
  compositionHeight: e,
  compositionWidth: t,
  fps: n,
  inputProps: s,
  style: i,
  controls: a = !1,
  loop: c = !1,
  autoPlay: u = !1,
  showVolumeControls: h = !0,
  allowFullscreen: d = !0,
  clickToPlay: p,
  doubleClickToFullscreen: g = !1,
  spaceKeyToPlayOrPause: v = !0,
  moveToBeginningWhenEnded: b = !0,
  numberOfSharedAudioTags: _ = 5,
  errorFallback: C = () => "⚠️",
  playbackRate: T = 1,
  renderLoading: k,
  className: M,
  showPosterWhenUnplayed: A,
  showPosterWhenEnded: D,
  showPosterWhenPaused: F,
  showPosterWhenBuffering: U,
  initialFrame: B,
  renderPoster: X,
  inFrame: Y,
  outFrame: Z,
  initiallyShowControls: G,
  renderFullscreenButton: K,
  renderPlayPauseButton: oe,
  renderVolumeSlider: ve,
  alwaysShowControls: Q = !1,
  initiallyMuted: ge = !1,
  showPlaybackRateControl: de = !1,
  posterFillMode: ne = "player-size",
  bufferStateDelayInMilliseconds: I,
  hideControlsWhenPointerDoesntMove: W = !0,
  overflowVisible: ce = !1,
  renderMuteButton: fe,
  browserMediaControlsBehavior: be,
  ...ye
}, ue) => {
  if (typeof window < "u" && m.useLayoutEffect(() => {
    window.remotion_isPlayer = !0;
  }, []), ye.defaultProps !== void 0)
    throw new Error("The <Player /> component does not accept `defaultProps`, but some were passed. Use `inputProps` instead.");
  const Xe = qD(ye);
  if (Xe?.type === s0)
    throw new TypeError("'component' should not be an instance of <Composition/>. Pass the React component directly, and set the duration, fps and dimensions as separate props. See https://www.remotion.dev/docs/player/examples for an example.");
  if (Xe === s0)
    throw new TypeError("'component' must not be the 'Composition' component. Pass your own React component directly, and set the duration, fps and dimensions as separate props. See https://www.remotion.dev/docs/player/examples for an example.");
  const We = Pe.useLazyComponent(ye);
  UD({ initialFrame: B, durationInFrames: r });
  const [bt, wt] = m.useState(() => ({
    [op]: B ?? 0
  })), [Vt, Ce] = m.useState(!1), [qt] = m.useState("player-comp"), it = m.useRef(null), Tt = m.useRef([]), Tr = m.useRef(!1), [tt, It] = m.useState(T);
  if (typeof e != "number")
    throw new TypeError(`'compositionHeight' must be a number but got '${typeof e}' instead`);
  if (typeof t != "number")
    throw new TypeError(`'compositionWidth' must be a number but got '${typeof t}' instead`);
  if (g0(e, "compositionHeight", "of the <Player /> component"), g0(t, "compositionWidth", "of the <Player /> component"), XD(r, {
    component: "of the <Player/> component",
    allowFloats: !1
  }), YD(n, "as a prop of the <Player/> component", !1), GD(s, "inputProps", null), HD({
    durationInFrames: r,
    inFrame: Y,
    outFrame: Z
  }), typeof a != "boolean" && typeof a < "u")
    throw new TypeError(`'controls' must be a boolean or undefined but got '${typeof a}' instead`);
  if (typeof u != "boolean" && typeof u < "u")
    throw new TypeError(`'autoPlay' must be a boolean or undefined but got '${typeof u}' instead`);
  if (typeof c != "boolean" && typeof c < "u")
    throw new TypeError(`'loop' must be a boolean or undefined but got '${typeof c}' instead`);
  if (typeof g != "boolean" && typeof g < "u")
    throw new TypeError(`'doubleClickToFullscreen' must be a boolean or undefined but got '${typeof g}' instead`);
  if (typeof h != "boolean" && typeof h < "u")
    throw new TypeError(`'showVolumeControls' must be a boolean or undefined but got '${typeof h}' instead`);
  if (typeof d != "boolean" && typeof d < "u")
    throw new TypeError(`'allowFullscreen' must be a boolean or undefined but got '${typeof d}' instead`);
  if (typeof p != "boolean" && typeof p < "u")
    throw new TypeError(`'clickToPlay' must be a boolean or undefined but got '${typeof p}' instead`);
  if (typeof v != "boolean" && typeof v < "u")
    throw new TypeError(`'spaceKeyToPlayOrPause' must be a boolean or undefined but got '${typeof v}' instead`);
  if (typeof _ != "number" || _ % 1 !== 0 || !Number.isFinite(_) || Number.isNaN(_) || _ < 0)
    throw new TypeError(`'numberOfSharedAudioTags' must be an integer but got '${_}' instead`);
  $D(tt), m.useEffect(() => {
    It(T);
  }, [T]), m.useImperativeHandle(ue, () => it.current, []);
  const Gr = m.useMemo(() => ({
    frame: bt,
    playing: Vt,
    rootId: qt,
    playbackRate: tt,
    imperativePlaying: Tr,
    setPlaybackRate: (pe) => {
      It(pe);
    },
    audioAndVideoTags: Tt
  }), [bt, tt, Vt, qt]), sr = m.useMemo(() => ({
    setFrame: wt,
    setPlaying: Ce
  }), [wt]);
  typeof window < "u" && m.useLayoutEffect(() => {
    Pe.CSSUtils.injectCSS(Pe.CSSUtils.makeDefaultPreviewCSS(`.${ip}`, "#fff"));
  }, []);
  const R = m.useMemo(() => s ?? {}, [s]), he = m.useMemo(() => be ?? {
    mode: "prevent-media-session"
  }, [be]);
  return /* @__PURE__ */ w.jsx(Pe.IsPlayerContextProvider, {
    children: /* @__PURE__ */ w.jsx($b, {
      timelineContext: Gr,
      component: We,
      compositionHeight: e,
      compositionWidth: t,
      durationInFrames: r,
      fps: n,
      numberOfSharedAudioTags: _,
      initiallyMuted: ge,
      children: /* @__PURE__ */ w.jsx(Pe.Timeline.SetTimelineContext.Provider, {
        value: sr,
        children: /* @__PURE__ */ w.jsx(ZP, {
          currentPlaybackRate: tt,
          children: /* @__PURE__ */ w.jsx(VD, {
            ref: it,
            posterFillMode: ne,
            renderLoading: k,
            autoPlay: !!u,
            loop: !!c,
            controls: !!a,
            errorFallback: C,
            style: i,
            inputProps: R,
            allowFullscreen: !!d,
            moveToBeginningWhenEnded: !!b,
            clickToPlay: typeof p == "boolean" ? p : !!a,
            showVolumeControls: !!h,
            doubleClickToFullscreen: !!g,
            spaceKeyToPlayOrPause: !!v,
            playbackRate: tt,
            className: M ?? void 0,
            showPosterWhenUnplayed: !!A,
            showPosterWhenEnded: !!D,
            showPosterWhenPaused: !!F,
            showPosterWhenBuffering: !!U,
            renderPoster: X,
            inFrame: Y ?? null,
            outFrame: Z ?? null,
            initiallyShowControls: G ?? !0,
            renderFullscreen: K ?? null,
            renderPlayPauseButton: oe ?? null,
            renderMuteButton: fe ?? null,
            renderVolumeSlider: ve ?? null,
            alwaysShowControls: Q,
            showPlaybackRateControl: de,
            bufferStateDelayInMilliseconds: I ?? 300,
            hideControlsWhenPointerDoesntMove: W,
            overflowVisible: ce,
            browserMediaControlsBehavior: he
          })
        })
      })
    })
  });
}, ZD = m.forwardRef, JD = ZD(KD), QD = () => {
  const r = m.useContext(Vb);
  if (!r)
    throw new TypeError("Expected Player event emitter context");
  return m.useMemo(() => ({
    emitter: r
  }), [r]);
}, ef = Ie.version.split(".")[0];
if (ef === "0")
  throw new Error(`Version ${ef} of "react" is not supported by Remotion`);
var eR = parseInt(ef, 10) >= 18, tR = ({ style: r, inputProps: e, errorFallback: t, renderLoading: n, className: s, overflowVisible: i }, a) => {
  const c = Pe.useUnsafeVideoConfig(), u = Pe.useVideo(), h = m.useRef(null), d = sp(h, {
    triggerOnWindowResize: !1,
    shouldApplyCssTransforms: !1
  }), p = m.useMemo(() => !c || !d ? null : jb({
    canvasSize: d,
    compositionHeight: c.height,
    compositionWidth: c.width,
    previewSize: "auto"
  }), [d, c]), g = p?.scale ?? 1, v = QD();
  zb(v.emitter), m.useImperativeHandle(a, () => {
    const F = {
      getContainerNode: () => h.current,
      getScale: () => g
    };
    return Object.assign(v.emitter, F);
  }, [g, v.emitter]);
  const b = u ? u.component : null, _ = m.useMemo(() => Lb({
    config: c,
    style: r,
    canvasSize: d,
    overflowVisible: i,
    layout: p
  }), [d, c, p, i, r]), C = m.useMemo(() => Nb({ config: c, layout: p, scale: g, overflowVisible: i }), [c, p, i, g]), T = m.useMemo(() => Fb({
    canvasSize: d,
    config: c,
    layout: p,
    scale: g,
    overflowVisible: i
  }), [d, c, p, i, g]), k = m.useCallback((F) => {
    v.emitter.dispatchError(F);
  }, [v.emitter]), M = m.useMemo(() => n ? n({
    height: _.height,
    width: _.width,
    isBuffering: !1
  }) : null, [_.height, _.width, n]), A = m.useMemo(() => ({
    type: "scale",
    scale: g
  }), [g]);
  if (!c)
    return null;
  const D = /* @__PURE__ */ w.jsx("div", {
    style: C,
    children: /* @__PURE__ */ w.jsx("div", {
      style: T,
      className: ip,
      children: b ? /* @__PURE__ */ w.jsx(Wb, {
        onError: k,
        errorFallback: t,
        children: /* @__PURE__ */ w.jsx(Pe.CurrentScaleContext.Provider, {
          value: A,
          children: /* @__PURE__ */ w.jsx(b, {
            ...u?.props ?? {},
            ...e ?? {}
          })
        })
      }) : null
    })
  });
  return Hb && !eR ? /* @__PURE__ */ w.jsx("div", {
    ref: h,
    style: _,
    className: s,
    children: D
  }) : /* @__PURE__ */ w.jsx("div", {
    ref: h,
    style: _,
    className: s,
    children: /* @__PURE__ */ w.jsx(m.Suspense, {
      fallback: M,
      children: D
    })
  });
}, rR = m.forwardRef(tR), nR = ({
  frameToDisplay: r,
  style: e,
  inputProps: t,
  compositionHeight: n,
  compositionWidth: s,
  durationInFrames: i,
  fps: a,
  className: c,
  errorFallback: u = () => "⚠️",
  renderLoading: h,
  overflowVisible: d = !1,
  ...p
}, g) => {
  typeof window < "u" && m.useLayoutEffect(() => {
    window.remotion_isPlayer = !0;
  }, []);
  const [v] = m.useState(() => String(Ei(null))), b = m.useRef(null), _ = m.useMemo(() => ({
    playing: !1,
    frame: {
      [op]: r
    },
    rootId: v,
    imperativePlaying: {
      current: !1
    },
    playbackRate: 1,
    setPlaybackRate: () => {
      throw new Error("thumbnail");
    },
    audioAndVideoTags: { current: [] }
  }), [r, v]);
  m.useImperativeHandle(g, () => b.current, []);
  const C = Pe.useLazyComponent(p), [T] = m.useState(() => new KP()), k = m.useMemo(() => t ?? {}, [t]);
  return /* @__PURE__ */ w.jsx(Pe.IsPlayerContextProvider, {
    children: /* @__PURE__ */ w.jsx($b, {
      timelineContext: _,
      component: C,
      compositionHeight: n,
      compositionWidth: s,
      durationInFrames: i,
      fps: a,
      numberOfSharedAudioTags: 0,
      initiallyMuted: !0,
      children: /* @__PURE__ */ w.jsx(Vb.Provider, {
        value: T,
        children: /* @__PURE__ */ w.jsx(rR, {
          ref: b,
          className: c,
          errorFallback: u,
          inputProps: k,
          renderLoading: h,
          style: e,
          overflowVisible: d
        })
      })
    })
  });
}, sR = m.forwardRef;
sR(nR);
const Vc = (r, e) => {
  const t = r.from / 1e3 * e, n = r.to / 1e3 * e - t;
  return { from: t, durationInFrames: n };
}, iR = {
  text: (r, e) => {
    const { fps: t, height: n, width: s } = e, { from: i, durationInFrames: a } = Vc(r.display, t);
    return /* @__PURE__ */ w.jsx(
      In,
      {
        from: i,
        durationInFrames: a,
        "data-track-item": "transition-element",
        style: {
          position: "absolute",
          width: r.details.width ?? 300,
          height: r.details.height ?? 400,
          transform: r.details.transform ?? "none",
          fontSize: r.details.fontSize || "16px",
          // Updated default font size
          textAlign: r.details.textAlign || "left",
          // Updated default text alignment
          top: r.details.top ?? 300,
          left: r.details.left ?? 600,
          color: r.details.color || "#000000",
          // Updated text color (fill)
          backgroundColor: r.details.backgroundColor || "transparent",
          // Updated background color
          border: r.details.border ?? "none",
          // Updated border
          opacity: r.details.opacity ?? 100 / 100,
          fontFamily: r.details.fontFamily || "Arial",
          // Updated default font family
          textDecoration: r.details.textDecoration || "none",
          fontWeight: r.details.fontWeight || "normal",
          lineHeight: r.details.lineHeight || "normal",
          // Added line height
          letterSpacing: r.details.letterSpacing || "normal",
          // Added letter spacing
          wordSpacing: r.details.wordSpacing || "normal",
          // Added word spacing
          wordWrap: r.details.wordWrap || "normal",
          //'break-word'
          wordBreak: r.details.wordBreak || "normal",
          //'break-all',
          pointerEvents: "auto"
        },
        children: /* @__PURE__ */ w.jsx("div", { children: r.details.text })
      },
      r.id
    );
  },
  image: (r, e) => {
    const { fps: t } = e, { from: n, durationInFrames: s } = Vc(r.display, t);
    return /* @__PURE__ */ w.jsx(
      In,
      {
        from: n,
        durationInFrames: s,
        style: {
          width: r.details.width ?? "100%",
          // Default width
          height: r.details.height ?? "auto",
          // Default height
          transform: r.details.transform ?? "none",
          opacity: (r.details.opacity ?? 100) / 100 || 1,
          border: r.details.border ?? "none",
          // Default border
          borderRadius: r.details.borderRadius ?? "0",
          // Default border radius
          boxShadow: r.details.boxShadow ?? "none",
          // Default box shadow
          filter: r.details.filter || "none",
          top: r.details.top ?? 0,
          left: r.details.left ?? 0
        },
        children: /* @__PURE__ */ w.jsx(ha, { style: { pointerEvents: "none" }, children: /* @__PURE__ */ w.jsx(
          Mb,
          {
            style: { pointerEvents: "none" },
            "data-id": r.id,
            src: r.details.src
          }
        ) })
      },
      r.id
    );
  },
  video: (r, e) => {
    const { fps: t } = e, { from: n, durationInFrames: s } = Vc(r.display, t), i = r.trim, a = r.details.crop || {
      x: 0,
      y: 0,
      width: r.details.width,
      height: r.details.height
    };
    return i ? /* @__PURE__ */ w.jsx(
      In,
      {
        premountFor: 30 * 5,
        from: n,
        durationInFrames: s,
        style: {
          width: a.width || "100%",
          // Default width
          height: a.height || "auto",
          // Default height
          transform: r.details.transform ?? "none",
          opacity: (r.details.opacity ?? 100) / 100 || 1,
          border: r.details.border ?? "none",
          // Default border
          borderRadius: r.details.borderRadius ?? "0",
          // Default border radius
          boxShadow: r.details.boxShadow ?? "none",
          // Default box shadow
          top: r.details.top ?? 0,
          left: r.details.left ?? 0,
          overflow: "hidden"
        },
        children: /* @__PURE__ */ w.jsx(
          ha,
          {
            style: {
              pointerEvents: "none",
              width: r.details.width,
              height: r.details.height,
              top: -a.y,
              left: -a.x
            },
            children: /* @__PURE__ */ w.jsx(
              Rb,
              {
                startFrom: i.from / 1e3 * t,
                endAt: i.to / 1e3 * t,
                src: r.details.src,
                volume: (r.details.volume ?? 100) / 100,
                style: {
                  pointerEvents: "none",
                  width: r.details.width,
                  height: r.details.height
                }
              }
            )
          }
        )
      },
      r.id
    ) : /* @__PURE__ */ w.jsx(w.Fragment, {});
  },
  audio: (r, e) => {
    const { fps: t } = e, { from: n, durationInFrames: s } = Vc(r.display, t), i = r.trim;
    return i ? /* @__PURE__ */ w.jsx(
      In,
      {
        className: `moonshine-scene-item id-${r.id} moonshine-scene-item-type-${r.type}`,
        from: n,
        durationInFrames: s,
        style: {
          userSelect: "none",
          pointerEvents: "none"
        },
        children: /* @__PURE__ */ w.jsx(ha, { children: /* @__PURE__ */ w.jsx(
          da,
          {
            startFrom: i.from / 1e3 * t,
            endAt: i.to / 1e3 * t,
            src: r.details.src,
            volume: (r.details.volume ?? 100) / 100
          }
        ) })
      },
      r.id
    ) : /* @__PURE__ */ w.jsx(w.Fragment, {});
  }
};
var Tl = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
Tl.exports;
(function(r, e) {
  (function() {
    var t, n = "4.17.21", s = 200, i = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", a = "Expected a function", c = "Invalid `variable` option passed into `_.template`", u = "__lodash_hash_undefined__", h = 500, d = "__lodash_placeholder__", p = 1, g = 2, v = 4, b = 1, _ = 2, C = 1, T = 2, k = 4, M = 8, A = 16, D = 32, F = 64, U = 128, B = 256, X = 512, Y = 30, Z = "...", G = 800, K = 16, oe = 1, ve = 2, Q = 3, ge = 1 / 0, de = 9007199254740991, ne = 17976931348623157e292, I = NaN, W = 4294967295, ce = W - 1, fe = W >>> 1, be = [
      ["ary", U],
      ["bind", C],
      ["bindKey", T],
      ["curry", M],
      ["curryRight", A],
      ["flip", X],
      ["partial", D],
      ["partialRight", F],
      ["rearg", B]
    ], ye = "[object Arguments]", ue = "[object Array]", Xe = "[object AsyncFunction]", We = "[object Boolean]", bt = "[object Date]", wt = "[object DOMException]", Vt = "[object Error]", Ce = "[object Function]", qt = "[object GeneratorFunction]", it = "[object Map]", Tt = "[object Number]", Tr = "[object Null]", tt = "[object Object]", It = "[object Promise]", Gr = "[object Proxy]", sr = "[object RegExp]", R = "[object Set]", he = "[object String]", pe = "[object Symbol]", De = "[object Undefined]", Je = "[object WeakMap]", Ge = "[object WeakSet]", ke = "[object ArrayBuffer]", xe = "[object DataView]", zt = "[object Float32Array]", xt = "[object Float64Array]", Wt = "[object Int8Array]", Er = "[object Int16Array]", Qt = "[object Int32Array]", jr = "[object Uint8Array]", Kt = "[object Uint8ClampedArray]", ls = "[object Uint16Array]", us = "[object Uint32Array]", Vn = /\b__p \+= '';/g, Tn = /\b(__p \+=) '' \+/g, Ii = /(__e\(.*?\)|\b__t\)) \+\n'';/g, hs = /&(?:amp|lt|gt|quot|#39);/g, un = /[&<>"']/g, Pi = RegExp(hs.source), Do = RegExp(un.source), Ro = /<%-([\s\S]+?)%>/g, jo = /<%([\s\S]+?)%>/g, Di = /<%=([\s\S]+?)%>/g, Ri = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Vs = /^\w*$/, qe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Ue = /[\\^$.*+?()[\]{}|]/g, Zt = RegExp(Ue.source), fr = /^\s+/, zs = /\s/, Lo = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, qa = /\{\n\/\* \[wrapped with (.+)\] \*/, x = /,? & /, V = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, te = /[()=,{}\[\]\/\s]/, ae = /\\(\\)?/g, _e = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Ee = /\w*$/, Se = /^[-+]0x[0-9a-f]+$/i, rt = /^0b[01]+$/i, Qe = /^\[object .+?Constructor\]$/, gt = /^0o[0-7]+$/i, ir = /^(?:0|[1-9]\d*)$/, zn = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, pr = /($^)/, ji = /['\n\r\u2028\u2029\\]/g, kr = "\\ud800-\\udfff", f_ = "\\u0300-\\u036f", p_ = "\\ufe20-\\ufe2f", g_ = "\\u20d0-\\u20ff", $p = f_ + p_ + g_, Yp = "\\u2700-\\u27bf", Xp = "a-z\\xdf-\\xf6\\xf8-\\xff", m_ = "\\xac\\xb1\\xd7\\xf7", v_ = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", y_ = "\\u2000-\\u206f", b_ = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Gp = "A-Z\\xc0-\\xd6\\xd8-\\xde", qp = "\\ufe0e\\ufe0f", Kp = m_ + v_ + y_ + b_, ju = "['’]", w_ = "[" + kr + "]", Zp = "[" + Kp + "]", Ka = "[" + $p + "]", Jp = "\\d+", x_ = "[" + Yp + "]", Qp = "[" + Xp + "]", eg = "[^" + kr + Kp + Jp + Yp + Xp + Gp + "]", Lu = "\\ud83c[\\udffb-\\udfff]", __ = "(?:" + Ka + "|" + Lu + ")", tg = "[^" + kr + "]", Fu = "(?:\\ud83c[\\udde6-\\uddff]){2}", Nu = "[\\ud800-\\udbff][\\udc00-\\udfff]", Li = "[" + Gp + "]", rg = "\\u200d", ng = "(?:" + Qp + "|" + eg + ")", S_ = "(?:" + Li + "|" + eg + ")", sg = "(?:" + ju + "(?:d|ll|m|re|s|t|ve))?", ig = "(?:" + ju + "(?:D|LL|M|RE|S|T|VE))?", og = __ + "?", ag = "[" + qp + "]?", C_ = "(?:" + rg + "(?:" + [tg, Fu, Nu].join("|") + ")" + ag + og + ")*", T_ = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", E_ = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", cg = ag + og + C_, k_ = "(?:" + [x_, Fu, Nu].join("|") + ")" + cg, O_ = "(?:" + [tg + Ka + "?", Ka, Fu, Nu, w_].join("|") + ")", M_ = RegExp(ju, "g"), A_ = RegExp(Ka, "g"), Bu = RegExp(Lu + "(?=" + Lu + ")|" + O_ + cg, "g"), I_ = RegExp([
      Li + "?" + Qp + "+" + sg + "(?=" + [Zp, Li, "$"].join("|") + ")",
      S_ + "+" + ig + "(?=" + [Zp, Li + ng, "$"].join("|") + ")",
      Li + "?" + ng + "+" + sg,
      Li + "+" + ig,
      E_,
      T_,
      Jp,
      k_
    ].join("|"), "g"), P_ = RegExp("[" + rg + kr + $p + qp + "]"), D_ = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, R_ = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], j_ = -1, ft = {};
    ft[zt] = ft[xt] = ft[Wt] = ft[Er] = ft[Qt] = ft[jr] = ft[Kt] = ft[ls] = ft[us] = !0, ft[ye] = ft[ue] = ft[ke] = ft[We] = ft[xe] = ft[bt] = ft[Vt] = ft[Ce] = ft[it] = ft[Tt] = ft[tt] = ft[sr] = ft[R] = ft[he] = ft[Je] = !1;
    var dt = {};
    dt[ye] = dt[ue] = dt[ke] = dt[xe] = dt[We] = dt[bt] = dt[zt] = dt[xt] = dt[Wt] = dt[Er] = dt[Qt] = dt[it] = dt[Tt] = dt[tt] = dt[sr] = dt[R] = dt[he] = dt[pe] = dt[jr] = dt[Kt] = dt[ls] = dt[us] = !0, dt[Vt] = dt[Ce] = dt[Je] = !1;
    var L_ = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, F_ = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, N_ = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, B_ = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, V_ = parseFloat, z_ = parseInt, lg = typeof Jo == "object" && Jo && Jo.Object === Object && Jo, W_ = typeof self == "object" && self && self.Object === Object && self, er = lg || W_ || Function("return this")(), Vu = e && !e.nodeType && e, Ws = Vu && !0 && r && !r.nodeType && r, ug = Ws && Ws.exports === Vu, zu = ug && lg.process, qr = function() {
      try {
        var z = Ws && Ws.require && Ws.require("util").types;
        return z || zu && zu.binding && zu.binding("util");
      } catch {
      }
    }(), hg = qr && qr.isArrayBuffer, dg = qr && qr.isDate, fg = qr && qr.isMap, pg = qr && qr.isRegExp, gg = qr && qr.isSet, mg = qr && qr.isTypedArray;
    function Lr(z, J, q) {
      switch (q.length) {
        case 0:
          return z.call(J);
        case 1:
          return z.call(J, q[0]);
        case 2:
          return z.call(J, q[0], q[1]);
        case 3:
          return z.call(J, q[0], q[1], q[2]);
      }
      return z.apply(J, q);
    }
    function H_(z, J, q, we) {
      for (var Re = -1, nt = z == null ? 0 : z.length; ++Re < nt; ) {
        var Ht = z[Re];
        J(we, Ht, q(Ht), z);
      }
      return we;
    }
    function Kr(z, J) {
      for (var q = -1, we = z == null ? 0 : z.length; ++q < we && J(z[q], q, z) !== !1; )
        ;
      return z;
    }
    function U_(z, J) {
      for (var q = z == null ? 0 : z.length; q-- && J(z[q], q, z) !== !1; )
        ;
      return z;
    }
    function vg(z, J) {
      for (var q = -1, we = z == null ? 0 : z.length; ++q < we; )
        if (!J(z[q], q, z))
          return !1;
      return !0;
    }
    function ds(z, J) {
      for (var q = -1, we = z == null ? 0 : z.length, Re = 0, nt = []; ++q < we; ) {
        var Ht = z[q];
        J(Ht, q, z) && (nt[Re++] = Ht);
      }
      return nt;
    }
    function Za(z, J) {
      var q = z == null ? 0 : z.length;
      return !!q && Fi(z, J, 0) > -1;
    }
    function Wu(z, J, q) {
      for (var we = -1, Re = z == null ? 0 : z.length; ++we < Re; )
        if (q(J, z[we]))
          return !0;
      return !1;
    }
    function mt(z, J) {
      for (var q = -1, we = z == null ? 0 : z.length, Re = Array(we); ++q < we; )
        Re[q] = J(z[q], q, z);
      return Re;
    }
    function fs(z, J) {
      for (var q = -1, we = J.length, Re = z.length; ++q < we; )
        z[Re + q] = J[q];
      return z;
    }
    function Hu(z, J, q, we) {
      var Re = -1, nt = z == null ? 0 : z.length;
      for (we && nt && (q = z[++Re]); ++Re < nt; )
        q = J(q, z[Re], Re, z);
      return q;
    }
    function $_(z, J, q, we) {
      var Re = z == null ? 0 : z.length;
      for (we && Re && (q = z[--Re]); Re--; )
        q = J(q, z[Re], Re, z);
      return q;
    }
    function Uu(z, J) {
      for (var q = -1, we = z == null ? 0 : z.length; ++q < we; )
        if (J(z[q], q, z))
          return !0;
      return !1;
    }
    var Y_ = $u("length");
    function X_(z) {
      return z.split("");
    }
    function G_(z) {
      return z.match(V) || [];
    }
    function yg(z, J, q) {
      var we;
      return q(z, function(Re, nt, Ht) {
        if (J(Re, nt, Ht))
          return we = nt, !1;
      }), we;
    }
    function Ja(z, J, q, we) {
      for (var Re = z.length, nt = q + (we ? 1 : -1); we ? nt-- : ++nt < Re; )
        if (J(z[nt], nt, z))
          return nt;
      return -1;
    }
    function Fi(z, J, q) {
      return J === J ? oS(z, J, q) : Ja(z, bg, q);
    }
    function q_(z, J, q, we) {
      for (var Re = q - 1, nt = z.length; ++Re < nt; )
        if (we(z[Re], J))
          return Re;
      return -1;
    }
    function bg(z) {
      return z !== z;
    }
    function wg(z, J) {
      var q = z == null ? 0 : z.length;
      return q ? Xu(z, J) / q : I;
    }
    function $u(z) {
      return function(J) {
        return J == null ? t : J[z];
      };
    }
    function Yu(z) {
      return function(J) {
        return z == null ? t : z[J];
      };
    }
    function xg(z, J, q, we, Re) {
      return Re(z, function(nt, Ht, ut) {
        q = we ? (we = !1, nt) : J(q, nt, Ht, ut);
      }), q;
    }
    function K_(z, J) {
      var q = z.length;
      for (z.sort(J); q--; )
        z[q] = z[q].value;
      return z;
    }
    function Xu(z, J) {
      for (var q, we = -1, Re = z.length; ++we < Re; ) {
        var nt = J(z[we]);
        nt !== t && (q = q === t ? nt : q + nt);
      }
      return q;
    }
    function Gu(z, J) {
      for (var q = -1, we = Array(z); ++q < z; )
        we[q] = J(q);
      return we;
    }
    function Z_(z, J) {
      return mt(J, function(q) {
        return [q, z[q]];
      });
    }
    function _g(z) {
      return z && z.slice(0, Eg(z) + 1).replace(fr, "");
    }
    function Fr(z) {
      return function(J) {
        return z(J);
      };
    }
    function qu(z, J) {
      return mt(J, function(q) {
        return z[q];
      });
    }
    function Fo(z, J) {
      return z.has(J);
    }
    function Sg(z, J) {
      for (var q = -1, we = z.length; ++q < we && Fi(J, z[q], 0) > -1; )
        ;
      return q;
    }
    function Cg(z, J) {
      for (var q = z.length; q-- && Fi(J, z[q], 0) > -1; )
        ;
      return q;
    }
    function J_(z, J) {
      for (var q = z.length, we = 0; q--; )
        z[q] === J && ++we;
      return we;
    }
    var Q_ = Yu(L_), eS = Yu(F_);
    function tS(z) {
      return "\\" + B_[z];
    }
    function rS(z, J) {
      return z == null ? t : z[J];
    }
    function Ni(z) {
      return P_.test(z);
    }
    function nS(z) {
      return D_.test(z);
    }
    function sS(z) {
      for (var J, q = []; !(J = z.next()).done; )
        q.push(J.value);
      return q;
    }
    function Ku(z) {
      var J = -1, q = Array(z.size);
      return z.forEach(function(we, Re) {
        q[++J] = [Re, we];
      }), q;
    }
    function Tg(z, J) {
      return function(q) {
        return z(J(q));
      };
    }
    function ps(z, J) {
      for (var q = -1, we = z.length, Re = 0, nt = []; ++q < we; ) {
        var Ht = z[q];
        (Ht === J || Ht === d) && (z[q] = d, nt[Re++] = q);
      }
      return nt;
    }
    function Qa(z) {
      var J = -1, q = Array(z.size);
      return z.forEach(function(we) {
        q[++J] = we;
      }), q;
    }
    function iS(z) {
      var J = -1, q = Array(z.size);
      return z.forEach(function(we) {
        q[++J] = [we, we];
      }), q;
    }
    function oS(z, J, q) {
      for (var we = q - 1, Re = z.length; ++we < Re; )
        if (z[we] === J)
          return we;
      return -1;
    }
    function aS(z, J, q) {
      for (var we = q + 1; we--; )
        if (z[we] === J)
          return we;
      return we;
    }
    function Bi(z) {
      return Ni(z) ? lS(z) : Y_(z);
    }
    function hn(z) {
      return Ni(z) ? uS(z) : X_(z);
    }
    function Eg(z) {
      for (var J = z.length; J-- && zs.test(z.charAt(J)); )
        ;
      return J;
    }
    var cS = Yu(N_);
    function lS(z) {
      for (var J = Bu.lastIndex = 0; Bu.test(z); )
        ++J;
      return J;
    }
    function uS(z) {
      return z.match(Bu) || [];
    }
    function hS(z) {
      return z.match(I_) || [];
    }
    var dS = function z(J) {
      J = J == null ? er : Vi.defaults(er.Object(), J, Vi.pick(er, R_));
      var q = J.Array, we = J.Date, Re = J.Error, nt = J.Function, Ht = J.Math, ut = J.Object, Zu = J.RegExp, fS = J.String, Zr = J.TypeError, ec = q.prototype, pS = nt.prototype, zi = ut.prototype, tc = J["__core-js_shared__"], rc = pS.toString, ct = zi.hasOwnProperty, gS = 0, kg = function() {
        var o = /[^.]+$/.exec(tc && tc.keys && tc.keys.IE_PROTO || "");
        return o ? "Symbol(src)_1." + o : "";
      }(), nc = zi.toString, mS = rc.call(ut), vS = er._, yS = Zu(
        "^" + rc.call(ct).replace(Ue, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), sc = ug ? J.Buffer : t, gs = J.Symbol, ic = J.Uint8Array, Og = sc ? sc.allocUnsafe : t, oc = Tg(ut.getPrototypeOf, ut), Mg = ut.create, Ag = zi.propertyIsEnumerable, ac = ec.splice, Ig = gs ? gs.isConcatSpreadable : t, No = gs ? gs.iterator : t, Hs = gs ? gs.toStringTag : t, cc = function() {
        try {
          var o = Gs(ut, "defineProperty");
          return o({}, "", {}), o;
        } catch {
        }
      }(), bS = J.clearTimeout !== er.clearTimeout && J.clearTimeout, wS = we && we.now !== er.Date.now && we.now, xS = J.setTimeout !== er.setTimeout && J.setTimeout, lc = Ht.ceil, uc = Ht.floor, Ju = ut.getOwnPropertySymbols, _S = sc ? sc.isBuffer : t, Pg = J.isFinite, SS = ec.join, CS = Tg(ut.keys, ut), Ut = Ht.max, or = Ht.min, TS = we.now, ES = J.parseInt, Dg = Ht.random, kS = ec.reverse, Qu = Gs(J, "DataView"), Bo = Gs(J, "Map"), eh = Gs(J, "Promise"), Wi = Gs(J, "Set"), Vo = Gs(J, "WeakMap"), zo = Gs(ut, "create"), hc = Vo && new Vo(), Hi = {}, OS = qs(Qu), MS = qs(Bo), AS = qs(eh), IS = qs(Wi), PS = qs(Vo), dc = gs ? gs.prototype : t, Wo = dc ? dc.valueOf : t, Rg = dc ? dc.toString : t;
      function E(o) {
        if (Et(o) && !je(o) && !(o instanceof $e)) {
          if (o instanceof Jr)
            return o;
          if (ct.call(o, "__wrapped__"))
            return jm(o);
        }
        return new Jr(o);
      }
      var Ui = /* @__PURE__ */ function() {
        function o() {
        }
        return function(l) {
          if (!_t(l))
            return {};
          if (Mg)
            return Mg(l);
          o.prototype = l;
          var f = new o();
          return o.prototype = t, f;
        };
      }();
      function fc() {
      }
      function Jr(o, l) {
        this.__wrapped__ = o, this.__actions__ = [], this.__chain__ = !!l, this.__index__ = 0, this.__values__ = t;
      }
      E.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Ro,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: jo,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: Di,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: E
        }
      }, E.prototype = fc.prototype, E.prototype.constructor = E, Jr.prototype = Ui(fc.prototype), Jr.prototype.constructor = Jr;
      function $e(o) {
        this.__wrapped__ = o, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = W, this.__views__ = [];
      }
      function DS() {
        var o = new $e(this.__wrapped__);
        return o.__actions__ = Or(this.__actions__), o.__dir__ = this.__dir__, o.__filtered__ = this.__filtered__, o.__iteratees__ = Or(this.__iteratees__), o.__takeCount__ = this.__takeCount__, o.__views__ = Or(this.__views__), o;
      }
      function RS() {
        if (this.__filtered__) {
          var o = new $e(this);
          o.__dir__ = -1, o.__filtered__ = !0;
        } else
          o = this.clone(), o.__dir__ *= -1;
        return o;
      }
      function jS() {
        var o = this.__wrapped__.value(), l = this.__dir__, f = je(o), y = l < 0, S = f ? o.length : 0, O = XC(0, S, this.__views__), P = O.start, j = O.end, H = j - P, ee = y ? j : P - 1, re = this.__iteratees__, se = re.length, me = 0, Te = or(H, this.__takeCount__);
        if (!f || !y && S == H && Te == H)
          return sm(o, this.__actions__);
        var Me = [];
        e:
          for (; H-- && me < Te; ) {
            ee += l;
            for (var Ve = -1, Ae = o[ee]; ++Ve < se; ) {
              var He = re[Ve], Ke = He.iteratee, Vr = He.type, vr = Ke(Ae);
              if (Vr == ve)
                Ae = vr;
              else if (!vr) {
                if (Vr == oe)
                  continue e;
                break e;
              }
            }
            Me[me++] = Ae;
          }
        return Me;
      }
      $e.prototype = Ui(fc.prototype), $e.prototype.constructor = $e;
      function Us(o) {
        var l = -1, f = o == null ? 0 : o.length;
        for (this.clear(); ++l < f; ) {
          var y = o[l];
          this.set(y[0], y[1]);
        }
      }
      function LS() {
        this.__data__ = zo ? zo(null) : {}, this.size = 0;
      }
      function FS(o) {
        var l = this.has(o) && delete this.__data__[o];
        return this.size -= l ? 1 : 0, l;
      }
      function NS(o) {
        var l = this.__data__;
        if (zo) {
          var f = l[o];
          return f === u ? t : f;
        }
        return ct.call(l, o) ? l[o] : t;
      }
      function BS(o) {
        var l = this.__data__;
        return zo ? l[o] !== t : ct.call(l, o);
      }
      function VS(o, l) {
        var f = this.__data__;
        return this.size += this.has(o) ? 0 : 1, f[o] = zo && l === t ? u : l, this;
      }
      Us.prototype.clear = LS, Us.prototype.delete = FS, Us.prototype.get = NS, Us.prototype.has = BS, Us.prototype.set = VS;
      function Wn(o) {
        var l = -1, f = o == null ? 0 : o.length;
        for (this.clear(); ++l < f; ) {
          var y = o[l];
          this.set(y[0], y[1]);
        }
      }
      function zS() {
        this.__data__ = [], this.size = 0;
      }
      function WS(o) {
        var l = this.__data__, f = pc(l, o);
        if (f < 0)
          return !1;
        var y = l.length - 1;
        return f == y ? l.pop() : ac.call(l, f, 1), --this.size, !0;
      }
      function HS(o) {
        var l = this.__data__, f = pc(l, o);
        return f < 0 ? t : l[f][1];
      }
      function US(o) {
        return pc(this.__data__, o) > -1;
      }
      function $S(o, l) {
        var f = this.__data__, y = pc(f, o);
        return y < 0 ? (++this.size, f.push([o, l])) : f[y][1] = l, this;
      }
      Wn.prototype.clear = zS, Wn.prototype.delete = WS, Wn.prototype.get = HS, Wn.prototype.has = US, Wn.prototype.set = $S;
      function Hn(o) {
        var l = -1, f = o == null ? 0 : o.length;
        for (this.clear(); ++l < f; ) {
          var y = o[l];
          this.set(y[0], y[1]);
        }
      }
      function YS() {
        this.size = 0, this.__data__ = {
          hash: new Us(),
          map: new (Bo || Wn)(),
          string: new Us()
        };
      }
      function XS(o) {
        var l = Ec(this, o).delete(o);
        return this.size -= l ? 1 : 0, l;
      }
      function GS(o) {
        return Ec(this, o).get(o);
      }
      function qS(o) {
        return Ec(this, o).has(o);
      }
      function KS(o, l) {
        var f = Ec(this, o), y = f.size;
        return f.set(o, l), this.size += f.size == y ? 0 : 1, this;
      }
      Hn.prototype.clear = YS, Hn.prototype.delete = XS, Hn.prototype.get = GS, Hn.prototype.has = qS, Hn.prototype.set = KS;
      function $s(o) {
        var l = -1, f = o == null ? 0 : o.length;
        for (this.__data__ = new Hn(); ++l < f; )
          this.add(o[l]);
      }
      function ZS(o) {
        return this.__data__.set(o, u), this;
      }
      function JS(o) {
        return this.__data__.has(o);
      }
      $s.prototype.add = $s.prototype.push = ZS, $s.prototype.has = JS;
      function dn(o) {
        var l = this.__data__ = new Wn(o);
        this.size = l.size;
      }
      function QS() {
        this.__data__ = new Wn(), this.size = 0;
      }
      function eC(o) {
        var l = this.__data__, f = l.delete(o);
        return this.size = l.size, f;
      }
      function tC(o) {
        return this.__data__.get(o);
      }
      function rC(o) {
        return this.__data__.has(o);
      }
      function nC(o, l) {
        var f = this.__data__;
        if (f instanceof Wn) {
          var y = f.__data__;
          if (!Bo || y.length < s - 1)
            return y.push([o, l]), this.size = ++f.size, this;
          f = this.__data__ = new Hn(y);
        }
        return f.set(o, l), this.size = f.size, this;
      }
      dn.prototype.clear = QS, dn.prototype.delete = eC, dn.prototype.get = tC, dn.prototype.has = rC, dn.prototype.set = nC;
      function jg(o, l) {
        var f = je(o), y = !f && Ks(o), S = !f && !y && ws(o), O = !f && !y && !S && Gi(o), P = f || y || S || O, j = P ? Gu(o.length, fS) : [], H = j.length;
        for (var ee in o)
          (l || ct.call(o, ee)) && !(P && // Safari 9 has enumerable `arguments.length` in strict mode.
          (ee == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          S && (ee == "offset" || ee == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          O && (ee == "buffer" || ee == "byteLength" || ee == "byteOffset") || // Skip index properties.
          Xn(ee, H))) && j.push(ee);
        return j;
      }
      function Lg(o) {
        var l = o.length;
        return l ? o[hh(0, l - 1)] : t;
      }
      function sC(o, l) {
        return kc(Or(o), Ys(l, 0, o.length));
      }
      function iC(o) {
        return kc(Or(o));
      }
      function th(o, l, f) {
        (f !== t && !fn(o[l], f) || f === t && !(l in o)) && Un(o, l, f);
      }
      function Ho(o, l, f) {
        var y = o[l];
        (!(ct.call(o, l) && fn(y, f)) || f === t && !(l in o)) && Un(o, l, f);
      }
      function pc(o, l) {
        for (var f = o.length; f--; )
          if (fn(o[f][0], l))
            return f;
        return -1;
      }
      function oC(o, l, f, y) {
        return ms(o, function(S, O, P) {
          l(y, S, f(S), P);
        }), y;
      }
      function Fg(o, l) {
        return o && kn(l, Jt(l), o);
      }
      function aC(o, l) {
        return o && kn(l, Ar(l), o);
      }
      function Un(o, l, f) {
        l == "__proto__" && cc ? cc(o, l, {
          configurable: !0,
          enumerable: !0,
          value: f,
          writable: !0
        }) : o[l] = f;
      }
      function rh(o, l) {
        for (var f = -1, y = l.length, S = q(y), O = o == null; ++f < y; )
          S[f] = O ? t : Lh(o, l[f]);
        return S;
      }
      function Ys(o, l, f) {
        return o === o && (f !== t && (o = o <= f ? o : f), l !== t && (o = o >= l ? o : l)), o;
      }
      function Qr(o, l, f, y, S, O) {
        var P, j = l & p, H = l & g, ee = l & v;
        if (f && (P = S ? f(o, y, S, O) : f(o)), P !== t)
          return P;
        if (!_t(o))
          return o;
        var re = je(o);
        if (re) {
          if (P = qC(o), !j)
            return Or(o, P);
        } else {
          var se = ar(o), me = se == Ce || se == qt;
          if (ws(o))
            return am(o, j);
          if (se == tt || se == ye || me && !S) {
            if (P = H || me ? {} : Em(o), !j)
              return H ? NC(o, aC(P, o)) : FC(o, Fg(P, o));
          } else {
            if (!dt[se])
              return S ? o : {};
            P = KC(o, se, j);
          }
        }
        O || (O = new dn());
        var Te = O.get(o);
        if (Te)
          return Te;
        O.set(o, P), tv(o) ? o.forEach(function(Ae) {
          P.add(Qr(Ae, l, f, Ae, o, O));
        }) : Qm(o) && o.forEach(function(Ae, He) {
          P.set(He, Qr(Ae, l, f, He, o, O));
        });
        var Me = ee ? H ? _h : xh : H ? Ar : Jt, Ve = re ? t : Me(o);
        return Kr(Ve || o, function(Ae, He) {
          Ve && (He = Ae, Ae = o[He]), Ho(P, He, Qr(Ae, l, f, He, o, O));
        }), P;
      }
      function cC(o) {
        var l = Jt(o);
        return function(f) {
          return Ng(f, o, l);
        };
      }
      function Ng(o, l, f) {
        var y = f.length;
        if (o == null)
          return !y;
        for (o = ut(o); y--; ) {
          var S = f[y], O = l[S], P = o[S];
          if (P === t && !(S in o) || !O(P))
            return !1;
        }
        return !0;
      }
      function Bg(o, l, f) {
        if (typeof o != "function")
          throw new Zr(a);
        return Ko(function() {
          o.apply(t, f);
        }, l);
      }
      function Uo(o, l, f, y) {
        var S = -1, O = Za, P = !0, j = o.length, H = [], ee = l.length;
        if (!j)
          return H;
        f && (l = mt(l, Fr(f))), y ? (O = Wu, P = !1) : l.length >= s && (O = Fo, P = !1, l = new $s(l));
        e:
          for (; ++S < j; ) {
            var re = o[S], se = f == null ? re : f(re);
            if (re = y || re !== 0 ? re : 0, P && se === se) {
              for (var me = ee; me--; )
                if (l[me] === se)
                  continue e;
              H.push(re);
            } else O(l, se, y) || H.push(re);
          }
        return H;
      }
      var ms = dm(En), Vg = dm(sh, !0);
      function lC(o, l) {
        var f = !0;
        return ms(o, function(y, S, O) {
          return f = !!l(y, S, O), f;
        }), f;
      }
      function gc(o, l, f) {
        for (var y = -1, S = o.length; ++y < S; ) {
          var O = o[y], P = l(O);
          if (P != null && (j === t ? P === P && !Br(P) : f(P, j)))
            var j = P, H = O;
        }
        return H;
      }
      function uC(o, l, f, y) {
        var S = o.length;
        for (f = Le(f), f < 0 && (f = -f > S ? 0 : S + f), y = y === t || y > S ? S : Le(y), y < 0 && (y += S), y = f > y ? 0 : nv(y); f < y; )
          o[f++] = l;
        return o;
      }
      function zg(o, l) {
        var f = [];
        return ms(o, function(y, S, O) {
          l(y, S, O) && f.push(y);
        }), f;
      }
      function tr(o, l, f, y, S) {
        var O = -1, P = o.length;
        for (f || (f = JC), S || (S = []); ++O < P; ) {
          var j = o[O];
          l > 0 && f(j) ? l > 1 ? tr(j, l - 1, f, y, S) : fs(S, j) : y || (S[S.length] = j);
        }
        return S;
      }
      var nh = fm(), Wg = fm(!0);
      function En(o, l) {
        return o && nh(o, l, Jt);
      }
      function sh(o, l) {
        return o && Wg(o, l, Jt);
      }
      function mc(o, l) {
        return ds(l, function(f) {
          return Gn(o[f]);
        });
      }
      function Xs(o, l) {
        l = ys(l, o);
        for (var f = 0, y = l.length; o != null && f < y; )
          o = o[On(l[f++])];
        return f && f == y ? o : t;
      }
      function Hg(o, l, f) {
        var y = l(o);
        return je(o) ? y : fs(y, f(o));
      }
      function gr(o) {
        return o == null ? o === t ? De : Tr : Hs && Hs in ut(o) ? YC(o) : iT(o);
      }
      function ih(o, l) {
        return o > l;
      }
      function hC(o, l) {
        return o != null && ct.call(o, l);
      }
      function dC(o, l) {
        return o != null && l in ut(o);
      }
      function fC(o, l, f) {
        return o >= or(l, f) && o < Ut(l, f);
      }
      function oh(o, l, f) {
        for (var y = f ? Wu : Za, S = o[0].length, O = o.length, P = O, j = q(O), H = 1 / 0, ee = []; P--; ) {
          var re = o[P];
          P && l && (re = mt(re, Fr(l))), H = or(re.length, H), j[P] = !f && (l || S >= 120 && re.length >= 120) ? new $s(P && re) : t;
        }
        re = o[0];
        var se = -1, me = j[0];
        e:
          for (; ++se < S && ee.length < H; ) {
            var Te = re[se], Me = l ? l(Te) : Te;
            if (Te = f || Te !== 0 ? Te : 0, !(me ? Fo(me, Me) : y(ee, Me, f))) {
              for (P = O; --P; ) {
                var Ve = j[P];
                if (!(Ve ? Fo(Ve, Me) : y(o[P], Me, f)))
                  continue e;
              }
              me && me.push(Me), ee.push(Te);
            }
          }
        return ee;
      }
      function pC(o, l, f, y) {
        return En(o, function(S, O, P) {
          l(y, f(S), O, P);
        }), y;
      }
      function $o(o, l, f) {
        l = ys(l, o), o = Am(o, l);
        var y = o == null ? o : o[On(tn(l))];
        return y == null ? t : Lr(y, o, f);
      }
      function Ug(o) {
        return Et(o) && gr(o) == ye;
      }
      function gC(o) {
        return Et(o) && gr(o) == ke;
      }
      function mC(o) {
        return Et(o) && gr(o) == bt;
      }
      function Yo(o, l, f, y, S) {
        return o === l ? !0 : o == null || l == null || !Et(o) && !Et(l) ? o !== o && l !== l : vC(o, l, f, y, Yo, S);
      }
      function vC(o, l, f, y, S, O) {
        var P = je(o), j = je(l), H = P ? ue : ar(o), ee = j ? ue : ar(l);
        H = H == ye ? tt : H, ee = ee == ye ? tt : ee;
        var re = H == tt, se = ee == tt, me = H == ee;
        if (me && ws(o)) {
          if (!ws(l))
            return !1;
          P = !0, re = !1;
        }
        if (me && !re)
          return O || (O = new dn()), P || Gi(o) ? Sm(o, l, f, y, S, O) : UC(o, l, H, f, y, S, O);
        if (!(f & b)) {
          var Te = re && ct.call(o, "__wrapped__"), Me = se && ct.call(l, "__wrapped__");
          if (Te || Me) {
            var Ve = Te ? o.value() : o, Ae = Me ? l.value() : l;
            return O || (O = new dn()), S(Ve, Ae, f, y, O);
          }
        }
        return me ? (O || (O = new dn()), $C(o, l, f, y, S, O)) : !1;
      }
      function yC(o) {
        return Et(o) && ar(o) == it;
      }
      function ah(o, l, f, y) {
        var S = f.length, O = S, P = !y;
        if (o == null)
          return !O;
        for (o = ut(o); S--; ) {
          var j = f[S];
          if (P && j[2] ? j[1] !== o[j[0]] : !(j[0] in o))
            return !1;
        }
        for (; ++S < O; ) {
          j = f[S];
          var H = j[0], ee = o[H], re = j[1];
          if (P && j[2]) {
            if (ee === t && !(H in o))
              return !1;
          } else {
            var se = new dn();
            if (y)
              var me = y(ee, re, H, o, l, se);
            if (!(me === t ? Yo(re, ee, b | _, y, se) : me))
              return !1;
          }
        }
        return !0;
      }
      function $g(o) {
        if (!_t(o) || eT(o))
          return !1;
        var l = Gn(o) ? yS : Qe;
        return l.test(qs(o));
      }
      function bC(o) {
        return Et(o) && gr(o) == sr;
      }
      function wC(o) {
        return Et(o) && ar(o) == R;
      }
      function xC(o) {
        return Et(o) && Dc(o.length) && !!ft[gr(o)];
      }
      function Yg(o) {
        return typeof o == "function" ? o : o == null ? Ir : typeof o == "object" ? je(o) ? qg(o[0], o[1]) : Gg(o) : pv(o);
      }
      function ch(o) {
        if (!qo(o))
          return CS(o);
        var l = [];
        for (var f in ut(o))
          ct.call(o, f) && f != "constructor" && l.push(f);
        return l;
      }
      function _C(o) {
        if (!_t(o))
          return sT(o);
        var l = qo(o), f = [];
        for (var y in o)
          y == "constructor" && (l || !ct.call(o, y)) || f.push(y);
        return f;
      }
      function lh(o, l) {
        return o < l;
      }
      function Xg(o, l) {
        var f = -1, y = Mr(o) ? q(o.length) : [];
        return ms(o, function(S, O, P) {
          y[++f] = l(S, O, P);
        }), y;
      }
      function Gg(o) {
        var l = Ch(o);
        return l.length == 1 && l[0][2] ? Om(l[0][0], l[0][1]) : function(f) {
          return f === o || ah(f, o, l);
        };
      }
      function qg(o, l) {
        return Eh(o) && km(l) ? Om(On(o), l) : function(f) {
          var y = Lh(f, o);
          return y === t && y === l ? Fh(f, o) : Yo(l, y, b | _);
        };
      }
      function vc(o, l, f, y, S) {
        o !== l && nh(l, function(O, P) {
          if (S || (S = new dn()), _t(O))
            SC(o, l, P, f, vc, y, S);
          else {
            var j = y ? y(Oh(o, P), O, P + "", o, l, S) : t;
            j === t && (j = O), th(o, P, j);
          }
        }, Ar);
      }
      function SC(o, l, f, y, S, O, P) {
        var j = Oh(o, f), H = Oh(l, f), ee = P.get(H);
        if (ee) {
          th(o, f, ee);
          return;
        }
        var re = O ? O(j, H, f + "", o, l, P) : t, se = re === t;
        if (se) {
          var me = je(H), Te = !me && ws(H), Me = !me && !Te && Gi(H);
          re = H, me || Te || Me ? je(j) ? re = j : Pt(j) ? re = Or(j) : Te ? (se = !1, re = am(H, !0)) : Me ? (se = !1, re = cm(H, !0)) : re = [] : Zo(H) || Ks(H) ? (re = j, Ks(j) ? re = sv(j) : (!_t(j) || Gn(j)) && (re = Em(H))) : se = !1;
        }
        se && (P.set(H, re), S(re, H, y, O, P), P.delete(H)), th(o, f, re);
      }
      function Kg(o, l) {
        var f = o.length;
        if (f)
          return l += l < 0 ? f : 0, Xn(l, f) ? o[l] : t;
      }
      function Zg(o, l, f) {
        l.length ? l = mt(l, function(O) {
          return je(O) ? function(P) {
            return Xs(P, O.length === 1 ? O[0] : O);
          } : O;
        }) : l = [Ir];
        var y = -1;
        l = mt(l, Fr(Oe()));
        var S = Xg(o, function(O, P, j) {
          var H = mt(l, function(ee) {
            return ee(O);
          });
          return { criteria: H, index: ++y, value: O };
        });
        return K_(S, function(O, P) {
          return LC(O, P, f);
        });
      }
      function CC(o, l) {
        return Jg(o, l, function(f, y) {
          return Fh(o, y);
        });
      }
      function Jg(o, l, f) {
        for (var y = -1, S = l.length, O = {}; ++y < S; ) {
          var P = l[y], j = Xs(o, P);
          f(j, P) && Xo(O, ys(P, o), j);
        }
        return O;
      }
      function TC(o) {
        return function(l) {
          return Xs(l, o);
        };
      }
      function uh(o, l, f, y) {
        var S = y ? q_ : Fi, O = -1, P = l.length, j = o;
        for (o === l && (l = Or(l)), f && (j = mt(o, Fr(f))); ++O < P; )
          for (var H = 0, ee = l[O], re = f ? f(ee) : ee; (H = S(j, re, H, y)) > -1; )
            j !== o && ac.call(j, H, 1), ac.call(o, H, 1);
        return o;
      }
      function Qg(o, l) {
        for (var f = o ? l.length : 0, y = f - 1; f--; ) {
          var S = l[f];
          if (f == y || S !== O) {
            var O = S;
            Xn(S) ? ac.call(o, S, 1) : ph(o, S);
          }
        }
        return o;
      }
      function hh(o, l) {
        return o + uc(Dg() * (l - o + 1));
      }
      function EC(o, l, f, y) {
        for (var S = -1, O = Ut(lc((l - o) / (f || 1)), 0), P = q(O); O--; )
          P[y ? O : ++S] = o, o += f;
        return P;
      }
      function dh(o, l) {
        var f = "";
        if (!o || l < 1 || l > de)
          return f;
        do
          l % 2 && (f += o), l = uc(l / 2), l && (o += o);
        while (l);
        return f;
      }
      function ze(o, l) {
        return Mh(Mm(o, l, Ir), o + "");
      }
      function kC(o) {
        return Lg(qi(o));
      }
      function OC(o, l) {
        var f = qi(o);
        return kc(f, Ys(l, 0, f.length));
      }
      function Xo(o, l, f, y) {
        if (!_t(o))
          return o;
        l = ys(l, o);
        for (var S = -1, O = l.length, P = O - 1, j = o; j != null && ++S < O; ) {
          var H = On(l[S]), ee = f;
          if (H === "__proto__" || H === "constructor" || H === "prototype")
            return o;
          if (S != P) {
            var re = j[H];
            ee = y ? y(re, H, j) : t, ee === t && (ee = _t(re) ? re : Xn(l[S + 1]) ? [] : {});
          }
          Ho(j, H, ee), j = j[H];
        }
        return o;
      }
      var em = hc ? function(o, l) {
        return hc.set(o, l), o;
      } : Ir, MC = cc ? function(o, l) {
        return cc(o, "toString", {
          configurable: !0,
          enumerable: !1,
          value: Bh(l),
          writable: !0
        });
      } : Ir;
      function AC(o) {
        return kc(qi(o));
      }
      function en(o, l, f) {
        var y = -1, S = o.length;
        l < 0 && (l = -l > S ? 0 : S + l), f = f > S ? S : f, f < 0 && (f += S), S = l > f ? 0 : f - l >>> 0, l >>>= 0;
        for (var O = q(S); ++y < S; )
          O[y] = o[y + l];
        return O;
      }
      function IC(o, l) {
        var f;
        return ms(o, function(y, S, O) {
          return f = l(y, S, O), !f;
        }), !!f;
      }
      function yc(o, l, f) {
        var y = 0, S = o == null ? y : o.length;
        if (typeof l == "number" && l === l && S <= fe) {
          for (; y < S; ) {
            var O = y + S >>> 1, P = o[O];
            P !== null && !Br(P) && (f ? P <= l : P < l) ? y = O + 1 : S = O;
          }
          return S;
        }
        return fh(o, l, Ir, f);
      }
      function fh(o, l, f, y) {
        var S = 0, O = o == null ? 0 : o.length;
        if (O === 0)
          return 0;
        l = f(l);
        for (var P = l !== l, j = l === null, H = Br(l), ee = l === t; S < O; ) {
          var re = uc((S + O) / 2), se = f(o[re]), me = se !== t, Te = se === null, Me = se === se, Ve = Br(se);
          if (P)
            var Ae = y || Me;
          else ee ? Ae = Me && (y || me) : j ? Ae = Me && me && (y || !Te) : H ? Ae = Me && me && !Te && (y || !Ve) : Te || Ve ? Ae = !1 : Ae = y ? se <= l : se < l;
          Ae ? S = re + 1 : O = re;
        }
        return or(O, ce);
      }
      function tm(o, l) {
        for (var f = -1, y = o.length, S = 0, O = []; ++f < y; ) {
          var P = o[f], j = l ? l(P) : P;
          if (!f || !fn(j, H)) {
            var H = j;
            O[S++] = P === 0 ? 0 : P;
          }
        }
        return O;
      }
      function rm(o) {
        return typeof o == "number" ? o : Br(o) ? I : +o;
      }
      function Nr(o) {
        if (typeof o == "string")
          return o;
        if (je(o))
          return mt(o, Nr) + "";
        if (Br(o))
          return Rg ? Rg.call(o) : "";
        var l = o + "";
        return l == "0" && 1 / o == -1 / 0 ? "-0" : l;
      }
      function vs(o, l, f) {
        var y = -1, S = Za, O = o.length, P = !0, j = [], H = j;
        if (f)
          P = !1, S = Wu;
        else if (O >= s) {
          var ee = l ? null : WC(o);
          if (ee)
            return Qa(ee);
          P = !1, S = Fo, H = new $s();
        } else
          H = l ? [] : j;
        e:
          for (; ++y < O; ) {
            var re = o[y], se = l ? l(re) : re;
            if (re = f || re !== 0 ? re : 0, P && se === se) {
              for (var me = H.length; me--; )
                if (H[me] === se)
                  continue e;
              l && H.push(se), j.push(re);
            } else S(H, se, f) || (H !== j && H.push(se), j.push(re));
          }
        return j;
      }
      function ph(o, l) {
        return l = ys(l, o), o = Am(o, l), o == null || delete o[On(tn(l))];
      }
      function nm(o, l, f, y) {
        return Xo(o, l, f(Xs(o, l)), y);
      }
      function bc(o, l, f, y) {
        for (var S = o.length, O = y ? S : -1; (y ? O-- : ++O < S) && l(o[O], O, o); )
          ;
        return f ? en(o, y ? 0 : O, y ? O + 1 : S) : en(o, y ? O + 1 : 0, y ? S : O);
      }
      function sm(o, l) {
        var f = o;
        return f instanceof $e && (f = f.value()), Hu(l, function(y, S) {
          return S.func.apply(S.thisArg, fs([y], S.args));
        }, f);
      }
      function gh(o, l, f) {
        var y = o.length;
        if (y < 2)
          return y ? vs(o[0]) : [];
        for (var S = -1, O = q(y); ++S < y; )
          for (var P = o[S], j = -1; ++j < y; )
            j != S && (O[S] = Uo(O[S] || P, o[j], l, f));
        return vs(tr(O, 1), l, f);
      }
      function im(o, l, f) {
        for (var y = -1, S = o.length, O = l.length, P = {}; ++y < S; ) {
          var j = y < O ? l[y] : t;
          f(P, o[y], j);
        }
        return P;
      }
      function mh(o) {
        return Pt(o) ? o : [];
      }
      function vh(o) {
        return typeof o == "function" ? o : Ir;
      }
      function ys(o, l) {
        return je(o) ? o : Eh(o, l) ? [o] : Rm(ot(o));
      }
      var PC = ze;
      function bs(o, l, f) {
        var y = o.length;
        return f = f === t ? y : f, !l && f >= y ? o : en(o, l, f);
      }
      var om = bS || function(o) {
        return er.clearTimeout(o);
      };
      function am(o, l) {
        if (l)
          return o.slice();
        var f = o.length, y = Og ? Og(f) : new o.constructor(f);
        return o.copy(y), y;
      }
      function yh(o) {
        var l = new o.constructor(o.byteLength);
        return new ic(l).set(new ic(o)), l;
      }
      function DC(o, l) {
        var f = l ? yh(o.buffer) : o.buffer;
        return new o.constructor(f, o.byteOffset, o.byteLength);
      }
      function RC(o) {
        var l = new o.constructor(o.source, Ee.exec(o));
        return l.lastIndex = o.lastIndex, l;
      }
      function jC(o) {
        return Wo ? ut(Wo.call(o)) : {};
      }
      function cm(o, l) {
        var f = l ? yh(o.buffer) : o.buffer;
        return new o.constructor(f, o.byteOffset, o.length);
      }
      function lm(o, l) {
        if (o !== l) {
          var f = o !== t, y = o === null, S = o === o, O = Br(o), P = l !== t, j = l === null, H = l === l, ee = Br(l);
          if (!j && !ee && !O && o > l || O && P && H && !j && !ee || y && P && H || !f && H || !S)
            return 1;
          if (!y && !O && !ee && o < l || ee && f && S && !y && !O || j && f && S || !P && S || !H)
            return -1;
        }
        return 0;
      }
      function LC(o, l, f) {
        for (var y = -1, S = o.criteria, O = l.criteria, P = S.length, j = f.length; ++y < P; ) {
          var H = lm(S[y], O[y]);
          if (H) {
            if (y >= j)
              return H;
            var ee = f[y];
            return H * (ee == "desc" ? -1 : 1);
          }
        }
        return o.index - l.index;
      }
      function um(o, l, f, y) {
        for (var S = -1, O = o.length, P = f.length, j = -1, H = l.length, ee = Ut(O - P, 0), re = q(H + ee), se = !y; ++j < H; )
          re[j] = l[j];
        for (; ++S < P; )
          (se || S < O) && (re[f[S]] = o[S]);
        for (; ee--; )
          re[j++] = o[S++];
        return re;
      }
      function hm(o, l, f, y) {
        for (var S = -1, O = o.length, P = -1, j = f.length, H = -1, ee = l.length, re = Ut(O - j, 0), se = q(re + ee), me = !y; ++S < re; )
          se[S] = o[S];
        for (var Te = S; ++H < ee; )
          se[Te + H] = l[H];
        for (; ++P < j; )
          (me || S < O) && (se[Te + f[P]] = o[S++]);
        return se;
      }
      function Or(o, l) {
        var f = -1, y = o.length;
        for (l || (l = q(y)); ++f < y; )
          l[f] = o[f];
        return l;
      }
      function kn(o, l, f, y) {
        var S = !f;
        f || (f = {});
        for (var O = -1, P = l.length; ++O < P; ) {
          var j = l[O], H = y ? y(f[j], o[j], j, f, o) : t;
          H === t && (H = o[j]), S ? Un(f, j, H) : Ho(f, j, H);
        }
        return f;
      }
      function FC(o, l) {
        return kn(o, Th(o), l);
      }
      function NC(o, l) {
        return kn(o, Cm(o), l);
      }
      function wc(o, l) {
        return function(f, y) {
          var S = je(f) ? H_ : oC, O = l ? l() : {};
          return S(f, o, Oe(y, 2), O);
        };
      }
      function $i(o) {
        return ze(function(l, f) {
          var y = -1, S = f.length, O = S > 1 ? f[S - 1] : t, P = S > 2 ? f[2] : t;
          for (O = o.length > 3 && typeof O == "function" ? (S--, O) : t, P && mr(f[0], f[1], P) && (O = S < 3 ? t : O, S = 1), l = ut(l); ++y < S; ) {
            var j = f[y];
            j && o(l, j, y, O);
          }
          return l;
        });
      }
      function dm(o, l) {
        return function(f, y) {
          if (f == null)
            return f;
          if (!Mr(f))
            return o(f, y);
          for (var S = f.length, O = l ? S : -1, P = ut(f); (l ? O-- : ++O < S) && y(P[O], O, P) !== !1; )
            ;
          return f;
        };
      }
      function fm(o) {
        return function(l, f, y) {
          for (var S = -1, O = ut(l), P = y(l), j = P.length; j--; ) {
            var H = P[o ? j : ++S];
            if (f(O[H], H, O) === !1)
              break;
          }
          return l;
        };
      }
      function BC(o, l, f) {
        var y = l & C, S = Go(o);
        function O() {
          var P = this && this !== er && this instanceof O ? S : o;
          return P.apply(y ? f : this, arguments);
        }
        return O;
      }
      function pm(o) {
        return function(l) {
          l = ot(l);
          var f = Ni(l) ? hn(l) : t, y = f ? f[0] : l.charAt(0), S = f ? bs(f, 1).join("") : l.slice(1);
          return y[o]() + S;
        };
      }
      function Yi(o) {
        return function(l) {
          return Hu(dv(hv(l).replace(M_, "")), o, "");
        };
      }
      function Go(o) {
        return function() {
          var l = arguments;
          switch (l.length) {
            case 0:
              return new o();
            case 1:
              return new o(l[0]);
            case 2:
              return new o(l[0], l[1]);
            case 3:
              return new o(l[0], l[1], l[2]);
            case 4:
              return new o(l[0], l[1], l[2], l[3]);
            case 5:
              return new o(l[0], l[1], l[2], l[3], l[4]);
            case 6:
              return new o(l[0], l[1], l[2], l[3], l[4], l[5]);
            case 7:
              return new o(l[0], l[1], l[2], l[3], l[4], l[5], l[6]);
          }
          var f = Ui(o.prototype), y = o.apply(f, l);
          return _t(y) ? y : f;
        };
      }
      function VC(o, l, f) {
        var y = Go(o);
        function S() {
          for (var O = arguments.length, P = q(O), j = O, H = Xi(S); j--; )
            P[j] = arguments[j];
          var ee = O < 3 && P[0] !== H && P[O - 1] !== H ? [] : ps(P, H);
          if (O -= ee.length, O < f)
            return bm(
              o,
              l,
              xc,
              S.placeholder,
              t,
              P,
              ee,
              t,
              t,
              f - O
            );
          var re = this && this !== er && this instanceof S ? y : o;
          return Lr(re, this, P);
        }
        return S;
      }
      function gm(o) {
        return function(l, f, y) {
          var S = ut(l);
          if (!Mr(l)) {
            var O = Oe(f, 3);
            l = Jt(l), f = function(j) {
              return O(S[j], j, S);
            };
          }
          var P = o(l, f, y);
          return P > -1 ? S[O ? l[P] : P] : t;
        };
      }
      function mm(o) {
        return Yn(function(l) {
          var f = l.length, y = f, S = Jr.prototype.thru;
          for (o && l.reverse(); y--; ) {
            var O = l[y];
            if (typeof O != "function")
              throw new Zr(a);
            if (S && !P && Tc(O) == "wrapper")
              var P = new Jr([], !0);
          }
          for (y = P ? y : f; ++y < f; ) {
            O = l[y];
            var j = Tc(O), H = j == "wrapper" ? Sh(O) : t;
            H && kh(H[0]) && H[1] == (U | M | D | B) && !H[4].length && H[9] == 1 ? P = P[Tc(H[0])].apply(P, H[3]) : P = O.length == 1 && kh(O) ? P[j]() : P.thru(O);
          }
          return function() {
            var ee = arguments, re = ee[0];
            if (P && ee.length == 1 && je(re))
              return P.plant(re).value();
            for (var se = 0, me = f ? l[se].apply(this, ee) : re; ++se < f; )
              me = l[se].call(this, me);
            return me;
          };
        });
      }
      function xc(o, l, f, y, S, O, P, j, H, ee) {
        var re = l & U, se = l & C, me = l & T, Te = l & (M | A), Me = l & X, Ve = me ? t : Go(o);
        function Ae() {
          for (var He = arguments.length, Ke = q(He), Vr = He; Vr--; )
            Ke[Vr] = arguments[Vr];
          if (Te)
            var vr = Xi(Ae), zr = J_(Ke, vr);
          if (y && (Ke = um(Ke, y, S, Te)), O && (Ke = hm(Ke, O, P, Te)), He -= zr, Te && He < ee) {
            var Dt = ps(Ke, vr);
            return bm(
              o,
              l,
              xc,
              Ae.placeholder,
              f,
              Ke,
              Dt,
              j,
              H,
              ee - He
            );
          }
          var pn = se ? f : this, Kn = me ? pn[o] : o;
          return He = Ke.length, j ? Ke = oT(Ke, j) : Me && He > 1 && Ke.reverse(), re && H < He && (Ke.length = H), this && this !== er && this instanceof Ae && (Kn = Ve || Go(Kn)), Kn.apply(pn, Ke);
        }
        return Ae;
      }
      function vm(o, l) {
        return function(f, y) {
          return pC(f, o, l(y), {});
        };
      }
      function _c(o, l) {
        return function(f, y) {
          var S;
          if (f === t && y === t)
            return l;
          if (f !== t && (S = f), y !== t) {
            if (S === t)
              return y;
            typeof f == "string" || typeof y == "string" ? (f = Nr(f), y = Nr(y)) : (f = rm(f), y = rm(y)), S = o(f, y);
          }
          return S;
        };
      }
      function bh(o) {
        return Yn(function(l) {
          return l = mt(l, Fr(Oe())), ze(function(f) {
            var y = this;
            return o(l, function(S) {
              return Lr(S, y, f);
            });
          });
        });
      }
      function Sc(o, l) {
        l = l === t ? " " : Nr(l);
        var f = l.length;
        if (f < 2)
          return f ? dh(l, o) : l;
        var y = dh(l, lc(o / Bi(l)));
        return Ni(l) ? bs(hn(y), 0, o).join("") : y.slice(0, o);
      }
      function zC(o, l, f, y) {
        var S = l & C, O = Go(o);
        function P() {
          for (var j = -1, H = arguments.length, ee = -1, re = y.length, se = q(re + H), me = this && this !== er && this instanceof P ? O : o; ++ee < re; )
            se[ee] = y[ee];
          for (; H--; )
            se[ee++] = arguments[++j];
          return Lr(me, S ? f : this, se);
        }
        return P;
      }
      function ym(o) {
        return function(l, f, y) {
          return y && typeof y != "number" && mr(l, f, y) && (f = y = t), l = qn(l), f === t ? (f = l, l = 0) : f = qn(f), y = y === t ? l < f ? 1 : -1 : qn(y), EC(l, f, y, o);
        };
      }
      function Cc(o) {
        return function(l, f) {
          return typeof l == "string" && typeof f == "string" || (l = rn(l), f = rn(f)), o(l, f);
        };
      }
      function bm(o, l, f, y, S, O, P, j, H, ee) {
        var re = l & M, se = re ? P : t, me = re ? t : P, Te = re ? O : t, Me = re ? t : O;
        l |= re ? D : F, l &= ~(re ? F : D), l & k || (l &= -4);
        var Ve = [
          o,
          l,
          S,
          Te,
          se,
          Me,
          me,
          j,
          H,
          ee
        ], Ae = f.apply(t, Ve);
        return kh(o) && Im(Ae, Ve), Ae.placeholder = y, Pm(Ae, o, l);
      }
      function wh(o) {
        var l = Ht[o];
        return function(f, y) {
          if (f = rn(f), y = y == null ? 0 : or(Le(y), 292), y && Pg(f)) {
            var S = (ot(f) + "e").split("e"), O = l(S[0] + "e" + (+S[1] + y));
            return S = (ot(O) + "e").split("e"), +(S[0] + "e" + (+S[1] - y));
          }
          return l(f);
        };
      }
      var WC = Wi && 1 / Qa(new Wi([, -0]))[1] == ge ? function(o) {
        return new Wi(o);
      } : Wh;
      function wm(o) {
        return function(l) {
          var f = ar(l);
          return f == it ? Ku(l) : f == R ? iS(l) : Z_(l, o(l));
        };
      }
      function $n(o, l, f, y, S, O, P, j) {
        var H = l & T;
        if (!H && typeof o != "function")
          throw new Zr(a);
        var ee = y ? y.length : 0;
        if (ee || (l &= -97, y = S = t), P = P === t ? P : Ut(Le(P), 0), j = j === t ? j : Le(j), ee -= S ? S.length : 0, l & F) {
          var re = y, se = S;
          y = S = t;
        }
        var me = H ? t : Sh(o), Te = [
          o,
          l,
          f,
          y,
          S,
          re,
          se,
          O,
          P,
          j
        ];
        if (me && nT(Te, me), o = Te[0], l = Te[1], f = Te[2], y = Te[3], S = Te[4], j = Te[9] = Te[9] === t ? H ? 0 : o.length : Ut(Te[9] - ee, 0), !j && l & (M | A) && (l &= -25), !l || l == C)
          var Me = BC(o, l, f);
        else l == M || l == A ? Me = VC(o, l, j) : (l == D || l == (C | D)) && !S.length ? Me = zC(o, l, f, y) : Me = xc.apply(t, Te);
        var Ve = me ? em : Im;
        return Pm(Ve(Me, Te), o, l);
      }
      function xm(o, l, f, y) {
        return o === t || fn(o, zi[f]) && !ct.call(y, f) ? l : o;
      }
      function _m(o, l, f, y, S, O) {
        return _t(o) && _t(l) && (O.set(l, o), vc(o, l, t, _m, O), O.delete(l)), o;
      }
      function HC(o) {
        return Zo(o) ? t : o;
      }
      function Sm(o, l, f, y, S, O) {
        var P = f & b, j = o.length, H = l.length;
        if (j != H && !(P && H > j))
          return !1;
        var ee = O.get(o), re = O.get(l);
        if (ee && re)
          return ee == l && re == o;
        var se = -1, me = !0, Te = f & _ ? new $s() : t;
        for (O.set(o, l), O.set(l, o); ++se < j; ) {
          var Me = o[se], Ve = l[se];
          if (y)
            var Ae = P ? y(Ve, Me, se, l, o, O) : y(Me, Ve, se, o, l, O);
          if (Ae !== t) {
            if (Ae)
              continue;
            me = !1;
            break;
          }
          if (Te) {
            if (!Uu(l, function(He, Ke) {
              if (!Fo(Te, Ke) && (Me === He || S(Me, He, f, y, O)))
                return Te.push(Ke);
            })) {
              me = !1;
              break;
            }
          } else if (!(Me === Ve || S(Me, Ve, f, y, O))) {
            me = !1;
            break;
          }
        }
        return O.delete(o), O.delete(l), me;
      }
      function UC(o, l, f, y, S, O, P) {
        switch (f) {
          case xe:
            if (o.byteLength != l.byteLength || o.byteOffset != l.byteOffset)
              return !1;
            o = o.buffer, l = l.buffer;
          case ke:
            return !(o.byteLength != l.byteLength || !O(new ic(o), new ic(l)));
          case We:
          case bt:
          case Tt:
            return fn(+o, +l);
          case Vt:
            return o.name == l.name && o.message == l.message;
          case sr:
          case he:
            return o == l + "";
          case it:
            var j = Ku;
          case R:
            var H = y & b;
            if (j || (j = Qa), o.size != l.size && !H)
              return !1;
            var ee = P.get(o);
            if (ee)
              return ee == l;
            y |= _, P.set(o, l);
            var re = Sm(j(o), j(l), y, S, O, P);
            return P.delete(o), re;
          case pe:
            if (Wo)
              return Wo.call(o) == Wo.call(l);
        }
        return !1;
      }
      function $C(o, l, f, y, S, O) {
        var P = f & b, j = xh(o), H = j.length, ee = xh(l), re = ee.length;
        if (H != re && !P)
          return !1;
        for (var se = H; se--; ) {
          var me = j[se];
          if (!(P ? me in l : ct.call(l, me)))
            return !1;
        }
        var Te = O.get(o), Me = O.get(l);
        if (Te && Me)
          return Te == l && Me == o;
        var Ve = !0;
        O.set(o, l), O.set(l, o);
        for (var Ae = P; ++se < H; ) {
          me = j[se];
          var He = o[me], Ke = l[me];
          if (y)
            var Vr = P ? y(Ke, He, me, l, o, O) : y(He, Ke, me, o, l, O);
          if (!(Vr === t ? He === Ke || S(He, Ke, f, y, O) : Vr)) {
            Ve = !1;
            break;
          }
          Ae || (Ae = me == "constructor");
        }
        if (Ve && !Ae) {
          var vr = o.constructor, zr = l.constructor;
          vr != zr && "constructor" in o && "constructor" in l && !(typeof vr == "function" && vr instanceof vr && typeof zr == "function" && zr instanceof zr) && (Ve = !1);
        }
        return O.delete(o), O.delete(l), Ve;
      }
      function Yn(o) {
        return Mh(Mm(o, t, Nm), o + "");
      }
      function xh(o) {
        return Hg(o, Jt, Th);
      }
      function _h(o) {
        return Hg(o, Ar, Cm);
      }
      var Sh = hc ? function(o) {
        return hc.get(o);
      } : Wh;
      function Tc(o) {
        for (var l = o.name + "", f = Hi[l], y = ct.call(Hi, l) ? f.length : 0; y--; ) {
          var S = f[y], O = S.func;
          if (O == null || O == o)
            return S.name;
        }
        return l;
      }
      function Xi(o) {
        var l = ct.call(E, "placeholder") ? E : o;
        return l.placeholder;
      }
      function Oe() {
        var o = E.iteratee || Vh;
        return o = o === Vh ? Yg : o, arguments.length ? o(arguments[0], arguments[1]) : o;
      }
      function Ec(o, l) {
        var f = o.__data__;
        return QC(l) ? f[typeof l == "string" ? "string" : "hash"] : f.map;
      }
      function Ch(o) {
        for (var l = Jt(o), f = l.length; f--; ) {
          var y = l[f], S = o[y];
          l[f] = [y, S, km(S)];
        }
        return l;
      }
      function Gs(o, l) {
        var f = rS(o, l);
        return $g(f) ? f : t;
      }
      function YC(o) {
        var l = ct.call(o, Hs), f = o[Hs];
        try {
          o[Hs] = t;
          var y = !0;
        } catch {
        }
        var S = nc.call(o);
        return y && (l ? o[Hs] = f : delete o[Hs]), S;
      }
      var Th = Ju ? function(o) {
        return o == null ? [] : (o = ut(o), ds(Ju(o), function(l) {
          return Ag.call(o, l);
        }));
      } : Hh, Cm = Ju ? function(o) {
        for (var l = []; o; )
          fs(l, Th(o)), o = oc(o);
        return l;
      } : Hh, ar = gr;
      (Qu && ar(new Qu(new ArrayBuffer(1))) != xe || Bo && ar(new Bo()) != it || eh && ar(eh.resolve()) != It || Wi && ar(new Wi()) != R || Vo && ar(new Vo()) != Je) && (ar = function(o) {
        var l = gr(o), f = l == tt ? o.constructor : t, y = f ? qs(f) : "";
        if (y)
          switch (y) {
            case OS:
              return xe;
            case MS:
              return it;
            case AS:
              return It;
            case IS:
              return R;
            case PS:
              return Je;
          }
        return l;
      });
      function XC(o, l, f) {
        for (var y = -1, S = f.length; ++y < S; ) {
          var O = f[y], P = O.size;
          switch (O.type) {
            case "drop":
              o += P;
              break;
            case "dropRight":
              l -= P;
              break;
            case "take":
              l = or(l, o + P);
              break;
            case "takeRight":
              o = Ut(o, l - P);
              break;
          }
        }
        return { start: o, end: l };
      }
      function GC(o) {
        var l = o.match(qa);
        return l ? l[1].split(x) : [];
      }
      function Tm(o, l, f) {
        l = ys(l, o);
        for (var y = -1, S = l.length, O = !1; ++y < S; ) {
          var P = On(l[y]);
          if (!(O = o != null && f(o, P)))
            break;
          o = o[P];
        }
        return O || ++y != S ? O : (S = o == null ? 0 : o.length, !!S && Dc(S) && Xn(P, S) && (je(o) || Ks(o)));
      }
      function qC(o) {
        var l = o.length, f = new o.constructor(l);
        return l && typeof o[0] == "string" && ct.call(o, "index") && (f.index = o.index, f.input = o.input), f;
      }
      function Em(o) {
        return typeof o.constructor == "function" && !qo(o) ? Ui(oc(o)) : {};
      }
      function KC(o, l, f) {
        var y = o.constructor;
        switch (l) {
          case ke:
            return yh(o);
          case We:
          case bt:
            return new y(+o);
          case xe:
            return DC(o, f);
          case zt:
          case xt:
          case Wt:
          case Er:
          case Qt:
          case jr:
          case Kt:
          case ls:
          case us:
            return cm(o, f);
          case it:
            return new y();
          case Tt:
          case he:
            return new y(o);
          case sr:
            return RC(o);
          case R:
            return new y();
          case pe:
            return jC(o);
        }
      }
      function ZC(o, l) {
        var f = l.length;
        if (!f)
          return o;
        var y = f - 1;
        return l[y] = (f > 1 ? "& " : "") + l[y], l = l.join(f > 2 ? ", " : " "), o.replace(Lo, `{
/* [wrapped with ` + l + `] */
`);
      }
      function JC(o) {
        return je(o) || Ks(o) || !!(Ig && o && o[Ig]);
      }
      function Xn(o, l) {
        var f = typeof o;
        return l = l ?? de, !!l && (f == "number" || f != "symbol" && ir.test(o)) && o > -1 && o % 1 == 0 && o < l;
      }
      function mr(o, l, f) {
        if (!_t(f))
          return !1;
        var y = typeof l;
        return (y == "number" ? Mr(f) && Xn(l, f.length) : y == "string" && l in f) ? fn(f[l], o) : !1;
      }
      function Eh(o, l) {
        if (je(o))
          return !1;
        var f = typeof o;
        return f == "number" || f == "symbol" || f == "boolean" || o == null || Br(o) ? !0 : Vs.test(o) || !Ri.test(o) || l != null && o in ut(l);
      }
      function QC(o) {
        var l = typeof o;
        return l == "string" || l == "number" || l == "symbol" || l == "boolean" ? o !== "__proto__" : o === null;
      }
      function kh(o) {
        var l = Tc(o), f = E[l];
        if (typeof f != "function" || !(l in $e.prototype))
          return !1;
        if (o === f)
          return !0;
        var y = Sh(f);
        return !!y && o === y[0];
      }
      function eT(o) {
        return !!kg && kg in o;
      }
      var tT = tc ? Gn : Uh;
      function qo(o) {
        var l = o && o.constructor, f = typeof l == "function" && l.prototype || zi;
        return o === f;
      }
      function km(o) {
        return o === o && !_t(o);
      }
      function Om(o, l) {
        return function(f) {
          return f == null ? !1 : f[o] === l && (l !== t || o in ut(f));
        };
      }
      function rT(o) {
        var l = Ic(o, function(y) {
          return f.size === h && f.clear(), y;
        }), f = l.cache;
        return l;
      }
      function nT(o, l) {
        var f = o[1], y = l[1], S = f | y, O = S < (C | T | U), P = y == U && f == M || y == U && f == B && o[7].length <= l[8] || y == (U | B) && l[7].length <= l[8] && f == M;
        if (!(O || P))
          return o;
        y & C && (o[2] = l[2], S |= f & C ? 0 : k);
        var j = l[3];
        if (j) {
          var H = o[3];
          o[3] = H ? um(H, j, l[4]) : j, o[4] = H ? ps(o[3], d) : l[4];
        }
        return j = l[5], j && (H = o[5], o[5] = H ? hm(H, j, l[6]) : j, o[6] = H ? ps(o[5], d) : l[6]), j = l[7], j && (o[7] = j), y & U && (o[8] = o[8] == null ? l[8] : or(o[8], l[8])), o[9] == null && (o[9] = l[9]), o[0] = l[0], o[1] = S, o;
      }
      function sT(o) {
        var l = [];
        if (o != null)
          for (var f in ut(o))
            l.push(f);
        return l;
      }
      function iT(o) {
        return nc.call(o);
      }
      function Mm(o, l, f) {
        return l = Ut(l === t ? o.length - 1 : l, 0), function() {
          for (var y = arguments, S = -1, O = Ut(y.length - l, 0), P = q(O); ++S < O; )
            P[S] = y[l + S];
          S = -1;
          for (var j = q(l + 1); ++S < l; )
            j[S] = y[S];
          return j[l] = f(P), Lr(o, this, j);
        };
      }
      function Am(o, l) {
        return l.length < 2 ? o : Xs(o, en(l, 0, -1));
      }
      function oT(o, l) {
        for (var f = o.length, y = or(l.length, f), S = Or(o); y--; ) {
          var O = l[y];
          o[y] = Xn(O, f) ? S[O] : t;
        }
        return o;
      }
      function Oh(o, l) {
        if (!(l === "constructor" && typeof o[l] == "function") && l != "__proto__")
          return o[l];
      }
      var Im = Dm(em), Ko = xS || function(o, l) {
        return er.setTimeout(o, l);
      }, Mh = Dm(MC);
      function Pm(o, l, f) {
        var y = l + "";
        return Mh(o, ZC(y, aT(GC(y), f)));
      }
      function Dm(o) {
        var l = 0, f = 0;
        return function() {
          var y = TS(), S = K - (y - f);
          if (f = y, S > 0) {
            if (++l >= G)
              return arguments[0];
          } else
            l = 0;
          return o.apply(t, arguments);
        };
      }
      function kc(o, l) {
        var f = -1, y = o.length, S = y - 1;
        for (l = l === t ? y : l; ++f < l; ) {
          var O = hh(f, S), P = o[O];
          o[O] = o[f], o[f] = P;
        }
        return o.length = l, o;
      }
      var Rm = rT(function(o) {
        var l = [];
        return o.charCodeAt(0) === 46 && l.push(""), o.replace(qe, function(f, y, S, O) {
          l.push(S ? O.replace(ae, "$1") : y || f);
        }), l;
      });
      function On(o) {
        if (typeof o == "string" || Br(o))
          return o;
        var l = o + "";
        return l == "0" && 1 / o == -1 / 0 ? "-0" : l;
      }
      function qs(o) {
        if (o != null) {
          try {
            return rc.call(o);
          } catch {
          }
          try {
            return o + "";
          } catch {
          }
        }
        return "";
      }
      function aT(o, l) {
        return Kr(be, function(f) {
          var y = "_." + f[0];
          l & f[1] && !Za(o, y) && o.push(y);
        }), o.sort();
      }
      function jm(o) {
        if (o instanceof $e)
          return o.clone();
        var l = new Jr(o.__wrapped__, o.__chain__);
        return l.__actions__ = Or(o.__actions__), l.__index__ = o.__index__, l.__values__ = o.__values__, l;
      }
      function cT(o, l, f) {
        (f ? mr(o, l, f) : l === t) ? l = 1 : l = Ut(Le(l), 0);
        var y = o == null ? 0 : o.length;
        if (!y || l < 1)
          return [];
        for (var S = 0, O = 0, P = q(lc(y / l)); S < y; )
          P[O++] = en(o, S, S += l);
        return P;
      }
      function lT(o) {
        for (var l = -1, f = o == null ? 0 : o.length, y = 0, S = []; ++l < f; ) {
          var O = o[l];
          O && (S[y++] = O);
        }
        return S;
      }
      function uT() {
        var o = arguments.length;
        if (!o)
          return [];
        for (var l = q(o - 1), f = arguments[0], y = o; y--; )
          l[y - 1] = arguments[y];
        return fs(je(f) ? Or(f) : [f], tr(l, 1));
      }
      var hT = ze(function(o, l) {
        return Pt(o) ? Uo(o, tr(l, 1, Pt, !0)) : [];
      }), dT = ze(function(o, l) {
        var f = tn(l);
        return Pt(f) && (f = t), Pt(o) ? Uo(o, tr(l, 1, Pt, !0), Oe(f, 2)) : [];
      }), fT = ze(function(o, l) {
        var f = tn(l);
        return Pt(f) && (f = t), Pt(o) ? Uo(o, tr(l, 1, Pt, !0), t, f) : [];
      });
      function pT(o, l, f) {
        var y = o == null ? 0 : o.length;
        return y ? (l = f || l === t ? 1 : Le(l), en(o, l < 0 ? 0 : l, y)) : [];
      }
      function gT(o, l, f) {
        var y = o == null ? 0 : o.length;
        return y ? (l = f || l === t ? 1 : Le(l), l = y - l, en(o, 0, l < 0 ? 0 : l)) : [];
      }
      function mT(o, l) {
        return o && o.length ? bc(o, Oe(l, 3), !0, !0) : [];
      }
      function vT(o, l) {
        return o && o.length ? bc(o, Oe(l, 3), !0) : [];
      }
      function yT(o, l, f, y) {
        var S = o == null ? 0 : o.length;
        return S ? (f && typeof f != "number" && mr(o, l, f) && (f = 0, y = S), uC(o, l, f, y)) : [];
      }
      function Lm(o, l, f) {
        var y = o == null ? 0 : o.length;
        if (!y)
          return -1;
        var S = f == null ? 0 : Le(f);
        return S < 0 && (S = Ut(y + S, 0)), Ja(o, Oe(l, 3), S);
      }
      function Fm(o, l, f) {
        var y = o == null ? 0 : o.length;
        if (!y)
          return -1;
        var S = y - 1;
        return f !== t && (S = Le(f), S = f < 0 ? Ut(y + S, 0) : or(S, y - 1)), Ja(o, Oe(l, 3), S, !0);
      }
      function Nm(o) {
        var l = o == null ? 0 : o.length;
        return l ? tr(o, 1) : [];
      }
      function bT(o) {
        var l = o == null ? 0 : o.length;
        return l ? tr(o, ge) : [];
      }
      function wT(o, l) {
        var f = o == null ? 0 : o.length;
        return f ? (l = l === t ? 1 : Le(l), tr(o, l)) : [];
      }
      function xT(o) {
        for (var l = -1, f = o == null ? 0 : o.length, y = {}; ++l < f; ) {
          var S = o[l];
          y[S[0]] = S[1];
        }
        return y;
      }
      function Bm(o) {
        return o && o.length ? o[0] : t;
      }
      function _T(o, l, f) {
        var y = o == null ? 0 : o.length;
        if (!y)
          return -1;
        var S = f == null ? 0 : Le(f);
        return S < 0 && (S = Ut(y + S, 0)), Fi(o, l, S);
      }
      function ST(o) {
        var l = o == null ? 0 : o.length;
        return l ? en(o, 0, -1) : [];
      }
      var CT = ze(function(o) {
        var l = mt(o, mh);
        return l.length && l[0] === o[0] ? oh(l) : [];
      }), TT = ze(function(o) {
        var l = tn(o), f = mt(o, mh);
        return l === tn(f) ? l = t : f.pop(), f.length && f[0] === o[0] ? oh(f, Oe(l, 2)) : [];
      }), ET = ze(function(o) {
        var l = tn(o), f = mt(o, mh);
        return l = typeof l == "function" ? l : t, l && f.pop(), f.length && f[0] === o[0] ? oh(f, t, l) : [];
      });
      function kT(o, l) {
        return o == null ? "" : SS.call(o, l);
      }
      function tn(o) {
        var l = o == null ? 0 : o.length;
        return l ? o[l - 1] : t;
      }
      function OT(o, l, f) {
        var y = o == null ? 0 : o.length;
        if (!y)
          return -1;
        var S = y;
        return f !== t && (S = Le(f), S = S < 0 ? Ut(y + S, 0) : or(S, y - 1)), l === l ? aS(o, l, S) : Ja(o, bg, S, !0);
      }
      function MT(o, l) {
        return o && o.length ? Kg(o, Le(l)) : t;
      }
      var AT = ze(Vm);
      function Vm(o, l) {
        return o && o.length && l && l.length ? uh(o, l) : o;
      }
      function IT(o, l, f) {
        return o && o.length && l && l.length ? uh(o, l, Oe(f, 2)) : o;
      }
      function PT(o, l, f) {
        return o && o.length && l && l.length ? uh(o, l, t, f) : o;
      }
      var DT = Yn(function(o, l) {
        var f = o == null ? 0 : o.length, y = rh(o, l);
        return Qg(o, mt(l, function(S) {
          return Xn(S, f) ? +S : S;
        }).sort(lm)), y;
      });
      function RT(o, l) {
        var f = [];
        if (!(o && o.length))
          return f;
        var y = -1, S = [], O = o.length;
        for (l = Oe(l, 3); ++y < O; ) {
          var P = o[y];
          l(P, y, o) && (f.push(P), S.push(y));
        }
        return Qg(o, S), f;
      }
      function Ah(o) {
        return o == null ? o : kS.call(o);
      }
      function jT(o, l, f) {
        var y = o == null ? 0 : o.length;
        return y ? (f && typeof f != "number" && mr(o, l, f) ? (l = 0, f = y) : (l = l == null ? 0 : Le(l), f = f === t ? y : Le(f)), en(o, l, f)) : [];
      }
      function LT(o, l) {
        return yc(o, l);
      }
      function FT(o, l, f) {
        return fh(o, l, Oe(f, 2));
      }
      function NT(o, l) {
        var f = o == null ? 0 : o.length;
        if (f) {
          var y = yc(o, l);
          if (y < f && fn(o[y], l))
            return y;
        }
        return -1;
      }
      function BT(o, l) {
        return yc(o, l, !0);
      }
      function VT(o, l, f) {
        return fh(o, l, Oe(f, 2), !0);
      }
      function zT(o, l) {
        var f = o == null ? 0 : o.length;
        if (f) {
          var y = yc(o, l, !0) - 1;
          if (fn(o[y], l))
            return y;
        }
        return -1;
      }
      function WT(o) {
        return o && o.length ? tm(o) : [];
      }
      function HT(o, l) {
        return o && o.length ? tm(o, Oe(l, 2)) : [];
      }
      function UT(o) {
        var l = o == null ? 0 : o.length;
        return l ? en(o, 1, l) : [];
      }
      function $T(o, l, f) {
        return o && o.length ? (l = f || l === t ? 1 : Le(l), en(o, 0, l < 0 ? 0 : l)) : [];
      }
      function YT(o, l, f) {
        var y = o == null ? 0 : o.length;
        return y ? (l = f || l === t ? 1 : Le(l), l = y - l, en(o, l < 0 ? 0 : l, y)) : [];
      }
      function XT(o, l) {
        return o && o.length ? bc(o, Oe(l, 3), !1, !0) : [];
      }
      function GT(o, l) {
        return o && o.length ? bc(o, Oe(l, 3)) : [];
      }
      var qT = ze(function(o) {
        return vs(tr(o, 1, Pt, !0));
      }), KT = ze(function(o) {
        var l = tn(o);
        return Pt(l) && (l = t), vs(tr(o, 1, Pt, !0), Oe(l, 2));
      }), ZT = ze(function(o) {
        var l = tn(o);
        return l = typeof l == "function" ? l : t, vs(tr(o, 1, Pt, !0), t, l);
      });
      function JT(o) {
        return o && o.length ? vs(o) : [];
      }
      function QT(o, l) {
        return o && o.length ? vs(o, Oe(l, 2)) : [];
      }
      function e2(o, l) {
        return l = typeof l == "function" ? l : t, o && o.length ? vs(o, t, l) : [];
      }
      function Ih(o) {
        if (!(o && o.length))
          return [];
        var l = 0;
        return o = ds(o, function(f) {
          if (Pt(f))
            return l = Ut(f.length, l), !0;
        }), Gu(l, function(f) {
          return mt(o, $u(f));
        });
      }
      function zm(o, l) {
        if (!(o && o.length))
          return [];
        var f = Ih(o);
        return l == null ? f : mt(f, function(y) {
          return Lr(l, t, y);
        });
      }
      var t2 = ze(function(o, l) {
        return Pt(o) ? Uo(o, l) : [];
      }), r2 = ze(function(o) {
        return gh(ds(o, Pt));
      }), n2 = ze(function(o) {
        var l = tn(o);
        return Pt(l) && (l = t), gh(ds(o, Pt), Oe(l, 2));
      }), s2 = ze(function(o) {
        var l = tn(o);
        return l = typeof l == "function" ? l : t, gh(ds(o, Pt), t, l);
      }), i2 = ze(Ih);
      function o2(o, l) {
        return im(o || [], l || [], Ho);
      }
      function a2(o, l) {
        return im(o || [], l || [], Xo);
      }
      var c2 = ze(function(o) {
        var l = o.length, f = l > 1 ? o[l - 1] : t;
        return f = typeof f == "function" ? (o.pop(), f) : t, zm(o, f);
      });
      function Wm(o) {
        var l = E(o);
        return l.__chain__ = !0, l;
      }
      function l2(o, l) {
        return l(o), o;
      }
      function Oc(o, l) {
        return l(o);
      }
      var u2 = Yn(function(o) {
        var l = o.length, f = l ? o[0] : 0, y = this.__wrapped__, S = function(O) {
          return rh(O, o);
        };
        return l > 1 || this.__actions__.length || !(y instanceof $e) || !Xn(f) ? this.thru(S) : (y = y.slice(f, +f + (l ? 1 : 0)), y.__actions__.push({
          func: Oc,
          args: [S],
          thisArg: t
        }), new Jr(y, this.__chain__).thru(function(O) {
          return l && !O.length && O.push(t), O;
        }));
      });
      function h2() {
        return Wm(this);
      }
      function d2() {
        return new Jr(this.value(), this.__chain__);
      }
      function f2() {
        this.__values__ === t && (this.__values__ = rv(this.value()));
        var o = this.__index__ >= this.__values__.length, l = o ? t : this.__values__[this.__index__++];
        return { done: o, value: l };
      }
      function p2() {
        return this;
      }
      function g2(o) {
        for (var l, f = this; f instanceof fc; ) {
          var y = jm(f);
          y.__index__ = 0, y.__values__ = t, l ? S.__wrapped__ = y : l = y;
          var S = y;
          f = f.__wrapped__;
        }
        return S.__wrapped__ = o, l;
      }
      function m2() {
        var o = this.__wrapped__;
        if (o instanceof $e) {
          var l = o;
          return this.__actions__.length && (l = new $e(this)), l = l.reverse(), l.__actions__.push({
            func: Oc,
            args: [Ah],
            thisArg: t
          }), new Jr(l, this.__chain__);
        }
        return this.thru(Ah);
      }
      function v2() {
        return sm(this.__wrapped__, this.__actions__);
      }
      var y2 = wc(function(o, l, f) {
        ct.call(o, f) ? ++o[f] : Un(o, f, 1);
      });
      function b2(o, l, f) {
        var y = je(o) ? vg : lC;
        return f && mr(o, l, f) && (l = t), y(o, Oe(l, 3));
      }
      function w2(o, l) {
        var f = je(o) ? ds : zg;
        return f(o, Oe(l, 3));
      }
      var x2 = gm(Lm), _2 = gm(Fm);
      function S2(o, l) {
        return tr(Mc(o, l), 1);
      }
      function C2(o, l) {
        return tr(Mc(o, l), ge);
      }
      function T2(o, l, f) {
        return f = f === t ? 1 : Le(f), tr(Mc(o, l), f);
      }
      function Hm(o, l) {
        var f = je(o) ? Kr : ms;
        return f(o, Oe(l, 3));
      }
      function Um(o, l) {
        var f = je(o) ? U_ : Vg;
        return f(o, Oe(l, 3));
      }
      var E2 = wc(function(o, l, f) {
        ct.call(o, f) ? o[f].push(l) : Un(o, f, [l]);
      });
      function k2(o, l, f, y) {
        o = Mr(o) ? o : qi(o), f = f && !y ? Le(f) : 0;
        var S = o.length;
        return f < 0 && (f = Ut(S + f, 0)), Rc(o) ? f <= S && o.indexOf(l, f) > -1 : !!S && Fi(o, l, f) > -1;
      }
      var O2 = ze(function(o, l, f) {
        var y = -1, S = typeof l == "function", O = Mr(o) ? q(o.length) : [];
        return ms(o, function(P) {
          O[++y] = S ? Lr(l, P, f) : $o(P, l, f);
        }), O;
      }), M2 = wc(function(o, l, f) {
        Un(o, f, l);
      });
      function Mc(o, l) {
        var f = je(o) ? mt : Xg;
        return f(o, Oe(l, 3));
      }
      function A2(o, l, f, y) {
        return o == null ? [] : (je(l) || (l = l == null ? [] : [l]), f = y ? t : f, je(f) || (f = f == null ? [] : [f]), Zg(o, l, f));
      }
      var I2 = wc(function(o, l, f) {
        o[f ? 0 : 1].push(l);
      }, function() {
        return [[], []];
      });
      function P2(o, l, f) {
        var y = je(o) ? Hu : xg, S = arguments.length < 3;
        return y(o, Oe(l, 4), f, S, ms);
      }
      function D2(o, l, f) {
        var y = je(o) ? $_ : xg, S = arguments.length < 3;
        return y(o, Oe(l, 4), f, S, Vg);
      }
      function R2(o, l) {
        var f = je(o) ? ds : zg;
        return f(o, Pc(Oe(l, 3)));
      }
      function j2(o) {
        var l = je(o) ? Lg : kC;
        return l(o);
      }
      function L2(o, l, f) {
        (f ? mr(o, l, f) : l === t) ? l = 1 : l = Le(l);
        var y = je(o) ? sC : OC;
        return y(o, l);
      }
      function F2(o) {
        var l = je(o) ? iC : AC;
        return l(o);
      }
      function N2(o) {
        if (o == null)
          return 0;
        if (Mr(o))
          return Rc(o) ? Bi(o) : o.length;
        var l = ar(o);
        return l == it || l == R ? o.size : ch(o).length;
      }
      function B2(o, l, f) {
        var y = je(o) ? Uu : IC;
        return f && mr(o, l, f) && (l = t), y(o, Oe(l, 3));
      }
      var V2 = ze(function(o, l) {
        if (o == null)
          return [];
        var f = l.length;
        return f > 1 && mr(o, l[0], l[1]) ? l = [] : f > 2 && mr(l[0], l[1], l[2]) && (l = [l[0]]), Zg(o, tr(l, 1), []);
      }), Ac = wS || function() {
        return er.Date.now();
      };
      function z2(o, l) {
        if (typeof l != "function")
          throw new Zr(a);
        return o = Le(o), function() {
          if (--o < 1)
            return l.apply(this, arguments);
        };
      }
      function $m(o, l, f) {
        return l = f ? t : l, l = o && l == null ? o.length : l, $n(o, U, t, t, t, t, l);
      }
      function Ym(o, l) {
        var f;
        if (typeof l != "function")
          throw new Zr(a);
        return o = Le(o), function() {
          return --o > 0 && (f = l.apply(this, arguments)), o <= 1 && (l = t), f;
        };
      }
      var Ph = ze(function(o, l, f) {
        var y = C;
        if (f.length) {
          var S = ps(f, Xi(Ph));
          y |= D;
        }
        return $n(o, y, l, f, S);
      }), Xm = ze(function(o, l, f) {
        var y = C | T;
        if (f.length) {
          var S = ps(f, Xi(Xm));
          y |= D;
        }
        return $n(l, y, o, f, S);
      });
      function Gm(o, l, f) {
        l = f ? t : l;
        var y = $n(o, M, t, t, t, t, t, l);
        return y.placeholder = Gm.placeholder, y;
      }
      function qm(o, l, f) {
        l = f ? t : l;
        var y = $n(o, A, t, t, t, t, t, l);
        return y.placeholder = qm.placeholder, y;
      }
      function Km(o, l, f) {
        var y, S, O, P, j, H, ee = 0, re = !1, se = !1, me = !0;
        if (typeof o != "function")
          throw new Zr(a);
        l = rn(l) || 0, _t(f) && (re = !!f.leading, se = "maxWait" in f, O = se ? Ut(rn(f.maxWait) || 0, l) : O, me = "trailing" in f ? !!f.trailing : me);
        function Te(Dt) {
          var pn = y, Kn = S;
          return y = S = t, ee = Dt, P = o.apply(Kn, pn), P;
        }
        function Me(Dt) {
          return ee = Dt, j = Ko(He, l), re ? Te(Dt) : P;
        }
        function Ve(Dt) {
          var pn = Dt - H, Kn = Dt - ee, gv = l - pn;
          return se ? or(gv, O - Kn) : gv;
        }
        function Ae(Dt) {
          var pn = Dt - H, Kn = Dt - ee;
          return H === t || pn >= l || pn < 0 || se && Kn >= O;
        }
        function He() {
          var Dt = Ac();
          if (Ae(Dt))
            return Ke(Dt);
          j = Ko(He, Ve(Dt));
        }
        function Ke(Dt) {
          return j = t, me && y ? Te(Dt) : (y = S = t, P);
        }
        function Vr() {
          j !== t && om(j), ee = 0, y = H = S = j = t;
        }
        function vr() {
          return j === t ? P : Ke(Ac());
        }
        function zr() {
          var Dt = Ac(), pn = Ae(Dt);
          if (y = arguments, S = this, H = Dt, pn) {
            if (j === t)
              return Me(H);
            if (se)
              return om(j), j = Ko(He, l), Te(H);
          }
          return j === t && (j = Ko(He, l)), P;
        }
        return zr.cancel = Vr, zr.flush = vr, zr;
      }
      var W2 = ze(function(o, l) {
        return Bg(o, 1, l);
      }), H2 = ze(function(o, l, f) {
        return Bg(o, rn(l) || 0, f);
      });
      function U2(o) {
        return $n(o, X);
      }
      function Ic(o, l) {
        if (typeof o != "function" || l != null && typeof l != "function")
          throw new Zr(a);
        var f = function() {
          var y = arguments, S = l ? l.apply(this, y) : y[0], O = f.cache;
          if (O.has(S))
            return O.get(S);
          var P = o.apply(this, y);
          return f.cache = O.set(S, P) || O, P;
        };
        return f.cache = new (Ic.Cache || Hn)(), f;
      }
      Ic.Cache = Hn;
      function Pc(o) {
        if (typeof o != "function")
          throw new Zr(a);
        return function() {
          var l = arguments;
          switch (l.length) {
            case 0:
              return !o.call(this);
            case 1:
              return !o.call(this, l[0]);
            case 2:
              return !o.call(this, l[0], l[1]);
            case 3:
              return !o.call(this, l[0], l[1], l[2]);
          }
          return !o.apply(this, l);
        };
      }
      function $2(o) {
        return Ym(2, o);
      }
      var Y2 = PC(function(o, l) {
        l = l.length == 1 && je(l[0]) ? mt(l[0], Fr(Oe())) : mt(tr(l, 1), Fr(Oe()));
        var f = l.length;
        return ze(function(y) {
          for (var S = -1, O = or(y.length, f); ++S < O; )
            y[S] = l[S].call(this, y[S]);
          return Lr(o, this, y);
        });
      }), Dh = ze(function(o, l) {
        var f = ps(l, Xi(Dh));
        return $n(o, D, t, l, f);
      }), Zm = ze(function(o, l) {
        var f = ps(l, Xi(Zm));
        return $n(o, F, t, l, f);
      }), X2 = Yn(function(o, l) {
        return $n(o, B, t, t, t, l);
      });
      function G2(o, l) {
        if (typeof o != "function")
          throw new Zr(a);
        return l = l === t ? l : Le(l), ze(o, l);
      }
      function q2(o, l) {
        if (typeof o != "function")
          throw new Zr(a);
        return l = l == null ? 0 : Ut(Le(l), 0), ze(function(f) {
          var y = f[l], S = bs(f, 0, l);
          return y && fs(S, y), Lr(o, this, S);
        });
      }
      function K2(o, l, f) {
        var y = !0, S = !0;
        if (typeof o != "function")
          throw new Zr(a);
        return _t(f) && (y = "leading" in f ? !!f.leading : y, S = "trailing" in f ? !!f.trailing : S), Km(o, l, {
          leading: y,
          maxWait: l,
          trailing: S
        });
      }
      function Z2(o) {
        return $m(o, 1);
      }
      function J2(o, l) {
        return Dh(vh(l), o);
      }
      function Q2() {
        if (!arguments.length)
          return [];
        var o = arguments[0];
        return je(o) ? o : [o];
      }
      function eE(o) {
        return Qr(o, v);
      }
      function tE(o, l) {
        return l = typeof l == "function" ? l : t, Qr(o, v, l);
      }
      function rE(o) {
        return Qr(o, p | v);
      }
      function nE(o, l) {
        return l = typeof l == "function" ? l : t, Qr(o, p | v, l);
      }
      function sE(o, l) {
        return l == null || Ng(o, l, Jt(l));
      }
      function fn(o, l) {
        return o === l || o !== o && l !== l;
      }
      var iE = Cc(ih), oE = Cc(function(o, l) {
        return o >= l;
      }), Ks = Ug(/* @__PURE__ */ function() {
        return arguments;
      }()) ? Ug : function(o) {
        return Et(o) && ct.call(o, "callee") && !Ag.call(o, "callee");
      }, je = q.isArray, aE = hg ? Fr(hg) : gC;
      function Mr(o) {
        return o != null && Dc(o.length) && !Gn(o);
      }
      function Pt(o) {
        return Et(o) && Mr(o);
      }
      function cE(o) {
        return o === !0 || o === !1 || Et(o) && gr(o) == We;
      }
      var ws = _S || Uh, lE = dg ? Fr(dg) : mC;
      function uE(o) {
        return Et(o) && o.nodeType === 1 && !Zo(o);
      }
      function hE(o) {
        if (o == null)
          return !0;
        if (Mr(o) && (je(o) || typeof o == "string" || typeof o.splice == "function" || ws(o) || Gi(o) || Ks(o)))
          return !o.length;
        var l = ar(o);
        if (l == it || l == R)
          return !o.size;
        if (qo(o))
          return !ch(o).length;
        for (var f in o)
          if (ct.call(o, f))
            return !1;
        return !0;
      }
      function dE(o, l) {
        return Yo(o, l);
      }
      function fE(o, l, f) {
        f = typeof f == "function" ? f : t;
        var y = f ? f(o, l) : t;
        return y === t ? Yo(o, l, t, f) : !!y;
      }
      function Rh(o) {
        if (!Et(o))
          return !1;
        var l = gr(o);
        return l == Vt || l == wt || typeof o.message == "string" && typeof o.name == "string" && !Zo(o);
      }
      function pE(o) {
        return typeof o == "number" && Pg(o);
      }
      function Gn(o) {
        if (!_t(o))
          return !1;
        var l = gr(o);
        return l == Ce || l == qt || l == Xe || l == Gr;
      }
      function Jm(o) {
        return typeof o == "number" && o == Le(o);
      }
      function Dc(o) {
        return typeof o == "number" && o > -1 && o % 1 == 0 && o <= de;
      }
      function _t(o) {
        var l = typeof o;
        return o != null && (l == "object" || l == "function");
      }
      function Et(o) {
        return o != null && typeof o == "object";
      }
      var Qm = fg ? Fr(fg) : yC;
      function gE(o, l) {
        return o === l || ah(o, l, Ch(l));
      }
      function mE(o, l, f) {
        return f = typeof f == "function" ? f : t, ah(o, l, Ch(l), f);
      }
      function vE(o) {
        return ev(o) && o != +o;
      }
      function yE(o) {
        if (tT(o))
          throw new Re(i);
        return $g(o);
      }
      function bE(o) {
        return o === null;
      }
      function wE(o) {
        return o == null;
      }
      function ev(o) {
        return typeof o == "number" || Et(o) && gr(o) == Tt;
      }
      function Zo(o) {
        if (!Et(o) || gr(o) != tt)
          return !1;
        var l = oc(o);
        if (l === null)
          return !0;
        var f = ct.call(l, "constructor") && l.constructor;
        return typeof f == "function" && f instanceof f && rc.call(f) == mS;
      }
      var jh = pg ? Fr(pg) : bC;
      function xE(o) {
        return Jm(o) && o >= -9007199254740991 && o <= de;
      }
      var tv = gg ? Fr(gg) : wC;
      function Rc(o) {
        return typeof o == "string" || !je(o) && Et(o) && gr(o) == he;
      }
      function Br(o) {
        return typeof o == "symbol" || Et(o) && gr(o) == pe;
      }
      var Gi = mg ? Fr(mg) : xC;
      function _E(o) {
        return o === t;
      }
      function SE(o) {
        return Et(o) && ar(o) == Je;
      }
      function CE(o) {
        return Et(o) && gr(o) == Ge;
      }
      var TE = Cc(lh), EE = Cc(function(o, l) {
        return o <= l;
      });
      function rv(o) {
        if (!o)
          return [];
        if (Mr(o))
          return Rc(o) ? hn(o) : Or(o);
        if (No && o[No])
          return sS(o[No]());
        var l = ar(o), f = l == it ? Ku : l == R ? Qa : qi;
        return f(o);
      }
      function qn(o) {
        if (!o)
          return o === 0 ? o : 0;
        if (o = rn(o), o === ge || o === -1 / 0) {
          var l = o < 0 ? -1 : 1;
          return l * ne;
        }
        return o === o ? o : 0;
      }
      function Le(o) {
        var l = qn(o), f = l % 1;
        return l === l ? f ? l - f : l : 0;
      }
      function nv(o) {
        return o ? Ys(Le(o), 0, W) : 0;
      }
      function rn(o) {
        if (typeof o == "number")
          return o;
        if (Br(o))
          return I;
        if (_t(o)) {
          var l = typeof o.valueOf == "function" ? o.valueOf() : o;
          o = _t(l) ? l + "" : l;
        }
        if (typeof o != "string")
          return o === 0 ? o : +o;
        o = _g(o);
        var f = rt.test(o);
        return f || gt.test(o) ? z_(o.slice(2), f ? 2 : 8) : Se.test(o) ? I : +o;
      }
      function sv(o) {
        return kn(o, Ar(o));
      }
      function kE(o) {
        return o ? Ys(Le(o), -9007199254740991, de) : o === 0 ? o : 0;
      }
      function ot(o) {
        return o == null ? "" : Nr(o);
      }
      var OE = $i(function(o, l) {
        if (qo(l) || Mr(l)) {
          kn(l, Jt(l), o);
          return;
        }
        for (var f in l)
          ct.call(l, f) && Ho(o, f, l[f]);
      }), iv = $i(function(o, l) {
        kn(l, Ar(l), o);
      }), jc = $i(function(o, l, f, y) {
        kn(l, Ar(l), o, y);
      }), ME = $i(function(o, l, f, y) {
        kn(l, Jt(l), o, y);
      }), AE = Yn(rh);
      function IE(o, l) {
        var f = Ui(o);
        return l == null ? f : Fg(f, l);
      }
      var PE = ze(function(o, l) {
        o = ut(o);
        var f = -1, y = l.length, S = y > 2 ? l[2] : t;
        for (S && mr(l[0], l[1], S) && (y = 1); ++f < y; )
          for (var O = l[f], P = Ar(O), j = -1, H = P.length; ++j < H; ) {
            var ee = P[j], re = o[ee];
            (re === t || fn(re, zi[ee]) && !ct.call(o, ee)) && (o[ee] = O[ee]);
          }
        return o;
      }), DE = ze(function(o) {
        return o.push(t, _m), Lr(ov, t, o);
      });
      function RE(o, l) {
        return yg(o, Oe(l, 3), En);
      }
      function jE(o, l) {
        return yg(o, Oe(l, 3), sh);
      }
      function LE(o, l) {
        return o == null ? o : nh(o, Oe(l, 3), Ar);
      }
      function FE(o, l) {
        return o == null ? o : Wg(o, Oe(l, 3), Ar);
      }
      function NE(o, l) {
        return o && En(o, Oe(l, 3));
      }
      function BE(o, l) {
        return o && sh(o, Oe(l, 3));
      }
      function VE(o) {
        return o == null ? [] : mc(o, Jt(o));
      }
      function zE(o) {
        return o == null ? [] : mc(o, Ar(o));
      }
      function Lh(o, l, f) {
        var y = o == null ? t : Xs(o, l);
        return y === t ? f : y;
      }
      function WE(o, l) {
        return o != null && Tm(o, l, hC);
      }
      function Fh(o, l) {
        return o != null && Tm(o, l, dC);
      }
      var HE = vm(function(o, l, f) {
        l != null && typeof l.toString != "function" && (l = nc.call(l)), o[l] = f;
      }, Bh(Ir)), UE = vm(function(o, l, f) {
        l != null && typeof l.toString != "function" && (l = nc.call(l)), ct.call(o, l) ? o[l].push(f) : o[l] = [f];
      }, Oe), $E = ze($o);
      function Jt(o) {
        return Mr(o) ? jg(o) : ch(o);
      }
      function Ar(o) {
        return Mr(o) ? jg(o, !0) : _C(o);
      }
      function YE(o, l) {
        var f = {};
        return l = Oe(l, 3), En(o, function(y, S, O) {
          Un(f, l(y, S, O), y);
        }), f;
      }
      function XE(o, l) {
        var f = {};
        return l = Oe(l, 3), En(o, function(y, S, O) {
          Un(f, S, l(y, S, O));
        }), f;
      }
      var GE = $i(function(o, l, f) {
        vc(o, l, f);
      }), ov = $i(function(o, l, f, y) {
        vc(o, l, f, y);
      }), qE = Yn(function(o, l) {
        var f = {};
        if (o == null)
          return f;
        var y = !1;
        l = mt(l, function(O) {
          return O = ys(O, o), y || (y = O.length > 1), O;
        }), kn(o, _h(o), f), y && (f = Qr(f, p | g | v, HC));
        for (var S = l.length; S--; )
          ph(f, l[S]);
        return f;
      });
      function KE(o, l) {
        return av(o, Pc(Oe(l)));
      }
      var ZE = Yn(function(o, l) {
        return o == null ? {} : CC(o, l);
      });
      function av(o, l) {
        if (o == null)
          return {};
        var f = mt(_h(o), function(y) {
          return [y];
        });
        return l = Oe(l), Jg(o, f, function(y, S) {
          return l(y, S[0]);
        });
      }
      function JE(o, l, f) {
        l = ys(l, o);
        var y = -1, S = l.length;
        for (S || (S = 1, o = t); ++y < S; ) {
          var O = o == null ? t : o[On(l[y])];
          O === t && (y = S, O = f), o = Gn(O) ? O.call(o) : O;
        }
        return o;
      }
      function QE(o, l, f) {
        return o == null ? o : Xo(o, l, f);
      }
      function ek(o, l, f, y) {
        return y = typeof y == "function" ? y : t, o == null ? o : Xo(o, l, f, y);
      }
      var cv = wm(Jt), lv = wm(Ar);
      function tk(o, l, f) {
        var y = je(o), S = y || ws(o) || Gi(o);
        if (l = Oe(l, 4), f == null) {
          var O = o && o.constructor;
          S ? f = y ? new O() : [] : _t(o) ? f = Gn(O) ? Ui(oc(o)) : {} : f = {};
        }
        return (S ? Kr : En)(o, function(P, j, H) {
          return l(f, P, j, H);
        }), f;
      }
      function rk(o, l) {
        return o == null ? !0 : ph(o, l);
      }
      function nk(o, l, f) {
        return o == null ? o : nm(o, l, vh(f));
      }
      function sk(o, l, f, y) {
        return y = typeof y == "function" ? y : t, o == null ? o : nm(o, l, vh(f), y);
      }
      function qi(o) {
        return o == null ? [] : qu(o, Jt(o));
      }
      function ik(o) {
        return o == null ? [] : qu(o, Ar(o));
      }
      function ok(o, l, f) {
        return f === t && (f = l, l = t), f !== t && (f = rn(f), f = f === f ? f : 0), l !== t && (l = rn(l), l = l === l ? l : 0), Ys(rn(o), l, f);
      }
      function ak(o, l, f) {
        return l = qn(l), f === t ? (f = l, l = 0) : f = qn(f), o = rn(o), fC(o, l, f);
      }
      function ck(o, l, f) {
        if (f && typeof f != "boolean" && mr(o, l, f) && (l = f = t), f === t && (typeof l == "boolean" ? (f = l, l = t) : typeof o == "boolean" && (f = o, o = t)), o === t && l === t ? (o = 0, l = 1) : (o = qn(o), l === t ? (l = o, o = 0) : l = qn(l)), o > l) {
          var y = o;
          o = l, l = y;
        }
        if (f || o % 1 || l % 1) {
          var S = Dg();
          return or(o + S * (l - o + V_("1e-" + ((S + "").length - 1))), l);
        }
        return hh(o, l);
      }
      var lk = Yi(function(o, l, f) {
        return l = l.toLowerCase(), o + (f ? uv(l) : l);
      });
      function uv(o) {
        return Nh(ot(o).toLowerCase());
      }
      function hv(o) {
        return o = ot(o), o && o.replace(zn, Q_).replace(A_, "");
      }
      function uk(o, l, f) {
        o = ot(o), l = Nr(l);
        var y = o.length;
        f = f === t ? y : Ys(Le(f), 0, y);
        var S = f;
        return f -= l.length, f >= 0 && o.slice(f, S) == l;
      }
      function hk(o) {
        return o = ot(o), o && Do.test(o) ? o.replace(un, eS) : o;
      }
      function dk(o) {
        return o = ot(o), o && Zt.test(o) ? o.replace(Ue, "\\$&") : o;
      }
      var fk = Yi(function(o, l, f) {
        return o + (f ? "-" : "") + l.toLowerCase();
      }), pk = Yi(function(o, l, f) {
        return o + (f ? " " : "") + l.toLowerCase();
      }), gk = pm("toLowerCase");
      function mk(o, l, f) {
        o = ot(o), l = Le(l);
        var y = l ? Bi(o) : 0;
        if (!l || y >= l)
          return o;
        var S = (l - y) / 2;
        return Sc(uc(S), f) + o + Sc(lc(S), f);
      }
      function vk(o, l, f) {
        o = ot(o), l = Le(l);
        var y = l ? Bi(o) : 0;
        return l && y < l ? o + Sc(l - y, f) : o;
      }
      function yk(o, l, f) {
        o = ot(o), l = Le(l);
        var y = l ? Bi(o) : 0;
        return l && y < l ? Sc(l - y, f) + o : o;
      }
      function bk(o, l, f) {
        return f || l == null ? l = 0 : l && (l = +l), ES(ot(o).replace(fr, ""), l || 0);
      }
      function wk(o, l, f) {
        return (f ? mr(o, l, f) : l === t) ? l = 1 : l = Le(l), dh(ot(o), l);
      }
      function xk() {
        var o = arguments, l = ot(o[0]);
        return o.length < 3 ? l : l.replace(o[1], o[2]);
      }
      var _k = Yi(function(o, l, f) {
        return o + (f ? "_" : "") + l.toLowerCase();
      });
      function Sk(o, l, f) {
        return f && typeof f != "number" && mr(o, l, f) && (l = f = t), f = f === t ? W : f >>> 0, f ? (o = ot(o), o && (typeof l == "string" || l != null && !jh(l)) && (l = Nr(l), !l && Ni(o)) ? bs(hn(o), 0, f) : o.split(l, f)) : [];
      }
      var Ck = Yi(function(o, l, f) {
        return o + (f ? " " : "") + Nh(l);
      });
      function Tk(o, l, f) {
        return o = ot(o), f = f == null ? 0 : Ys(Le(f), 0, o.length), l = Nr(l), o.slice(f, f + l.length) == l;
      }
      function Ek(o, l, f) {
        var y = E.templateSettings;
        f && mr(o, l, f) && (l = t), o = ot(o), l = jc({}, l, y, xm);
        var S = jc({}, l.imports, y.imports, xm), O = Jt(S), P = qu(S, O), j, H, ee = 0, re = l.interpolate || pr, se = "__p += '", me = Zu(
          (l.escape || pr).source + "|" + re.source + "|" + (re === Di ? _e : pr).source + "|" + (l.evaluate || pr).source + "|$",
          "g"
        ), Te = "//# sourceURL=" + (ct.call(l, "sourceURL") ? (l.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++j_ + "]") + `
`;
        o.replace(me, function(Ae, He, Ke, Vr, vr, zr) {
          return Ke || (Ke = Vr), se += o.slice(ee, zr).replace(ji, tS), He && (j = !0, se += `' +
__e(` + He + `) +
'`), vr && (H = !0, se += `';
` + vr + `;
__p += '`), Ke && (se += `' +
((__t = (` + Ke + `)) == null ? '' : __t) +
'`), ee = zr + Ae.length, Ae;
        }), se += `';
`;
        var Me = ct.call(l, "variable") && l.variable;
        if (!Me)
          se = `with (obj) {
` + se + `
}
`;
        else if (te.test(Me))
          throw new Re(c);
        se = (H ? se.replace(Vn, "") : se).replace(Tn, "$1").replace(Ii, "$1;"), se = "function(" + (Me || "obj") + `) {
` + (Me ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (j ? ", __e = _.escape" : "") + (H ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + se + `return __p
}`;
        var Ve = fv(function() {
          return nt(O, Te + "return " + se).apply(t, P);
        });
        if (Ve.source = se, Rh(Ve))
          throw Ve;
        return Ve;
      }
      function kk(o) {
        return ot(o).toLowerCase();
      }
      function Ok(o) {
        return ot(o).toUpperCase();
      }
      function Mk(o, l, f) {
        if (o = ot(o), o && (f || l === t))
          return _g(o);
        if (!o || !(l = Nr(l)))
          return o;
        var y = hn(o), S = hn(l), O = Sg(y, S), P = Cg(y, S) + 1;
        return bs(y, O, P).join("");
      }
      function Ak(o, l, f) {
        if (o = ot(o), o && (f || l === t))
          return o.slice(0, Eg(o) + 1);
        if (!o || !(l = Nr(l)))
          return o;
        var y = hn(o), S = Cg(y, hn(l)) + 1;
        return bs(y, 0, S).join("");
      }
      function Ik(o, l, f) {
        if (o = ot(o), o && (f || l === t))
          return o.replace(fr, "");
        if (!o || !(l = Nr(l)))
          return o;
        var y = hn(o), S = Sg(y, hn(l));
        return bs(y, S).join("");
      }
      function Pk(o, l) {
        var f = Y, y = Z;
        if (_t(l)) {
          var S = "separator" in l ? l.separator : S;
          f = "length" in l ? Le(l.length) : f, y = "omission" in l ? Nr(l.omission) : y;
        }
        o = ot(o);
        var O = o.length;
        if (Ni(o)) {
          var P = hn(o);
          O = P.length;
        }
        if (f >= O)
          return o;
        var j = f - Bi(y);
        if (j < 1)
          return y;
        var H = P ? bs(P, 0, j).join("") : o.slice(0, j);
        if (S === t)
          return H + y;
        if (P && (j += H.length - j), jh(S)) {
          if (o.slice(j).search(S)) {
            var ee, re = H;
            for (S.global || (S = Zu(S.source, ot(Ee.exec(S)) + "g")), S.lastIndex = 0; ee = S.exec(re); )
              var se = ee.index;
            H = H.slice(0, se === t ? j : se);
          }
        } else if (o.indexOf(Nr(S), j) != j) {
          var me = H.lastIndexOf(S);
          me > -1 && (H = H.slice(0, me));
        }
        return H + y;
      }
      function Dk(o) {
        return o = ot(o), o && Pi.test(o) ? o.replace(hs, cS) : o;
      }
      var Rk = Yi(function(o, l, f) {
        return o + (f ? " " : "") + l.toUpperCase();
      }), Nh = pm("toUpperCase");
      function dv(o, l, f) {
        return o = ot(o), l = f ? t : l, l === t ? nS(o) ? hS(o) : G_(o) : o.match(l) || [];
      }
      var fv = ze(function(o, l) {
        try {
          return Lr(o, t, l);
        } catch (f) {
          return Rh(f) ? f : new Re(f);
        }
      }), jk = Yn(function(o, l) {
        return Kr(l, function(f) {
          f = On(f), Un(o, f, Ph(o[f], o));
        }), o;
      });
      function Lk(o) {
        var l = o == null ? 0 : o.length, f = Oe();
        return o = l ? mt(o, function(y) {
          if (typeof y[1] != "function")
            throw new Zr(a);
          return [f(y[0]), y[1]];
        }) : [], ze(function(y) {
          for (var S = -1; ++S < l; ) {
            var O = o[S];
            if (Lr(O[0], this, y))
              return Lr(O[1], this, y);
          }
        });
      }
      function Fk(o) {
        return cC(Qr(o, p));
      }
      function Bh(o) {
        return function() {
          return o;
        };
      }
      function Nk(o, l) {
        return o == null || o !== o ? l : o;
      }
      var Bk = mm(), Vk = mm(!0);
      function Ir(o) {
        return o;
      }
      function Vh(o) {
        return Yg(typeof o == "function" ? o : Qr(o, p));
      }
      function zk(o) {
        return Gg(Qr(o, p));
      }
      function Wk(o, l) {
        return qg(o, Qr(l, p));
      }
      var Hk = ze(function(o, l) {
        return function(f) {
          return $o(f, o, l);
        };
      }), Uk = ze(function(o, l) {
        return function(f) {
          return $o(o, f, l);
        };
      });
      function zh(o, l, f) {
        var y = Jt(l), S = mc(l, y);
        f == null && !(_t(l) && (S.length || !y.length)) && (f = l, l = o, o = this, S = mc(l, Jt(l)));
        var O = !(_t(f) && "chain" in f) || !!f.chain, P = Gn(o);
        return Kr(S, function(j) {
          var H = l[j];
          o[j] = H, P && (o.prototype[j] = function() {
            var ee = this.__chain__;
            if (O || ee) {
              var re = o(this.__wrapped__), se = re.__actions__ = Or(this.__actions__);
              return se.push({ func: H, args: arguments, thisArg: o }), re.__chain__ = ee, re;
            }
            return H.apply(o, fs([this.value()], arguments));
          });
        }), o;
      }
      function $k() {
        return er._ === this && (er._ = vS), this;
      }
      function Wh() {
      }
      function Yk(o) {
        return o = Le(o), ze(function(l) {
          return Kg(l, o);
        });
      }
      var Xk = bh(mt), Gk = bh(vg), qk = bh(Uu);
      function pv(o) {
        return Eh(o) ? $u(On(o)) : TC(o);
      }
      function Kk(o) {
        return function(l) {
          return o == null ? t : Xs(o, l);
        };
      }
      var Zk = ym(), Jk = ym(!0);
      function Hh() {
        return [];
      }
      function Uh() {
        return !1;
      }
      function Qk() {
        return {};
      }
      function eO() {
        return "";
      }
      function tO() {
        return !0;
      }
      function rO(o, l) {
        if (o = Le(o), o < 1 || o > de)
          return [];
        var f = W, y = or(o, W);
        l = Oe(l), o -= W;
        for (var S = Gu(y, l); ++f < o; )
          l(f);
        return S;
      }
      function nO(o) {
        return je(o) ? mt(o, On) : Br(o) ? [o] : Or(Rm(ot(o)));
      }
      function sO(o) {
        var l = ++gS;
        return ot(o) + l;
      }
      var iO = _c(function(o, l) {
        return o + l;
      }, 0), oO = wh("ceil"), aO = _c(function(o, l) {
        return o / l;
      }, 1), cO = wh("floor");
      function lO(o) {
        return o && o.length ? gc(o, Ir, ih) : t;
      }
      function uO(o, l) {
        return o && o.length ? gc(o, Oe(l, 2), ih) : t;
      }
      function hO(o) {
        return wg(o, Ir);
      }
      function dO(o, l) {
        return wg(o, Oe(l, 2));
      }
      function fO(o) {
        return o && o.length ? gc(o, Ir, lh) : t;
      }
      function pO(o, l) {
        return o && o.length ? gc(o, Oe(l, 2), lh) : t;
      }
      var gO = _c(function(o, l) {
        return o * l;
      }, 1), mO = wh("round"), vO = _c(function(o, l) {
        return o - l;
      }, 0);
      function yO(o) {
        return o && o.length ? Xu(o, Ir) : 0;
      }
      function bO(o, l) {
        return o && o.length ? Xu(o, Oe(l, 2)) : 0;
      }
      return E.after = z2, E.ary = $m, E.assign = OE, E.assignIn = iv, E.assignInWith = jc, E.assignWith = ME, E.at = AE, E.before = Ym, E.bind = Ph, E.bindAll = jk, E.bindKey = Xm, E.castArray = Q2, E.chain = Wm, E.chunk = cT, E.compact = lT, E.concat = uT, E.cond = Lk, E.conforms = Fk, E.constant = Bh, E.countBy = y2, E.create = IE, E.curry = Gm, E.curryRight = qm, E.debounce = Km, E.defaults = PE, E.defaultsDeep = DE, E.defer = W2, E.delay = H2, E.difference = hT, E.differenceBy = dT, E.differenceWith = fT, E.drop = pT, E.dropRight = gT, E.dropRightWhile = mT, E.dropWhile = vT, E.fill = yT, E.filter = w2, E.flatMap = S2, E.flatMapDeep = C2, E.flatMapDepth = T2, E.flatten = Nm, E.flattenDeep = bT, E.flattenDepth = wT, E.flip = U2, E.flow = Bk, E.flowRight = Vk, E.fromPairs = xT, E.functions = VE, E.functionsIn = zE, E.groupBy = E2, E.initial = ST, E.intersection = CT, E.intersectionBy = TT, E.intersectionWith = ET, E.invert = HE, E.invertBy = UE, E.invokeMap = O2, E.iteratee = Vh, E.keyBy = M2, E.keys = Jt, E.keysIn = Ar, E.map = Mc, E.mapKeys = YE, E.mapValues = XE, E.matches = zk, E.matchesProperty = Wk, E.memoize = Ic, E.merge = GE, E.mergeWith = ov, E.method = Hk, E.methodOf = Uk, E.mixin = zh, E.negate = Pc, E.nthArg = Yk, E.omit = qE, E.omitBy = KE, E.once = $2, E.orderBy = A2, E.over = Xk, E.overArgs = Y2, E.overEvery = Gk, E.overSome = qk, E.partial = Dh, E.partialRight = Zm, E.partition = I2, E.pick = ZE, E.pickBy = av, E.property = pv, E.propertyOf = Kk, E.pull = AT, E.pullAll = Vm, E.pullAllBy = IT, E.pullAllWith = PT, E.pullAt = DT, E.range = Zk, E.rangeRight = Jk, E.rearg = X2, E.reject = R2, E.remove = RT, E.rest = G2, E.reverse = Ah, E.sampleSize = L2, E.set = QE, E.setWith = ek, E.shuffle = F2, E.slice = jT, E.sortBy = V2, E.sortedUniq = WT, E.sortedUniqBy = HT, E.split = Sk, E.spread = q2, E.tail = UT, E.take = $T, E.takeRight = YT, E.takeRightWhile = XT, E.takeWhile = GT, E.tap = l2, E.throttle = K2, E.thru = Oc, E.toArray = rv, E.toPairs = cv, E.toPairsIn = lv, E.toPath = nO, E.toPlainObject = sv, E.transform = tk, E.unary = Z2, E.union = qT, E.unionBy = KT, E.unionWith = ZT, E.uniq = JT, E.uniqBy = QT, E.uniqWith = e2, E.unset = rk, E.unzip = Ih, E.unzipWith = zm, E.update = nk, E.updateWith = sk, E.values = qi, E.valuesIn = ik, E.without = t2, E.words = dv, E.wrap = J2, E.xor = r2, E.xorBy = n2, E.xorWith = s2, E.zip = i2, E.zipObject = o2, E.zipObjectDeep = a2, E.zipWith = c2, E.entries = cv, E.entriesIn = lv, E.extend = iv, E.extendWith = jc, zh(E, E), E.add = iO, E.attempt = fv, E.camelCase = lk, E.capitalize = uv, E.ceil = oO, E.clamp = ok, E.clone = eE, E.cloneDeep = rE, E.cloneDeepWith = nE, E.cloneWith = tE, E.conformsTo = sE, E.deburr = hv, E.defaultTo = Nk, E.divide = aO, E.endsWith = uk, E.eq = fn, E.escape = hk, E.escapeRegExp = dk, E.every = b2, E.find = x2, E.findIndex = Lm, E.findKey = RE, E.findLast = _2, E.findLastIndex = Fm, E.findLastKey = jE, E.floor = cO, E.forEach = Hm, E.forEachRight = Um, E.forIn = LE, E.forInRight = FE, E.forOwn = NE, E.forOwnRight = BE, E.get = Lh, E.gt = iE, E.gte = oE, E.has = WE, E.hasIn = Fh, E.head = Bm, E.identity = Ir, E.includes = k2, E.indexOf = _T, E.inRange = ak, E.invoke = $E, E.isArguments = Ks, E.isArray = je, E.isArrayBuffer = aE, E.isArrayLike = Mr, E.isArrayLikeObject = Pt, E.isBoolean = cE, E.isBuffer = ws, E.isDate = lE, E.isElement = uE, E.isEmpty = hE, E.isEqual = dE, E.isEqualWith = fE, E.isError = Rh, E.isFinite = pE, E.isFunction = Gn, E.isInteger = Jm, E.isLength = Dc, E.isMap = Qm, E.isMatch = gE, E.isMatchWith = mE, E.isNaN = vE, E.isNative = yE, E.isNil = wE, E.isNull = bE, E.isNumber = ev, E.isObject = _t, E.isObjectLike = Et, E.isPlainObject = Zo, E.isRegExp = jh, E.isSafeInteger = xE, E.isSet = tv, E.isString = Rc, E.isSymbol = Br, E.isTypedArray = Gi, E.isUndefined = _E, E.isWeakMap = SE, E.isWeakSet = CE, E.join = kT, E.kebabCase = fk, E.last = tn, E.lastIndexOf = OT, E.lowerCase = pk, E.lowerFirst = gk, E.lt = TE, E.lte = EE, E.max = lO, E.maxBy = uO, E.mean = hO, E.meanBy = dO, E.min = fO, E.minBy = pO, E.stubArray = Hh, E.stubFalse = Uh, E.stubObject = Qk, E.stubString = eO, E.stubTrue = tO, E.multiply = gO, E.nth = MT, E.noConflict = $k, E.noop = Wh, E.now = Ac, E.pad = mk, E.padEnd = vk, E.padStart = yk, E.parseInt = bk, E.random = ck, E.reduce = P2, E.reduceRight = D2, E.repeat = wk, E.replace = xk, E.result = JE, E.round = mO, E.runInContext = z, E.sample = j2, E.size = N2, E.snakeCase = _k, E.some = B2, E.sortedIndex = LT, E.sortedIndexBy = FT, E.sortedIndexOf = NT, E.sortedLastIndex = BT, E.sortedLastIndexBy = VT, E.sortedLastIndexOf = zT, E.startCase = Ck, E.startsWith = Tk, E.subtract = vO, E.sum = yO, E.sumBy = bO, E.template = Ek, E.times = rO, E.toFinite = qn, E.toInteger = Le, E.toLength = nv, E.toLower = kk, E.toNumber = rn, E.toSafeInteger = kE, E.toString = ot, E.toUpper = Ok, E.trim = Mk, E.trimEnd = Ak, E.trimStart = Ik, E.truncate = Pk, E.unescape = Dk, E.uniqueId = sO, E.upperCase = Rk, E.upperFirst = Nh, E.each = Hm, E.eachRight = Um, E.first = Bm, zh(E, function() {
        var o = {};
        return En(E, function(l, f) {
          ct.call(E.prototype, f) || (o[f] = l);
        }), o;
      }(), { chain: !1 }), E.VERSION = n, Kr(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(o) {
        E[o].placeholder = E;
      }), Kr(["drop", "take"], function(o, l) {
        $e.prototype[o] = function(f) {
          f = f === t ? 1 : Ut(Le(f), 0);
          var y = this.__filtered__ && !l ? new $e(this) : this.clone();
          return y.__filtered__ ? y.__takeCount__ = or(f, y.__takeCount__) : y.__views__.push({
            size: or(f, W),
            type: o + (y.__dir__ < 0 ? "Right" : "")
          }), y;
        }, $e.prototype[o + "Right"] = function(f) {
          return this.reverse()[o](f).reverse();
        };
      }), Kr(["filter", "map", "takeWhile"], function(o, l) {
        var f = l + 1, y = f == oe || f == Q;
        $e.prototype[o] = function(S) {
          var O = this.clone();
          return O.__iteratees__.push({
            iteratee: Oe(S, 3),
            type: f
          }), O.__filtered__ = O.__filtered__ || y, O;
        };
      }), Kr(["head", "last"], function(o, l) {
        var f = "take" + (l ? "Right" : "");
        $e.prototype[o] = function() {
          return this[f](1).value()[0];
        };
      }), Kr(["initial", "tail"], function(o, l) {
        var f = "drop" + (l ? "" : "Right");
        $e.prototype[o] = function() {
          return this.__filtered__ ? new $e(this) : this[f](1);
        };
      }), $e.prototype.compact = function() {
        return this.filter(Ir);
      }, $e.prototype.find = function(o) {
        return this.filter(o).head();
      }, $e.prototype.findLast = function(o) {
        return this.reverse().find(o);
      }, $e.prototype.invokeMap = ze(function(o, l) {
        return typeof o == "function" ? new $e(this) : this.map(function(f) {
          return $o(f, o, l);
        });
      }), $e.prototype.reject = function(o) {
        return this.filter(Pc(Oe(o)));
      }, $e.prototype.slice = function(o, l) {
        o = Le(o);
        var f = this;
        return f.__filtered__ && (o > 0 || l < 0) ? new $e(f) : (o < 0 ? f = f.takeRight(-o) : o && (f = f.drop(o)), l !== t && (l = Le(l), f = l < 0 ? f.dropRight(-l) : f.take(l - o)), f);
      }, $e.prototype.takeRightWhile = function(o) {
        return this.reverse().takeWhile(o).reverse();
      }, $e.prototype.toArray = function() {
        return this.take(W);
      }, En($e.prototype, function(o, l) {
        var f = /^(?:filter|find|map|reject)|While$/.test(l), y = /^(?:head|last)$/.test(l), S = E[y ? "take" + (l == "last" ? "Right" : "") : l], O = y || /^find/.test(l);
        S && (E.prototype[l] = function() {
          var P = this.__wrapped__, j = y ? [1] : arguments, H = P instanceof $e, ee = j[0], re = H || je(P), se = function(He) {
            var Ke = S.apply(E, fs([He], j));
            return y && me ? Ke[0] : Ke;
          };
          re && f && typeof ee == "function" && ee.length != 1 && (H = re = !1);
          var me = this.__chain__, Te = !!this.__actions__.length, Me = O && !me, Ve = H && !Te;
          if (!O && re) {
            P = Ve ? P : new $e(this);
            var Ae = o.apply(P, j);
            return Ae.__actions__.push({ func: Oc, args: [se], thisArg: t }), new Jr(Ae, me);
          }
          return Me && Ve ? o.apply(this, j) : (Ae = this.thru(se), Me ? y ? Ae.value()[0] : Ae.value() : Ae);
        });
      }), Kr(["pop", "push", "shift", "sort", "splice", "unshift"], function(o) {
        var l = ec[o], f = /^(?:push|sort|unshift)$/.test(o) ? "tap" : "thru", y = /^(?:pop|shift)$/.test(o);
        E.prototype[o] = function() {
          var S = arguments;
          if (y && !this.__chain__) {
            var O = this.value();
            return l.apply(je(O) ? O : [], S);
          }
          return this[f](function(P) {
            return l.apply(je(P) ? P : [], S);
          });
        };
      }), En($e.prototype, function(o, l) {
        var f = E[l];
        if (f) {
          var y = f.name + "";
          ct.call(Hi, y) || (Hi[y] = []), Hi[y].push({ name: l, func: f });
        }
      }), Hi[xc(t, T).name] = [{
        name: "wrapper",
        func: t
      }], $e.prototype.clone = DS, $e.prototype.reverse = RS, $e.prototype.value = jS, E.prototype.at = u2, E.prototype.chain = h2, E.prototype.commit = d2, E.prototype.next = f2, E.prototype.plant = g2, E.prototype.reverse = m2, E.prototype.toJSON = E.prototype.valueOf = E.prototype.value = v2, E.prototype.first = E.prototype.head, No && (E.prototype[No] = p2), E;
    }, Vi = dS();
    Ws ? ((Ws.exports = Vi)._ = Vi, Vu._ = Vi) : er._ = Vi;
  }).call(Jo);
})(Tl, Tl.exports);
var st = Tl.exports;
const oR = () => {
  const { trackItemIds: r, trackItemsMap: e, fps: t, trackItemDetailsMap: n } = fi(), s = st.merge(e, n);
  return /* @__PURE__ */ w.jsx(w.Fragment, { children: r.map((i) => {
    const a = s[i];
    return iR[a.type](a, {
      fps: t
    });
  }) });
};
var Yb = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(r) {
  (function() {
    var e = {}.hasOwnProperty;
    function t() {
      for (var i = "", a = 0; a < arguments.length; a++) {
        var c = arguments[a];
        c && (i = s(i, n(c)));
      }
      return i;
    }
    function n(i) {
      if (typeof i == "string" || typeof i == "number")
        return i;
      if (typeof i != "object")
        return "";
      if (Array.isArray(i))
        return t.apply(null, i);
      if (i.toString !== Object.prototype.toString && !i.toString.toString().includes("[native code]"))
        return i.toString();
      var a = "";
      for (var c in i)
        e.call(i, c) && i[c] && (a = s(a, c));
      return a;
    }
    function s(i, a) {
      return a ? i ? i + " " + a : i + a : i;
    }
    r.exports ? (t.default = t, r.exports = t) : window.classNames = t;
  })();
})(Yb);
var aR = Yb.exports;
const ca = /* @__PURE__ */ xy(aR), cR = { asChild: { type: "boolean" } }, lR = { width: { type: "string", className: "rt-r-w", customProperties: ["--width"], responsive: !0 }, minWidth: { type: "string", className: "rt-r-min-w", customProperties: ["--min-width"], responsive: !0 }, maxWidth: { type: "string", className: "rt-r-max-w", customProperties: ["--max-width"], responsive: !0 } }, uR = { height: { type: "string", className: "rt-r-h", customProperties: ["--height"], responsive: !0 }, minHeight: { type: "string", className: "rt-r-min-h", customProperties: ["--min-height"], responsive: !0 }, maxHeight: { type: "string", className: "rt-r-max-h", customProperties: ["--max-height"], responsive: !0 } }, ap = ["initial", "xs", "sm", "md", "lg", "xl"];
function Xb(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
function fa(r) {
  return typeof r == "object" && Object.keys(r).some((e) => ap.includes(e));
}
function hR({ className: r, customProperties: e, ...t }) {
  const n = Gb({ allowArbitraryValues: !0, className: r, ...t }), s = dR({ customProperties: e, ...t });
  return [n, s];
}
function Gb({ allowArbitraryValues: r, value: e, className: t, propValues: n, parseValue: s = (i) => i }) {
  const i = [];
  if (e) {
    if (typeof e == "string" && n.includes(e)) return m0(t, e, s);
    if (fa(e)) {
      const a = e;
      for (const c in a) {
        if (!Xb(a, c) || !ap.includes(c)) continue;
        const u = a[c];
        if (u !== void 0) {
          if (n.includes(u)) {
            const h = m0(t, u, s), d = c === "initial" ? h : `${c}:${h}`;
            i.push(d);
          } else if (r) {
            const h = c === "initial" ? t : `${c}:${t}`;
            i.push(h);
          }
        }
      }
      return i.join(" ");
    }
    if (r) return t;
  }
}
function m0(r, e, t) {
  const n = r ? "-" : "", s = t(e), i = s?.startsWith("-"), a = i ? "-" : "", c = i ? s?.substring(1) : s;
  return `${a}${r}${n}${c}`;
}
function dR({ customProperties: r, value: e, propValues: t, parseValue: n = (s) => s }) {
  let s = {};
  if (!(!e || typeof e == "string" && t.includes(e))) {
    if (typeof e == "string" && (s = Object.fromEntries(r.map((i) => [i, e]))), fa(e)) {
      const i = e;
      for (const a in i) {
        if (!Xb(i, a) || !ap.includes(a)) continue;
        const c = i[a];
        if (!t.includes(c)) for (const u of r) s = { [a === "initial" ? u : `${u}-${a}`]: c, ...s };
      }
    }
    for (const i in s) {
      const a = s[i];
      a !== void 0 && (s[i] = n(a));
    }
    return s;
  }
}
function v0(...r) {
  let e = {};
  for (const t of r) t && (e = { ...e, ...t });
  return Object.keys(e).length ? e : void 0;
}
function fR(...r) {
  return Object.assign({}, ...r);
}
function pR(r, ...e) {
  let t, n;
  const s = { ...r }, i = fR(...e);
  for (const a in i) {
    let c = s[a];
    const u = i[a];
    if (u.default !== void 0 && c === void 0 && (c = u.default), u.type === "enum" && ![u.default, ...u.values].includes(c) && !fa(c) && (c = u.default), s[a] = c, "className" in u && u.className) {
      delete s[a];
      const h = "responsive" in u;
      if (!c || fa(c) && !h) continue;
      if (fa(c) && (u.default !== void 0 && c.initial === void 0 && (c.initial = u.default), u.type === "enum" && ([u.default, ...u.values].includes(c.initial) || (c.initial = u.default))), u.type === "enum") {
        const d = Gb({ allowArbitraryValues: !1, value: c, className: u.className, propValues: u.values, parseValue: u.parseValue });
        t = ca(t, d);
        continue;
      }
      if (u.type === "string" || u.type === "enum | string") {
        const d = u.type === "string" ? [] : u.values, [p, g] = hR({ className: u.className, customProperties: u.customProperties, propValues: d, parseValue: u.parseValue, value: c });
        n = v0(n, g), t = ca(t, p);
        continue;
      }
      if (u.type === "boolean" && c) {
        t = ca(t, u.className);
        continue;
      }
    }
  }
  return s.className = ca(t, r.className), s.style = v0(n, r.style), s;
}
const Zs = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9"], gR = { m: { type: "enum | string", values: Zs, responsive: !0, className: "rt-r-m", customProperties: ["--m"] }, mx: { type: "enum | string", values: Zs, responsive: !0, className: "rt-r-mx", customProperties: ["--ml", "--mr"] }, my: { type: "enum | string", values: Zs, responsive: !0, className: "rt-r-my", customProperties: ["--mt", "--mb"] }, mt: { type: "enum | string", values: Zs, responsive: !0, className: "rt-r-mt", customProperties: ["--mt"] }, mr: { type: "enum | string", values: Zs, responsive: !0, className: "rt-r-mr", customProperties: ["--mr"] }, mb: { type: "enum | string", values: Zs, responsive: !0, className: "rt-r-mb", customProperties: ["--mb"] }, ml: { type: "enum | string", values: Zs, responsive: !0, className: "rt-r-ml", customProperties: ["--ml"] } }, mR = AO, Js = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], vR = { p: { type: "enum | string", className: "rt-r-p", customProperties: ["--p"], values: Js, responsive: !0 }, px: { type: "enum | string", className: "rt-r-px", customProperties: ["--pl", "--pr"], values: Js, responsive: !0 }, py: { type: "enum | string", className: "rt-r-py", customProperties: ["--pt", "--pb"], values: Js, responsive: !0 }, pt: { type: "enum | string", className: "rt-r-pt", customProperties: ["--pt"], values: Js, responsive: !0 }, pr: { type: "enum | string", className: "rt-r-pr", customProperties: ["--pr"], values: Js, responsive: !0 }, pb: { type: "enum | string", className: "rt-r-pb", customProperties: ["--pb"], values: Js, responsive: !0 }, pl: { type: "enum | string", className: "rt-r-pl", customProperties: ["--pl"], values: Js, responsive: !0 } }, ed = ["visible", "hidden", "clip", "scroll", "auto"], yR = ["static", "relative", "absolute", "fixed", "sticky"], sa = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9"], bR = ["0", "1"], wR = ["0", "1"], xR = { ...vR, ...lR, ...uR, position: { type: "enum", className: "rt-r-position", values: yR, responsive: !0 }, inset: { type: "enum | string", className: "rt-r-inset", customProperties: ["--inset"], values: sa, responsive: !0 }, top: { type: "enum | string", className: "rt-r-top", customProperties: ["--top"], values: sa, responsive: !0 }, right: { type: "enum | string", className: "rt-r-right", customProperties: ["--right"], values: sa, responsive: !0 }, bottom: { type: "enum | string", className: "rt-r-bottom", customProperties: ["--bottom"], values: sa, responsive: !0 }, left: { type: "enum | string", className: "rt-r-left", customProperties: ["--left"], values: sa, responsive: !0 }, overflow: { type: "enum", className: "rt-r-overflow", values: ed, responsive: !0 }, overflowX: { type: "enum", className: "rt-r-ox", values: ed, responsive: !0 }, overflowY: { type: "enum", className: "rt-r-oy", values: ed, responsive: !0 }, flexBasis: { type: "string", className: "rt-r-fb", customProperties: ["--flex-basis"], responsive: !0 }, flexShrink: { type: "enum | string", className: "rt-r-fs", customProperties: ["--flex-shrink"], values: bR, responsive: !0 }, flexGrow: { type: "enum | string", className: "rt-r-fg", customProperties: ["--flex-grow"], values: wR, responsive: !0 }, gridArea: { type: "string", className: "rt-r-ga", customProperties: ["--grid-area"], responsive: !0 }, gridColumn: { type: "string", className: "rt-r-gc", customProperties: ["--grid-column"], responsive: !0 }, gridColumnStart: { type: "string", className: "rt-r-gcs", customProperties: ["--grid-column-start"], responsive: !0 }, gridColumnEnd: { type: "string", className: "rt-r-gce", customProperties: ["--grid-column-end"], responsive: !0 }, gridRow: { type: "string", className: "rt-r-gr", customProperties: ["--grid-row"], responsive: !0 }, gridRowStart: { type: "string", className: "rt-r-grs", customProperties: ["--grid-row-start"], responsive: !0 }, gridRowEnd: { type: "string", className: "rt-r-gre", customProperties: ["--grid-row-end"], responsive: !0 } }, td = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], _R = { gap: { type: "enum | string", className: "rt-r-gap", customProperties: ["--gap"], values: td, responsive: !0 }, gapX: { type: "enum | string", className: "rt-r-cg", customProperties: ["--column-gap"], values: td, responsive: !0 }, gapY: { type: "enum | string", className: "rt-r-rg", customProperties: ["--row-gap"], values: td, responsive: !0 } }, SR = ["div", "span"], CR = ["none", "inline-flex", "flex"], TR = ["row", "column", "row-reverse", "column-reverse"], ER = ["start", "center", "end", "baseline", "stretch"], kR = ["start", "center", "end", "between"], OR = ["nowrap", "wrap", "wrap-reverse"], MR = { as: { type: "enum", values: SR, default: "div" }, ...cR, display: { type: "enum", className: "rt-r-display", values: CR, responsive: !0 }, direction: { type: "enum", className: "rt-r-fd", values: TR, responsive: !0 }, align: { type: "enum", className: "rt-r-ai", values: ER, responsive: !0 }, justify: { type: "enum", className: "rt-r-jc", values: kR, parseValue: AR, responsive: !0 }, wrap: { type: "enum", className: "rt-r-fw", values: OR, responsive: !0 }, ..._R };
function AR(r) {
  return r === "between" ? "space-between" : r;
}
const cp = m.forwardRef((r, e) => {
  const { className: t, asChild: n, as: s = "div", ...i } = pR(r, MR, xR, gR);
  return m.createElement(n ? mR : s, { ...i, ref: e, className: ca("rt-Flex", t) });
});
cp.displayName = "Flex";
const IR = () => {
  const r = m.useRef(null), { setPlayerRef: e, duration: t, fps: n, size: s } = fi();
  return m.useEffect(() => {
    e(r);
  }, []), /* @__PURE__ */ w.jsx(cp, { className: "size-full", children: /* @__PURE__ */ w.jsx(
    JD,
    {
      ref: r,
      component: oR,
      durationInFrames: Math.round(t / 1e3 * n) || 5 * 30,
      compositionWidth: 1920,
      compositionHeight: 1080,
      style: { width: "100%", height: "100%" },
      inputProps: {},
      fps: n,
      controls: !0
    }
  ) });
}, PR = ({ scrollLeft: r }) => {
  const e = m.useRef(null), { playerRef: t, fps: n, scale: s } = fi(), i = Vf(t ?? void 0), a = Nt(i / n * 1e3, s.zoom) - r, [c, u] = m.useState(!1), [h, d] = m.useState(0), [p, g] = m.useState(a), v = () => {
    u(!1);
  }, b = (C) => {
    u(!0);
    const T = "touches" in C ? C.touches[0].clientX : C.clientX;
    d(T), g(a);
  }, _ = (C) => {
    if (c) {
      const k = ("touches" in C ? C.touches[0].clientX : C.clientX) - h, M = p + k, A = di(M, s.zoom);
      t?.current?.seekTo(A * n / 1e3);
    }
  };
  return m.useEffect(() => {
    const C = (T) => {
      T.preventDefault();
    };
    return c ? (document.addEventListener("mousemove", _), document.addEventListener("mouseup", v), document.addEventListener("touchmove", _), document.addEventListener("touchend", v), document.addEventListener("dragstart", C)) : (document.removeEventListener("mousemove", _), document.removeEventListener("mouseup", v), document.removeEventListener("touchmove", _), document.removeEventListener("touchend", v)), () => {
      document.removeEventListener("mousemove", _), document.removeEventListener("mouseup", v), document.removeEventListener("touchmove", _), document.removeEventListener("touchend", v), document.removeEventListener("dragstart", C);
    };
  }, [c, _, v]), /* @__PURE__ */ w.jsx(
    "div",
    {
      ref: e,
      role: "button",
      tabIndex: 0,
      onMouseDown: (C) => {
        b(C);
      },
      onTouchStart: (C) => {
        b(C);
      },
      onKeyDown: (C) => {
        (C.key === "Enter" || C.key === " ") && b(C);
      },
      style: {
        position: "absolute",
        left: 40 + Bf + a,
        top: 80,
        width: 1,
        height: "calc(100% - 80px)",
        background: "#d4d4d8",
        zIndex: 10,
        cursor: "pointer"
      },
      children: /* @__PURE__ */ w.jsxs("div", { className: "relative h-full", children: [
        /* @__PURE__ */ w.jsx("div", { className: "absolute top-0  h-full w-3 -translate-x-1/2" }),
        /* @__PURE__ */ w.jsx("div", { className: "absolute top-0  h-full w-0.5 -translate-x-1/2 bg-white/50" }),
        /* @__PURE__ */ w.jsx(
          "div",
          {
            style: {
              borderRadius: "0 0 20px 20px"
            },
            className: "absolute h-3 -translate-x-1/2 px-1.5",
            children: /* @__PURE__ */ w.jsx(
              "svg",
              {
                height: "12",
                viewBox: "0 0 12 12",
                fill: "none",
                children: /* @__PURE__ */ w.jsx(
                  "path",
                  {
                    fill: "currentColor",
                    d: "M11.6585 7.04881L6.6585 11.4238C6.28148 11.7537 5.71852 11.7537 5.3415 11.4238L0.341495 7.04881C0.12448 6.85892 0 6.58459 0 6.29623V1C0 0.447715 0.447715 0 1 0H11C11.5523 0 12 0.447715 12 1V6.29623C12 6.58459 11.8755 6.85892 11.6585 7.04881Z"
                  }
                )
              }
            )
          }
        )
      ] })
    }
  );
}, DR = (r) => {
  const {
    height: e = 40,
    // Increased height to give space for the text
    longLineSize: t = 8,
    shortLineSize: n = 6,
    offsetX: s = zd + Bf,
    textOffsetY: i = 12,
    // Place the text above the lines but inside the canvas
    textFormat: a = t5,
    scrollLeft: c = 0,
    onClick: u
  } = r, { scale: h } = fi(), d = m.useRef(null), [p, g] = m.useState(null), [v, b] = m.useState({
    width: 0,
    height: e
    // Increased height for text space
  });
  m.useEffect(() => {
    const k = d.current;
    if (k) {
      const M = k.getContext("2d");
      g(M), _(k, M, c);
    }
  }, []), m.useEffect(() => {
    p && _(d.current, p, c);
  }, [p, c, h]);
  const _ = (k, M, A) => {
    if (!k || !M) return;
    const F = k.offsetParent.offsetWidth ?? k.offsetWidth, U = v.height;
    k.width = F, k.height = U, C(M, A, F, U), b({ width: F, height: U });
  }, C = (k, M, A, D) => {
    const F = h.zoom, U = h.unit, B = h.segments;
    k.clearRect(0, 0, A, D), k.save(), k.strokeStyle = "#71717a", k.fillStyle = "#71717a", k.lineWidth = 1, k.font = `${qA}px ${KA}`, k.textBaseline = "top", k.translate(0.5, 0), k.beginPath();
    const X = U * F * tu, Y = Math.floor(M / X), G = Math.ceil((M + A) / X) - Y;
    for (let K = 0; K <= G; ++K) {
      const oe = K + Y;
      if (oe < 0) continue;
      const ve = oe * X / F, Q = (ve - M / F) * F;
      if (Q < -X || Q >= A + X) continue;
      const ge = a(ve), ne = -k.measureText(ge).width / 2;
      k.fillText(ge, Q + ne + s, i);
    }
    for (let K = 0; K <= G; ++K) {
      const oe = K + Y;
      if (oe < 0) continue;
      const Q = oe * X - M + s;
      for (let ge = 0; ge < B; ++ge) {
        const de = Q + ge / B * X;
        if (de < 0 || de >= A) continue;
        const ne = ge % B ? n : t;
        ne === n ? k.strokeStyle = "#a1a1aa" : k.strokeStyle = "#d4d4d8";
        const I = 32, [W, ce] = [de, I], [fe, be] = [W, ce + ne];
        k.beginPath(), k.moveTo(W, ce), k.lineTo(fe, be), k.stroke();
      }
    }
    k.restore();
  }, T = (k) => {
    const M = d.current;
    if (!M) return;
    const A = M.getBoundingClientRect(), F = k.clientX - A.left + c - zd;
    u?.(F);
  };
  return /* @__PURE__ */ w.jsx(
    "div",
    {
      className: "border-border border-t",
      style: {
        position: "relative",
        width: "100%",
        height: `${v.height}px`,
        backgroundColor: "transparent"
      },
      children: /* @__PURE__ */ w.jsx(
        "canvas",
        {
          onClick: T,
          ref: d,
          height: v.height
        }
      )
    }
  );
}, e9 = () => /* @__PURE__ */ w.jsx(
  cp,
  {
    flexGrow: "1",
    justify: "center",
    width: "100%",
    height: "100%",
    className: "bg-scene py-3",
    children: /* @__PURE__ */ w.jsx("div", { className: "max-w-3xl flex-1  w-full h-full flex relative", children: /* @__PURE__ */ w.jsx(IR, {}) })
  }
);
function N(r, e, t) {
  return (e = function(n) {
    var s = function(i, a) {
      if (typeof i != "object" || !i) return i;
      var c = i[Symbol.toPrimitive];
      if (c !== void 0) {
        var u = c.call(i, a);
        if (typeof u != "object") return u;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (a === "string" ? String : Number)(i);
    }(n, "string");
    return typeof s == "symbol" ? s : s + "";
  }(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function y0(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function L(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? y0(Object(t), !0).forEach(function(n) {
      N(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : y0(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function yt(r, e) {
  if (r == null) return {};
  var t, n, s = function(a, c) {
    if (a == null) return {};
    var u = {};
    for (var h in a) if ({}.hasOwnProperty.call(a, h)) {
      if (c.indexOf(h) >= 0) continue;
      u[h] = a[h];
    }
    return u;
  }(r, e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(r);
    for (n = 0; n < i.length; n++) t = i[n], e.indexOf(t) >= 0 || {}.propertyIsEnumerable.call(r, t) && (s[t] = r[t]);
  }
  return s;
}
function Fs(r, e) {
  return e || (e = r.slice(0)), Object.freeze(Object.defineProperties(r, { raw: { value: Object.freeze(e) } }));
}
class b0 {
  constructor() {
    N(this, "browserShadowBlurConstant", 1), N(this, "DPI", 96), N(this, "devicePixelRatio", typeof window < "u" ? window.devicePixelRatio : 1), N(this, "perfLimitSizeTotal", 2097152), N(this, "maxCacheSideLimit", 4096), N(this, "minCacheSideLimit", 256), N(this, "disableStyleCopyPaste", !1), N(this, "enableGLFiltering", !0), N(this, "textureSize", 4096), N(this, "forceGLPutImageData", !1), N(this, "cachesBoundsOfCurve", !1), N(this, "fontPaths", {}), N(this, "NUM_FRACTION_DIGITS", 4);
  }
}
const et = new class extends b0 {
  constructor(r) {
    super(), this.configure(r);
  }
  configure() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.assign(this, r);
  }
  addFonts() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.fontPaths = L(L({}, this.fontPaths), r);
  }
  removeFonts() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((r) => {
      delete this.fontPaths[r];
    });
  }
  clearFonts() {
    this.fontPaths = {};
  }
  restoreDefaults(r) {
    const e = new b0(), t = r?.reduce((n, s) => (n[s] = e[s], n), {}) || e;
    this.configure(t);
  }
}(), ks = function(r) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) t[n - 1] = arguments[n];
  return console[r]("fabric", ...t);
};
class Pn extends Error {
  constructor(e, t) {
    super("fabric: ".concat(e), t);
  }
}
class qb extends Pn {
  constructor(e) {
    super("".concat(e, " 'options.signal' is in 'aborted' state"));
  }
}
class RR {
}
class jR extends RR {
  testPrecision(e, t) {
    const n = "precision ".concat(t, ` float;
void main(){}`), s = e.createShader(e.FRAGMENT_SHADER);
    return !!s && (e.shaderSource(s, n), e.compileShader(s), !!e.getShaderParameter(s, e.COMPILE_STATUS));
  }
  queryWebGL(e) {
    const t = e.getContext("webgl");
    t && (this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), this.GLPrecision = ["highp", "mediump", "lowp"].find((n) => this.testPrecision(t, n)), t.getExtension("WEBGL_lose_context").loseContext(), ks("log", "WebGL: max texture size ".concat(this.maxTextureSize)));
  }
  isSupported(e) {
    return !!this.maxTextureSize && this.maxTextureSize >= e;
  }
}
const LR = {};
let w0;
const Fn = () => w0 || (w0 = { document, window, isTouchSupported: "ontouchstart" in window || "ontouchstart" in document || window && window.navigator && window.navigator.maxTouchPoints > 0, WebGLProbe: new jR(), dispose() {
}, copyPasteData: LR }), Eo = () => Fn().document, pu = () => Fn().window, Kb = () => {
  var r;
  return Math.max((r = et.devicePixelRatio) !== null && r !== void 0 ? r : pu().devicePixelRatio, 1);
}, pa = new class {
  constructor() {
    N(this, "charWidthsCache", {}), N(this, "boundsOfCurveCache", {});
  }
  getFontCache(r) {
    let { fontFamily: e, fontStyle: t, fontWeight: n } = r;
    e = e.toLowerCase(), this.charWidthsCache[e] || (this.charWidthsCache[e] = {});
    const s = this.charWidthsCache[e], i = "".concat(t.toLowerCase(), "_").concat((n + "").toLowerCase());
    return s[i] || (s[i] = {}), s[i];
  }
  clearFontCache(r) {
    (r = (r || "").toLowerCase()) ? this.charWidthsCache[r] && delete this.charWidthsCache[r] : this.charWidthsCache = {};
  }
  limitDimsByArea(r) {
    const { perfLimitSizeTotal: e } = et, t = Math.sqrt(e * r);
    return [Math.floor(t), Math.floor(e / t)];
  }
}(), tf = "6.5.4";
function ui() {
}
const Os = Math.PI / 2, os = 2 * Math.PI, lp = Math.PI / 180, _r = Object.freeze([1, 0, 0, 1, 0, 0]), up = 16, Ss = 0.4477152502, Be = "center", at = "left", Pr = "top", rf = "bottom", Rt = "right", Dr = "none", hp = /\r?\n/, Zb = "moving", gu = "scaling", Jb = "rotating", dp = "rotate", Qb = "skewing", Sa = "resizing", ew = "modifyPoly", FR = "modifyPath", El = "changed", mu = "scale", Sr = "scaleX", $r = "scaleY", ko = "skewX", Oo = "skewY", Xt = "fill", Rr = "stroke", kl = "modified", Zi = "json", rd = "svg", le = new class {
  constructor() {
    this[Zi] = /* @__PURE__ */ new Map(), this[rd] = /* @__PURE__ */ new Map();
  }
  has(r) {
    return this[Zi].has(r);
  }
  getClass(r) {
    const e = this[Zi].get(r);
    if (!e) throw new Pn("No class registered for ".concat(r));
    return e;
  }
  setClass(r, e) {
    e ? this[Zi].set(e, r) : (this[Zi].set(r.type, r), this[Zi].set(r.type.toLowerCase(), r));
  }
  getSVGClass(r) {
    return this[rd].get(r);
  }
  setSVGClass(r, e) {
    this[rd].set(e ?? r.type.toLowerCase(), r);
  }
}(), Ol = new class extends Array {
  remove(r) {
    const e = this.indexOf(r);
    e > -1 && this.splice(e, 1);
  }
  cancelAll() {
    const r = this.splice(0);
    return r.forEach((e) => e.abort()), r;
  }
  cancelByCanvas(r) {
    if (!r) return [];
    const e = this.filter((t) => {
      var n;
      return t.target === r || typeof t.target == "object" && ((n = t.target) === null || n === void 0 ? void 0 : n.canvas) === r;
    });
    return e.forEach((t) => t.abort()), e;
  }
  cancelByTarget(r) {
    if (!r) return [];
    const e = this.filter((t) => t.target === r);
    return e.forEach((t) => t.abort()), e;
  }
}();
class NR {
  constructor() {
    N(this, "__eventListeners", {});
  }
  on(e, t) {
    if (this.__eventListeners || (this.__eventListeners = {}), typeof e == "object") return Object.entries(e).forEach((n) => {
      let [s, i] = n;
      this.on(s, i);
    }), () => this.off(e);
    if (t) {
      const n = e;
      return this.__eventListeners[n] || (this.__eventListeners[n] = []), this.__eventListeners[n].push(t), () => this.off(n, t);
    }
    return () => !1;
  }
  once(e, t) {
    if (typeof e == "object") {
      const n = [];
      return Object.entries(e).forEach((s) => {
        let [i, a] = s;
        n.push(this.once(i, a));
      }), () => n.forEach((s) => s());
    }
    if (t) {
      const n = this.on(e, function() {
        for (var s = arguments.length, i = new Array(s), a = 0; a < s; a++) i[a] = arguments[a];
        t.call(this, ...i), n();
      });
      return n;
    }
    return () => !1;
  }
  _removeEventListener(e, t) {
    if (this.__eventListeners[e]) if (t) {
      const n = this.__eventListeners[e], s = n.indexOf(t);
      s > -1 && n.splice(s, 1);
    } else this.__eventListeners[e] = [];
  }
  off(e, t) {
    if (this.__eventListeners) if (e === void 0) for (const n in this.__eventListeners) this._removeEventListener(n);
    else typeof e == "object" ? Object.entries(e).forEach((n) => {
      let [s, i] = n;
      this._removeEventListener(s, i);
    }) : this._removeEventListener(e, t);
  }
  fire(e, t) {
    var n;
    if (!this.__eventListeners) return;
    const s = (n = this.__eventListeners[e]) === null || n === void 0 ? void 0 : n.concat();
    if (s) for (let i = 0; i < s.length; i++) s[i].call(this, t || {});
  }
}
const ti = (r, e) => {
  const t = r.indexOf(e);
  return t !== -1 && r.splice(t, 1), r;
}, wn = (r) => {
  if (r === 0) return 1;
  switch (Math.abs(r) / Os) {
    case 1:
    case 3:
      return 0;
    case 2:
      return -1;
  }
  return Math.cos(r);
}, xn = (r) => {
  if (r === 0) return 0;
  const e = r / Os, t = Math.sign(r);
  switch (e) {
    case 1:
      return t;
    case 2:
      return 0;
    case 3:
      return -t;
  }
  return Math.sin(r);
};
class $ {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    typeof e == "object" ? (this.x = e.x, this.y = e.y) : (this.x = e, this.y = t);
  }
  add(e) {
    return new $(this.x + e.x, this.y + e.y);
  }
  addEquals(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  scalarAdd(e) {
    return new $(this.x + e, this.y + e);
  }
  scalarAddEquals(e) {
    return this.x += e, this.y += e, this;
  }
  subtract(e) {
    return new $(this.x - e.x, this.y - e.y);
  }
  subtractEquals(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  scalarSubtract(e) {
    return new $(this.x - e, this.y - e);
  }
  scalarSubtractEquals(e) {
    return this.x -= e, this.y -= e, this;
  }
  multiply(e) {
    return new $(this.x * e.x, this.y * e.y);
  }
  scalarMultiply(e) {
    return new $(this.x * e, this.y * e);
  }
  scalarMultiplyEquals(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return new $(this.x / e.x, this.y / e.y);
  }
  scalarDivide(e) {
    return new $(this.x / e, this.y / e);
  }
  scalarDivideEquals(e) {
    return this.x /= e, this.y /= e, this;
  }
  eq(e) {
    return this.x === e.x && this.y === e.y;
  }
  lt(e) {
    return this.x < e.x && this.y < e.y;
  }
  lte(e) {
    return this.x <= e.x && this.y <= e.y;
  }
  gt(e) {
    return this.x > e.x && this.y > e.y;
  }
  gte(e) {
    return this.x >= e.x && this.y >= e.y;
  }
  lerp(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;
    return t = Math.max(Math.min(1, t), 0), new $(this.x + (e.x - this.x) * t, this.y + (e.y - this.y) * t);
  }
  distanceFrom(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return Math.sqrt(t * t + n * n);
  }
  midPointFrom(e) {
    return this.lerp(e);
  }
  min(e) {
    return new $(Math.min(this.x, e.x), Math.min(this.y, e.y));
  }
  max(e) {
    return new $(Math.max(this.x, e.x), Math.max(this.y, e.y));
  }
  toString() {
    return "".concat(this.x, ",").concat(this.y);
  }
  setXY(e, t) {
    return this.x = e, this.y = t, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setFromPoint(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  swap(e) {
    const t = this.x, n = this.y;
    this.x = e.x, this.y = e.y, e.x = t, e.y = n;
  }
  clone() {
    return new $(this.x, this.y);
  }
  rotate(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fp;
    const n = xn(e), s = wn(e), i = this.subtract(t);
    return new $(i.x * s - i.y * n, i.x * n + i.y * s).add(t);
  }
  transform(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    return new $(e[0] * this.x + e[2] * this.y + (t ? 0 : e[4]), e[1] * this.x + e[3] * this.y + (t ? 0 : e[5]));
  }
}
const fp = new $(0, 0), pl = (r) => !!r && Array.isArray(r._objects);
function tw(r) {
  class e extends r {
    constructor() {
      super(...arguments), N(this, "_objects", []);
    }
    _onObjectAdded(n) {
    }
    _onObjectRemoved(n) {
    }
    _onStackOrderChanged(n) {
    }
    add() {
      for (var n = arguments.length, s = new Array(n), i = 0; i < n; i++) s[i] = arguments[i];
      const a = this._objects.push(...s);
      return s.forEach((c) => this._onObjectAdded(c)), a;
    }
    insertAt(n) {
      for (var s = arguments.length, i = new Array(s > 1 ? s - 1 : 0), a = 1; a < s; a++) i[a - 1] = arguments[a];
      return this._objects.splice(n, 0, ...i), i.forEach((c) => this._onObjectAdded(c)), this._objects.length;
    }
    remove() {
      const n = this._objects, s = [];
      for (var i = arguments.length, a = new Array(i), c = 0; c < i; c++) a[c] = arguments[c];
      return a.forEach((u) => {
        const h = n.indexOf(u);
        h !== -1 && (n.splice(h, 1), s.push(u), this._onObjectRemoved(u));
      }), s;
    }
    forEachObject(n) {
      this.getObjects().forEach((s, i, a) => n(s, i, a));
    }
    getObjects() {
      for (var n = arguments.length, s = new Array(n), i = 0; i < n; i++) s[i] = arguments[i];
      return s.length === 0 ? [...this._objects] : this._objects.filter((a) => a.isType(...s));
    }
    item(n) {
      return this._objects[n];
    }
    isEmpty() {
      return this._objects.length === 0;
    }
    size() {
      return this._objects.length;
    }
    contains(n, s) {
      return !!this._objects.includes(n) || !!s && this._objects.some((i) => i instanceof e && i.contains(n, !0));
    }
    complexity() {
      return this._objects.reduce((n, s) => n += s.complexity ? s.complexity() : 0, 0);
    }
    sendObjectToBack(n) {
      return !(!n || n === this._objects[0]) && (ti(this._objects, n), this._objects.unshift(n), this._onStackOrderChanged(n), !0);
    }
    bringObjectToFront(n) {
      return !(!n || n === this._objects[this._objects.length - 1]) && (ti(this._objects, n), this._objects.push(n), this._onStackOrderChanged(n), !0);
    }
    sendObjectBackwards(n, s) {
      if (!n) return !1;
      const i = this._objects.indexOf(n);
      if (i !== 0) {
        const a = this.findNewLowerIndex(n, i, s);
        return ti(this._objects, n), this._objects.splice(a, 0, n), this._onStackOrderChanged(n), !0;
      }
      return !1;
    }
    bringObjectForward(n, s) {
      if (!n) return !1;
      const i = this._objects.indexOf(n);
      if (i !== this._objects.length - 1) {
        const a = this.findNewUpperIndex(n, i, s);
        return ti(this._objects, n), this._objects.splice(a, 0, n), this._onStackOrderChanged(n), !0;
      }
      return !1;
    }
    moveObjectTo(n, s) {
      return n !== this._objects[s] && (ti(this._objects, n), this._objects.splice(s, 0, n), this._onStackOrderChanged(n), !0);
    }
    findNewLowerIndex(n, s, i) {
      let a;
      if (i) {
        a = s;
        for (let c = s - 1; c >= 0; --c) if (n.isOverlapping(this._objects[c])) {
          a = c;
          break;
        }
      } else a = s - 1;
      return a;
    }
    findNewUpperIndex(n, s, i) {
      let a;
      if (i) {
        a = s;
        for (let c = s + 1; c < this._objects.length; ++c) if (n.isOverlapping(this._objects[c])) {
          a = c;
          break;
        }
      } else a = s + 1;
      return a;
    }
    collectObjects(n) {
      let { left: s, top: i, width: a, height: c } = n, { includeIntersecting: u = !0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const h = [], d = new $(s, i), p = d.add(new $(a, c));
      for (let g = this._objects.length - 1; g >= 0; g--) {
        const v = this._objects[g];
        v.selectable && v.visible && (u && v.intersectsWithRect(d, p) || v.isContainedWithinRect(d, p) || u && v.containsPoint(d) || u && v.containsPoint(p)) && h.push(v);
      }
      return h;
    }
  }
  return e;
}
class rw extends NR {
  _setOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    for (const t in e) this.set(t, e[t]);
  }
  _setObject(e) {
    for (const t in e) this._set(t, e[t]);
  }
  set(e, t) {
    return typeof e == "object" ? this._setObject(e) : this._set(e, t), this;
  }
  _set(e, t) {
    this[e] = t;
  }
  toggle(e) {
    const t = this.get(e);
    return typeof t == "boolean" && this.set(e, !t), this;
  }
  get(e) {
    return this[e];
  }
}
function ga(r) {
  return pu().requestAnimationFrame(r);
}
function nw(r) {
  return pu().cancelAnimationFrame(r);
}
let BR = 0;
const Ms = () => BR++, cn = () => {
  const r = Eo().createElement("canvas");
  if (!r || r.getContext === void 0) throw new Pn("Failed to create `canvas` element");
  return r;
}, sw = () => Eo().createElement("img"), _n = (r) => {
  const e = cn();
  return e.width = r.width, e.height = r.height, e;
}, pp = (r, e, t) => r.toDataURL("image/".concat(e), t), Mt = (r) => r * lp, As = (r) => r / lp, iw = (r) => r.every((e, t) => e === _r[t]), ur = (r, e, t) => new $(r).transform(e, t), Ur = (r) => {
  const e = 1 / (r[0] * r[3] - r[1] * r[2]), t = [e * r[3], -e * r[1], -e * r[2], e * r[0], 0, 0], { x: n, y: s } = new $(r[4], r[5]).transform(t, !0);
  return t[4] = -n, t[5] = -s, t;
}, At = (r, e, t) => [r[0] * e[0] + r[2] * e[1], r[1] * e[0] + r[3] * e[1], r[0] * e[2] + r[2] * e[3], r[1] * e[2] + r[3] * e[3], t ? 0 : r[0] * e[4] + r[2] * e[5] + r[4], t ? 0 : r[1] * e[4] + r[3] * e[5] + r[5]], vu = (r, e) => r.reduceRight((t, n) => n && t ? At(n, t, e) : n || t, void 0) || _r.concat(), ow = (r) => {
  let [e, t] = r;
  return Math.atan2(t, e);
}, lo = (r) => {
  const e = ow(r), t = Math.pow(r[0], 2) + Math.pow(r[1], 2), n = Math.sqrt(t), s = (r[0] * r[3] - r[2] * r[1]) / n, i = Math.atan2(r[0] * r[2] + r[1] * r[3], t);
  return { angle: As(e), scaleX: n, scaleY: s, skewX: As(i), skewY: 0, translateX: r[4] || 0, translateY: r[5] || 0 };
}, Mo = function(r) {
  return [1, 0, 0, 1, r, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0];
};
function Ao() {
  let { angle: r = 0 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { x: e = 0, y: t = 0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const n = Mt(r), s = wn(n), i = xn(n);
  return [s, i, -i, s, e ? e - (s * e - i * t) : 0, t ? t - (i * e + s * t) : 0];
}
const yu = function(r) {
  return [r, 0, 0, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : r, 0, 0];
}, aw = (r) => Math.tan(Mt(r)), gp = (r) => [1, 0, aw(r), 1, 0, 0], mp = (r) => [1, aw(r), 0, 1, 0, 0], za = (r) => {
  let { scaleX: e = 1, scaleY: t = 1, flipX: n = !1, flipY: s = !1, skewX: i = 0, skewY: a = 0 } = r, c = yu(n ? -e : e, s ? -t : t);
  return i && (c = At(c, gp(i), !0)), a && (c = At(c, mp(a), !0)), c;
}, cw = (r) => {
  const { translateX: e = 0, translateY: t = 0, angle: n = 0 } = r;
  let s = Mo(e, t);
  n && (s = At(s, Ao({ angle: n })));
  const i = za(r);
  return iw(i) || (s = At(s, i)), s;
}, ma = function(r) {
  let { signal: e, crossOrigin: t = null } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise(function(n, s) {
    if (e && e.aborted) return s(new qb("loadImage"));
    const i = sw();
    let a;
    e && (a = function(u) {
      i.src = "", s(u);
    }, e.addEventListener("abort", a, { once: !0 }));
    const c = function() {
      i.onload = i.onerror = null, a && e?.removeEventListener("abort", a), n(i);
    };
    r ? (i.onload = c, i.onerror = function() {
      a && e?.removeEventListener("abort", a), s(new Pn("Error loading ".concat(i.src)));
    }, t && (i.crossOrigin = t), i.src = r) : c();
  });
}, uo = function(r) {
  let { signal: e, reviver: t = ui } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((n, s) => {
    const i = [];
    e && e.addEventListener("abort", s, { once: !0 }), Promise.all(r.map((a) => le.getClass(a.type).fromObject(a, { signal: e }).then((c) => (t(a, c), i.push(c), c)))).then(n).catch((a) => {
      i.forEach((c) => {
        c.dispose && c.dispose();
      }), s(a);
    }).finally(() => {
      e && e.removeEventListener("abort", s);
    });
  });
}, Wa = function(r) {
  let { signal: e } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((t, n) => {
    const s = [];
    e && e.addEventListener("abort", n, { once: !0 });
    const i = Object.values(r).map((c) => c && c.type && le.has(c.type) ? uo([c], { signal: e }).then((u) => {
      let [h] = u;
      return s.push(h), h;
    }) : c), a = Object.keys(r);
    Promise.all(i).then((c) => c.reduce((u, h, d) => (u[a[d]] = h, u), {})).then(t).catch((c) => {
      s.forEach((u) => {
        u.dispose && u.dispose();
      }), n(c);
    }).finally(() => {
      e && e.removeEventListener("abort", n);
    });
  });
}, ki = function(r) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []).reduce((e, t) => (t in r && (e[t] = r[t]), e), {});
}, vp = (r, e) => Object.keys(r).reduce((t, n) => (e(r[n], n, r) && (t[n] = r[n]), t), {}), x0 = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aqua: "#0FF", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000", blanchedalmond: "#FFEBCD", blue: "#00F", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#0FF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgrey: "#A9A9A9", darkgreen: "#006400", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", fuchsia: "#F0F", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", gray: "#808080", grey: "#808080", green: "#008000", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgray: "#D3D3D3", lightgrey: "#D3D3D3", lightgreen: "#90EE90", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#789", lightslategrey: "#789", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", lime: "#0F0", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#F0F", maroon: "#800000", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", navy: "#000080", oldlace: "#FDF5E6", olive: "#808000", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", purple: "#800080", rebeccapurple: "#639", red: "#F00", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", silver: "#C0C0C0", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", teal: "#008080", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", white: "#FFF", whitesmoke: "#F5F5F5", yellow: "#FF0", yellowgreen: "#9ACD32" }, nd = (r, e, t) => (t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? r + 6 * (e - r) * t : t < 0.5 ? e : t < 2 / 3 ? r + (e - r) * (2 / 3 - t) * 6 : r), _0 = (r, e, t, n) => {
  r /= 255, e /= 255, t /= 255;
  const s = Math.max(r, e, t), i = Math.min(r, e, t);
  let a, c;
  const u = (s + i) / 2;
  if (s === i) a = c = 0;
  else {
    const h = s - i;
    switch (c = u > 0.5 ? h / (2 - s - i) : h / (s + i), s) {
      case r:
        a = (e - t) / h + (e < t ? 6 : 0);
        break;
      case e:
        a = (t - r) / h + 2;
        break;
      case t:
        a = (r - e) / h + 4;
    }
    a /= 6;
  }
  return [Math.round(360 * a), Math.round(100 * c), Math.round(100 * u), n];
}, S0 = function() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "1";
  return parseFloat(r) / (r.endsWith("%") ? 100 : 1);
}, zc = (r) => Math.min(Math.round(r), 255).toString(16).toUpperCase().padStart(2, "0"), C0 = (r) => {
  let [e, t, n, s = 1] = r;
  const i = Math.round(0.3 * e + 0.59 * t + 0.11 * n);
  return [i, i, i, s];
};
class lt {
  constructor(e) {
    if (N(this, "isUnrecognised", !1), e) if (e instanceof lt) this.setSource([...e._source]);
    else if (Array.isArray(e)) {
      const [t, n, s, i = 1] = e;
      this.setSource([t, n, s, i]);
    } else this.setSource(this._tryParsingColor(e));
    else this.setSource([0, 0, 0, 1]);
  }
  _tryParsingColor(e) {
    return (e = e.toLowerCase()) in x0 && (e = x0[e]), e === "transparent" ? [255, 255, 255, 0] : lt.sourceFromHex(e) || lt.sourceFromRgb(e) || lt.sourceFromHsl(e) || (this.isUnrecognised = !0) && [0, 0, 0, 1];
  }
  getSource() {
    return this._source;
  }
  setSource(e) {
    this._source = e;
  }
  toRgb() {
    const [e, t, n] = this.getSource();
    return "rgb(".concat(e, ",").concat(t, ",").concat(n, ")");
  }
  toRgba() {
    return "rgba(".concat(this.getSource().join(","), ")");
  }
  toHsl() {
    const [e, t, n] = _0(...this.getSource());
    return "hsl(".concat(e, ",").concat(t, "%,").concat(n, "%)");
  }
  toHsla() {
    const [e, t, n, s] = _0(...this.getSource());
    return "hsla(".concat(e, ",").concat(t, "%,").concat(n, "%,").concat(s, ")");
  }
  toHex() {
    return this.toHexa().slice(0, 6);
  }
  toHexa() {
    const [e, t, n, s] = this.getSource();
    return "".concat(zc(e)).concat(zc(t)).concat(zc(n)).concat(zc(Math.round(255 * s)));
  }
  getAlpha() {
    return this.getSource()[3];
  }
  setAlpha(e) {
    return this._source[3] = e, this;
  }
  toGrayscale() {
    return this.setSource(C0(this.getSource())), this;
  }
  toBlackWhite(e) {
    const [t, , , n] = C0(this.getSource()), s = t < (e || 127) ? 0 : 255;
    return this.setSource([s, s, s, n]), this;
  }
  overlayWith(e) {
    e instanceof lt || (e = new lt(e));
    const t = this.getSource(), n = e.getSource(), [s, i, a] = t.map((c, u) => Math.round(0.5 * c + 0.5 * n[u]));
    return this.setSource([s, i, a, t[3]]), this;
  }
  static fromRgb(e) {
    return lt.fromRgba(e);
  }
  static fromRgba(e) {
    return new lt(lt.sourceFromRgb(e));
  }
  static sourceFromRgb(e) {
    const t = e.match(/^rgba?\(\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*(?:\s*[,/]\s*(\d{0,3}(?:\.\d+)?%?)\s*)?\)$/i);
    if (t) {
      const [n, s, i] = t.slice(1, 4).map((a) => {
        const c = parseFloat(a);
        return a.endsWith("%") ? Math.round(2.55 * c) : c;
      });
      return [n, s, i, S0(t[4])];
    }
  }
  static fromHsl(e) {
    return lt.fromHsla(e);
  }
  static fromHsla(e) {
    return new lt(lt.sourceFromHsl(e));
  }
  static sourceFromHsl(e) {
    const t = e.match(/^hsla?\(\s*([+-]?\d{0,3}(?:\.\d+)?(?:deg|turn|rad)?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*(?:\s*[,/]\s*(\d*(?:\.\d+)?%?)\s*)?\)$/i);
    if (!t) return;
    const n = (lt.parseAngletoDegrees(t[1]) % 360 + 360) % 360 / 360, s = parseFloat(t[2]) / 100, i = parseFloat(t[3]) / 100;
    let a, c, u;
    if (s === 0) a = c = u = i;
    else {
      const h = i <= 0.5 ? i * (s + 1) : i + s - i * s, d = 2 * i - h;
      a = nd(d, h, n + 1 / 3), c = nd(d, h, n), u = nd(d, h, n - 1 / 3);
    }
    return [Math.round(255 * a), Math.round(255 * c), Math.round(255 * u), S0(t[4])];
  }
  static fromHex(e) {
    return new lt(lt.sourceFromHex(e));
  }
  static sourceFromHex(e) {
    if (e.match(/^#?(([0-9a-f]){3,4}|([0-9a-f]{2}){3,4})$/i)) {
      const t = e.slice(e.indexOf("#") + 1);
      let n;
      n = t.length <= 4 ? t.split("").map((u) => u + u) : t.match(/.{2}/g);
      const [s, i, a, c = 255] = n.map((u) => parseInt(u, 16));
      return [s, i, a, c / 255];
    }
  }
  static parseAngletoDegrees(e) {
    const t = e.toLowerCase(), n = parseFloat(t);
    return t.includes("rad") ? As(n) : t.includes("turn") ? 360 * n : n;
  }
}
const vt = (r, e) => parseFloat(Number(r).toFixed(e)), hi = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : up;
  const t = /\D{0,2}$/.exec(r), n = parseFloat(r), s = et.DPI;
  switch (t?.[0]) {
    case "mm":
      return n * s / 25.4;
    case "cm":
      return n * s / 2.54;
    case "in":
      return n * s;
    case "pt":
      return n * s / 72;
    case "pc":
      return n * s / 72 * 12;
    case "em":
      return n * e;
    default:
      return n;
  }
}, lw = (r) => {
  const [e, t] = r.trim().split(" "), [n, s] = (i = e) && i !== Dr ? [i.slice(1, 4), i.slice(5, 8)] : i === Dr ? [i, i] : ["Mid", "Mid"];
  var i;
  return { meetOrSlice: t || "meet", alignX: n, alignY: s };
}, Ca = (r) => "matrix(" + r.map((e) => vt(e, et.NUM_FRACTION_DIGITS)).join(" ") + ")", Ta = function(r, e) {
  let t, n, s = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
  if (e) if (e.toLive) t = "url(#SVGID_".concat(e.id, ")");
  else {
    const i = new lt(e), a = i.getAlpha();
    t = i.toRgb(), a !== 1 && (n = a.toString());
  }
  else t = "none";
  return s ? "".concat(r, ": ").concat(t, "; ").concat(n ? "".concat(r, "-opacity: ").concat(n, "; ") : "") : "".concat(r, '="').concat(t, '" ').concat(n ? "".concat(r, '-opacity="').concat(n, '" ') : "");
}, on = (r) => !!r && r.toLive !== void 0, T0 = (r) => !!r && typeof r.toObject == "function", E0 = (r) => !!r && r.offsetX !== void 0 && "source" in r, ri = (r) => !!r && "multiSelectionStacking" in r;
function uw(r) {
  const e = r && vn(r);
  let t = 0, n = 0;
  if (!r || !e) return { left: t, top: n };
  let s = r;
  const i = e.documentElement, a = e.body || { scrollLeft: 0, scrollTop: 0 };
  for (; s && (s.parentNode || s.host) && (s = s.parentNode || s.host, s === e ? (t = a.scrollLeft || i.scrollLeft || 0, n = a.scrollTop || i.scrollTop || 0) : (t += s.scrollLeft || 0, n += s.scrollTop || 0), s.nodeType !== 1 || s.style.position !== "fixed"); ) ;
  return { left: t, top: n };
}
const vn = (r) => r.ownerDocument || null, hw = (r) => {
  var e;
  return ((e = r.ownerDocument) === null || e === void 0 ? void 0 : e.defaultView) || null;
}, dw = function(r, e, t) {
  let { width: n, height: s } = t, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  r.width = n, r.height = s, i > 1 && (r.setAttribute("width", (n * i).toString()), r.setAttribute("height", (s * i).toString()), e.scale(i, i));
}, nf = (r, e) => {
  let { width: t, height: n } = e;
  t && (r.style.width = typeof t == "number" ? "".concat(t, "px") : t), n && (r.style.height = typeof n == "number" ? "".concat(n, "px") : n);
};
function k0(r) {
  return r.onselectstart !== void 0 && (r.onselectstart = () => !1), r.style.userSelect = Dr, r;
}
class fw {
  constructor(e) {
    N(this, "_originalCanvasStyle", void 0), N(this, "lower", void 0);
    const t = this.createLowerCanvas(e);
    this.lower = { el: t, ctx: t.getContext("2d") };
  }
  createLowerCanvas(e) {
    const t = (n = e) && n.getContext !== void 0 ? e : e && Eo().getElementById(e) || cn();
    var n;
    if (t.hasAttribute("data-fabric")) throw new Pn("Trying to initialize a canvas that has already been initialized. Did you forget to dispose the canvas?");
    return this._originalCanvasStyle = t.style.cssText, t.setAttribute("data-fabric", "main"), t.classList.add("lower-canvas"), t;
  }
  cleanupDOM(e) {
    let { width: t, height: n } = e;
    const { el: s } = this.lower;
    s.classList.remove("lower-canvas"), s.removeAttribute("data-fabric"), s.setAttribute("width", "".concat(t)), s.setAttribute("height", "".concat(n)), s.style.cssText = this._originalCanvasStyle || "", this._originalCanvasStyle = void 0;
  }
  setDimensions(e, t) {
    const { el: n, ctx: s } = this.lower;
    dw(n, s, e, t);
  }
  setCSSDimensions(e) {
    nf(this.lower.el, e);
  }
  calcOffset() {
    return function(e) {
      var t;
      const n = e && vn(e), s = { left: 0, top: 0 };
      if (!n) return s;
      const i = ((t = hw(e)) === null || t === void 0 ? void 0 : t.getComputedStyle(e, null)) || {};
      s.left += parseInt(i.borderLeftWidth, 10) || 0, s.top += parseInt(i.borderTopWidth, 10) || 0, s.left += parseInt(i.paddingLeft, 10) || 0, s.top += parseInt(i.paddingTop, 10) || 0;
      let a = { left: 0, top: 0 };
      const c = n.documentElement;
      e.getBoundingClientRect !== void 0 && (a = e.getBoundingClientRect());
      const u = uw(e);
      return { left: a.left + u.left - (c.clientLeft || 0) + s.left, top: a.top + u.top - (c.clientTop || 0) + s.top };
    }(this.lower.el);
  }
  dispose() {
    Fn().dispose(this.lower.el), delete this.lower;
  }
}
const VR = { backgroundVpt: !0, backgroundColor: "", overlayVpt: !0, overlayColor: "", includeDefaultValues: !0, svgViewportTransformation: !0, renderOnAddRemove: !0, skipOffscreen: !0, enableRetinaScaling: !0, imageSmoothingEnabled: !0, controlsAboveOverlay: !1, allowTouchScrolling: !1, viewportTransform: [..._r] };
class Ha extends tw(rw) {
  get lowerCanvasEl() {
    var e;
    return (e = this.elements.lower) === null || e === void 0 ? void 0 : e.el;
  }
  get contextContainer() {
    var e;
    return (e = this.elements.lower) === null || e === void 0 ? void 0 : e.ctx;
  }
  static getDefaults() {
    return Ha.ownDefaults;
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, this.constructor.getDefaults()), this.set(t), this.initElements(e), this._setDimensionsImpl({ width: this.width || this.elements.lower.el.width || 0, height: this.height || this.elements.lower.el.height || 0 }), this.skipControlsDrawing = !1, this.viewportTransform = [...this.viewportTransform], this.calcViewportBoundaries();
  }
  initElements(e) {
    this.elements = new fw(e);
  }
  add() {
    const e = super.add(...arguments);
    return arguments.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), e;
  }
  insertAt(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++) n[s - 1] = arguments[s];
    const i = super.insertAt(e, ...n);
    return n.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), i;
  }
  remove() {
    const e = super.remove(...arguments);
    return e.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), e;
  }
  _onObjectAdded(e) {
    e.canvas && e.canvas !== this && (ks("warn", `Canvas is trying to add an object that belongs to a different canvas.
Resulting to default behavior: removing object from previous canvas and adding to new canvas`), e.canvas.remove(e)), e._set("canvas", this), e.setCoords(), this.fire("object:added", { target: e }), e.fire("added", { target: this });
  }
  _onObjectRemoved(e) {
    e._set("canvas", void 0), this.fire("object:removed", { target: e }), e.fire("removed", { target: this });
  }
  _onStackOrderChanged() {
    this.renderOnAddRemove && this.requestRenderAll();
  }
  getRetinaScaling() {
    return this.enableRetinaScaling ? Kb() : 1;
  }
  calcOffset() {
    return this._offset = this.elements.calcOffset();
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  setWidth(e, t) {
    return this.setDimensions({ width: e }, t);
  }
  setHeight(e, t) {
    return this.setDimensions({ height: e }, t);
  }
  _setDimensionsImpl(e) {
    let { cssOnly: t = !1, backstoreOnly: n = !1 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!t) {
      const s = L({ width: this.width, height: this.height }, e);
      this.elements.setDimensions(s, this.getRetinaScaling()), this.hasLostContext = !0, this.width = s.width, this.height = s.height;
    }
    n || this.elements.setCSSDimensions(e), this.calcOffset();
  }
  setDimensions(e, t) {
    this._setDimensionsImpl(e, t), t && t.cssOnly || this.requestRenderAll();
  }
  getZoom() {
    return this.viewportTransform[0];
  }
  setViewportTransform(e) {
    this.viewportTransform = e, this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll();
  }
  zoomToPoint(e, t) {
    const n = e, s = [...this.viewportTransform], i = ur(e, Ur(s));
    s[0] = t, s[3] = t;
    const a = ur(i, s);
    s[4] += n.x - a.x, s[5] += n.y - a.y, this.setViewportTransform(s);
  }
  setZoom(e) {
    this.zoomToPoint(new $(0, 0), e);
  }
  absolutePan(e) {
    const t = [...this.viewportTransform];
    return t[4] = -e.x, t[5] = -e.y, this.setViewportTransform(t);
  }
  relativePan(e) {
    return this.absolutePan(new $(-e.x - this.viewportTransform[4], -e.y - this.viewportTransform[5]));
  }
  getElement() {
    return this.elements.lower.el;
  }
  clearContext(e) {
    e.clearRect(0, 0, this.width, this.height);
  }
  getContext() {
    return this.elements.lower.ctx;
  }
  clear() {
    this.remove(...this.getObjects()), this.backgroundImage = void 0, this.overlayImage = void 0, this.backgroundColor = "", this.overlayColor = "", this.clearContext(this.getContext()), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll();
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || this.renderCanvas(this.getContext(), this._objects);
  }
  renderAndReset() {
    this.nextRenderHandle = 0, this.renderAll();
  }
  requestRenderAll() {
    this.nextRenderHandle || this.disposed || this.destroyed || (this.nextRenderHandle = ga(() => this.renderAndReset()));
  }
  calcViewportBoundaries() {
    const e = this.width, t = this.height, n = Ur(this.viewportTransform), s = ur({ x: 0, y: 0 }, n), i = ur({ x: e, y: t }, n), a = s.min(i), c = s.max(i);
    return this.vptCoords = { tl: a, tr: new $(c.x, a.y), bl: new $(a.x, c.y), br: c };
  }
  cancelRequestedRender() {
    this.nextRenderHandle && (nw(this.nextRenderHandle), this.nextRenderHandle = 0);
  }
  drawControls(e) {
  }
  renderCanvas(e, t) {
    if (this.destroyed) return;
    const n = this.viewportTransform, s = this.clipPath;
    this.calcViewportBoundaries(), this.clearContext(e), e.imageSmoothingEnabled = this.imageSmoothingEnabled, e.patternQuality = "best", this.fire("before:render", { ctx: e }), this._renderBackground(e), e.save(), e.transform(n[0], n[1], n[2], n[3], n[4], n[5]), this._renderObjects(e, t), e.restore(), this.controlsAboveOverlay || this.skipControlsDrawing || this.drawControls(e), s && (s._set("canvas", this), s.shouldCache(), s._transformDone = !0, s.renderCache({ forClipping: !0 }), this.drawClipPathOnCanvas(e, s)), this._renderOverlay(e), this.controlsAboveOverlay && !this.skipControlsDrawing && this.drawControls(e), this.fire("after:render", { ctx: e }), this.__cleanupTask && (this.__cleanupTask(), this.__cleanupTask = void 0);
  }
  drawClipPathOnCanvas(e, t) {
    const n = this.viewportTransform;
    e.save(), e.transform(...n), e.globalCompositeOperation = "destination-in", t.transform(e), e.scale(1 / t.zoomX, 1 / t.zoomY), e.drawImage(t._cacheCanvas, -t.cacheTranslationX, -t.cacheTranslationY), e.restore();
  }
  _renderObjects(e, t) {
    for (let n = 0, s = t.length; n < s; ++n) t[n] && t[n].render(e);
  }
  _renderBackgroundOrOverlay(e, t) {
    const n = this["".concat(t, "Color")], s = this["".concat(t, "Image")], i = this.viewportTransform, a = this["".concat(t, "Vpt")];
    if (!n && !s) return;
    const c = on(n);
    if (n) {
      if (e.save(), e.beginPath(), e.moveTo(0, 0), e.lineTo(this.width, 0), e.lineTo(this.width, this.height), e.lineTo(0, this.height), e.closePath(), e.fillStyle = c ? n.toLive(e) : n, a && e.transform(...i), c) {
        e.transform(1, 0, 0, 1, n.offsetX || 0, n.offsetY || 0);
        const u = n.gradientTransform || n.patternTransform;
        u && e.transform(...u);
      }
      e.fill(), e.restore();
    }
    if (s) {
      e.save();
      const { skipOffscreen: u } = this;
      this.skipOffscreen = a, a && e.transform(...i), s.render(e), this.skipOffscreen = u, e.restore();
    }
  }
  _renderBackground(e) {
    this._renderBackgroundOrOverlay(e, "background");
  }
  _renderOverlay(e) {
    this._renderBackgroundOrOverlay(e, "overlay");
  }
  getCenter() {
    return { top: this.height / 2, left: this.width / 2 };
  }
  getCenterPoint() {
    return new $(this.width / 2, this.height / 2);
  }
  centerObjectH(e) {
    return this._centerObject(e, new $(this.getCenterPoint().x, e.getCenterPoint().y));
  }
  centerObjectV(e) {
    return this._centerObject(e, new $(e.getCenterPoint().x, this.getCenterPoint().y));
  }
  centerObject(e) {
    return this._centerObject(e, this.getCenterPoint());
  }
  viewportCenterObject(e) {
    return this._centerObject(e, this.getVpCenter());
  }
  viewportCenterObjectH(e) {
    return this._centerObject(e, new $(this.getVpCenter().x, e.getCenterPoint().y));
  }
  viewportCenterObjectV(e) {
    return this._centerObject(e, new $(e.getCenterPoint().x, this.getVpCenter().y));
  }
  getVpCenter() {
    return ur(this.getCenterPoint(), Ur(this.viewportTransform));
  }
  _centerObject(e, t) {
    e.setXY(t, Be, Be), e.setCoords(), this.renderOnAddRemove && this.requestRenderAll();
  }
  toDatalessJSON(e) {
    return this.toDatalessObject(e);
  }
  toObject(e) {
    return this._toObjectMethod("toObject", e);
  }
  toJSON() {
    return this.toObject();
  }
  toDatalessObject(e) {
    return this._toObjectMethod("toDatalessObject", e);
  }
  _toObjectMethod(e, t) {
    const n = this.clipPath, s = n && !n.excludeFromExport ? this._toObject(n, e, t) : null;
    return L(L(L({ version: tf }, ki(this, t)), {}, { objects: this._objects.filter((i) => !i.excludeFromExport).map((i) => this._toObject(i, e, t)) }, this.__serializeBgOverlay(e, t)), s ? { clipPath: s } : null);
  }
  _toObject(e, t, n) {
    let s;
    this.includeDefaultValues || (s = e.includeDefaultValues, e.includeDefaultValues = !1);
    const i = e[t](n);
    return this.includeDefaultValues || (e.includeDefaultValues = !!s), i;
  }
  __serializeBgOverlay(e, t) {
    const n = {}, s = this.backgroundImage, i = this.overlayImage, a = this.backgroundColor, c = this.overlayColor;
    return on(a) ? a.excludeFromExport || (n.background = a.toObject(t)) : a && (n.background = a), on(c) ? c.excludeFromExport || (n.overlay = c.toObject(t)) : c && (n.overlay = c), s && !s.excludeFromExport && (n.backgroundImage = this._toObject(s, e, t)), i && !i.excludeFromExport && (n.overlayImage = this._toObject(i, e, t)), n;
  }
  toSVG() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
    e.reviver = t;
    const n = [];
    return this._setSVGPreamble(n, e), this._setSVGHeader(n, e), this.clipPath && n.push('<g clip-path="url(#'.concat(this.clipPath.clipPathId, `)" >
`)), this._setSVGBgOverlayColor(n, "background"), this._setSVGBgOverlayImage(n, "backgroundImage", t), this._setSVGObjects(n, t), this.clipPath && n.push(`</g>
`), this._setSVGBgOverlayColor(n, "overlay"), this._setSVGBgOverlayImage(n, "overlayImage", t), n.push("</svg>"), n.join("");
  }
  _setSVGPreamble(e, t) {
    t.suppressPreamble || e.push('<?xml version="1.0" encoding="', t.encoding || "UTF-8", `" standalone="no" ?>
`, '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', `"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
`);
  }
  _setSVGHeader(e, t) {
    const n = t.width || "".concat(this.width), s = t.height || "".concat(this.height), i = et.NUM_FRACTION_DIGITS, a = t.viewBox;
    let c;
    if (a) c = 'viewBox="'.concat(a.x, " ").concat(a.y, " ").concat(a.width, " ").concat(a.height, '" ');
    else if (this.svgViewportTransformation) {
      const u = this.viewportTransform;
      c = 'viewBox="'.concat(vt(-u[4] / u[0], i), " ").concat(vt(-u[5] / u[3], i), " ").concat(vt(this.width / u[0], i), " ").concat(vt(this.height / u[3], i), '" ');
    } else c = 'viewBox="0 0 '.concat(this.width, " ").concat(this.height, '" ');
    e.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', n, '" ', 'height="', s, '" ', c, `xml:space="preserve">
`, "<desc>Created with Fabric.js ", tf, `</desc>
`, `<defs>
`, this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(t), `</defs>
`);
  }
  createSVGClipPathMarkup(e) {
    const t = this.clipPath;
    return t ? (t.clipPathId = "CLIPPATH_".concat(Ms()), '<clipPath id="'.concat(t.clipPathId, `" >
`).concat(t.toClipPathSVG(e.reviver), `</clipPath>
`)) : "";
  }
  createSVGRefElementsMarkup() {
    return ["background", "overlay"].map((e) => {
      const t = this["".concat(e, "Color")];
      if (on(t)) {
        const n = this["".concat(e, "Vpt")], s = this.viewportTransform, i = { isType: () => !1, width: this.width / (n ? s[0] : 1), height: this.height / (n ? s[3] : 1) };
        return t.toSVG(i, { additionalTransform: n ? Ca(s) : "" });
      }
    }).join("");
  }
  createSVGFontFacesMarkup() {
    const e = [], t = {}, n = et.fontPaths;
    this._objects.forEach(function i(a) {
      e.push(a), pl(a) && a._objects.forEach(i);
    }), e.forEach((i) => {
      if (!(a = i) || typeof a._renderText != "function") return;
      var a;
      const { styles: c, fontFamily: u } = i;
      !t[u] && n[u] && (t[u] = !0, c && Object.values(c).forEach((h) => {
        Object.values(h).forEach((d) => {
          let { fontFamily: p = "" } = d;
          !t[p] && n[p] && (t[p] = !0);
        });
      }));
    });
    const s = Object.keys(t).map((i) => `		@font-face {
			font-family: '`.concat(i, `';
			src: url('`).concat(n[i], `');
		}
`)).join("");
    return s ? `	<style type="text/css"><![CDATA[
`.concat(s, `]]></style>
`) : "";
  }
  _setSVGObjects(e, t) {
    this.forEachObject((n) => {
      n.excludeFromExport || this._setSVGObject(e, n, t);
    });
  }
  _setSVGObject(e, t, n) {
    e.push(t.toSVG(n));
  }
  _setSVGBgOverlayImage(e, t, n) {
    const s = this[t];
    s && !s.excludeFromExport && s.toSVG && e.push(s.toSVG(n));
  }
  _setSVGBgOverlayColor(e, t) {
    const n = this["".concat(t, "Color")];
    if (n) if (on(n)) {
      const s = n.repeat || "", i = this.width, a = this.height, c = this["".concat(t, "Vpt")] ? Ca(Ur(this.viewportTransform)) : "";
      e.push('<rect transform="'.concat(c, " translate(").concat(i / 2, ",").concat(a / 2, ')" x="').concat(n.offsetX - i / 2, '" y="').concat(n.offsetY - a / 2, '" width="').concat(s !== "repeat-y" && s !== "no-repeat" || !E0(n) ? i : n.source.width, '" height="').concat(s !== "repeat-x" && s !== "no-repeat" || !E0(n) ? a : n.source.height, '" fill="url(#SVGID_').concat(n.id, `)"></rect>
`));
    } else e.push('<rect x="0" y="0" width="100%" height="100%" ', 'fill="', n, '"', `></rect>
`);
  }
  loadFromJSON(e, t) {
    let { signal: n } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return Promise.reject(new Pn("`json` is undefined"));
    const s = typeof e == "string" ? JSON.parse(e) : e, { objects: i = [], backgroundImage: a, background: c, overlayImage: u, overlay: h, clipPath: d } = s, p = this.renderOnAddRemove;
    return this.renderOnAddRemove = !1, Promise.all([uo(i, { reviver: t, signal: n }), Wa({ backgroundImage: a, backgroundColor: c, overlayImage: u, overlayColor: h, clipPath: d }, { signal: n })]).then((g) => {
      let [v, b] = g;
      return this.clear(), this.add(...v), this.set(s), this.set(b), this.renderOnAddRemove = p, this;
    });
  }
  clone(e) {
    const t = this.toObject(e);
    return this.cloneWithoutData().loadFromJSON(t);
  }
  cloneWithoutData() {
    const e = _n(this);
    return new this.constructor(e);
  }
  toDataURL() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { format: t = "png", quality: n = 1, multiplier: s = 1, enableRetinaScaling: i = !1 } = e, a = s * (i ? this.getRetinaScaling() : 1);
    return pp(this.toCanvasElement(a, e), t, n);
  }
  toCanvasElement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, { width: t, height: n, left: s, top: i, filter: a } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const c = (t || this.width) * e, u = (n || this.height) * e, h = this.getZoom(), d = this.width, p = this.height, g = this.skipControlsDrawing, v = h * e, b = this.viewportTransform, _ = [v, 0, 0, v, (b[4] - (s || 0)) * e, (b[5] - (i || 0)) * e], C = this.enableRetinaScaling, T = _n({ width: c, height: u }), k = a ? this._objects.filter((M) => a(M)) : this._objects;
    return this.enableRetinaScaling = !1, this.viewportTransform = _, this.width = c, this.height = u, this.skipControlsDrawing = !0, this.calcViewportBoundaries(), this.renderCanvas(T.getContext("2d"), k), this.viewportTransform = b, this.width = d, this.height = p, this.calcViewportBoundaries(), this.enableRetinaScaling = C, this.skipControlsDrawing = g, T;
  }
  dispose() {
    return !this.disposed && this.elements.cleanupDOM({ width: this.width, height: this.height }), Ol.cancelByCanvas(this), this.disposed = !0, new Promise((e, t) => {
      const n = () => {
        this.destroy(), e(!0);
      };
      n.kill = t, this.__cleanupTask && this.__cleanupTask.kill("aborted"), this.destroyed ? e(!1) : this.nextRenderHandle ? this.__cleanupTask = n : n();
    });
  }
  destroy() {
    this.destroyed = !0, this.cancelRequestedRender(), this.forEachObject((e) => e.dispose()), this._objects = [], this.backgroundImage && this.backgroundImage.dispose(), this.backgroundImage = void 0, this.overlayImage && this.overlayImage.dispose(), this.overlayImage = void 0, this.elements.dispose();
  }
  toString() {
    return "#<Canvas (".concat(this.complexity(), "): { objects: ").concat(this._objects.length, " }>");
  }
}
N(Ha, "ownDefaults", VR);
const zR = ["touchstart", "touchmove", "touchend"], pw = (r) => {
  const e = uw(r.target), t = function(n) {
    const s = n.changedTouches;
    return s && s[0] ? s[0] : n;
  }(r);
  return new $(t.clientX + e.left, t.clientY + e.top);
}, Ml = (r) => zR.includes(r.type) || r.pointerType === "touch", sf = (r) => {
  r.preventDefault(), r.stopPropagation();
}, jn = (r) => {
  let e = 0, t = 0, n = 0, s = 0;
  for (let i = 0, a = r.length; i < a; i++) {
    const { x: c, y: u } = r[i];
    (c > n || !i) && (n = c), (c < e || !i) && (e = c), (u > s || !i) && (s = u), (u < t || !i) && (t = u);
  }
  return { left: e, top: t, width: n - e, height: s - t };
}, WR = ["translateX", "translateY", "scaleX", "scaleY"], gw = (r, e) => ho(r, At(e, r.calcOwnMatrix())), ho = (r, e) => {
  const t = lo(e), { translateX: n, translateY: s, scaleX: i, scaleY: a } = t, c = yt(t, WR), u = new $(n, s);
  r.flipX = !1, r.flipY = !1, Object.assign(r, c), r.set({ scaleX: i, scaleY: a }), r.setPositionByOrigin(u, Be, Be);
}, mw = (r) => {
  r.scaleX = 1, r.scaleY = 1, r.skewX = 0, r.skewY = 0, r.flipX = !1, r.flipY = !1, r.rotate(0);
}, yp = (r) => ({ scaleX: r.scaleX, scaleY: r.scaleY, skewX: r.skewX, skewY: r.skewY, angle: r.angle, left: r.left, flipX: r.flipX, flipY: r.flipY, top: r.top }), bu = (r, e, t) => {
  const n = r / 2, s = e / 2, i = [new $(-n, -s), new $(n, -s), new $(-n, s), new $(n, s)].map((c) => c.transform(t)), a = jn(i);
  return new $(a.width, a.height);
}, Ua = function() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _r;
  return At(Ur(arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _r), r);
}, ns = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _r, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _r;
  return r.transform(Ua(e, t));
}, vw = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _r, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _r;
  return r.transform(Ua(e, t), !0);
}, of = (r, e, t) => {
  const n = Ua(e, t);
  return ho(r, At(n, r.calcOwnMatrix())), n;
}, bp = (r, e) => {
  var t;
  const { transform: { target: n } } = e;
  (t = n.canvas) === null || t === void 0 || t.fire("object:".concat(r), L(L({}, e), {}, { target: n })), n.fire(r, e);
}, HR = { left: -0.5, top: -0.5, center: 0, bottom: 0.5, right: 0.5 }, Lt = (r) => typeof r == "string" ? HR[r] : r - 0.5, Al = "not-allowed";
function yw(r) {
  return Lt(r.originX) === Lt(Be) && Lt(r.originY) === Lt(Be);
}
function O0(r) {
  return 0.5 - Lt(r);
}
const yn = (r, e) => r[e], wp = (r, e, t, n) => ({ e: r, transform: e, pointer: new $(t, n) });
function bw(r, e) {
  const t = r.getTotalAngle() + As(Math.atan2(e.y, e.x)) + 360;
  return Math.round(t % 360 / 45);
}
function wu(r, e, t, n, s) {
  var i;
  let { target: a, corner: c } = r;
  const u = a.controls[c], h = ((i = a.canvas) === null || i === void 0 ? void 0 : i.getZoom()) || 1, d = a.padding / h, p = function(g, v, b, _) {
    const C = g.getRelativeCenterPoint(), T = b !== void 0 && _ !== void 0 ? g.translateToGivenOrigin(C, Be, Be, b, _) : new $(g.left, g.top);
    return (g.angle ? v.rotate(-Mt(g.angle), C) : v).subtract(T);
  }(a, new $(n, s), e, t);
  return p.x >= d && (p.x -= d), p.x <= -d && (p.x += d), p.y >= d && (p.y -= d), p.y <= d && (p.y += d), p.x -= u.offsetX, p.y -= u.offsetY, p;
}
const ww = (r, e, t, n) => {
  const { target: s, offsetX: i, offsetY: a } = e, c = t - i, u = n - a, h = !yn(s, "lockMovementX") && s.left !== c, d = !yn(s, "lockMovementY") && s.top !== u;
  return h && s.set(at, c), d && s.set(Pr, u), (h || d) && bp(Zb, wp(r, e, t, n)), h || d;
};
class xw {
  getSvgStyles(e) {
    const t = this.fillRule ? this.fillRule : "nonzero", n = this.strokeWidth ? this.strokeWidth : "0", s = this.strokeDashArray ? this.strokeDashArray.join(" ") : Dr, i = this.strokeDashOffset ? this.strokeDashOffset : "0", a = this.strokeLineCap ? this.strokeLineCap : "butt", c = this.strokeLineJoin ? this.strokeLineJoin : "miter", u = this.strokeMiterLimit ? this.strokeMiterLimit : "4", h = this.opacity !== void 0 ? this.opacity : "1", d = this.visible ? "" : " visibility: hidden;", p = e ? "" : this.getSvgFilter(), g = Ta(Xt, this.fill);
    return [Ta(Rr, this.stroke), "stroke-width: ", n, "; ", "stroke-dasharray: ", s, "; ", "stroke-linecap: ", a, "; ", "stroke-dashoffset: ", i, "; ", "stroke-linejoin: ", c, "; ", "stroke-miterlimit: ", u, "; ", g, "fill-rule: ", t, "; ", "opacity: ", h, ";", p, d].join("");
  }
  getSvgFilter() {
    return this.shadow ? "filter: url(#SVGID_".concat(this.shadow.id, ");") : "";
  }
  getSvgCommons() {
    return [this.id ? 'id="'.concat(this.id, '" ') : "", this.clipPath ? 'clip-path="url(#'.concat(this.clipPath.clipPathId, ')" ') : ""].join("");
  }
  getSvgTransform(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const n = e ? this.calcTransformMatrix() : this.calcOwnMatrix(), s = 'transform="'.concat(Ca(n));
    return "".concat(s).concat(t, '" ');
  }
  _toSVG(e) {
    return [""];
  }
  toSVG(e) {
    return this._createBaseSVGMarkup(this._toSVG(e), { reviver: e });
  }
  toClipPathSVG(e) {
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(e), { reviver: e });
  }
  _createBaseClipPathSVGMarkup(e) {
    let { reviver: t, additionalTransform: n = "" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const s = [this.getSvgTransform(!0, n), this.getSvgCommons()].join(""), i = e.indexOf("COMMON_PARTS");
    return e[i] = s, t ? t(e.join("")) : e.join("");
  }
  _createBaseSVGMarkup(e) {
    let { noStyle: t, reviver: n, withShadow: s, additionalTransform: i } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const a = t ? "" : 'style="'.concat(this.getSvgStyles(), '" '), c = s ? 'style="'.concat(this.getSvgFilter(), '" ') : "", u = this.clipPath, h = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", d = u && u.absolutePositioned, p = this.stroke, g = this.fill, v = this.shadow, b = [], _ = e.indexOf("COMMON_PARTS");
    let C;
    u && (u.clipPathId = "CLIPPATH_".concat(Ms()), C = '<clipPath id="'.concat(u.clipPathId, `" >
`).concat(u.toClipPathSVG(n), `</clipPath>
`)), d && b.push("<g ", c, this.getSvgCommons(), ` >
`), b.push("<g ", this.getSvgTransform(!1), d ? "" : c + this.getSvgCommons(), ` >
`);
    const T = [a, h, t ? "" : this.addPaintOrder(), " ", i ? 'transform="'.concat(i, '" ') : ""].join("");
    return e[_] = T, on(g) && b.push(g.toSVG(this)), on(p) && b.push(p.toSVG(this)), v && b.push(v.toSVG(this)), u && b.push(C), b.push(e.join("")), b.push(`</g>
`), d && b.push(`</g>
`), n ? n(b.join("")) : b.join("");
  }
  addPaintOrder() {
    return this.paintFirst !== Xt ? ' paint-order="'.concat(this.paintFirst, '" ') : "";
  }
}
function xu(r) {
  return new RegExp("^(" + r.join("|") + ")\\b", "i");
}
var M0;
const pi = String.raw(M0 || (M0 = Fs(["(?:[-+]?(?:d*.d+|d+.?)(?:[eE][-+]?d+)?)"], ["(?:[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?)"]))), UR = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + pi + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + pi + "))?\\s+(.*)"), $R = { cx: at, x: at, r: "radius", cy: Pr, y: Pr, display: "visible", visibility: "visible", transform: "transformMatrix", "fill-opacity": "fillOpacity", "fill-rule": "fillRule", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "letter-spacing": "charSpacing", "paint-order": "paintFirst", "stroke-dasharray": "strokeDashArray", "stroke-dashoffset": "strokeDashOffset", "stroke-linecap": "strokeLineCap", "stroke-linejoin": "strokeLineJoin", "stroke-miterlimit": "strokeMiterLimit", "stroke-opacity": "strokeOpacity", "stroke-width": "strokeWidth", "text-decoration": "textDecoration", "text-anchor": "textAnchor", opacity: "opacity", "clip-path": "clipPath", "clip-rule": "clipRule", "vector-effect": "strokeUniform", "image-rendering": "imageSmoothing" }, sd = "font-size", id = "clip-path";
xu(["path", "circle", "polygon", "polyline", "ellipse", "rect", "line", "image", "text"]);
xu(["symbol", "image", "marker", "pattern", "view", "svg"]);
const A0 = xu(["symbol", "g", "a", "svg", "clipPath", "defs"]), YR = new $(1, 0), _w = new $(), xp = (r, e) => r.rotate(e), Il = (r, e) => new $(e).subtract(r), Pl = (r) => r.distanceFrom(_w), Dl = (r, e) => Math.atan2(io(r, e), Cw(r, e)), Sw = (r) => Dl(YR, r), _u = (r) => r.eq(_w) ? r : r.scalarDivide(Pl(r)), _p = function(r) {
  let e = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
  return _u(new $(-r.y, r.x).scalarMultiply(e ? 1 : -1));
}, io = (r, e) => r.x * e.y - r.y * e.x, Cw = (r, e) => r.x * e.x + r.y * e.y, af = (r, e, t) => {
  if (r.eq(e) || r.eq(t)) return !0;
  const n = io(e, t), s = io(e, r), i = io(t, r);
  return n >= 0 ? s >= 0 && i <= 0 : !(s <= 0 && i >= 0);
}, I0 = "(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?", P0 = new RegExp("(?:\\s|^)" + I0 + I0 + "(" + pi + "?(?:px)?)?(?:\\s?|$)(?:$|\\s)");
class ss {
  constructor(e) {
    const t = typeof e == "string" ? ss.parseShadow(e) : e;
    Object.assign(this, ss.ownDefaults, t), this.id = Ms();
  }
  static parseShadow(e) {
    const t = e.trim(), [, n = 0, s = 0, i = 0] = (P0.exec(t) || []).map((a) => parseFloat(a) || 0);
    return { color: (t.replace(P0, "") || "rgb(0,0,0)").trim(), offsetX: n, offsetY: s, blur: i };
  }
  toString() {
    return [this.offsetX, this.offsetY, this.blur, this.color].join("px ");
  }
  toSVG(e) {
    const t = xp(new $(this.offsetX, this.offsetY), Mt(-e.angle)), n = new lt(this.color);
    let s = 40, i = 40;
    return e.width && e.height && (s = 100 * vt((Math.abs(t.x) + this.blur) / e.width, et.NUM_FRACTION_DIGITS) + 20, i = 100 * vt((Math.abs(t.y) + this.blur) / e.height, et.NUM_FRACTION_DIGITS) + 20), e.flipX && (t.x *= -1), e.flipY && (t.y *= -1), '<filter id="SVGID_'.concat(this.id, '" y="-').concat(i, '%" height="').concat(100 + 2 * i, '%" x="-').concat(s, '%" width="').concat(100 + 2 * s, `%" >
	<feGaussianBlur in="SourceAlpha" stdDeviation="`).concat(vt(this.blur ? this.blur / 2 : 0, et.NUM_FRACTION_DIGITS), `"></feGaussianBlur>
	<feOffset dx="`).concat(vt(t.x, et.NUM_FRACTION_DIGITS), '" dy="').concat(vt(t.y, et.NUM_FRACTION_DIGITS), `" result="oBlur" ></feOffset>
	<feFlood flood-color="`).concat(n.toRgb(), '" flood-opacity="').concat(n.getAlpha(), `"/>
	<feComposite in2="oBlur" operator="in" />
	<feMerge>
		<feMergeNode></feMergeNode>
		<feMergeNode in="SourceGraphic"></feMergeNode>
	</feMerge>
</filter>
`);
  }
  toObject() {
    const e = { color: this.color, blur: this.blur, offsetX: this.offsetX, offsetY: this.offsetY, affectStroke: this.affectStroke, nonScaling: this.nonScaling, type: this.constructor.type }, t = ss.ownDefaults;
    return this.includeDefaultValues ? e : vp(e, (n, s) => n !== t[s]);
  }
  static async fromObject(e) {
    return new this(e);
  }
}
N(ss, "ownDefaults", { color: "rgb(0,0,0)", blur: 0, offsetX: 0, offsetY: 0, affectStroke: !1, includeDefaultValues: !0, nonScaling: !1 }), N(ss, "type", "shadow"), le.setClass(ss, "shadow");
const gi = (r, e, t) => Math.max(r, Math.min(e, t)), XR = [Pr, at, Sr, $r, "flipX", "flipY", "originX", "originY", "angle", "opacity", "globalCompositeOperation", "shadow", "visible", ko, Oo], as = [Xt, Rr, "strokeWidth", "strokeDashArray", "width", "height", "paintFirst", "strokeUniform", "strokeLineCap", "strokeDashOffset", "strokeLineJoin", "strokeMiterLimit", "backgroundColor", "clipPath"], GR = { top: 0, left: 0, width: 0, height: 0, angle: 0, flipX: !1, flipY: !1, scaleX: 1, scaleY: 1, minScaleLimit: 0, skewX: 0, skewY: 0, originX: at, originY: Pr, strokeWidth: 1, strokeUniform: !1, padding: 0, opacity: 1, paintFirst: Xt, fill: "rgb(0,0,0)", fillRule: "nonzero", stroke: null, strokeDashArray: null, strokeDashOffset: 0, strokeLineCap: "butt", strokeLineJoin: "miter", strokeMiterLimit: 4, globalCompositeOperation: "source-over", backgroundColor: "", shadow: null, visible: !0, includeDefaultValues: !0, excludeFromExport: !1, objectCaching: !0, clipPath: void 0, inverted: !1, absolutePositioned: !1, centeredRotation: !0, centeredScaling: !1, dirty: !0 }, od = (r, e, t, n) => (r < Math.abs(e) ? (r = e, n = t / 4) : n = e === 0 && r === 0 ? t / os * Math.asin(1) : t / os * Math.asin(e / r), { a: r, c: e, p: t, s: n }), D0 = (r, e, t, n, s) => r * Math.pow(2, 10 * (n -= 1)) * Math.sin((n * s - e) * os / t), Tw = (r, e, t, n) => -t * Math.cos(r / n * Os) + t + e, cf = (r, e, t, n) => (r /= n) < 1 / 2.75 ? t * (7.5625 * r * r) + e : r < 2 / 2.75 ? t * (7.5625 * (r -= 1.5 / 2.75) * r + 0.75) + e : r < 2.5 / 2.75 ? t * (7.5625 * (r -= 2.25 / 2.75) * r + 0.9375) + e : t * (7.5625 * (r -= 2.625 / 2.75) * r + 0.984375) + e, R0 = (r, e, t, n) => t - cf(n - r, 0, t, n) + e;
var qR = Object.freeze({ __proto__: null, defaultEasing: Tw, easeInBack: function(r, e, t, n) {
  let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1.70158;
  return t * (r /= n) * r * ((s + 1) * r - s) + e;
}, easeInBounce: R0, easeInCirc: (r, e, t, n) => -t * (Math.sqrt(1 - (r /= n) * r) - 1) + e, easeInCubic: (r, e, t, n) => t * (r / n) ** 3 + e, easeInElastic: (r, e, t, n) => {
  const s = t;
  let i = 0;
  if (r === 0) return e;
  if ((r /= n) === 1) return e + t;
  i || (i = 0.3 * n);
  const { a, s: c, p: u } = od(s, t, i, 1.70158);
  return -D0(a, c, u, r, n) + e;
}, easeInExpo: (r, e, t, n) => r === 0 ? e : t * 2 ** (10 * (r / n - 1)) + e, easeInOutBack: function(r, e, t, n) {
  let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1.70158;
  return (r /= n / 2) < 1 ? t / 2 * (r * r * ((1 + (s *= 1.525)) * r - s)) + e : t / 2 * ((r -= 2) * r * ((1 + (s *= 1.525)) * r + s) + 2) + e;
}, easeInOutBounce: (r, e, t, n) => r < n / 2 ? 0.5 * R0(2 * r, 0, t, n) + e : 0.5 * cf(2 * r - n, 0, t, n) + 0.5 * t + e, easeInOutCirc: (r, e, t, n) => (r /= n / 2) < 1 ? -t / 2 * (Math.sqrt(1 - r ** 2) - 1) + e : t / 2 * (Math.sqrt(1 - (r -= 2) * r) + 1) + e, easeInOutCubic: (r, e, t, n) => (r /= n / 2) < 1 ? t / 2 * r ** 3 + e : t / 2 * ((r - 2) ** 3 + 2) + e, easeInOutElastic: (r, e, t, n) => {
  const s = t;
  let i = 0;
  if (r === 0) return e;
  if ((r /= n / 2) === 2) return e + t;
  i || (i = n * (0.3 * 1.5));
  const { a, s: c, p: u, c: h } = od(s, t, i, 1.70158);
  return r < 1 ? -0.5 * D0(a, c, u, r, n) + e : a * Math.pow(2, -10 * (r -= 1)) * Math.sin((r * n - c) * os / u) * 0.5 + h + e;
}, easeInOutExpo: (r, e, t, n) => r === 0 ? e : r === n ? e + t : (r /= n / 2) < 1 ? t / 2 * 2 ** (10 * (r - 1)) + e : t / 2 * -(2 ** (-10 * --r) + 2) + e, easeInOutQuad: (r, e, t, n) => (r /= n / 2) < 1 ? t / 2 * r ** 2 + e : -t / 2 * (--r * (r - 2) - 1) + e, easeInOutQuart: (r, e, t, n) => (r /= n / 2) < 1 ? t / 2 * r ** 4 + e : -t / 2 * ((r -= 2) * r ** 3 - 2) + e, easeInOutQuint: (r, e, t, n) => (r /= n / 2) < 1 ? t / 2 * r ** 5 + e : t / 2 * ((r - 2) ** 5 + 2) + e, easeInOutSine: (r, e, t, n) => -t / 2 * (Math.cos(Math.PI * r / n) - 1) + e, easeInQuad: (r, e, t, n) => t * (r /= n) * r + e, easeInQuart: (r, e, t, n) => t * (r /= n) * r ** 3 + e, easeInQuint: (r, e, t, n) => t * (r / n) ** 5 + e, easeInSine: (r, e, t, n) => -t * Math.cos(r / n * Os) + t + e, easeOutBack: function(r, e, t, n) {
  let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1.70158;
  return t * ((r = r / n - 1) * r * ((s + 1) * r + s) + 1) + e;
}, easeOutBounce: cf, easeOutCirc: (r, e, t, n) => t * Math.sqrt(1 - (r = r / n - 1) * r) + e, easeOutCubic: (r, e, t, n) => t * ((r / n - 1) ** 3 + 1) + e, easeOutElastic: (r, e, t, n) => {
  const s = t;
  let i = 0;
  if (r === 0) return e;
  if ((r /= n) === 1) return e + t;
  i || (i = 0.3 * n);
  const { a, s: c, p: u, c: h } = od(s, t, i, 1.70158);
  return a * 2 ** (-10 * r) * Math.sin((r * n - c) * os / u) + h + e;
}, easeOutExpo: (r, e, t, n) => r === n ? e + t : t * -(2 ** (-10 * r / n) + 1) + e, easeOutQuad: (r, e, t, n) => -t * (r /= n) * (r - 2) + e, easeOutQuart: (r, e, t, n) => -t * ((r = r / n - 1) * r ** 3 - 1) + e, easeOutQuint: (r, e, t, n) => t * ((r / n - 1) ** 5 + 1) + e, easeOutSine: (r, e, t, n) => t * Math.sin(r / n * Os) + e });
const KR = () => !1;
class Sp {
  constructor(e) {
    let { startValue: t, byValue: n, duration: s = 500, delay: i = 0, easing: a = Tw, onStart: c = ui, onChange: u = ui, onComplete: h = ui, abort: d = KR, target: p } = e;
    N(this, "_state", "pending"), N(this, "durationProgress", 0), N(this, "valueProgress", 0), this.tick = this.tick.bind(this), this.duration = s, this.delay = i, this.easing = a, this._onStart = c, this._onChange = u, this._onComplete = h, this._abort = d, this.target = p, this.startValue = t, this.byValue = n, this.value = this.startValue, this.endValue = Object.freeze(this.calculate(this.duration).value);
  }
  get state() {
    return this._state;
  }
  isDone() {
    return this._state === "aborted" || this._state === "completed";
  }
  start() {
    const e = (t) => {
      this._state === "pending" && (this.startTime = t || +/* @__PURE__ */ new Date(), this._state = "running", this._onStart(), this.tick(this.startTime));
    };
    this.register(), this.delay > 0 ? setTimeout(() => ga(e), this.delay) : ga(e);
  }
  tick(e) {
    const t = (e || +/* @__PURE__ */ new Date()) - this.startTime, n = Math.min(t, this.duration);
    this.durationProgress = n / this.duration;
    const { value: s, valueProgress: i } = this.calculate(n);
    this.value = Object.freeze(s), this.valueProgress = i, this._state !== "aborted" && (this._abort(this.value, this.valueProgress, this.durationProgress) ? (this._state = "aborted", this.unregister()) : t >= this.duration ? (this.durationProgress = this.valueProgress = 1, this._onChange(this.endValue, this.valueProgress, this.durationProgress), this._state = "completed", this._onComplete(this.endValue, this.valueProgress, this.durationProgress), this.unregister()) : (this._onChange(this.value, this.valueProgress, this.durationProgress), ga(this.tick)));
  }
  register() {
    Ol.push(this);
  }
  unregister() {
    Ol.remove(this);
  }
  abort() {
    this._state = "aborted", this.unregister();
  }
}
const ZR = ["startValue", "endValue"];
class JR extends Sp {
  constructor(e) {
    let { startValue: t = 0, endValue: n = 100 } = e;
    super(L(L({}, yt(e, ZR)), {}, { startValue: t, byValue: n - t }));
  }
  calculate(e) {
    const t = this.easing(e, this.startValue, this.byValue, this.duration);
    return { value: t, valueProgress: Math.abs((t - this.startValue) / this.byValue) };
  }
}
const QR = ["startValue", "endValue"];
class e3 extends Sp {
  constructor(e) {
    let { startValue: t = [0], endValue: n = [100] } = e;
    super(L(L({}, yt(e, QR)), {}, { startValue: t, byValue: n.map((s, i) => s - t[i]) }));
  }
  calculate(e) {
    const t = this.startValue.map((n, s) => this.easing(e, n, this.byValue[s], this.duration, s));
    return { value: t, valueProgress: Math.abs((t[0] - this.startValue[0]) / this.byValue[0]) };
  }
}
const t3 = ["startValue", "endValue", "easing", "onChange", "onComplete", "abort"], r3 = (r, e, t, n) => e + t * (1 - Math.cos(r / n * Os)), ad = (r) => r && ((e, t, n) => r(new lt(e).toRgba(), t, n));
class n3 extends Sp {
  constructor(e) {
    let { startValue: t, endValue: n, easing: s = r3, onChange: i, onComplete: a, abort: c } = e, u = yt(e, t3);
    const h = new lt(t).getSource(), d = new lt(n).getSource();
    super(L(L({}, u), {}, { startValue: h, byValue: d.map((p, g) => p - h[g]), easing: s, onChange: ad(i), onComplete: ad(a), abort: ad(c) }));
  }
  calculate(e) {
    const [t, n, s, i] = this.startValue.map((c, u) => this.easing(e, c, this.byValue[u], this.duration, u)), a = [...[t, n, s].map(Math.round), gi(0, i, 1)];
    return { value: a, valueProgress: a.map((c, u) => this.byValue[u] !== 0 ? Math.abs((c - this.startValue[u]) / this.byValue[u]) : 0).find((c) => c !== 0) || 0 };
  }
}
function Cp(r) {
  const e = ((t) => Array.isArray(t.startValue) || Array.isArray(t.endValue))(r) ? new e3(r) : new JR(r);
  return e.start(), e;
}
function Ew(r) {
  const e = new n3(r);
  return e.start(), e;
}
class St {
  constructor(e) {
    this.status = e, this.points = [];
  }
  includes(e) {
    return this.points.some((t) => t.eq(e));
  }
  append() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    return this.points = this.points.concat(t.filter((s) => !this.includes(s))), this;
  }
  static isPointContained(e, t, n) {
    let s = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
    if (t.eq(n)) return e.eq(t);
    if (t.x === n.x) return e.x === t.x && (s || e.y >= Math.min(t.y, n.y) && e.y <= Math.max(t.y, n.y));
    if (t.y === n.y) return e.y === t.y && (s || e.x >= Math.min(t.x, n.x) && e.x <= Math.max(t.x, n.x));
    {
      const i = Il(t, n), a = Il(t, e).divide(i);
      return s ? Math.abs(a.x) === Math.abs(a.y) : a.x === a.y && a.x >= 0 && a.x <= 1;
    }
  }
  static isPointInPolygon(e, t) {
    const n = new $(e).setX(Math.min(e.x - 1, ...t.map((i) => i.x)));
    let s = 0;
    for (let i = 0; i < t.length; i++) {
      const a = this.intersectSegmentSegment(t[i], t[(i + 1) % t.length], e, n);
      if (a.includes(e)) return !0;
      s += +(a.status === "Intersection");
    }
    return s % 2 == 1;
  }
  static intersectLineLine(e, t, n, s) {
    let i = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], a = !(arguments.length > 5 && arguments[5] !== void 0) || arguments[5];
    const c = t.x - e.x, u = t.y - e.y, h = s.x - n.x, d = s.y - n.y, p = e.x - n.x, g = e.y - n.y, v = h * g - d * p, b = c * g - u * p, _ = d * c - h * u;
    if (_ !== 0) {
      const C = v / _, T = b / _;
      return (i || 0 <= C && C <= 1) && (a || 0 <= T && T <= 1) ? new St("Intersection").append(new $(e.x + C * c, e.y + C * u)) : new St();
    }
    if (v === 0 || b === 0) {
      const C = i || a || St.isPointContained(e, n, s) || St.isPointContained(t, n, s) || St.isPointContained(n, e, t) || St.isPointContained(s, e, t);
      return new St(C ? "Coincident" : void 0);
    }
    return new St("Parallel");
  }
  static intersectSegmentLine(e, t, n, s) {
    return St.intersectLineLine(e, t, n, s, !1, !0);
  }
  static intersectSegmentSegment(e, t, n, s) {
    return St.intersectLineLine(e, t, n, s, !1, !1);
  }
  static intersectLinePolygon(e, t, n) {
    let s = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
    const i = new St(), a = n.length;
    for (let c, u, h, d = 0; d < a; d++) {
      if (c = n[d], u = n[(d + 1) % a], h = St.intersectLineLine(e, t, c, u, s, !1), h.status === "Coincident") return h;
      i.append(...h.points);
    }
    return i.points.length > 0 && (i.status = "Intersection"), i;
  }
  static intersectSegmentPolygon(e, t, n) {
    return St.intersectLinePolygon(e, t, n, !1);
  }
  static intersectPolygonPolygon(e, t) {
    const n = new St(), s = e.length, i = [];
    for (let a = 0; a < s; a++) {
      const c = e[a], u = e[(a + 1) % s], h = St.intersectSegmentPolygon(c, u, t);
      h.status === "Coincident" ? (i.push(h), n.append(c, u)) : n.append(...h.points);
    }
    return i.length > 0 && i.length === e.length ? new St("Coincident") : (n.points.length > 0 && (n.status = "Intersection"), n);
  }
  static intersectPolygonRectangle(e, t, n) {
    const s = t.min(n), i = t.max(n), a = new $(i.x, s.y), c = new $(s.x, i.y);
    return St.intersectPolygonPolygon(e, [s, a, i, c]);
  }
}
class s3 extends rw {
  getX() {
    return this.getXY().x;
  }
  setX(e) {
    this.setXY(this.getXY().setX(e));
  }
  getY() {
    return this.getXY().y;
  }
  setY(e) {
    this.setXY(this.getXY().setY(e));
  }
  getRelativeX() {
    return this.left;
  }
  setRelativeX(e) {
    this.left = e;
  }
  getRelativeY() {
    return this.top;
  }
  setRelativeY(e) {
    this.top = e;
  }
  getXY() {
    const e = this.getRelativeXY();
    return this.group ? ur(e, this.group.calcTransformMatrix()) : e;
  }
  setXY(e, t, n) {
    this.group && (e = ur(e, Ur(this.group.calcTransformMatrix()))), this.setRelativeXY(e, t, n);
  }
  getRelativeXY() {
    return new $(this.left, this.top);
  }
  setRelativeXY(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.originX, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.originY;
    this.setPositionByOrigin(e, t, n);
  }
  isStrokeAccountedForInDimensions() {
    return !1;
  }
  getCoords() {
    const { tl: e, tr: t, br: n, bl: s } = this.aCoords || (this.aCoords = this.calcACoords()), i = [e, t, n, s];
    if (this.group) {
      const a = this.group.calcTransformMatrix();
      return i.map((c) => ur(c, a));
    }
    return i;
  }
  intersectsWithRect(e, t) {
    return St.intersectPolygonRectangle(this.getCoords(), e, t).status === "Intersection";
  }
  intersectsWithObject(e) {
    const t = St.intersectPolygonPolygon(this.getCoords(), e.getCoords());
    return t.status === "Intersection" || t.status === "Coincident" || e.isContainedWithinObject(this) || this.isContainedWithinObject(e);
  }
  isContainedWithinObject(e) {
    return this.getCoords().every((t) => e.containsPoint(t));
  }
  isContainedWithinRect(e, t) {
    const { left: n, top: s, width: i, height: a } = this.getBoundingRect();
    return n >= e.x && n + i <= t.x && s >= e.y && s + a <= t.y;
  }
  isOverlapping(e) {
    return this.intersectsWithObject(e) || this.isContainedWithinObject(e) || e.isContainedWithinObject(this);
  }
  containsPoint(e) {
    return St.isPointInPolygon(e, this.getCoords());
  }
  isOnScreen() {
    if (!this.canvas) return !1;
    const { tl: e, br: t } = this.canvas.vptCoords;
    return !!this.getCoords().some((n) => n.x <= t.x && n.x >= e.x && n.y <= t.y && n.y >= e.y) || !!this.intersectsWithRect(e, t) || this.containsPoint(e.midPointFrom(t));
  }
  isPartiallyOnScreen() {
    if (!this.canvas) return !1;
    const { tl: e, br: t } = this.canvas.vptCoords;
    return this.intersectsWithRect(e, t) ? !0 : this.getCoords().every((n) => (n.x >= t.x || n.x <= e.x) && (n.y >= t.y || n.y <= e.y)) && this.containsPoint(e.midPointFrom(t));
  }
  getBoundingRect() {
    return jn(this.getCoords());
  }
  getScaledWidth() {
    return this._getTransformedDimensions().x;
  }
  getScaledHeight() {
    return this._getTransformedDimensions().y;
  }
  scale(e) {
    this._set(Sr, e), this._set($r, e), this.setCoords();
  }
  scaleToWidth(e) {
    const t = this.getBoundingRect().width / this.getScaledWidth();
    return this.scale(e / this.width / t);
  }
  scaleToHeight(e) {
    const t = this.getBoundingRect().height / this.getScaledHeight();
    return this.scale(e / this.height / t);
  }
  getCanvasRetinaScaling() {
    var e;
    return ((e = this.canvas) === null || e === void 0 ? void 0 : e.getRetinaScaling()) || 1;
  }
  getTotalAngle() {
    return this.group ? As(ow(this.calcTransformMatrix())) : this.angle;
  }
  getViewportTransform() {
    var e;
    return ((e = this.canvas) === null || e === void 0 ? void 0 : e.viewportTransform) || _r.concat();
  }
  calcACoords() {
    const e = Ao({ angle: this.angle }), { x: t, y: n } = this.getRelativeCenterPoint(), s = Mo(t, n), i = At(s, e), a = this._getTransformedDimensions(), c = a.x / 2, u = a.y / 2;
    return { tl: ur({ x: -c, y: -u }, i), tr: ur({ x: c, y: -u }, i), bl: ur({ x: -c, y: u }, i), br: ur({ x: c, y: u }, i) };
  }
  setCoords() {
    this.aCoords = this.calcACoords();
  }
  transformMatrixKey() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], t = [];
    return !e && this.group && (t = this.group.transformMatrixKey(e)), t.push(this.top, this.left, this.width, this.height, this.scaleX, this.scaleY, this.angle, this.strokeWidth, this.skewX, this.skewY, +this.flipX, +this.flipY, Lt(this.originX), Lt(this.originY)), t;
  }
  calcTransformMatrix() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], t = this.calcOwnMatrix();
    if (e || !this.group) return t;
    const n = this.transformMatrixKey(e), s = this.matrixCache;
    return s && s.key.every((i, a) => i === n[a]) ? s.value : (this.group && (t = At(this.group.calcTransformMatrix(!1), t)), this.matrixCache = { key: n, value: t }, t);
  }
  calcOwnMatrix() {
    const e = this.transformMatrixKey(!0), t = this.ownMatrixCache;
    if (t && t.key === e) return t.value;
    const n = this.getRelativeCenterPoint(), s = { angle: this.angle, translateX: n.x, translateY: n.y, scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, flipX: this.flipX, flipY: this.flipY }, i = cw(s);
    return this.ownMatrixCache = { key: e, value: i }, i;
  }
  _getNonTransformedDimensions() {
    return new $(this.width, this.height).scalarAdd(this.strokeWidth);
  }
  _calculateCurrentDimensions(e) {
    return this._getTransformedDimensions(e).transform(this.getViewportTransform(), !0).scalarAdd(2 * this.padding);
  }
  _getTransformedDimensions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = L({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, width: this.width, height: this.height, strokeWidth: this.strokeWidth }, e), n = t.strokeWidth;
    let s = n, i = 0;
    this.strokeUniform && (s = 0, i = n);
    const a = t.width + s, c = t.height + s;
    let u;
    return u = t.skewX === 0 && t.skewY === 0 ? new $(a * t.scaleX, c * t.scaleY) : bu(a, c, za(t)), u.scalarAdd(i);
  }
  translateToGivenOrigin(e, t, n, s, i) {
    let a = e.x, c = e.y;
    const u = Lt(s) - Lt(t), h = Lt(i) - Lt(n);
    if (u || h) {
      const d = this._getTransformedDimensions();
      a += u * d.x, c += h * d.y;
    }
    return new $(a, c);
  }
  translateToCenterPoint(e, t, n) {
    if (t === Be && n === Be) return e;
    const s = this.translateToGivenOrigin(e, t, n, Be, Be);
    return this.angle ? s.rotate(Mt(this.angle), e) : s;
  }
  translateToOriginPoint(e, t, n) {
    const s = this.translateToGivenOrigin(e, Be, Be, t, n);
    return this.angle ? s.rotate(Mt(this.angle), e) : s;
  }
  getCenterPoint() {
    const e = this.getRelativeCenterPoint();
    return this.group ? ur(e, this.group.calcTransformMatrix()) : e;
  }
  getRelativeCenterPoint() {
    return this.translateToCenterPoint(new $(this.left, this.top), this.originX, this.originY);
  }
  getPointByOrigin(e, t) {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), e, t);
  }
  setPositionByOrigin(e, t, n) {
    const s = this.translateToCenterPoint(e, t, n), i = this.translateToOriginPoint(s, this.originX, this.originY);
    this.set({ left: i.x, top: i.y });
  }
  _getLeftTopCoords() {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), at, Pr);
  }
}
const i3 = ["type"], o3 = ["extraParam"];
let Jn = class gl extends s3 {
  static getDefaults() {
    return gl.ownDefaults;
  }
  get type() {
    const e = this.constructor.type;
    return e === "FabricObject" ? "object" : e.toLowerCase();
  }
  set type(e) {
    ks("warn", "Setting type has no effect", e);
  }
  constructor(e) {
    super(), N(this, "_cacheContext", null), Object.assign(this, gl.ownDefaults), this.setOptions(e);
  }
  _createCacheCanvas() {
    this._cacheCanvas = cn(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = !0;
  }
  _limitCacheSize(e) {
    const t = e.width, n = e.height, s = et.maxCacheSideLimit, i = et.minCacheSideLimit;
    if (t <= s && n <= s && t * n <= et.perfLimitSizeTotal) return t < i && (e.width = i), n < i && (e.height = i), e;
    const a = t / n, [c, u] = pa.limitDimsByArea(a), h = gi(i, c, s), d = gi(i, u, s);
    return t > h && (e.zoomX /= t / h, e.width = h, e.capped = !0), n > d && (e.zoomY /= n / d, e.height = d, e.capped = !0), e;
  }
  _getCacheCanvasDimensions() {
    const e = this.getTotalObjectScaling(), t = this._getTransformedDimensions({ skewX: 0, skewY: 0 }), n = t.x * e.x / this.scaleX, s = t.y * e.y / this.scaleY;
    return { width: Math.ceil(n + 2), height: Math.ceil(s + 2), zoomX: e.x, zoomY: e.y, x: n, y: s };
  }
  _updateCacheCanvas() {
    const e = this._cacheCanvas, t = this._cacheContext, { width: n, height: s, zoomX: i, zoomY: a, x: c, y: u } = this._limitCacheSize(this._getCacheCanvasDimensions()), h = n !== e.width || s !== e.height, d = this.zoomX !== i || this.zoomY !== a;
    if (!e || !t) return !1;
    if (h || d) {
      n !== e.width || s !== e.height ? (e.width = n, e.height = s) : (t.setTransform(1, 0, 0, 1, 0, 0), t.clearRect(0, 0, e.width, e.height));
      const p = c / 2, g = u / 2;
      return this.cacheTranslationX = Math.round(e.width / 2 - p) + p, this.cacheTranslationY = Math.round(e.height / 2 - g) + g, t.translate(this.cacheTranslationX, this.cacheTranslationY), t.scale(i, a), this.zoomX = i, this.zoomY = a, !0;
    }
    return !1;
  }
  setOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setOptions(e);
  }
  transform(e) {
    const t = this.group && !this.group._transformDone || this.group && this.canvas && e === this.canvas.contextTop, n = this.calcTransformMatrix(!t);
    e.transform(n[0], n[1], n[2], n[3], n[4], n[5]);
  }
  getObjectScaling() {
    if (!this.group) return new $(Math.abs(this.scaleX), Math.abs(this.scaleY));
    const e = lo(this.calcTransformMatrix());
    return new $(Math.abs(e.scaleX), Math.abs(e.scaleY));
  }
  getTotalObjectScaling() {
    const e = this.getObjectScaling();
    if (this.canvas) {
      const t = this.canvas.getZoom(), n = this.getCanvasRetinaScaling();
      return e.scalarMultiply(t * n);
    }
    return e;
  }
  getObjectOpacity() {
    let e = this.opacity;
    return this.group && (e *= this.group.getObjectOpacity()), e;
  }
  _constrainScale(e) {
    return Math.abs(e) < this.minScaleLimit ? e < 0 ? -this.minScaleLimit : this.minScaleLimit : e === 0 ? 1e-4 : e;
  }
  _set(e, t) {
    e !== Sr && e !== $r || (t = this._constrainScale(t)), e === Sr && t < 0 ? (this.flipX = !this.flipX, t *= -1) : e === "scaleY" && t < 0 ? (this.flipY = !this.flipY, t *= -1) : e !== "shadow" || !t || t instanceof ss || (t = new ss(t));
    const n = this[e] !== t;
    return this[e] = t, n && this.constructor.cacheProperties.includes(e) && (this.dirty = !0), this.parent && (this.dirty || n && this.constructor.stateProperties.includes(e)) && this.parent._set("dirty", !0), this;
  }
  isNotVisible() {
    return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;
  }
  render(e) {
    this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (e.save(), this._setupCompositeOperation(e), this.drawSelectionBackground(e), this.transform(e), this._setOpacity(e), this._setShadow(e), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(e)) : (this._removeCacheCanvas(), this.drawObject(e, !1, {}), this.dirty = !1), e.restore());
  }
  drawSelectionBackground(e) {
  }
  renderCache(e) {
    if (e = e || {}, this._cacheCanvas && this._cacheContext || this._createCacheCanvas(), this.isCacheDirty() && this._cacheContext) {
      const { zoomX: t, zoomY: n, cacheTranslationX: s, cacheTranslationY: i } = this, { width: a, height: c } = this._cacheCanvas;
      this.drawObject(this._cacheContext, e.forClipping, { zoomX: t, zoomY: n, cacheTranslationX: s, cacheTranslationY: i, width: a, height: c, parentClipPaths: [] }), this.dirty = !1;
    }
  }
  _removeCacheCanvas() {
    this._cacheCanvas = void 0, this._cacheContext = null;
  }
  hasStroke() {
    return this.stroke && this.stroke !== "transparent" && this.strokeWidth !== 0;
  }
  hasFill() {
    return this.fill && this.fill !== "transparent";
  }
  needsItsOwnCache() {
    return !!(this.paintFirst === Rr && this.hasFill() && this.hasStroke() && this.shadow) || !!this.clipPath;
  }
  shouldCache() {
    return this.ownCaching = this.objectCaching && (!this.parent || !this.parent.isOnACache()) || this.needsItsOwnCache(), this.ownCaching;
  }
  willDrawShadow() {
    return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
  }
  drawClipPathOnCache(e, t, n) {
    e.save(), t.inverted ? e.globalCompositeOperation = "destination-out" : e.globalCompositeOperation = "destination-in", e.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(n, 0, 0), e.restore();
  }
  drawObject(e, t, n) {
    const s = this.fill, i = this.stroke;
    t ? (this.fill = "black", this.stroke = "", this._setClippingProperties(e)) : this._renderBackground(e), this._render(e), this._drawClipPath(e, this.clipPath, n), this.fill = s, this.stroke = i;
  }
  createClipPathLayer(e, t) {
    const n = _n(t), s = n.getContext("2d");
    if (s.translate(t.cacheTranslationX, t.cacheTranslationY), s.scale(t.zoomX, t.zoomY), e._cacheCanvas = n, t.parentClipPaths.forEach((i) => {
      i.transform(s);
    }), t.parentClipPaths.push(e), e.absolutePositioned) {
      const i = Ur(this.calcTransformMatrix());
      s.transform(i[0], i[1], i[2], i[3], i[4], i[5]);
    }
    return e.transform(s), e.drawObject(s, !0, t), n;
  }
  _drawClipPath(e, t, n) {
    if (!t) return;
    t._transformDone = !0;
    const s = this.createClipPathLayer(t, n);
    this.drawClipPathOnCache(e, t, s);
  }
  drawCacheOnCanvas(e) {
    e.scale(1 / this.zoomX, 1 / this.zoomY), e.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
  }
  isCacheDirty() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
    if (this.isNotVisible()) return !1;
    const t = this._cacheCanvas, n = this._cacheContext;
    return !(!t || !n || e || !this._updateCacheCanvas()) || !!(this.dirty || this.clipPath && this.clipPath.absolutePositioned) && (t && n && !e && (n.save(), n.setTransform(1, 0, 0, 1, 0, 0), n.clearRect(0, 0, t.width, t.height), n.restore()), !0);
  }
  _renderBackground(e) {
    if (!this.backgroundColor) return;
    const t = this._getNonTransformedDimensions();
    e.fillStyle = this.backgroundColor, e.fillRect(-t.x / 2, -t.y / 2, t.x, t.y), this._removeShadow(e);
  }
  _setOpacity(e) {
    this.group && !this.group._transformDone ? e.globalAlpha = this.getObjectOpacity() : e.globalAlpha *= this.opacity;
  }
  _setStrokeStyles(e, t) {
    const n = t.stroke;
    n && (e.lineWidth = t.strokeWidth, e.lineCap = t.strokeLineCap, e.lineDashOffset = t.strokeDashOffset, e.lineJoin = t.strokeLineJoin, e.miterLimit = t.strokeMiterLimit, on(n) ? n.gradientUnits === "percentage" || n.gradientTransform || n.patternTransform ? this._applyPatternForTransformedGradient(e, n) : (e.strokeStyle = n.toLive(e), this._applyPatternGradientTransform(e, n)) : e.strokeStyle = t.stroke);
  }
  _setFillStyles(e, t) {
    let { fill: n } = t;
    n && (on(n) ? (e.fillStyle = n.toLive(e), this._applyPatternGradientTransform(e, n)) : e.fillStyle = n);
  }
  _setClippingProperties(e) {
    e.globalAlpha = 1, e.strokeStyle = "transparent", e.fillStyle = "#000000";
  }
  _setLineDash(e, t) {
    t && t.length !== 0 && e.setLineDash(t);
  }
  _setShadow(e) {
    if (!this.shadow) return;
    const t = this.shadow, n = this.canvas, s = this.getCanvasRetinaScaling(), [i, , , a] = n?.viewportTransform || _r, c = i * s, u = a * s, h = t.nonScaling ? new $(1, 1) : this.getObjectScaling();
    e.shadowColor = t.color, e.shadowBlur = t.blur * et.browserShadowBlurConstant * (c + u) * (h.x + h.y) / 4, e.shadowOffsetX = t.offsetX * c * h.x, e.shadowOffsetY = t.offsetY * u * h.y;
  }
  _removeShadow(e) {
    this.shadow && (e.shadowColor = "", e.shadowBlur = e.shadowOffsetX = e.shadowOffsetY = 0);
  }
  _applyPatternGradientTransform(e, t) {
    if (!on(t)) return { offsetX: 0, offsetY: 0 };
    const n = t.gradientTransform || t.patternTransform, s = -this.width / 2 + t.offsetX || 0, i = -this.height / 2 + t.offsetY || 0;
    return t.gradientUnits === "percentage" ? e.transform(this.width, 0, 0, this.height, s, i) : e.transform(1, 0, 0, 1, s, i), n && e.transform(n[0], n[1], n[2], n[3], n[4], n[5]), { offsetX: s, offsetY: i };
  }
  _renderPaintInOrder(e) {
    this.paintFirst === Rr ? (this._renderStroke(e), this._renderFill(e)) : (this._renderFill(e), this._renderStroke(e));
  }
  _render(e) {
  }
  _renderFill(e) {
    this.fill && (e.save(), this._setFillStyles(e, this), this.fillRule === "evenodd" ? e.fill("evenodd") : e.fill(), e.restore());
  }
  _renderStroke(e) {
    if (this.stroke && this.strokeWidth !== 0) {
      if (this.shadow && !this.shadow.affectStroke && this._removeShadow(e), e.save(), this.strokeUniform) {
        const t = this.getObjectScaling();
        e.scale(1 / t.x, 1 / t.y);
      }
      this._setLineDash(e, this.strokeDashArray), this._setStrokeStyles(e, this), e.stroke(), e.restore();
    }
  }
  _applyPatternForTransformedGradient(e, t) {
    var n;
    const s = this._limitCacheSize(this._getCacheCanvasDimensions()), i = this.getCanvasRetinaScaling(), a = s.x / this.scaleX / i, c = s.y / this.scaleY / i, u = _n({ width: Math.ceil(a), height: Math.ceil(c) }), h = u.getContext("2d");
    h && (h.beginPath(), h.moveTo(0, 0), h.lineTo(a, 0), h.lineTo(a, c), h.lineTo(0, c), h.closePath(), h.translate(a / 2, c / 2), h.scale(s.zoomX / this.scaleX / i, s.zoomY / this.scaleY / i), this._applyPatternGradientTransform(h, t), h.fillStyle = t.toLive(e), h.fill(), e.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), e.scale(i * this.scaleX / s.zoomX, i * this.scaleY / s.zoomY), e.strokeStyle = (n = h.createPattern(u, "no-repeat")) !== null && n !== void 0 ? n : "");
  }
  _findCenterFromElement() {
    return new $(this.left + this.width / 2, this.top + this.height / 2);
  }
  clone(e) {
    const t = this.toObject(e);
    return this.constructor.fromObject(t);
  }
  cloneAsImage(e) {
    const t = this.toCanvasElement(e);
    return new (le.getClass("image"))(t);
  }
  toCanvasElement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = yp(this), n = this.group, s = this.shadow, i = Math.abs, a = e.enableRetinaScaling ? Kb() : 1, c = (e.multiplier || 1) * a, u = e.canvasProvider || ((k) => new Ha(k, { enableRetinaScaling: !1, renderOnAddRemove: !1, skipOffscreen: !1 }));
    delete this.group, e.withoutTransform && mw(this), e.withoutShadow && (this.shadow = null), e.viewportTransform && of(this, this.getViewportTransform()), this.setCoords();
    const h = cn(), d = this.getBoundingRect(), p = this.shadow, g = new $();
    if (p) {
      const k = p.blur, M = p.nonScaling ? new $(1, 1) : this.getObjectScaling();
      g.x = 2 * Math.round(i(p.offsetX) + k) * i(M.x), g.y = 2 * Math.round(i(p.offsetY) + k) * i(M.y);
    }
    const v = d.width + g.x, b = d.height + g.y;
    h.width = Math.ceil(v), h.height = Math.ceil(b);
    const _ = u(h);
    e.format === "jpeg" && (_.backgroundColor = "#fff"), this.setPositionByOrigin(new $(_.width / 2, _.height / 2), Be, Be);
    const C = this.canvas;
    _._objects = [this], this.set("canvas", _), this.setCoords();
    const T = _.toCanvasElement(c || 1, e);
    return this.set("canvas", C), this.shadow = s, n && (this.group = n), this.set(t), this.setCoords(), _._objects = [], _.destroy(), T;
  }
  toDataURL() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return pp(this.toCanvasElement(e), e.format || "png", e.quality || 1);
  }
  isType() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    return t.includes(this.constructor.type) || t.includes(this.type);
  }
  complexity() {
    return 1;
  }
  toJSON() {
    return this.toObject();
  }
  rotate(e) {
    const { centeredRotation: t, originX: n, originY: s } = this;
    if (t) {
      const { x: i, y: a } = this.getRelativeCenterPoint();
      this.originX = Be, this.originY = Be, this.left = i, this.top = a;
    }
    if (this.set("angle", e), t) {
      const { x: i, y: a } = this.translateToOriginPoint(this.getRelativeCenterPoint(), n, s);
      this.left = i, this.top = a, this.originX = n, this.originY = s;
    }
  }
  setOnGroup() {
  }
  _setupCompositeOperation(e) {
    this.globalCompositeOperation && (e.globalCompositeOperation = this.globalCompositeOperation);
  }
  dispose() {
    Ol.cancelByTarget(this), this.off(), this._set("canvas", void 0), this._cacheCanvas && Fn().dispose(this._cacheCanvas), this._cacheCanvas = void 0, this._cacheContext = null;
  }
  animate(e, t) {
    return Object.entries(e).reduce((n, s) => {
      let [i, a] = s;
      return n[i] = this._animate(i, a, t), n;
    }, {});
  }
  _animate(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const s = e.split("."), i = this.constructor.colorProperties.includes(s[s.length - 1]), { abort: a, startValue: c, onChange: u, onComplete: h } = n, d = L(L({}, n), {}, { target: this, startValue: c ?? s.reduce((p, g) => p[g], this), endValue: t, abort: a?.bind(this), onChange: (p, g, v) => {
      s.reduce((b, _, C) => (C === s.length - 1 && (b[_] = p), b[_]), this), u && u(p, g, v);
    }, onComplete: (p, g, v) => {
      this.setCoords(), h && h(p, g, v);
    } });
    return i ? Ew(d) : Cp(d);
  }
  isDescendantOf(e) {
    const { parent: t, group: n } = this;
    return t === e || n === e || !!t && t.isDescendantOf(e) || !!n && n !== t && n.isDescendantOf(e);
  }
  getAncestors() {
    const e = [];
    let t = this;
    do
      t = t.parent, t && e.push(t);
    while (t);
    return e;
  }
  findCommonAncestors(e) {
    if (this === e) return { fork: [], otherFork: [], common: [this, ...this.getAncestors()] };
    const t = this.getAncestors(), n = e.getAncestors();
    if (t.length === 0 && n.length > 0 && this === n[n.length - 1]) return { fork: [], otherFork: [e, ...n.slice(0, n.length - 1)], common: [this] };
    for (let s, i = 0; i < t.length; i++) {
      if (s = t[i], s === e) return { fork: [this, ...t.slice(0, i)], otherFork: [], common: t.slice(i) };
      for (let a = 0; a < n.length; a++) {
        if (this === n[a]) return { fork: [], otherFork: [e, ...n.slice(0, a)], common: [this, ...t] };
        if (s === n[a]) return { fork: [this, ...t.slice(0, i)], otherFork: [e, ...n.slice(0, a)], common: t.slice(i) };
      }
    }
    return { fork: [this, ...t], otherFork: [e, ...n], common: [] };
  }
  hasCommonAncestors(e) {
    const t = this.findCommonAncestors(e);
    return t && !!t.common.length;
  }
  isInFrontOf(e) {
    if (this === e) return;
    const t = this.findCommonAncestors(e);
    if (t.fork.includes(e)) return !0;
    if (t.otherFork.includes(this)) return !1;
    const n = t.common[0] || this.canvas;
    if (!n) return;
    const s = t.fork.pop(), i = t.otherFork.pop(), a = n._objects.indexOf(s), c = n._objects.indexOf(i);
    return a > -1 && a > c;
  }
  toObject() {
    const e = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).concat(gl.customProperties, this.constructor.customProperties || []);
    let t;
    const n = et.NUM_FRACTION_DIGITS, { clipPath: s, fill: i, stroke: a, shadow: c, strokeDashArray: u, left: h, top: d, originX: p, originY: g, width: v, height: b, strokeWidth: _, strokeLineCap: C, strokeDashOffset: T, strokeLineJoin: k, strokeUniform: M, strokeMiterLimit: A, scaleX: D, scaleY: F, angle: U, flipX: B, flipY: X, opacity: Y, visible: Z, backgroundColor: G, fillRule: K, paintFirst: oe, globalCompositeOperation: ve, skewX: Q, skewY: ge } = this;
    s && !s.excludeFromExport && (t = s.toObject(e.concat("inverted", "absolutePositioned")));
    const de = (I) => vt(I, n), ne = L(L({}, ki(this, e)), {}, { type: this.constructor.type, version: tf, originX: p, originY: g, left: de(h), top: de(d), width: de(v), height: de(b), fill: T0(i) ? i.toObject() : i, stroke: T0(a) ? a.toObject() : a, strokeWidth: de(_), strokeDashArray: u && u.concat(), strokeLineCap: C, strokeDashOffset: T, strokeLineJoin: k, strokeUniform: M, strokeMiterLimit: de(A), scaleX: de(D), scaleY: de(F), angle: de(U), flipX: B, flipY: X, opacity: de(Y), shadow: c && c.toObject(), visible: Z, backgroundColor: G, fillRule: K, paintFirst: oe, globalCompositeOperation: ve, skewX: de(Q), skewY: de(ge) }, t ? { clipPath: t } : null);
    return this.includeDefaultValues ? ne : this._removeDefaultValues(ne);
  }
  toDatalessObject(e) {
    return this.toObject(e);
  }
  _removeDefaultValues(e) {
    const t = this.constructor.getDefaults(), n = Object.keys(t).length > 0 ? t : Object.getPrototypeOf(this);
    return vp(e, (s, i) => {
      if (i === at || i === Pr || i === "type") return !0;
      const a = n[i];
      return s !== a && !(Array.isArray(s) && Array.isArray(a) && s.length === 0 && a.length === 0);
    });
  }
  toString() {
    return "#<".concat(this.constructor.type, ">");
  }
  static _fromObject(e) {
    let t = yt(e, i3), n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { extraParam: s } = n, i = yt(n, o3);
    return Wa(t, i).then((a) => s ? (delete a[s], new this(t[s], a)) : new this(a));
  }
  static fromObject(e, t) {
    return this._fromObject(e, t);
  }
};
N(Jn, "stateProperties", XR), N(Jn, "cacheProperties", as), N(Jn, "ownDefaults", GR), N(Jn, "type", "FabricObject"), N(Jn, "colorProperties", [Xt, Rr, "backgroundColor"]), N(Jn, "customProperties", []), le.setClass(Jn), le.setClass(Jn, "object");
const Ns = (r, e, t) => (n, s, i, a) => {
  const c = e(n, s, i, a);
  return c && bp(r, L(L({}, wp(n, s, i, a)), t)), c;
};
function Oi(r) {
  return (e, t, n, s) => {
    const { target: i, originX: a, originY: c } = t, u = i.getRelativeCenterPoint(), h = i.translateToOriginPoint(u, a, c), d = r(e, t, n, s);
    return i.setPositionByOrigin(h, t.originX, t.originY), d;
  };
}
const lf = Ns(Sa, Oi((r, e, t, n) => {
  const s = wu(e, e.originX, e.originY, t, n);
  if (Lt(e.originX) === Lt(Be) || Lt(e.originX) === Lt(Rt) && s.x < 0 || Lt(e.originX) === Lt(at) && s.x > 0) {
    const { target: i } = e, a = i.strokeWidth / (i.strokeUniform ? i.scaleX : 1), c = yw(e) ? 2 : 1, u = i.width, h = Math.abs(s.x * c / i.scaleX) - a;
    return i.set("width", Math.max(h, 1)), u !== i.width;
  }
  return !1;
}));
function kw(r, e, t, n, s) {
  n = n || {};
  const i = this.sizeX || n.cornerSize || s.cornerSize, a = this.sizeY || n.cornerSize || s.cornerSize, c = n.transparentCorners !== void 0 ? n.transparentCorners : s.transparentCorners, u = c ? Rr : Xt, h = !c && (n.cornerStrokeColor || s.cornerStrokeColor);
  let d, p = e, g = t;
  r.save(), r.fillStyle = n.cornerColor || s.cornerColor || "", r.strokeStyle = n.cornerStrokeColor || s.cornerStrokeColor || "", i > a ? (d = i, r.scale(1, a / i), g = t * i / a) : a > i ? (d = a, r.scale(i / a, 1), p = e * a / i) : d = i, r.beginPath(), r.arc(p, g, d / 2, 0, os, !1), r[u](), h && r.stroke(), r.restore();
}
function Ow(r, e, t, n, s) {
  n = n || {};
  const i = this.sizeX || n.cornerSize || s.cornerSize, a = this.sizeY || n.cornerSize || s.cornerSize, c = n.transparentCorners !== void 0 ? n.transparentCorners : s.transparentCorners, u = c ? Rr : Xt, h = !c && (n.cornerStrokeColor || s.cornerStrokeColor), d = i / 2, p = a / 2;
  r.save(), r.fillStyle = n.cornerColor || s.cornerColor || "", r.strokeStyle = n.cornerStrokeColor || s.cornerStrokeColor || "", r.translate(e, t);
  const g = s.getTotalAngle();
  r.rotate(Mt(g)), r["".concat(u, "Rect")](-d, -p, i, a), h && r.strokeRect(-d, -p, i, a), r.restore();
}
class Ct {
  constructor(e) {
    N(this, "visible", !0), N(this, "actionName", mu), N(this, "angle", 0), N(this, "x", 0), N(this, "y", 0), N(this, "offsetX", 0), N(this, "offsetY", 0), N(this, "sizeX", 0), N(this, "sizeY", 0), N(this, "touchSizeX", 0), N(this, "touchSizeY", 0), N(this, "cursorStyle", "crosshair"), N(this, "withConnection", !1), Object.assign(this, e);
  }
  shouldActivate(e, t, n, s) {
    var i;
    let { tl: a, tr: c, br: u, bl: h } = s;
    return ((i = t.canvas) === null || i === void 0 ? void 0 : i.getActiveObject()) === t && t.isControlVisible(e) && St.isPointInPolygon(n, [a, c, u, h]);
  }
  getActionHandler(e, t, n) {
    return this.actionHandler;
  }
  getMouseDownHandler(e, t, n) {
    return this.mouseDownHandler;
  }
  getMouseUpHandler(e, t, n) {
    return this.mouseUpHandler;
  }
  cursorStyleHandler(e, t, n) {
    return t.cursorStyle;
  }
  getActionName(e, t, n) {
    return t.actionName;
  }
  getVisibility(e, t) {
    var n, s;
    return (n = (s = e._controlsVisibility) === null || s === void 0 ? void 0 : s[t]) !== null && n !== void 0 ? n : this.visible;
  }
  setVisibility(e, t, n) {
    this.visible = e;
  }
  positionHandler(e, t, n, s) {
    return new $(this.x * e.x + this.offsetX, this.y * e.y + this.offsetY).transform(t);
  }
  calcCornerCoords(e, t, n, s, i, a) {
    const c = vu([Mo(n, s), Ao({ angle: e }), yu((i ? this.touchSizeX : this.sizeX) || t, (i ? this.touchSizeY : this.sizeY) || t)]);
    return { tl: new $(-0.5, -0.5).transform(c), tr: new $(0.5, -0.5).transform(c), br: new $(0.5, 0.5).transform(c), bl: new $(-0.5, 0.5).transform(c) };
  }
  render(e, t, n, s, i) {
    ((s = s || {}).cornerStyle || i.cornerStyle) === "circle" ? kw.call(this, e, t, n, s, i) : Ow.call(this, e, t, n, s, i);
  }
}
const Mw = (r, e, t) => t.lockRotation ? Al : e.cursorStyle, Aw = Ns(Jb, Oi((r, e, t, n) => {
  let { target: s, ex: i, ey: a, theta: c, originX: u, originY: h } = e;
  const d = s.translateToOriginPoint(s.getRelativeCenterPoint(), u, h);
  if (yn(s, "lockRotation")) return !1;
  const p = Math.atan2(a - d.y, i - d.x), g = Math.atan2(n - d.y, t - d.x);
  let v = As(g - p + c);
  if (s.snapAngle && s.snapAngle > 0) {
    const _ = s.snapAngle, C = s.snapThreshold || _, T = Math.ceil(v / _) * _, k = Math.floor(v / _) * _;
    Math.abs(v - k) < C ? v = k : Math.abs(v - T) < C && (v = T);
  }
  v < 0 && (v = 360 + v), v %= 360;
  const b = s.angle !== v;
  return s.angle = v, b;
}));
function Iw(r, e) {
  const t = e.canvas, n = r[t.uniScaleKey];
  return t.uniformScaling && !n || !t.uniformScaling && n;
}
function Pw(r, e, t) {
  const n = yn(r, "lockScalingX"), s = yn(r, "lockScalingY");
  if (n && s || !e && (n || s) && t || n && e === "x" || s && e === "y") return !0;
  const { width: i, height: a, strokeWidth: c } = r;
  return i === 0 && c === 0 && e !== "y" || a === 0 && c === 0 && e !== "x";
}
const a3 = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"], to = (r, e, t) => {
  const n = Iw(r, t);
  if (Pw(t, e.x !== 0 && e.y === 0 ? "x" : e.x === 0 && e.y !== 0 ? "y" : "", n)) return Al;
  const s = bw(t, e);
  return "".concat(a3[s], "-resize");
};
function Tp(r, e, t, n) {
  let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const i = e.target, a = s.by, c = Iw(r, i);
  let u, h, d, p, g, v;
  if (Pw(i, a, c)) return !1;
  if (e.gestureScale) h = e.scaleX * e.gestureScale, d = e.scaleY * e.gestureScale;
  else {
    if (u = wu(e, e.originX, e.originY, t, n), g = a !== "y" ? Math.sign(u.x || e.signX || 1) : 1, v = a !== "x" ? Math.sign(u.y || e.signY || 1) : 1, e.signX || (e.signX = g), e.signY || (e.signY = v), yn(i, "lockScalingFlip") && (e.signX !== g || e.signY !== v)) return !1;
    if (p = i._getTransformedDimensions(), c && !a) {
      const C = Math.abs(u.x) + Math.abs(u.y), { original: T } = e, k = C / (Math.abs(p.x * T.scaleX / i.scaleX) + Math.abs(p.y * T.scaleY / i.scaleY));
      h = T.scaleX * k, d = T.scaleY * k;
    } else h = Math.abs(u.x * i.scaleX / p.x), d = Math.abs(u.y * i.scaleY / p.y);
    yw(e) && (h *= 2, d *= 2), e.signX !== g && a !== "y" && (e.originX = O0(e.originX), h *= -1, e.signX = g), e.signY !== v && a !== "x" && (e.originY = O0(e.originY), d *= -1, e.signY = v);
  }
  const b = i.scaleX, _ = i.scaleY;
  return a ? (a === "x" && i.set(Sr, h), a === "y" && i.set($r, d)) : (!yn(i, "lockScalingX") && i.set(Sr, h), !yn(i, "lockScalingY") && i.set($r, d)), b !== i.scaleX || _ !== i.scaleY;
}
const la = Ns(gu, Oi((r, e, t, n) => Tp(r, e, t, n))), Dw = Ns(gu, Oi((r, e, t, n) => Tp(r, e, t, n, { by: "x" }))), Rw = Ns(gu, Oi((r, e, t, n) => Tp(r, e, t, n, { by: "y" }))), c3 = ["target", "ex", "ey", "skewingSide"], cd = { x: { counterAxis: "y", scale: Sr, skew: ko, lockSkewing: "lockSkewingX", origin: "originX", flip: "flipX" }, y: { counterAxis: "x", scale: $r, skew: Oo, lockSkewing: "lockSkewingY", origin: "originY", flip: "flipY" } }, l3 = ["ns", "nesw", "ew", "nwse"], jw = (r, e, t) => {
  if (e.x !== 0 && yn(t, "lockSkewingY") || e.y !== 0 && yn(t, "lockSkewingX")) return Al;
  const n = bw(t, e) % 4;
  return "".concat(l3[n], "-resize");
};
function Lw(r, e, t, n, s) {
  const { target: i } = t, { counterAxis: a, origin: c, lockSkewing: u, skew: h, flip: d } = cd[r];
  if (yn(i, u)) return !1;
  const { origin: p, flip: g } = cd[a], v = Lt(t[p]) * (i[g] ? -1 : 1), b = -Math.sign(v) * (i[d] ? -1 : 1), _ = 0.5 * -((i[h] === 0 && wu(t, Be, Be, n, s)[r] > 0 || i[h] > 0 ? 1 : -1) * b) + 0.5;
  return Ns(Qb, Oi((T, k, M, A) => function(D, F, U) {
    let { target: B, ex: X, ey: Y, skewingSide: Z } = F, G = yt(F, c3);
    const { skew: K } = cd[D], oe = U.subtract(new $(X, Y)).divide(new $(B.scaleX, B.scaleY))[D], ve = B[K], Q = G[K], ge = Math.tan(Mt(Q)), de = D === "y" ? B._getTransformedDimensions({ scaleX: 1, scaleY: 1, skewX: 0 }).x : B._getTransformedDimensions({ scaleX: 1, scaleY: 1 }).y, ne = 2 * oe * Z / Math.max(de, 1) + ge, I = As(Math.atan(ne));
    B.set(K, I);
    const W = ve !== B[K];
    if (W && D === "y") {
      const { skewX: ce, scaleX: fe } = B, be = B._getTransformedDimensions({ skewY: ve }), ye = B._getTransformedDimensions(), ue = ce !== 0 ? be.x / ye.x : 1;
      ue !== 1 && B.set(Sr, ue * fe);
    }
    return W;
  }(r, k, new $(M, A))))(e, L(L({}, t), {}, { [c]: _, skewingSide: b }), n, s);
}
const Fw = (r, e, t, n) => Lw("x", r, e, t, n), Nw = (r, e, t, n) => Lw("y", r, e, t, n);
function Su(r, e) {
  return r[e.canvas.altActionKey];
}
const ua = (r, e, t) => {
  const n = Su(r, t);
  return e.x === 0 ? n ? ko : $r : e.y === 0 ? n ? Oo : Sr : "";
}, ai = (r, e, t) => Su(r, t) ? jw(0, e, t) : to(r, e, t), uf = (r, e, t, n) => Su(r, e.target) ? Nw(r, e, t, n) : Dw(r, e, t, n), hf = (r, e, t, n) => Su(r, e.target) ? Fw(r, e, t, n) : Rw(r, e, t, n), Ep = () => ({ ml: new Ct({ x: -0.5, y: 0, cursorStyleHandler: ai, actionHandler: uf, getActionName: ua }), mr: new Ct({ x: 0.5, y: 0, cursorStyleHandler: ai, actionHandler: uf, getActionName: ua }), mb: new Ct({ x: 0, y: 0.5, cursorStyleHandler: ai, actionHandler: hf, getActionName: ua }), mt: new Ct({ x: 0, y: -0.5, cursorStyleHandler: ai, actionHandler: hf, getActionName: ua }), tl: new Ct({ x: -0.5, y: -0.5, cursorStyleHandler: to, actionHandler: la }), tr: new Ct({ x: 0.5, y: -0.5, cursorStyleHandler: to, actionHandler: la }), bl: new Ct({ x: -0.5, y: 0.5, cursorStyleHandler: to, actionHandler: la }), br: new Ct({ x: 0.5, y: 0.5, cursorStyleHandler: to, actionHandler: la }), mtr: new Ct({ x: 0, y: -0.5, actionHandler: Aw, cursorStyleHandler: Mw, offsetY: -40, withConnection: !0, actionName: dp }) }), Bw = () => ({ mr: new Ct({ x: 0.5, y: 0, actionHandler: lf, cursorStyleHandler: ai, actionName: Sa }), ml: new Ct({ x: -0.5, y: 0, actionHandler: lf, cursorStyleHandler: ai, actionName: Sa }) }), Vw = () => L(L({}, Ep()), Bw());
class Ea extends Jn {
  static getDefaults() {
    return L(L({}, super.getDefaults()), Ea.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, this.constructor.createControls(), Ea.ownDefaults), this.setOptions(e);
  }
  static createControls() {
    return { controls: Ep() };
  }
  _updateCacheCanvas() {
    const e = this.canvas;
    if (this.noScaleCache && e && e._currentTransform) {
      const t = e._currentTransform, n = t.target, s = t.action;
      if (this === n && s && s.startsWith(mu)) return !1;
    }
    return super._updateCacheCanvas();
  }
  getActiveControl() {
    const e = this.__corner;
    return e ? { key: e, control: this.controls[e], coord: this.oCoords[e] } : void 0;
  }
  findControl(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    if (!this.hasControls || !this.canvas) return;
    this.__corner = void 0;
    const n = Object.entries(this.oCoords);
    for (let s = n.length - 1; s >= 0; s--) {
      const [i, a] = n[s], c = this.controls[i];
      if (c.shouldActivate(i, this, e, t ? a.touchCorner : a.corner)) return this.__corner = i, { key: i, control: c, coord: this.oCoords[i] };
    }
  }
  calcOCoords() {
    const e = this.getViewportTransform(), t = this.getCenterPoint(), n = Mo(t.x, t.y), s = Ao({ angle: this.getTotalAngle() - (this.group && this.flipX ? 180 : 0) }), i = At(n, s), a = At(e, i), c = At(a, [1 / e[0], 0, 0, 1 / e[3], 0, 0]), u = this.group ? lo(this.calcTransformMatrix()) : void 0;
    u && (u.scaleX = Math.abs(u.scaleX), u.scaleY = Math.abs(u.scaleY));
    const h = this._calculateCurrentDimensions(u), d = {};
    return this.forEachControl((p, g) => {
      const v = p.positionHandler(h, c, this, p);
      d[g] = Object.assign(v, this._calcCornerCoords(p, v));
    }), d;
  }
  _calcCornerCoords(e, t) {
    const n = this.getTotalAngle();
    return { corner: e.calcCornerCoords(n, this.cornerSize, t.x, t.y, !1, this), touchCorner: e.calcCornerCoords(n, this.touchCornerSize, t.x, t.y, !0, this) };
  }
  setCoords() {
    super.setCoords(), this.canvas && (this.oCoords = this.calcOCoords());
  }
  forEachControl(e) {
    for (const t in this.controls) e(this.controls[t], t, this);
  }
  drawSelectionBackground(e) {
    if (!this.selectionBackgroundColor || this.canvas && this.canvas._activeObject !== this) return;
    e.save();
    const t = this.getRelativeCenterPoint(), n = this._calculateCurrentDimensions(), s = this.getViewportTransform();
    e.translate(t.x, t.y), e.scale(1 / s[0], 1 / s[3]), e.rotate(Mt(this.angle)), e.fillStyle = this.selectionBackgroundColor, e.fillRect(-n.x / 2, -n.y / 2, n.x, n.y), e.restore();
  }
  strokeBorders(e, t) {
    e.strokeRect(-t.x / 2, -t.y / 2, t.x, t.y);
  }
  _drawBorders(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const s = L({ hasControls: this.hasControls, borderColor: this.borderColor, borderDashArray: this.borderDashArray }, n);
    e.save(), e.strokeStyle = s.borderColor, this._setLineDash(e, s.borderDashArray), this.strokeBorders(e, t), s.hasControls && this.drawControlsConnectingLines(e, t), e.restore();
  }
  _renderControls(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { hasBorders: n, hasControls: s } = this, i = L({ hasBorders: n, hasControls: s }, t), a = this.getViewportTransform(), c = i.hasBorders, u = i.hasControls, h = At(a, this.calcTransformMatrix()), d = lo(h);
    e.save(), e.translate(d.translateX, d.translateY), e.lineWidth = this.borderScaleFactor, this.group === this.parent && (e.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (d.angle -= 180), e.rotate(Mt(this.group ? d.angle : this.angle)), c && this.drawBorders(e, d, t), u && this.drawControls(e, t), e.restore();
  }
  drawBorders(e, t, n) {
    let s;
    if (n && n.forActiveSelection || this.group) {
      const i = bu(this.width, this.height, za(t)), a = this.isStrokeAccountedForInDimensions() ? fp : (this.strokeUniform ? new $().scalarAdd(this.canvas ? this.canvas.getZoom() : 1) : new $(t.scaleX, t.scaleY)).scalarMultiply(this.strokeWidth);
      s = i.add(a).scalarAdd(this.borderScaleFactor).scalarAdd(2 * this.padding);
    } else s = this._calculateCurrentDimensions().scalarAdd(this.borderScaleFactor);
    this._drawBorders(e, s, n);
  }
  drawControlsConnectingLines(e, t) {
    let n = !1;
    e.beginPath(), this.forEachControl((s, i) => {
      s.withConnection && s.getVisibility(this, i) && (n = !0, e.moveTo(s.x * t.x, s.y * t.y), e.lineTo(s.x * t.x + s.offsetX, s.y * t.y + s.offsetY));
    }), n && e.stroke();
  }
  drawControls(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e.save();
    const n = this.getCanvasRetinaScaling(), { cornerStrokeColor: s, cornerDashArray: i, cornerColor: a } = this, c = L({ cornerStrokeColor: s, cornerDashArray: i, cornerColor: a }, t);
    e.setTransform(n, 0, 0, n, 0, 0), e.strokeStyle = e.fillStyle = c.cornerColor, this.transparentCorners || (e.strokeStyle = c.cornerStrokeColor), this._setLineDash(e, c.cornerDashArray), this.forEachControl((u, h) => {
      if (u.getVisibility(this, h)) {
        const d = this.oCoords[h];
        u.render(e, d.x, d.y, c, this);
      }
    }), e.restore();
  }
  isControlVisible(e) {
    return this.controls[e] && this.controls[e].getVisibility(this, e);
  }
  setControlVisible(e, t) {
    this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[e] = t;
  }
  setControlsVisibility() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.entries(e).forEach((t) => {
      let [n, s] = t;
      return this.setControlVisible(n, s);
    });
  }
  clearContextTop(e) {
    if (!this.canvas) return;
    const t = this.canvas.contextTop;
    if (!t) return;
    const n = this.canvas.viewportTransform;
    t.save(), t.transform(n[0], n[1], n[2], n[3], n[4], n[5]), this.transform(t);
    const s = this.width + 4, i = this.height + 4;
    return t.clearRect(-s / 2, -i / 2, s, i), e || t.restore(), t;
  }
  onDeselect(e) {
    return !1;
  }
  onSelect(e) {
    return !1;
  }
  shouldStartDragging(e) {
    return !1;
  }
  onDragStart(e) {
    return !1;
  }
  canDrop(e) {
    return !1;
  }
  renderDragSourceEffect(e) {
  }
  renderDropTargetEffect(e) {
  }
}
function zw(r, e) {
  return e.forEach((t) => {
    Object.getOwnPropertyNames(t.prototype).forEach((n) => {
      n !== "constructor" && Object.defineProperty(r.prototype, n, Object.getOwnPropertyDescriptor(t.prototype, n) || /* @__PURE__ */ Object.create(null));
    });
  }), r;
}
N(Ea, "ownDefaults", { noScaleCache: !0, lockMovementX: !1, lockMovementY: !1, lockRotation: !1, lockScalingX: !1, lockScalingY: !1, lockSkewingX: !1, lockSkewingY: !1, lockScalingFlip: !1, cornerSize: 13, touchCornerSize: 24, transparentCorners: !0, cornerColor: "rgb(178,204,255)", cornerStrokeColor: "", cornerStyle: "rect", cornerDashArray: null, hasControls: !0, borderColor: "rgb(178,204,255)", borderDashArray: null, borderOpacityWhenMoving: 0.4, borderScaleFactor: 1, hasBorders: !0, selectionBackgroundColor: "", selectable: !0, evented: !0, perPixelTargetFind: !1, activeOn: "down", hoverCursor: null, moveCursor: null });
class ht extends Ea {
}
zw(ht, [xw]), le.setClass(ht), le.setClass(ht, "object");
const Ww = (r, e, t, n) => {
  const s = 2 * (n = Math.round(n)) + 1, { data: i } = r.getImageData(e - n, t - n, s, s);
  for (let a = 3; a < i.length; a += 4)
    if (i[a] > 0) return !1;
  return !0;
};
class Hw {
  constructor(e) {
    this.options = e, this.strokeProjectionMagnitude = this.options.strokeWidth / 2, this.scale = new $(this.options.scaleX, this.options.scaleY), this.strokeUniformScalar = this.options.strokeUniform ? new $(1 / this.options.scaleX, 1 / this.options.scaleY) : new $(1, 1);
  }
  createSideVector(e, t) {
    const n = Il(e, t);
    return this.options.strokeUniform ? n.multiply(this.scale) : n;
  }
  projectOrthogonally(e, t, n) {
    return this.applySkew(e.add(this.calcOrthogonalProjection(e, t, n)));
  }
  isSkewed() {
    return this.options.skewX !== 0 || this.options.skewY !== 0;
  }
  applySkew(e) {
    const t = new $(e);
    return t.y += t.x * Math.tan(Mt(this.options.skewY)), t.x += t.y * Math.tan(Mt(this.options.skewX)), t;
  }
  scaleUnitVector(e, t) {
    return e.multiply(this.strokeUniformScalar).scalarMultiply(t);
  }
}
const u3 = new $();
class oo extends Hw {
  static getOrthogonalRotationFactor(e, t) {
    const n = t ? Dl(e, t) : Sw(e);
    return Math.abs(n) < Os ? -1 : 1;
  }
  constructor(e, t, n, s) {
    super(s), N(this, "AB", void 0), N(this, "AC", void 0), N(this, "alpha", void 0), N(this, "bisector", void 0), this.A = new $(e), this.B = new $(t), this.C = new $(n), this.AB = this.createSideVector(this.A, this.B), this.AC = this.createSideVector(this.A, this.C), this.alpha = Dl(this.AB, this.AC), this.bisector = _u(xp(this.AB.eq(u3) ? this.AC : this.AB, this.alpha / 2));
  }
  calcOrthogonalProjection(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;
    const s = this.createSideVector(e, t), i = _p(s), a = oo.getOrthogonalRotationFactor(i, this.bisector);
    return this.scaleUnitVector(i, n * a);
  }
  projectBevel() {
    const e = [];
    return (this.alpha % os == 0 ? [this.B] : [this.B, this.C]).forEach((t) => {
      e.push(this.projectOrthogonally(this.A, t)), e.push(this.projectOrthogonally(this.A, t, -this.strokeProjectionMagnitude));
    }), e;
  }
  projectMiter() {
    const e = [], t = Math.abs(this.alpha), n = 1 / Math.sin(t / 2), s = this.scaleUnitVector(this.bisector, -this.strokeProjectionMagnitude * n), i = this.options.strokeUniform ? Pl(this.scaleUnitVector(this.bisector, this.options.strokeMiterLimit)) : this.options.strokeMiterLimit;
    return Pl(s) / this.strokeProjectionMagnitude <= i && e.push(this.applySkew(this.A.add(s))), e.push(...this.projectBevel()), e;
  }
  projectRoundNoSkew(e, t) {
    const n = [], s = new $(oo.getOrthogonalRotationFactor(this.bisector), oo.getOrthogonalRotationFactor(new $(this.bisector.y, this.bisector.x)));
    return [new $(1, 0).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(s), new $(0, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(s)].forEach((i) => {
      af(i, e, t) && n.push(this.A.add(i));
    }), n;
  }
  projectRoundWithSkew(e, t) {
    const n = [], { skewX: s, skewY: i, scaleX: a, scaleY: c, strokeUniform: u } = this.options, h = new $(Math.tan(Mt(s)), Math.tan(Mt(i))), d = this.strokeProjectionMagnitude, p = u ? d / c / Math.sqrt(1 / c ** 2 + 1 / a ** 2 * h.y ** 2) : d / Math.sqrt(1 + h.y ** 2), g = new $(Math.sqrt(Math.max(d ** 2 - p ** 2, 0)), p), v = u ? d / Math.sqrt(1 + h.x ** 2 * (1 / c) ** 2 / (1 / a + 1 / a * h.x * h.y) ** 2) : d / Math.sqrt(1 + h.x ** 2 / (1 + h.x * h.y) ** 2), b = new $(v, Math.sqrt(Math.max(d ** 2 - v ** 2, 0)));
    return [b, b.scalarMultiply(-1), g, g.scalarMultiply(-1)].map((_) => this.applySkew(u ? _.multiply(this.strokeUniformScalar) : _)).forEach((_) => {
      af(_, e, t) && n.push(this.applySkew(this.A).add(_));
    }), n;
  }
  projectRound() {
    const e = [];
    e.push(...this.projectBevel());
    const t = this.alpha % os == 0, n = this.applySkew(this.A), s = e[t ? 0 : 2].subtract(n), i = e[t ? 1 : 0].subtract(n), a = t ? this.applySkew(this.AB.scalarMultiply(-1)) : this.applySkew(this.bisector.multiply(this.strokeUniformScalar).scalarMultiply(-1)), c = io(s, a) > 0, u = c ? s : i, h = c ? i : s;
    return this.isSkewed() ? e.push(...this.projectRoundWithSkew(u, h)) : e.push(...this.projectRoundNoSkew(u, h)), e;
  }
  projectPoints() {
    switch (this.options.strokeLineJoin) {
      case "miter":
        return this.projectMiter();
      case "round":
        return this.projectRound();
      default:
        return this.projectBevel();
    }
  }
  project() {
    return this.projectPoints().map((e) => ({ originPoint: this.A, projectedPoint: e, angle: this.alpha, bisector: this.bisector }));
  }
}
class j0 extends Hw {
  constructor(e, t, n) {
    super(n), this.A = new $(e), this.T = new $(t);
  }
  calcOrthogonalProjection(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;
    const s = this.createSideVector(e, t);
    return this.scaleUnitVector(_p(s), n);
  }
  projectButt() {
    return [this.projectOrthogonally(this.A, this.T, this.strokeProjectionMagnitude), this.projectOrthogonally(this.A, this.T, -this.strokeProjectionMagnitude)];
  }
  projectRound() {
    const e = [];
    if (!this.isSkewed() && this.A.eq(this.T)) {
      const t = new $(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      e.push(this.applySkew(this.A.add(t)), this.applySkew(this.A.subtract(t)));
    } else e.push(...new oo(this.A, this.T, this.T, this.options).projectRound());
    return e;
  }
  projectSquare() {
    const e = [];
    if (this.A.eq(this.T)) {
      const t = new $(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      e.push(this.A.add(t), this.A.subtract(t));
    } else {
      const t = this.calcOrthogonalProjection(this.A, this.T, this.strokeProjectionMagnitude), n = this.scaleUnitVector(_u(this.createSideVector(this.A, this.T)), -this.strokeProjectionMagnitude), s = this.A.add(n);
      e.push(s.add(t), s.subtract(t));
    }
    return e.map((t) => this.applySkew(t));
  }
  projectPoints() {
    switch (this.options.strokeLineCap) {
      case "round":
        return this.projectRound();
      case "square":
        return this.projectSquare();
      default:
        return this.projectButt();
    }
  }
  project() {
    return this.projectPoints().map((e) => ({ originPoint: this.A, projectedPoint: e }));
  }
}
const Uw = function(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
  const n = [];
  if (r.length === 0) return n;
  const s = r.reduce((i, a) => (i[i.length - 1].eq(a) || i.push(new $(a)), i), [new $(r[0])]);
  if (s.length === 1) t = !0;
  else if (!t) {
    const i = s[0], a = ((c, u) => {
      for (let h = c.length - 1; h >= 0; h--) if (u(c[h], h, c)) return h;
      return -1;
    })(s, (c) => !c.eq(i));
    s.splice(a + 1);
  }
  return s.forEach((i, a, c) => {
    let u, h;
    a === 0 ? (h = c[1], u = t ? i : c[c.length - 1]) : a === c.length - 1 ? (u = c[a - 1], h = t ? i : c[0]) : (u = c[a - 1], h = c[a + 1]), t && c.length === 1 ? n.push(...new j0(i, i, e).project()) : !t || a !== 0 && a !== c.length - 1 ? n.push(...new oo(i, u, h, e).project()) : n.push(...new j0(i, a === 0 ? h : u, e).project());
  }), n;
}, kp = (r) => {
  const e = {};
  return Object.keys(r).forEach((t) => {
    e[t] = {}, Object.keys(r[t]).forEach((n) => {
      e[t][n] = L({}, r[t][n]);
    });
  }), e;
}, $w = (r) => r.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), Cu = (r) => {
  const e = [];
  for (let t, n = 0; n < r.length; n++) (t = h3(r, n)) !== !1 && e.push(t);
  return e;
}, h3 = (r, e) => {
  const t = r.charCodeAt(e);
  if (isNaN(t)) return "";
  if (t < 55296 || t > 57343) return r.charAt(e);
  if (55296 <= t && t <= 56319) {
    if (r.length <= e + 1) throw "High surrogate without following low surrogate";
    const s = r.charCodeAt(e + 1);
    if (56320 > s || s > 57343) throw "High surrogate without following low surrogate";
    return r.charAt(e) + r.charAt(e + 1);
  }
  if (e === 0) throw "Low surrogate without preceding high surrogate";
  const n = r.charCodeAt(e - 1);
  if (55296 > n || n > 56319) throw "Low surrogate without preceding high surrogate";
  return !1;
};
var d3 = Object.freeze({ __proto__: null, capitalize: function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
  return "".concat(r.charAt(0).toUpperCase()).concat(e ? r.slice(1) : r.slice(1).toLowerCase());
}, escapeXml: $w, graphemeSplit: Cu });
const Tu = function(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
  return r.fill !== e.fill || r.stroke !== e.stroke || r.strokeWidth !== e.strokeWidth || r.fontSize !== e.fontSize || r.fontFamily !== e.fontFamily || r.fontWeight !== e.fontWeight || r.fontStyle !== e.fontStyle || r.textBackgroundColor !== e.textBackgroundColor || r.deltaY !== e.deltaY || t && (r.overline !== e.overline || r.underline !== e.underline || r.linethrough !== e.linethrough);
}, Yw = (r, e) => {
  const t = e.split(`
`), n = [];
  let s = -1, i = {};
  r = kp(r);
  for (let a = 0; a < t.length; a++) {
    const c = Cu(t[a]);
    if (r[a]) for (let u = 0; u < c.length; u++) {
      s++;
      const h = r[a][u];
      h && Object.keys(h).length > 0 && (Tu(i, h, !0) ? n.push({ start: s, end: s + 1, style: h }) : n[n.length - 1].end++), i = h || {};
    }
    else s += c.length, i = {};
  }
  return n;
}, Xw = (r, e) => {
  if (!Array.isArray(r)) return kp(r);
  const t = e.split(hp), n = {};
  let s = -1, i = 0;
  for (let a = 0; a < t.length; a++) {
    const c = Cu(t[a]);
    for (let u = 0; u < c.length; u++) s++, r[i] && r[i].start <= s && s < r[i].end && (n[a] = n[a] || {}, n[a][u] = L({}, r[i].style), s === r[i].end - 1 && i++);
  }
  return n;
}, Bs = ["display", "transform", Xt, "fill-opacity", "fill-rule", "opacity", Rr, "stroke-dasharray", "stroke-linecap", "stroke-dashoffset", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id", "paint-order", "vector-effect", "instantiated_by_use", "clip-path"];
function L0(r, e) {
  const t = r.nodeName, n = r.getAttribute("class"), s = r.getAttribute("id"), i = "(?![a-zA-Z\\-]+)";
  let a;
  if (a = new RegExp("^" + t, "i"), e = e.replace(a, ""), s && e.length && (a = new RegExp("#" + s + i, "i"), e = e.replace(a, "")), n && e.length) {
    const c = n.split(" ");
    for (let u = c.length; u--; ) a = new RegExp("\\." + c[u] + i, "i"), e = e.replace(a, "");
  }
  return e.length === 0;
}
function f3(r, e) {
  let t = !0;
  const n = L0(r, e.pop());
  return n && e.length && (t = function(s, i) {
    let a, c = !0;
    for (; s.parentElement && s.parentElement.nodeType === 1 && i.length; ) c && (a = i.pop()), c = L0(s = s.parentElement, a);
    return i.length === 0;
  }(r, e)), n && t && e.length === 0;
}
const p3 = (r) => {
  var e;
  return (e = $R[r]) !== null && e !== void 0 ? e : r;
}, g3 = new RegExp("(".concat(pi, ")"), "gi"), m3 = (r) => r.replace(g3, " $1 ").replace(/,/gi, " ").replace(/\s+/gi, " ");
var F0, N0, B0, V0, z0, W0, H0;
const wr = "(".concat(pi, ")"), v3 = String.raw(F0 || (F0 = Fs(["(skewX)(", ")"], ["(skewX)\\(", "\\)"])), wr), y3 = String.raw(N0 || (N0 = Fs(["(skewY)(", ")"], ["(skewY)\\(", "\\)"])), wr), b3 = String.raw(B0 || (B0 = Fs(["(rotate)(", "(?: ", " ", ")?)"], ["(rotate)\\(", "(?: ", " ", ")?\\)"])), wr, wr, wr), w3 = String.raw(V0 || (V0 = Fs(["(scale)(", "(?: ", ")?)"], ["(scale)\\(", "(?: ", ")?\\)"])), wr, wr), x3 = String.raw(z0 || (z0 = Fs(["(translate)(", "(?: ", ")?)"], ["(translate)\\(", "(?: ", ")?\\)"])), wr, wr), _3 = String.raw(W0 || (W0 = Fs(["(matrix)(", " ", " ", " ", " ", " ", ")"], ["(matrix)\\(", " ", " ", " ", " ", " ", "\\)"])), wr, wr, wr, wr, wr, wr), Op = "(?:".concat(_3, "|").concat(x3, "|").concat(b3, "|").concat(w3, "|").concat(v3, "|").concat(y3, ")"), S3 = "(?:".concat(Op, "*)"), C3 = String.raw(H0 || (H0 = Fs(["^s*(?:", "?)s*$"], ["^\\s*(?:", "?)\\s*$"])), S3), T3 = new RegExp(C3), E3 = new RegExp(Op), k3 = new RegExp(Op, "g");
function df(r) {
  const e = [];
  if (!(r = m3(r).replace(/\s*([()])\s*/gi, "$1")) || r && !T3.test(r)) return [..._r];
  for (const t of r.matchAll(k3)) {
    const n = E3.exec(t[0]);
    if (!n) continue;
    let s = _r;
    const i = n.filter((b) => !!b), [, a, ...c] = i, [u, h, d, p, g, v] = c.map((b) => parseFloat(b));
    switch (a) {
      case "translate":
        s = Mo(u, h);
        break;
      case dp:
        s = Ao({ angle: u }, { x: h, y: d });
        break;
      case mu:
        s = yu(u, h);
        break;
      case ko:
        s = gp(u);
        break;
      case Oo:
        s = mp(u);
        break;
      case "matrix":
        s = [u, h, d, p, g, v];
    }
    e.push(s);
  }
  return vu(e);
}
function O3(r, e, t, n) {
  const s = Array.isArray(e);
  let i, a = e;
  if (r !== Xt && r !== Rr || e !== Dr) {
    if (r === "strokeUniform") return e === "non-scaling-stroke";
    if (r === "strokeDashArray") a = e === Dr ? null : e.replace(/,/g, " ").split(/\s+/).map(parseFloat);
    else if (r === "transformMatrix") a = t && t.transformMatrix ? At(t.transformMatrix, df(e)) : df(e);
    else if (r === "visible") a = e !== Dr && e !== "hidden", t && t.visible === !1 && (a = !1);
    else if (r === "opacity") a = parseFloat(e), t && t.opacity !== void 0 && (a *= t.opacity);
    else if (r === "textAnchor") a = e === "start" ? at : e === "end" ? Rt : Be;
    else if (r === "charSpacing") i = hi(e, n) / n * 1e3;
    else if (r === "paintFirst") {
      const c = e.indexOf(Xt), u = e.indexOf(Rr);
      a = Xt, (c > -1 && u > -1 && u < c || c === -1 && u > -1) && (a = Rr);
    } else {
      if (r === "href" || r === "xlink:href" || r === "font" || r === "id") return e;
      if (r === "imageSmoothing") return e === "optimizeQuality";
      i = s ? e.map(hi) : hi(e, n);
    }
  } else a = "";
  return !s && isNaN(i) ? a : i;
}
function M3(r, e) {
  const t = r.match(UR);
  if (!t) return;
  const n = t[1], s = t[3], i = t[4], a = t[5], c = t[6];
  n && (e.fontStyle = n), s && (e.fontWeight = isNaN(parseFloat(s)) ? s : parseFloat(s)), i && (e.fontSize = hi(i)), c && (e.fontFamily = c), a && (e.lineHeight = a === "normal" ? 1 : a);
}
function A3(r, e) {
  r.replace(/;\s*$/, "").split(";").forEach((t) => {
    if (!t) return;
    const [n, s] = t.split(":");
    e[n.trim().toLowerCase()] = s.trim();
  });
}
function I3(r) {
  const e = {}, t = r.getAttribute("style");
  return t && (typeof t == "string" ? A3(t, e) : function(n, s) {
    Object.entries(n).forEach((i) => {
      let [a, c] = i;
      c !== void 0 && (s[a.toLowerCase()] = c);
    });
  }(t, e)), e;
}
const P3 = { stroke: "strokeOpacity", fill: "fillOpacity" };
function cs(r, e, t) {
  if (!r) return {};
  let n, s = {}, i = up;
  r.parentNode && A0.test(r.parentNode.nodeName) && (s = cs(r.parentElement, e, t), s.fontSize && (n = i = hi(s.fontSize)));
  const a = L(L(L({}, e.reduce((h, d) => {
    const p = r.getAttribute(d);
    return p && (h[d] = p), h;
  }, {})), function(h) {
    let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = {};
    for (const g in d) f3(h, g.split(" ")) && (p = L(L({}, p), d[g]));
    return p;
  }(r, t)), I3(r));
  a[id] && r.setAttribute(id, a[id]), a[sd] && (n = hi(a[sd], i), a[sd] = "".concat(n));
  const c = {};
  for (const h in a) {
    const d = p3(h), p = O3(d, a[h], s, n);
    c[d] = p;
  }
  c && c.font && M3(c.font, c);
  const u = L(L({}, s), c);
  return A0.test(r.nodeName) ? u : function(h) {
    const d = ht.getDefaults();
    return Object.entries(P3).forEach((p) => {
      let [g, v] = p;
      if (h[v] === void 0 || h[g] === "") return;
      if (h[g] === void 0) {
        if (!d[g]) return;
        h[g] = d[g];
      }
      if (h[g].indexOf("url(") === 0) return;
      const b = new lt(h[g]);
      h[g] = b.setAlpha(vt(b.getAlpha() * h[v], 2)).toRgba();
    }), h;
  }(u);
}
const D3 = ["left", "top", "width", "height", "visible"], Gw = ["rx", "ry"];
class Ft extends ht {
  static getDefaults() {
    return L(L({}, super.getDefaults()), Ft.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, Ft.ownDefaults), this.setOptions(e), this._initRxRy();
  }
  _initRxRy() {
    const { rx: e, ry: t } = this;
    e && !t ? this.ry = e : t && !e && (this.rx = t);
  }
  _render(e) {
    const { width: t, height: n } = this, s = -t / 2, i = -n / 2, a = this.rx ? Math.min(this.rx, t / 2) : 0, c = this.ry ? Math.min(this.ry, n / 2) : 0, u = a !== 0 || c !== 0;
    e.beginPath(), e.moveTo(s + a, i), e.lineTo(s + t - a, i), u && e.bezierCurveTo(s + t - Ss * a, i, s + t, i + Ss * c, s + t, i + c), e.lineTo(s + t, i + n - c), u && e.bezierCurveTo(s + t, i + n - Ss * c, s + t - Ss * a, i + n, s + t - a, i + n), e.lineTo(s + a, i + n), u && e.bezierCurveTo(s + Ss * a, i + n, s, i + n - Ss * c, s, i + n - c), e.lineTo(s, i + c), u && e.bezierCurveTo(s, i + Ss * c, s + Ss * a, i, s + a, i), e.closePath(), this._renderPaintInOrder(e);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...Gw, ...e]);
  }
  _toSVG() {
    const { width: e, height: t, rx: n, ry: s } = this;
    return ["<rect ", "COMMON_PARTS", 'x="'.concat(-e / 2, '" y="').concat(-t / 2, '" rx="').concat(n, '" ry="').concat(s, '" width="').concat(e, '" height="').concat(t, `" />
`)];
  }
  static async fromElement(e, t, n) {
    const s = cs(e, this.ATTRIBUTE_NAMES, n), { left: i = 0, top: a = 0, width: c = 0, height: u = 0, visible: h = !0 } = s, d = yt(s, D3);
    return new this(L(L(L({}, t), d), {}, { left: i, top: a, width: c, height: u, visible: !!(h && c && u) }));
  }
}
N(Ft, "type", "Rect"), N(Ft, "cacheProperties", [...as, ...Gw]), N(Ft, "ownDefaults", { rx: 0, ry: 0 }), N(Ft, "ATTRIBUTE_NAMES", [...Bs, "x", "y", "rx", "ry", "width", "height"]), le.setClass(Ft), le.setSVGClass(Ft);
const ts = "initialization", Rl = "added", Mp = "removed", jl = "imperative", qw = (r, e) => {
  const { strokeUniform: t, strokeWidth: n, width: s, height: i, group: a } = e, c = a && a !== r ? Ua(a.calcTransformMatrix(), r.calcTransformMatrix()) : null, u = c ? e.getRelativeCenterPoint().transform(c) : e.getRelativeCenterPoint(), h = !e.isStrokeAccountedForInDimensions(), d = t && h ? vw(new $(n, n), void 0, r.calcTransformMatrix()) : fp, p = !t && h ? n : 0, g = bu(s + p, i + p, vu([c, e.calcOwnMatrix()], !0)).add(d).scalarDivide(2);
  return [u.subtract(g), u.add(g)];
};
class Eu {
  calcLayoutResult(e, t) {
    if (this.shouldPerformLayout(e)) return this.calcBoundingBox(t, e);
  }
  shouldPerformLayout(e) {
    let { type: t, prevStrategy: n, strategy: s } = e;
    return t === ts || t === jl || !!n && s !== n;
  }
  shouldLayoutClipPath(e) {
    let { type: t, target: { clipPath: n } } = e;
    return t !== ts && n && !n.absolutePositioned;
  }
  getInitialSize(e, t) {
    return t.size;
  }
  calcBoundingBox(e, t) {
    const { type: n, target: s } = t;
    if (n === jl && t.overrides) return t.overrides;
    if (e.length === 0) return;
    const { left: i, top: a, width: c, height: u } = jn(e.map((p) => qw(s, p)).reduce((p, g) => p.concat(g), [])), h = new $(c, u), d = new $(i, a).add(h.scalarDivide(2));
    if (n === ts) {
      const p = this.getInitialSize(t, { size: h, center: d });
      return { center: d, relativeCorrection: new $(0, 0), size: p };
    }
    return { center: d.transform(s.calcOwnMatrix()), size: h };
  }
}
N(Eu, "type", "strategy");
class ff extends Eu {
  shouldPerformLayout(e) {
    return !0;
  }
}
N(ff, "type", "fit-content"), le.setClass(ff);
const R3 = ["strategy"], j3 = ["target", "strategy", "bubbles", "prevStrategy"], Kw = "layoutManager";
class ka {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new ff();
    N(this, "strategy", void 0), this.strategy = e, this._subscriptions = /* @__PURE__ */ new Map();
  }
  performLayout(e) {
    const t = L(L({ bubbles: !0, strategy: this.strategy }, e), {}, { prevStrategy: this._prevLayoutStrategy, stopPropagation() {
      this.bubbles = !1;
    } });
    this.onBeforeLayout(t);
    const n = this.getLayoutResult(t);
    n && this.commitLayout(t, n), this.onAfterLayout(t, n), this._prevLayoutStrategy = t.strategy;
  }
  attachHandlers(e, t) {
    const { target: n } = t;
    return [kl, Zb, Sa, Jb, gu, Qb, El, ew, FR].map((s) => e.on(s, (i) => this.performLayout(s === kl ? { type: "object_modified", trigger: s, e: i, target: n } : { type: "object_modifying", trigger: s, e: i, target: n })));
  }
  subscribe(e, t) {
    this.unsubscribe(e, t);
    const n = this.attachHandlers(e, t);
    this._subscriptions.set(e, n);
  }
  unsubscribe(e, t) {
    (this._subscriptions.get(e) || []).forEach((n) => n()), this._subscriptions.delete(e);
  }
  unsubscribeTargets(e) {
    e.targets.forEach((t) => this.unsubscribe(t, e));
  }
  subscribeTargets(e) {
    e.targets.forEach((t) => this.subscribe(t, e));
  }
  onBeforeLayout(e) {
    const { target: t, type: n } = e, { canvas: s } = t;
    if (n === ts || n === Rl ? this.subscribeTargets(e) : n === Mp && this.unsubscribeTargets(e), t.fire("layout:before", { context: e }), s && s.fire("object:layout:before", { target: t, context: e }), n === jl && e.deep) {
      const i = yt(e, R3);
      t.forEachObject((a) => a.layoutManager && a.layoutManager.performLayout(L(L({}, i), {}, { bubbles: !1, target: a })));
    }
  }
  getLayoutResult(e) {
    const { target: t, strategy: n, type: s } = e, i = n.calcLayoutResult(e, t.getObjects());
    if (!i) return;
    const a = s === ts ? new $() : t.getRelativeCenterPoint(), { center: c, correction: u = new $(), relativeCorrection: h = new $() } = i, d = a.subtract(c).add(u).transform(s === ts ? _r : Ur(t.calcOwnMatrix()), !0).add(h);
    return { result: i, prevCenter: a, nextCenter: c, offset: d };
  }
  commitLayout(e, t) {
    const { target: n } = e, { result: { size: s }, nextCenter: i } = t;
    var a, c;
    n.set({ width: s.x, height: s.y }), this.layoutObjects(e, t), e.type === ts ? n.set({ left: (a = e.x) !== null && a !== void 0 ? a : i.x + s.x * Lt(n.originX), top: (c = e.y) !== null && c !== void 0 ? c : i.y + s.y * Lt(n.originY) }) : (n.setPositionByOrigin(i, Be, Be), n.setCoords(), n.set("dirty", !0));
  }
  layoutObjects(e, t) {
    const { target: n } = e;
    n.forEachObject((s) => {
      s.group === n && this.layoutObject(e, t, s);
    }), e.strategy.shouldLayoutClipPath(e) && this.layoutObject(e, t, n.clipPath);
  }
  layoutObject(e, t, n) {
    let { offset: s } = t;
    n.set({ left: n.left + s.x, top: n.top + s.y });
  }
  onAfterLayout(e, t) {
    const { target: n, strategy: s, bubbles: i, prevStrategy: a } = e, c = yt(e, j3), { canvas: u } = n;
    n.fire("layout:after", { context: e, result: t }), u && u.fire("object:layout:after", { context: e, result: t, target: n });
    const h = n.parent;
    i && h != null && h.layoutManager && ((c.path || (c.path = [])).push(n), h.layoutManager.performLayout(L(L({}, c), {}, { target: h }))), n.set("dirty", !0);
  }
  dispose() {
    const { _subscriptions: e } = this;
    e.forEach((t) => t.forEach((n) => n())), e.clear();
  }
  toObject() {
    return { type: Kw, strategy: this.strategy.constructor.type };
  }
  toJSON() {
    return this.toObject();
  }
}
le.setClass(ka, Kw);
const L3 = ["type", "objects", "layoutManager"];
class F3 extends ka {
  performLayout() {
  }
}
class an extends tw(ht) {
  static getDefaults() {
    return L(L({}, super.getDefaults()), an.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), N(this, "_activeObjects", []), N(this, "__objectSelectionTracker", void 0), N(this, "__objectSelectionDisposer", void 0), Object.assign(this, an.ownDefaults), this.setOptions(t), this.groupInit(e, t);
  }
  groupInit(e, t) {
    var n;
    this._objects = [...e], this.__objectSelectionTracker = this.__objectSelectionMonitor.bind(this, !0), this.__objectSelectionDisposer = this.__objectSelectionMonitor.bind(this, !1), this.forEachObject((s) => {
      this.enterGroup(s, !1);
    }), this.layoutManager = (n = t.layoutManager) !== null && n !== void 0 ? n : new ka(), this.layoutManager.performLayout({ type: ts, target: this, targets: [...e], x: t.left, y: t.top });
  }
  canEnterGroup(e) {
    return e === this || this.isDescendantOf(e) ? (ks("error", "Group: circular object trees are not supported, this call has no effect"), !1) : this._objects.indexOf(e) === -1 || (ks("error", "Group: duplicate objects are not supported inside group, this call has no effect"), !1);
  }
  _filterObjectsBeforeEnteringGroup(e) {
    return e.filter((t, n, s) => this.canEnterGroup(t) && s.indexOf(t) === n);
  }
  add() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    const s = this._filterObjectsBeforeEnteringGroup(t), i = super.add(...s);
    return this._onAfterObjectsChange(Rl, s), i;
  }
  insertAt(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++) n[s - 1] = arguments[s];
    const i = this._filterObjectsBeforeEnteringGroup(n), a = super.insertAt(e, ...i);
    return this._onAfterObjectsChange(Rl, i), a;
  }
  remove() {
    const e = super.remove(...arguments);
    return this._onAfterObjectsChange(Mp, e), e;
  }
  _onObjectAdded(e) {
    this.enterGroup(e, !0), this.fire("object:added", { target: e }), e.fire("added", { target: this });
  }
  _onObjectRemoved(e, t) {
    this.exitGroup(e, t), this.fire("object:removed", { target: e }), e.fire("removed", { target: this });
  }
  _onAfterObjectsChange(e, t) {
    this.layoutManager.performLayout({ type: e, targets: t, target: this });
  }
  _onStackOrderChanged() {
    this._set("dirty", !0);
  }
  _set(e, t) {
    const n = this[e];
    return super._set(e, t), e === "canvas" && n !== t && (this._objects || []).forEach((s) => {
      s._set(e, t);
    }), this;
  }
  _shouldSetNestedCoords() {
    return this.subTargetCheck;
  }
  removeAll() {
    return this._activeObjects = [], this.remove(...this._objects);
  }
  __objectSelectionMonitor(e, t) {
    let { target: n } = t;
    const s = this._activeObjects;
    if (e) s.push(n), this._set("dirty", !0);
    else if (s.length > 0) {
      const i = s.indexOf(n);
      i > -1 && (s.splice(i, 1), this._set("dirty", !0));
    }
  }
  _watchObject(e, t) {
    e && this._watchObject(!1, t), e ? (t.on("selected", this.__objectSelectionTracker), t.on("deselected", this.__objectSelectionDisposer)) : (t.off("selected", this.__objectSelectionTracker), t.off("deselected", this.__objectSelectionDisposer));
  }
  enterGroup(e, t) {
    e.group && e.group.remove(e), e._set("parent", this), this._enterGroup(e, t);
  }
  _enterGroup(e, t) {
    t && ho(e, At(Ur(this.calcTransformMatrix()), e.calcTransformMatrix())), this._shouldSetNestedCoords() && e.setCoords(), e._set("group", this), e._set("canvas", this.canvas), this._watchObject(!0, e);
    const n = this.canvas && this.canvas.getActiveObject && this.canvas.getActiveObject();
    n && (n === e || e.isDescendantOf(n)) && this._activeObjects.push(e);
  }
  exitGroup(e, t) {
    this._exitGroup(e, t), e._set("parent", void 0), e._set("canvas", void 0);
  }
  _exitGroup(e, t) {
    e._set("group", void 0), t || (ho(e, At(this.calcTransformMatrix(), e.calcTransformMatrix())), e.setCoords()), this._watchObject(!1, e);
    const n = this._activeObjects.length > 0 ? this._activeObjects.indexOf(e) : -1;
    n > -1 && this._activeObjects.splice(n, 1);
  }
  shouldCache() {
    const e = ht.prototype.shouldCache.call(this);
    if (e) {
      for (let t = 0; t < this._objects.length; t++) if (this._objects[t].willDrawShadow()) return this.ownCaching = !1, !1;
    }
    return e;
  }
  willDrawShadow() {
    if (super.willDrawShadow()) return !0;
    for (let e = 0; e < this._objects.length; e++) if (this._objects[e].willDrawShadow()) return !0;
    return !1;
  }
  isOnACache() {
    return this.ownCaching || !!this.parent && this.parent.isOnACache();
  }
  drawObject(e, t, n) {
    this._renderBackground(e);
    for (let i = 0; i < this._objects.length; i++) {
      var s;
      const a = this._objects[i];
      (s = this.canvas) !== null && s !== void 0 && s.preserveObjectStacking && a.group !== this ? (e.save(), e.transform(...Ur(this.calcTransformMatrix())), a.render(e), e.restore()) : a.group === this && a.render(e);
    }
    this._drawClipPath(e, this.clipPath, n);
  }
  setCoords() {
    super.setCoords(), this._shouldSetNestedCoords() && this.forEachObject((e) => e.setCoords());
  }
  triggerLayout() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.layoutManager.performLayout(L({ target: this, type: jl }, e));
  }
  render(e) {
    this._transformDone = !0, super.render(e), this._transformDone = !1;
  }
  __serializeObjects(e, t) {
    const n = this.includeDefaultValues;
    return this._objects.filter(function(s) {
      return !s.excludeFromExport;
    }).map(function(s) {
      const i = s.includeDefaultValues;
      s.includeDefaultValues = n;
      const a = s[e || "toObject"](t);
      return s.includeDefaultValues = i, a;
    });
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = this.layoutManager.toObject();
    return L(L(L({}, super.toObject(["subTargetCheck", "interactive", ...e])), t.strategy !== "fit-content" || this.includeDefaultValues ? { layoutManager: t } : {}), {}, { objects: this.__serializeObjects("toObject", e) });
  }
  toString() {
    return "#<Group: (".concat(this.complexity(), ")>");
  }
  dispose() {
    this.layoutManager.unsubscribeTargets({ targets: this.getObjects(), target: this }), this._activeObjects = [], this.forEachObject((e) => {
      this._watchObject(!1, e), e.dispose();
    }), super.dispose();
  }
  _createSVGBgRect(e) {
    if (!this.backgroundColor) return "";
    const t = Ft.prototype._toSVG.call(this), n = t.indexOf("COMMON_PARTS");
    t[n] = 'for="group" ';
    const s = t.join("");
    return e ? e(s) : s;
  }
  _toSVG(e) {
    const t = ["<g ", "COMMON_PARTS", ` >
`], n = this._createSVGBgRect(e);
    n && t.push("		", n);
    for (let s = 0; s < this._objects.length; s++) t.push("		", this._objects[s].toSVG(e));
    return t.push(`</g>
`), t;
  }
  getSvgStyles() {
    const e = this.opacity !== void 0 && this.opacity !== 1 ? "opacity: ".concat(this.opacity, ";") : "", t = this.visible ? "" : " visibility: hidden;";
    return [e, this.getSvgFilter(), t].join("");
  }
  toClipPathSVG(e) {
    const t = [], n = this._createSVGBgRect(e);
    n && t.push("	", n);
    for (let s = 0; s < this._objects.length; s++) t.push("	", this._objects[s].toClipPathSVG(e));
    return this._createBaseClipPathSVGMarkup(t, { reviver: e });
  }
  static fromObject(e, t) {
    let { type: n, objects: s = [], layoutManager: i } = e, a = yt(e, L3);
    return Promise.all([uo(s, t), Wa(a, t)]).then((c) => {
      let [u, h] = c;
      const d = new this(u, L(L(L({}, a), h), {}, { layoutManager: new F3() }));
      if (i) {
        const p = le.getClass(i.type), g = le.getClass(i.strategy);
        d.layoutManager = new p(new g());
      } else d.layoutManager = new ka();
      return d.layoutManager.subscribeTargets({ type: ts, target: d, targets: d.getObjects() }), d.setCoords(), d;
    });
  }
}
N(an, "type", "Group"), N(an, "ownDefaults", { strokeWidth: 0, subTargetCheck: !1, interactive: !1 }), le.setClass(an);
const Zw = (r, e) => Math.min(e.width / r.width, e.height / r.height), Jw = (r, e) => Math.max(e.width / r.width, e.height / r.height), pf = "\\s*,?\\s*", ia = "".concat(pf, "(").concat(pi, ")"), N3 = "".concat(ia).concat(ia).concat(ia).concat(pf, "([01])").concat(pf, "([01])").concat(ia).concat(ia), B3 = { m: "l", M: "L" }, V3 = (r, e, t, n, s, i, a, c, u, h, d) => {
  const p = wn(r), g = xn(r), v = wn(e), b = xn(e), _ = t * s * v - n * i * b + a, C = n * s * v + t * i * b + c;
  return ["C", h + u * (-t * s * g - n * i * p), d + u * (-n * s * g + t * i * p), _ + u * (t * s * b + n * i * v), C + u * (n * s * b - t * i * v), _, C];
}, U0 = (r, e, t, n) => {
  const s = Math.atan2(e, r), i = Math.atan2(n, t);
  return i >= s ? i - s : 2 * Math.PI - (s - i);
};
function gf(r, e, t, n, s, i, a, c) {
  let u;
  if (et.cachesBoundsOfCurve && (u = [...arguments].join(), pa.boundsOfCurveCache[u])) return pa.boundsOfCurveCache[u];
  const h = Math.sqrt, d = Math.abs, p = [], g = [[0, 0], [0, 0]];
  let v = 6 * r - 12 * t + 6 * s, b = -3 * r + 9 * t - 9 * s + 3 * a, _ = 3 * t - 3 * r;
  for (let A = 0; A < 2; ++A) {
    if (A > 0 && (v = 6 * e - 12 * n + 6 * i, b = -3 * e + 9 * n - 9 * i + 3 * c, _ = 3 * n - 3 * e), d(b) < 1e-12) {
      if (d(v) < 1e-12) continue;
      const X = -_ / v;
      0 < X && X < 1 && p.push(X);
      continue;
    }
    const D = v * v - 4 * _ * b;
    if (D < 0) continue;
    const F = h(D), U = (-v + F) / (2 * b);
    0 < U && U < 1 && p.push(U);
    const B = (-v - F) / (2 * b);
    0 < B && B < 1 && p.push(B);
  }
  let C = p.length;
  const T = C, k = ex(r, e, t, n, s, i, a, c);
  for (; C--; ) {
    const { x: A, y: D } = k(p[C]);
    g[0][C] = A, g[1][C] = D;
  }
  g[0][T] = r, g[1][T] = e, g[0][T + 1] = a, g[1][T + 1] = c;
  const M = [new $(Math.min(...g[0]), Math.min(...g[1])), new $(Math.max(...g[0]), Math.max(...g[1]))];
  return et.cachesBoundsOfCurve && (pa.boundsOfCurveCache[u] = M), M;
}
const z3 = (r, e, t) => {
  let [n, s, i, a, c, u, h, d] = t;
  const p = ((g, v, b, _, C, T, k) => {
    if (b === 0 || _ === 0) return [];
    let M = 0, A = 0, D = 0;
    const F = Math.PI, U = k * lp, B = xn(U), X = wn(U), Y = 0.5 * (-X * g - B * v), Z = 0.5 * (-X * v + B * g), G = b ** 2, K = _ ** 2, oe = Z ** 2, ve = Y ** 2, Q = G * K - G * oe - K * ve;
    let ge = Math.abs(b), de = Math.abs(_);
    if (Q < 0) {
      const wt = Math.sqrt(1 - Q / (G * K));
      ge *= wt, de *= wt;
    } else D = (C === T ? -1 : 1) * Math.sqrt(Q / (G * oe + K * ve));
    const ne = D * ge * Z / de, I = -D * de * Y / ge, W = X * ne - B * I + 0.5 * g, ce = B * ne + X * I + 0.5 * v;
    let fe = U0(1, 0, (Y - ne) / ge, (Z - I) / de), be = U0((Y - ne) / ge, (Z - I) / de, (-Y - ne) / ge, (-Z - I) / de);
    T === 0 && be > 0 ? be -= 2 * F : T === 1 && be < 0 && (be += 2 * F);
    const ye = Math.ceil(Math.abs(be / F * 2)), ue = [], Xe = be / ye, We = 8 / 3 * Math.sin(Xe / 4) * Math.sin(Xe / 4) / Math.sin(Xe / 2);
    let bt = fe + Xe;
    for (let wt = 0; wt < ye; wt++) ue[wt] = V3(fe, bt, X, B, ge, de, W, ce, We, M, A), M = ue[wt][5], A = ue[wt][6], fe = bt, bt += Xe;
    return ue;
  })(h - r, d - e, s, i, c, u, a);
  for (let g = 0, v = p.length; g < v; g++) p[g][1] += r, p[g][2] += e, p[g][3] += r, p[g][4] += e, p[g][5] += r, p[g][6] += e;
  return p;
}, Qw = (r) => {
  let e = 0, t = 0, n = 0, s = 0;
  const i = [];
  let a, c = 0, u = 0;
  for (const h of r) {
    const d = [...h];
    let p;
    switch (d[0]) {
      case "l":
        d[1] += e, d[2] += t;
      case "L":
        e = d[1], t = d[2], p = ["L", e, t];
        break;
      case "h":
        d[1] += e;
      case "H":
        e = d[1], p = ["L", e, t];
        break;
      case "v":
        d[1] += t;
      case "V":
        t = d[1], p = ["L", e, t];
        break;
      case "m":
        d[1] += e, d[2] += t;
      case "M":
        e = d[1], t = d[2], n = d[1], s = d[2], p = ["M", e, t];
        break;
      case "c":
        d[1] += e, d[2] += t, d[3] += e, d[4] += t, d[5] += e, d[6] += t;
      case "C":
        c = d[3], u = d[4], e = d[5], t = d[6], p = ["C", d[1], d[2], c, u, e, t];
        break;
      case "s":
        d[1] += e, d[2] += t, d[3] += e, d[4] += t;
      case "S":
        a === "C" ? (c = 2 * e - c, u = 2 * t - u) : (c = e, u = t), e = d[3], t = d[4], p = ["C", c, u, d[1], d[2], e, t], c = p[3], u = p[4];
        break;
      case "q":
        d[1] += e, d[2] += t, d[3] += e, d[4] += t;
      case "Q":
        c = d[1], u = d[2], e = d[3], t = d[4], p = ["Q", c, u, e, t];
        break;
      case "t":
        d[1] += e, d[2] += t;
      case "T":
        a === "Q" ? (c = 2 * e - c, u = 2 * t - u) : (c = e, u = t), e = d[1], t = d[2], p = ["Q", c, u, e, t];
        break;
      case "a":
        d[6] += e, d[7] += t;
      case "A":
        z3(e, t, d).forEach((g) => i.push(g)), e = d[6], t = d[7];
        break;
      case "z":
      case "Z":
        e = n, t = s, p = ["Z"];
    }
    p ? (i.push(p), a = p[0]) : a = "";
  }
  return i;
}, Ll = (r, e, t, n) => Math.sqrt((t - r) ** 2 + (n - e) ** 2), ex = (r, e, t, n, s, i, a, c) => (u) => {
  const h = u ** 3, d = ((v) => 3 * v ** 2 * (1 - v))(u), p = ((v) => 3 * v * (1 - v) ** 2)(u), g = ((v) => (1 - v) ** 3)(u);
  return new $(a * h + s * d + t * p + r * g, c * h + i * d + n * p + e * g);
}, tx = (r) => r ** 2, rx = (r) => 2 * r * (1 - r), nx = (r) => (1 - r) ** 2, W3 = (r, e, t, n, s, i, a, c) => (u) => {
  const h = tx(u), d = rx(u), p = nx(u), g = 3 * (p * (t - r) + d * (s - t) + h * (a - s)), v = 3 * (p * (n - e) + d * (i - n) + h * (c - i));
  return Math.atan2(v, g);
}, H3 = (r, e, t, n, s, i) => (a) => {
  const c = tx(a), u = rx(a), h = nx(a);
  return new $(s * c + t * u + r * h, i * c + n * u + e * h);
}, U3 = (r, e, t, n, s, i) => (a) => {
  const c = 1 - a, u = 2 * (c * (t - r) + a * (s - t)), h = 2 * (c * (n - e) + a * (i - n));
  return Math.atan2(h, u);
}, $0 = (r, e, t) => {
  let n = new $(e, t), s = 0;
  for (let i = 1; i <= 100; i += 1) {
    const a = r(i / 100);
    s += Ll(n.x, n.y, a.x, a.y), n = a;
  }
  return s;
}, $3 = (r, e) => {
  let t, n = 0, s = 0, i = { x: r.x, y: r.y }, a = L({}, i), c = 0.01, u = 0;
  const h = r.iterator, d = r.angleFinder;
  for (; s < e && c > 1e-4; ) a = h(n), u = n, t = Ll(i.x, i.y, a.x, a.y), t + s > e ? (n -= c, c /= 2) : (i = a, n += c, s += t);
  return L(L({}, a), {}, { angle: d(u) });
}, Ap = (r) => {
  let e, t, n = 0, s = 0, i = 0, a = 0, c = 0;
  const u = [];
  for (const h of r) {
    const d = { x: s, y: i, command: h[0], length: 0 };
    switch (h[0]) {
      case "M":
        t = d, t.x = a = s = h[1], t.y = c = i = h[2];
        break;
      case "L":
        t = d, t.length = Ll(s, i, h[1], h[2]), s = h[1], i = h[2];
        break;
      case "C":
        e = ex(s, i, h[1], h[2], h[3], h[4], h[5], h[6]), t = d, t.iterator = e, t.angleFinder = W3(s, i, h[1], h[2], h[3], h[4], h[5], h[6]), t.length = $0(e, s, i), s = h[5], i = h[6];
        break;
      case "Q":
        e = H3(s, i, h[1], h[2], h[3], h[4]), t = d, t.iterator = e, t.angleFinder = U3(s, i, h[1], h[2], h[3], h[4]), t.length = $0(e, s, i), s = h[3], i = h[4];
        break;
      case "Z":
        t = d, t.destX = a, t.destY = c, t.length = Ll(s, i, a, c), s = a, i = c;
    }
    n += t.length, u.push(t);
  }
  return u.push({ length: n, x: s, y: i }), u;
}, sx = function(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ap(r), n = 0;
  for (; e - t[n].length > 0 && n < t.length - 2; ) e -= t[n].length, n++;
  const s = t[n], i = e / s.length, a = r[n];
  switch (s.command) {
    case "M":
      return { x: s.x, y: s.y, angle: 0 };
    case "Z":
      return L(L({}, new $(s.x, s.y).lerp(new $(s.destX, s.destY), i)), {}, { angle: Math.atan2(s.destY - s.y, s.destX - s.x) });
    case "L":
      return L(L({}, new $(s.x, s.y).lerp(new $(a[1], a[2]), i)), {}, { angle: Math.atan2(a[2] - s.y, a[1] - s.x) });
    case "C":
    case "Q":
      return $3(s, e);
  }
}, Y3 = new RegExp("[mzlhvcsqta][^mzlhvcsqta]*", "gi"), Y0 = new RegExp(N3, "g"), X3 = new RegExp(pi, "gi"), G3 = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, ix = (r) => {
  var e;
  const t = [], n = (e = r.match(Y3)) !== null && e !== void 0 ? e : [];
  for (const s of n) {
    const i = s[0];
    if (i === "z" || i === "Z") {
      t.push([i]);
      continue;
    }
    const a = G3[i.toLowerCase()];
    let c = [];
    if (i === "a" || i === "A") {
      Y0.lastIndex = 0;
      for (let u = null; u = Y0.exec(s); ) c.push(...u.slice(1));
    } else c = s.match(X3) || [];
    for (let u = 0; u < c.length; u += a) {
      const h = new Array(a), d = B3[i];
      h[0] = u > 0 && d ? d : i;
      for (let p = 0; p < a; p++) h[p + 1] = parseFloat(c[u + p]);
      t.push(h);
    }
  }
  return t;
}, q3 = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = new $(r[0]), n = new $(r[1]), s = 1, i = 0;
  const a = [], c = r.length, u = c > 2;
  let h;
  for (u && (s = r[2].x < n.x ? -1 : r[2].x === n.x ? 0 : 1, i = r[2].y < n.y ? -1 : r[2].y === n.y ? 0 : 1), a.push(["M", t.x - s * e, t.y - i * e]), h = 1; h < c; h++) {
    if (!t.eq(n)) {
      const d = t.midPointFrom(n);
      a.push(["Q", t.x, t.y, d.x, d.y]);
    }
    t = r[h], h + 1 < r.length && (n = r[h + 1]);
  }
  return u && (s = t.x > r[h - 2].x ? 1 : t.x === r[h - 2].x ? 0 : -1, i = t.y > r[h - 2].y ? 1 : t.y === r[h - 2].y ? 0 : -1), a.push(["L", t.x + s * e, t.y + i * e]), a;
}, ox = (r, e) => r.map((t) => t.map((n, s) => s === 0 || e === void 0 ? n : vt(n, e)).join(" ")).join(" ");
function Fl(r, e) {
  const t = r.style;
  t && e && (typeof e == "string" ? t.cssText += ";" + e : Object.entries(e).forEach((n) => {
    let [s, i] = n;
    return t.setProperty(s, i);
  }));
}
const K3 = (r, e) => Math.floor(Math.random() * (e - r + 1)) + r;
function Z3(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = e.onComplete || ui, n = new (pu()).XMLHttpRequest(), s = e.signal, i = function() {
    n.abort();
  }, a = function() {
    s && s.removeEventListener("abort", i), n.onerror = n.ontimeout = ui;
  };
  if (s && s.aborted) throw new qb("request");
  return s && s.addEventListener("abort", i, { once: !0 }), n.onreadystatechange = function() {
    n.readyState === 4 && (a(), t(n), n.onreadystatechange = ui);
  }, n.onerror = n.ontimeout = a, n.open("get", r, !0), n.send(), n;
}
const J3 = (r, e) => {
  let t = r._findCenterFromElement();
  r.transformMatrix && (((n) => {
    if (n.transformMatrix) {
      const { scaleX: s, scaleY: i, angle: a, skewX: c } = lo(n.transformMatrix);
      n.flipX = !1, n.flipY = !1, n.set(Sr, s), n.set($r, i), n.angle = a, n.skewX = c, n.skewY = 0;
    }
  })(r), t = t.transform(r.transformMatrix)), delete r.transformMatrix, e && (r.scaleX *= e.scaleX, r.scaleY *= e.scaleY, r.cropX = e.cropX, r.cropY = e.cropY, t.x += e.offsetLeft, t.y += e.offsetTop, r.width = e.width, r.height = e.height), r.setPositionByOrigin(t, Be, Be);
};
var ax = Object.freeze({ __proto__: null, addTransformToObject: gw, animate: Cp, animateColor: Ew, applyTransformToObject: ho, calcAngleBetweenVectors: Dl, calcDimensionsMatrix: za, calcPlaneChangeMatrix: Ua, calcVectorRotation: Sw, cancelAnimFrame: nw, capValue: gi, composeMatrix: cw, copyCanvasElement: (r) => {
  var e;
  const t = _n(r);
  return (e = t.getContext("2d")) === null || e === void 0 || e.drawImage(r, 0, 0), t;
}, cos: wn, createCanvasElement: cn, createImage: sw, createRotateMatrix: Ao, createScaleMatrix: yu, createSkewXMatrix: gp, createSkewYMatrix: mp, createTranslateMatrix: Mo, createVector: Il, crossProduct: io, degreesToRadians: Mt, dotProduct: Cw, ease: qR, enlivenObjectEnlivables: Wa, enlivenObjects: uo, findScaleToCover: Jw, findScaleToFit: Zw, getBoundsOfCurve: gf, getOrthonormalVector: _p, getPathSegmentsInfo: Ap, getPointOnPath: sx, getPointer: pw, getRandomInt: K3, getRegularPolygonPath: (r, e) => {
  const t = 2 * Math.PI / r;
  let n = -Os;
  r % 2 == 0 && (n += t / 2);
  const s = new Array(r + 1);
  for (let i = 0; i < r; i++) {
    const a = i * t + n, { x: c, y: u } = new $(wn(a), xn(a)).scalarMultiply(e);
    s[i] = [i === 0 ? "M" : "L", c, u];
  }
  return s[r] = ["Z"], s;
}, getSmoothPathFromPoints: q3, getSvgAttributes: (r) => {
  const e = ["instantiated_by_use", "style", "id", "class"];
  switch (r) {
    case "linearGradient":
      return e.concat(["x1", "y1", "x2", "y2", "gradientUnits", "gradientTransform"]);
    case "radialGradient":
      return e.concat(["gradientUnits", "gradientTransform", "cx", "cy", "r", "fx", "fy", "fr"]);
    case "stop":
      return e.concat(["offset", "stop-color", "stop-opacity"]);
  }
  return e;
}, getUnitVector: _u, groupSVGElements: (r, e) => r && r.length === 1 ? r[0] : new an(r, e), hasStyleChanged: Tu, invertTransform: Ur, isBetweenVectors: af, isIdentityMatrix: iw, isTouchEvent: Ml, isTransparent: Ww, joinPath: ox, loadImage: ma, magnitude: Pl, makeBoundingBoxFromPoints: jn, makePathSimpler: Qw, matrixToSVG: Ca, mergeClipPaths: (r, e) => {
  var t;
  let n = r, s = e;
  n.inverted && !s.inverted && (n = e, s = r), of(s, (t = s.group) === null || t === void 0 ? void 0 : t.calcTransformMatrix(), n.calcTransformMatrix());
  const i = n.inverted && s.inverted;
  return i && (n.inverted = s.inverted = !1), new an([n], { clipPath: s, inverted: i });
}, multiplyTransformMatrices: At, multiplyTransformMatrixArray: vu, parsePath: ix, parsePreserveAspectRatioAttribute: lw, parseUnit: hi, pick: ki, projectStrokeOnPoints: Uw, qrDecompose: lo, radiansToDegrees: As, removeFromArray: ti, removeTransformFromObject: (r, e) => {
  const t = Ur(e), n = At(t, r.calcOwnMatrix());
  ho(r, n);
}, removeTransformMatrixForSvgParsing: J3, request: Z3, requestAnimFrame: ga, resetObjectTransform: mw, rotatePoint: (r, e, t) => r.rotate(t, e), rotateVector: xp, saveObjectTransform: yp, sendObjectToPlane: of, sendPointToPlane: ns, sendVectorToPlane: vw, setStyle: Fl, sin: xn, sizeAfterTransform: bu, string: d3, stylesFromArray: Xw, stylesToArray: Yw, toDataURL: pp, toFixed: vt, transformPath: (r, e, t) => (t && (e = At(e, [1, 0, 0, 1, -t.x, -t.y])), r.map((n) => {
  const s = [...n];
  for (let i = 1; i < n.length - 1; i += 2) {
    const { x: a, y: c } = ur({ x: n[i], y: n[i + 1] }, e);
    s[i] = a, s[i + 1] = c;
  }
  return s;
})), transformPoint: ur });
class Q3 extends fw {
  constructor(e) {
    let { allowTouchScrolling: t = !1, containerClass: n = "" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e), N(this, "upper", void 0), N(this, "container", void 0);
    const { el: s } = this.lower, i = this.createUpperCanvas();
    this.upper = { el: i, ctx: i.getContext("2d") }, this.applyCanvasStyle(s, { allowTouchScrolling: t }), this.applyCanvasStyle(i, { allowTouchScrolling: t, styles: { position: "absolute", left: "0", top: "0" } });
    const a = this.createContainerElement();
    a.classList.add(n), s.parentNode && s.parentNode.replaceChild(a, s), a.append(s, i), this.container = a;
  }
  createUpperCanvas() {
    const { el: e } = this.lower, t = cn();
    return t.className = e.className, t.classList.remove("lower-canvas"), t.classList.add("upper-canvas"), t.setAttribute("data-fabric", "top"), t.style.cssText = e.style.cssText, t.setAttribute("draggable", "true"), t;
  }
  createContainerElement() {
    const e = Eo().createElement("div");
    return e.setAttribute("data-fabric", "wrapper"), Fl(e, { position: "relative" }), k0(e), e;
  }
  applyCanvasStyle(e, t) {
    const { styles: n, allowTouchScrolling: s } = t;
    Fl(e, L(L({}, n), {}, { "touch-action": s ? "manipulation" : Dr })), k0(e);
  }
  setDimensions(e, t) {
    super.setDimensions(e, t);
    const { el: n, ctx: s } = this.upper;
    dw(n, s, e, t);
  }
  setCSSDimensions(e) {
    super.setCSSDimensions(e), nf(this.upper.el, e), nf(this.container, e);
  }
  cleanupDOM(e) {
    const t = this.container, { el: n } = this.lower, { el: s } = this.upper;
    super.cleanupDOM(e), t.removeChild(s), t.removeChild(n), t.parentNode && t.parentNode.replaceChild(n, t);
  }
  dispose() {
    super.dispose(), Fn().dispose(this.upper.el), delete this.upper, delete this.container;
  }
}
class ku extends Ha {
  constructor() {
    super(...arguments), N(this, "targets", []), N(this, "_hoveredTargets", []), N(this, "_objectsToRender", void 0), N(this, "_currentTransform", null), N(this, "_groupSelector", null), N(this, "contextTopDirty", !1);
  }
  static getDefaults() {
    return L(L({}, super.getDefaults()), ku.ownDefaults);
  }
  get upperCanvasEl() {
    var e;
    return (e = this.elements.upper) === null || e === void 0 ? void 0 : e.el;
  }
  get contextTop() {
    var e;
    return (e = this.elements.upper) === null || e === void 0 ? void 0 : e.ctx;
  }
  get wrapperEl() {
    return this.elements.container;
  }
  initElements(e) {
    this.elements = new Q3(e, { allowTouchScrolling: this.allowTouchScrolling, containerClass: this.containerClass }), this._createCacheCanvas();
  }
  _onObjectAdded(e) {
    this._objectsToRender = void 0, super._onObjectAdded(e);
  }
  _onObjectRemoved(e) {
    this._objectsToRender = void 0, e === this._activeObject && (this.fire("before:selection:cleared", { deselected: [e] }), this._discardActiveObject(), this.fire("selection:cleared", { deselected: [e] }), e.fire("deselected", { target: e })), e === this._hoveredTarget && (this._hoveredTarget = void 0, this._hoveredTargets = []), super._onObjectRemoved(e);
  }
  _onStackOrderChanged() {
    this._objectsToRender = void 0, super._onStackOrderChanged();
  }
  _chooseObjectsToRender() {
    const e = this._activeObject;
    return !this.preserveObjectStacking && e ? this._objects.filter((t) => !t.group && t !== e).concat(e) : this._objects;
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || (!this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = !1), !this._objectsToRender && (this._objectsToRender = this._chooseObjectsToRender()), this.renderCanvas(this.getContext(), this._objectsToRender));
  }
  renderTopLayer(e) {
    e.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(e), this.contextTopDirty = !0), e.restore();
  }
  renderTop() {
    const e = this.contextTop;
    this.clearContext(e), this.renderTopLayer(e), this.fire("after:render", { ctx: e });
  }
  setTargetFindTolerance(e) {
    e = Math.round(e), this.targetFindTolerance = e;
    const t = this.getRetinaScaling(), n = Math.ceil((2 * e + 1) * t);
    this.pixelFindCanvasEl.width = this.pixelFindCanvasEl.height = n, this.pixelFindContext.scale(t, t);
  }
  isTargetTransparent(e, t, n) {
    const s = this.targetFindTolerance, i = this.pixelFindContext;
    this.clearContext(i), i.save(), i.translate(-t + s, -n + s), i.transform(...this.viewportTransform);
    const a = e.selectionBackgroundColor;
    e.selectionBackgroundColor = "", e.render(i), e.selectionBackgroundColor = a, i.restore();
    const c = Math.round(s * this.getRetinaScaling());
    return Ww(i, c, c, c);
  }
  _isSelectionKeyPressed(e) {
    const t = this.selectionKey;
    return !!t && (Array.isArray(t) ? !!t.find((n) => !!n && e[n] === !0) : e[t]);
  }
  _shouldClearSelection(e, t) {
    const n = this.getActiveObjects(), s = this._activeObject;
    return !!(!t || t && s && n.length > 1 && n.indexOf(t) === -1 && s !== t && !this._isSelectionKeyPressed(e) || t && !t.evented || t && !t.selectable && s && s !== t);
  }
  _shouldCenterTransform(e, t, n) {
    if (!e) return;
    let s;
    return t === mu || t === Sr || t === $r || t === Sa ? s = this.centeredScaling || e.centeredScaling : t === dp && (s = this.centeredRotation || e.centeredRotation), s ? !n : n;
  }
  _getOriginFromCorner(e, t) {
    const n = { x: e.originX, y: e.originY };
    return t && (["ml", "tl", "bl"].includes(t) ? n.x = Rt : ["mr", "tr", "br"].includes(t) && (n.x = at), ["tl", "mt", "tr"].includes(t) ? n.y = rf : ["bl", "mb", "br"].includes(t) && (n.y = Pr)), n;
  }
  _setupCurrentTransform(e, t, n) {
    var s;
    const i = t.group ? ns(this.getScenePoint(e), void 0, t.group.calcTransformMatrix()) : this.getScenePoint(e), { key: a = "", control: c } = t.getActiveControl() || {}, u = n && c ? (s = c.getActionHandler(e, t, c)) === null || s === void 0 ? void 0 : s.bind(c) : ww, h = ((v, b, _, C) => {
      if (!b || !v) return "drag";
      const T = C.controls[b];
      return T.getActionName(_, T, C);
    })(n, a, e, t), d = e[this.centeredKey], p = this._shouldCenterTransform(t, h, d) ? { x: Be, y: Be } : this._getOriginFromCorner(t, a), g = { target: t, action: h, actionHandler: u, actionPerformed: !1, corner: a, scaleX: t.scaleX, scaleY: t.scaleY, skewX: t.skewX, skewY: t.skewY, offsetX: i.x - t.left, offsetY: i.y - t.top, originX: p.x, originY: p.y, ex: i.x, ey: i.y, lastX: i.x, lastY: i.y, theta: Mt(t.angle), width: t.width, height: t.height, shiftKey: e.shiftKey, altKey: d, original: L(L({}, yp(t)), {}, { originX: p.x, originY: p.y }) };
    this._currentTransform = g, this.fire("before:transform", { e, transform: g });
  }
  setCursor(e) {
    this.upperCanvasEl.style.cursor = e;
  }
  _drawSelection(e) {
    const { x: t, y: n, deltaX: s, deltaY: i } = this._groupSelector, a = new $(t, n).transform(this.viewportTransform), c = new $(t + s, n + i).transform(this.viewportTransform), u = this.selectionLineWidth / 2;
    let h = Math.min(a.x, c.x), d = Math.min(a.y, c.y), p = Math.max(a.x, c.x), g = Math.max(a.y, c.y);
    this.selectionColor && (e.fillStyle = this.selectionColor, e.fillRect(h, d, p - h, g - d)), this.selectionLineWidth && this.selectionBorderColor && (e.lineWidth = this.selectionLineWidth, e.strokeStyle = this.selectionBorderColor, h += u, d += u, p -= u, g -= u, ht.prototype._setLineDash.call(this, e, this.selectionDashArray), e.strokeRect(h, d, p - h, g - d));
  }
  findTarget(e) {
    if (this.skipTargetFind) return;
    const t = this.getViewportPoint(e), n = this._activeObject, s = this.getActiveObjects();
    if (this.targets = [], n && s.length >= 1) {
      if (n.findControl(t, Ml(e)) || s.length > 1 && this.searchPossibleTargets([n], t)) return n;
      if (n === this.searchPossibleTargets([n], t)) {
        if (this.preserveObjectStacking) {
          const i = this.targets;
          this.targets = [];
          const a = this.searchPossibleTargets(this._objects, t);
          return e[this.altSelectionKey] && a && a !== n ? (this.targets = i, n) : a;
        }
        return n;
      }
    }
    return this.searchPossibleTargets(this._objects, t);
  }
  _pointIsInObjectSelectionArea(e, t) {
    let n = e.getCoords();
    const s = this.getZoom(), i = e.padding / s;
    if (i) {
      const [a, c, u, h] = n, d = Math.atan2(c.y - a.y, c.x - a.x), p = wn(d) * i, g = xn(d) * i, v = p + g, b = p - g;
      n = [new $(a.x - b, a.y - v), new $(c.x + v, c.y - b), new $(u.x + b, u.y + v), new $(h.x - v, h.y + b)];
    }
    return St.isPointInPolygon(t, n);
  }
  _checkTarget(e, t) {
    return !!(e && e.visible && e.evented && this._pointIsInObjectSelectionArea(e, ns(t, void 0, this.viewportTransform)) && (!this.perPixelTargetFind && !e.perPixelTargetFind || e.isEditing || !this.isTargetTransparent(e, t.x, t.y)));
  }
  _searchPossibleTargets(e, t) {
    let n = e.length;
    for (; n--; ) {
      const s = e[n];
      if (this._checkTarget(s, t)) {
        if (pl(s) && s.subTargetCheck) {
          const i = this._searchPossibleTargets(s._objects, t);
          i && this.targets.push(i);
        }
        return s;
      }
    }
  }
  searchPossibleTargets(e, t) {
    const n = this._searchPossibleTargets(e, t);
    if (n && pl(n) && n.interactive && this.targets[0]) {
      const s = this.targets;
      for (let i = s.length - 1; i > 0; i--) {
        const a = s[i];
        if (!pl(a) || !a.interactive) return a;
      }
      return s[0];
    }
    return n;
  }
  getViewportPoint(e) {
    return this._pointer ? this._pointer : this.getPointer(e, !0);
  }
  getScenePoint(e) {
    return this._absolutePointer ? this._absolutePointer : this.getPointer(e);
  }
  getPointer(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    const n = this.upperCanvasEl, s = n.getBoundingClientRect();
    let i = pw(e), a = s.width || 0, c = s.height || 0;
    a && c || (Pr in s && rf in s && (c = Math.abs(s.top - s.bottom)), Rt in s && at in s && (a = Math.abs(s.right - s.left))), this.calcOffset(), i.x = i.x - this._offset.left, i.y = i.y - this._offset.top, t || (i = ns(i, void 0, this.viewportTransform));
    const u = this.getRetinaScaling();
    u !== 1 && (i.x /= u, i.y /= u);
    const h = a === 0 || c === 0 ? new $(1, 1) : new $(n.width / a, n.height / c);
    return i.multiply(h);
  }
  _setDimensionsImpl(e, t) {
    this._resetTransformEventData(), super._setDimensionsImpl(e, t), this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);
  }
  _createCacheCanvas() {
    this.pixelFindCanvasEl = cn(), this.pixelFindContext = this.pixelFindCanvasEl.getContext("2d", { willReadFrequently: !0 }), this.setTargetFindTolerance(this.targetFindTolerance);
  }
  getTopContext() {
    return this.elements.upper.ctx;
  }
  getSelectionContext() {
    return this.elements.upper.ctx;
  }
  getSelectionElement() {
    return this.elements.upper.el;
  }
  getActiveObject() {
    return this._activeObject;
  }
  getActiveObjects() {
    const e = this._activeObject;
    return ri(e) ? e.getObjects() : e ? [e] : [];
  }
  _fireSelectionEvents(e, t) {
    let n = !1, s = !1;
    const i = this.getActiveObjects(), a = [], c = [];
    e.forEach((u) => {
      i.includes(u) || (n = !0, u.fire("deselected", { e: t, target: u }), c.push(u));
    }), i.forEach((u) => {
      e.includes(u) || (n = !0, u.fire("selected", { e: t, target: u }), a.push(u));
    }), e.length > 0 && i.length > 0 ? (s = !0, n && this.fire("selection:updated", { e: t, selected: a, deselected: c })) : i.length > 0 ? (s = !0, this.fire("selection:created", { e: t, selected: a })) : e.length > 0 && (s = !0, this.fire("selection:cleared", { e: t, deselected: c })), s && (this._objectsToRender = void 0);
  }
  setActiveObject(e, t) {
    const n = this.getActiveObjects(), s = this._setActiveObject(e, t);
    return this._fireSelectionEvents(n, t), s;
  }
  _setActiveObject(e, t) {
    const n = this._activeObject;
    return n !== e && !(!this._discardActiveObject(t, e) && this._activeObject) && !e.onSelect({ e: t }) && (this._activeObject = e, ri(e) && n !== e && e.set("canvas", this), e.setCoords(), !0);
  }
  _discardActiveObject(e, t) {
    const n = this._activeObject;
    return !!n && !n.onDeselect({ e, object: t }) && (this._currentTransform && this._currentTransform.target === n && this.endCurrentTransform(e), ri(n) && n === this._hoveredTarget && (this._hoveredTarget = void 0), this._activeObject = void 0, !0);
  }
  discardActiveObject(e) {
    const t = this.getActiveObjects(), n = this.getActiveObject();
    t.length && this.fire("before:selection:cleared", { e, deselected: [n] });
    const s = this._discardActiveObject(e);
    return this._fireSelectionEvents(t, e), s;
  }
  endCurrentTransform(e) {
    const t = this._currentTransform;
    this._finalizeCurrentTransform(e), t && t.target && (t.target.isMoving = !1), this._currentTransform = null;
  }
  _finalizeCurrentTransform(e) {
    const t = this._currentTransform, n = t.target, s = { e, target: n, transform: t, action: t.action };
    n._scaling && (n._scaling = !1), n.setCoords(), t.actionPerformed && (this.fire("object:modified", s), n.fire(kl, s));
  }
  setViewportTransform(e) {
    super.setViewportTransform(e);
    const t = this._activeObject;
    t && t.setCoords();
  }
  destroy() {
    const e = this._activeObject;
    ri(e) && (e.removeAll(), e.dispose()), delete this._activeObject, super.destroy(), this.pixelFindContext = null, this.pixelFindCanvasEl = void 0;
  }
  clear() {
    this.discardActiveObject(), this._activeObject = void 0, this.clearContext(this.contextTop), super.clear();
  }
  drawControls(e) {
    const t = this._activeObject;
    t && t._renderControls(e);
  }
  _toObject(e, t, n) {
    const s = this._realizeGroupTransformOnObject(e), i = super._toObject(e, t, n);
    return e.set(s), i;
  }
  _realizeGroupTransformOnObject(e) {
    const { group: t } = e;
    if (t && ri(t) && this._activeObject === t) {
      const n = ki(e, ["angle", "flipX", "flipY", at, Sr, $r, ko, Oo, Pr]);
      return gw(e, t.calcOwnMatrix()), n;
    }
    return {};
  }
  _setSVGObject(e, t, n) {
    const s = this._realizeGroupTransformOnObject(t);
    super._setSVGObject(e, t, n), t.set(s);
  }
}
N(ku, "ownDefaults", { uniformScaling: !0, uniScaleKey: "shiftKey", centeredScaling: !1, centeredRotation: !1, centeredKey: "altKey", altActionKey: "shiftKey", selection: !0, selectionKey: "shiftKey", selectionColor: "rgba(100, 100, 255, 0.3)", selectionDashArray: [], selectionBorderColor: "rgba(255, 255, 255, 0.3)", selectionLineWidth: 1, selectionFullyContained: !1, hoverCursor: "move", moveCursor: "move", defaultCursor: "default", freeDrawingCursor: "crosshair", notAllowedCursor: "not-allowed", perPixelTargetFind: !1, targetFindTolerance: 0, skipTargetFind: !1, stopContextMenu: !1, fireRightClick: !1, fireMiddleClick: !1, enablePointerEvents: !1, containerClass: "canvas-container", preserveObjectStacking: !1 });
class e4 {
  constructor(e) {
    N(this, "targets", []), N(this, "__disposer", void 0);
    const t = () => {
      const { hiddenTextarea: s } = e.getActiveObject() || {};
      s && s.focus();
    }, n = e.upperCanvasEl;
    n.addEventListener("click", t), this.__disposer = () => n.removeEventListener("click", t);
  }
  exitTextEditing() {
    this.target = void 0, this.targets.forEach((e) => {
      e.isEditing && e.exitEditing();
    });
  }
  add(e) {
    this.targets.push(e);
  }
  remove(e) {
    this.unregister(e), ti(this.targets, e);
  }
  register(e) {
    this.target = e;
  }
  unregister(e) {
    e === this.target && (this.target = void 0);
  }
  onMouseMove(e) {
    var t;
    !((t = this.target) === null || t === void 0) && t.isEditing && this.target.updateSelectionOnMouseMove(e);
  }
  clear() {
    this.targets = [], this.target = void 0;
  }
  dispose() {
    this.clear(), this.__disposer(), delete this.__disposer;
  }
}
const t4 = ["target", "oldTarget", "fireCanvas", "e"], Hr = { passive: !1 }, Ji = (r, e) => {
  const t = r.getViewportPoint(e), n = r.getScenePoint(e);
  return { viewportPoint: t, scenePoint: n, pointer: t, absolutePointer: n };
}, Cs = function(r) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) t[n - 1] = arguments[n];
  return r.addEventListener(...t);
}, nn = function(r) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) t[n - 1] = arguments[n];
  return r.removeEventListener(...t);
}, r4 = { mouse: { in: "over", out: "out", targetIn: "mouseover", targetOut: "mouseout", canvasIn: "mouse:over", canvasOut: "mouse:out" }, drag: { in: "enter", out: "leave", targetIn: "dragenter", targetOut: "dragleave", canvasIn: "drag:enter", canvasOut: "drag:leave" } };
class mf extends ku {
  constructor(e) {
    super(e, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}), N(this, "_isClick", void 0), N(this, "textEditingManager", new e4(this)), ["_onMouseDown", "_onTouchStart", "_onMouseMove", "_onMouseUp", "_onTouchEnd", "_onResize", "_onMouseWheel", "_onMouseOut", "_onMouseEnter", "_onContextMenu", "_onDoubleClick", "_onDragStart", "_onDragEnd", "_onDragProgress", "_onDragOver", "_onDragEnter", "_onDragLeave", "_onDrop"].forEach((t) => {
      this[t] = this[t].bind(this);
    }), this.addOrRemove(Cs, "add");
  }
  _getEventPrefix() {
    return this.enablePointerEvents ? "pointer" : "mouse";
  }
  addOrRemove(e, t) {
    const n = this.upperCanvasEl, s = this._getEventPrefix();
    e(hw(n), "resize", this._onResize), e(n, s + "down", this._onMouseDown), e(n, "".concat(s, "move"), this._onMouseMove, Hr), e(n, "".concat(s, "out"), this._onMouseOut), e(n, "".concat(s, "enter"), this._onMouseEnter), e(n, "wheel", this._onMouseWheel), e(n, "contextmenu", this._onContextMenu), e(n, "dblclick", this._onDoubleClick), e(n, "dragstart", this._onDragStart), e(n, "dragend", this._onDragEnd), e(n, "dragover", this._onDragOver), e(n, "dragenter", this._onDragEnter), e(n, "dragleave", this._onDragLeave), e(n, "drop", this._onDrop), this.enablePointerEvents || e(n, "touchstart", this._onTouchStart, Hr);
  }
  removeListeners() {
    this.addOrRemove(nn, "remove");
    const e = this._getEventPrefix(), t = vn(this.upperCanvasEl);
    nn(t, "".concat(e, "up"), this._onMouseUp), nn(t, "touchend", this._onTouchEnd, Hr), nn(t, "".concat(e, "move"), this._onMouseMove, Hr), nn(t, "touchmove", this._onMouseMove, Hr), clearTimeout(this._willAddMouseDown);
  }
  _onMouseWheel(e) {
    this.__onMouseWheel(e);
  }
  _onMouseOut(e) {
    const t = this._hoveredTarget, n = L({ e }, Ji(this, e));
    this.fire("mouse:out", L(L({}, n), {}, { target: t })), this._hoveredTarget = void 0, t && t.fire("mouseout", L({}, n)), this._hoveredTargets.forEach((s) => {
      this.fire("mouse:out", L(L({}, n), {}, { target: s })), s && s.fire("mouseout", L({}, n));
    }), this._hoveredTargets = [];
  }
  _onMouseEnter(e) {
    this._currentTransform || this.findTarget(e) || (this.fire("mouse:over", L({ e }, Ji(this, e))), this._hoveredTarget = void 0, this._hoveredTargets = []);
  }
  _onDragStart(e) {
    this._isClick = !1;
    const t = this.getActiveObject();
    if (t && t.onDragStart(e)) {
      this._dragSource = t;
      const n = { e, target: t };
      return this.fire("dragstart", n), t.fire("dragstart", n), void Cs(this.upperCanvasEl, "drag", this._onDragProgress);
    }
    sf(e);
  }
  _renderDragEffects(e, t, n) {
    let s = !1;
    const i = this._dropTarget;
    i && i !== t && i !== n && (i.clearContextTop(), s = !0), t?.clearContextTop(), n !== t && n?.clearContextTop();
    const a = this.contextTop;
    a.save(), a.transform(...this.viewportTransform), t && (a.save(), t.transform(a), t.renderDragSourceEffect(e), a.restore(), s = !0), n && (a.save(), n.transform(a), n.renderDropTargetEffect(e), a.restore(), s = !0), a.restore(), s && (this.contextTopDirty = !0);
  }
  _onDragEnd(e) {
    const t = !!e.dataTransfer && e.dataTransfer.dropEffect !== Dr, n = t ? this._activeObject : void 0, s = { e, target: this._dragSource, subTargets: this.targets, dragSource: this._dragSource, didDrop: t, dropTarget: n };
    nn(this.upperCanvasEl, "drag", this._onDragProgress), this.fire("dragend", s), this._dragSource && this._dragSource.fire("dragend", s), delete this._dragSource, this._onMouseUp(e);
  }
  _onDragProgress(e) {
    const t = { e, target: this._dragSource, dragSource: this._dragSource, dropTarget: this._draggedoverTarget };
    this.fire("drag", t), this._dragSource && this._dragSource.fire("drag", t);
  }
  findDragTargets(e) {
    return this.targets = [], { target: this._searchPossibleTargets(this._objects, this.getViewportPoint(e)), targets: [...this.targets] };
  }
  _onDragOver(e) {
    const t = "dragover", { target: n, targets: s } = this.findDragTargets(e), i = this._dragSource, a = { e, target: n, subTargets: s, dragSource: i, canDrop: !1, dropTarget: void 0 };
    let c;
    this.fire(t, a), this._fireEnterLeaveEvents(n, a), n && (n.canDrop(e) && (c = n), n.fire(t, a));
    for (let u = 0; u < s.length; u++) {
      const h = s[u];
      h.canDrop(e) && (c = h), h.fire(t, a);
    }
    this._renderDragEffects(e, i, c), this._dropTarget = c;
  }
  _onDragEnter(e) {
    const { target: t, targets: n } = this.findDragTargets(e), s = { e, target: t, subTargets: n, dragSource: this._dragSource };
    this.fire("dragenter", s), this._fireEnterLeaveEvents(t, s);
  }
  _onDragLeave(e) {
    const t = { e, target: this._draggedoverTarget, subTargets: this.targets, dragSource: this._dragSource };
    this.fire("dragleave", t), this._fireEnterLeaveEvents(void 0, t), this._renderDragEffects(e, this._dragSource), this._dropTarget = void 0, this.targets = [], this._hoveredTargets = [];
  }
  _onDrop(e) {
    const { target: t, targets: n } = this.findDragTargets(e), s = this._basicEventHandler("drop:before", L({ e, target: t, subTargets: n, dragSource: this._dragSource }, Ji(this, e)));
    s.didDrop = !1, s.dropTarget = void 0, this._basicEventHandler("drop", s), this.fire("drop:after", s);
  }
  _onContextMenu(e) {
    const t = this.findTarget(e), n = this.targets || [], s = this._basicEventHandler("contextmenu:before", { e, target: t, subTargets: n });
    return this.stopContextMenu && sf(e), this._basicEventHandler("contextmenu", s), !1;
  }
  _onDoubleClick(e) {
    this._cacheTransformEventData(e), this._handleEvent(e, "dblclick"), this._resetTransformEventData();
  }
  getPointerId(e) {
    const t = e.changedTouches;
    return t ? t[0] && t[0].identifier : this.enablePointerEvents ? e.pointerId : -1;
  }
  _isMainEvent(e) {
    return e.isPrimary === !0 || e.isPrimary !== !1 && (e.type === "touchend" && e.touches.length === 0 || !e.changedTouches || e.changedTouches[0].identifier === this.mainTouchId);
  }
  _onTouchStart(e) {
    let t = !this.allowTouchScrolling;
    const n = this._activeObject;
    this.mainTouchId === void 0 && (this.mainTouchId = this.getPointerId(e)), this.__onMouseDown(e), (this.isDrawingMode || n && this._target === n) && (t = !0), t && e.preventDefault(), this._resetTransformEventData();
    const s = this.upperCanvasEl, i = this._getEventPrefix(), a = vn(s);
    Cs(a, "touchend", this._onTouchEnd, Hr), t && Cs(a, "touchmove", this._onMouseMove, Hr), nn(s, "".concat(i, "down"), this._onMouseDown);
  }
  _onMouseDown(e) {
    this.__onMouseDown(e), this._resetTransformEventData();
    const t = this.upperCanvasEl, n = this._getEventPrefix();
    nn(t, "".concat(n, "move"), this._onMouseMove, Hr);
    const s = vn(t);
    Cs(s, "".concat(n, "up"), this._onMouseUp), Cs(s, "".concat(n, "move"), this._onMouseMove, Hr);
  }
  _onTouchEnd(e) {
    if (e.touches.length > 0) return;
    this.__onMouseUp(e), this._resetTransformEventData(), delete this.mainTouchId;
    const t = this._getEventPrefix(), n = vn(this.upperCanvasEl);
    nn(n, "touchend", this._onTouchEnd, Hr), nn(n, "touchmove", this._onMouseMove, Hr), this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(() => {
      Cs(this.upperCanvasEl, "".concat(t, "down"), this._onMouseDown), this._willAddMouseDown = 0;
    }, 400);
  }
  _onMouseUp(e) {
    this.__onMouseUp(e), this._resetTransformEventData();
    const t = this.upperCanvasEl, n = this._getEventPrefix();
    if (this._isMainEvent(e)) {
      const s = vn(this.upperCanvasEl);
      nn(s, "".concat(n, "up"), this._onMouseUp), nn(s, "".concat(n, "move"), this._onMouseMove, Hr), Cs(t, "".concat(n, "move"), this._onMouseMove, Hr);
    }
  }
  _onMouseMove(e) {
    const t = this.getActiveObject();
    !this.allowTouchScrolling && (!t || !t.shouldStartDragging(e)) && e.preventDefault && e.preventDefault(), this.__onMouseMove(e);
  }
  _onResize() {
    this.calcOffset(), this._resetTransformEventData();
  }
  _shouldRender(e) {
    const t = this.getActiveObject();
    return !!t != !!e || t && e && t !== e;
  }
  __onMouseUp(e) {
    var t;
    this._cacheTransformEventData(e), this._handleEvent(e, "up:before");
    const n = this._currentTransform, s = this._isClick, i = this._target, { button: a } = e;
    if (a) return (this.fireMiddleClick && a === 1 || this.fireRightClick && a === 2) && this._handleEvent(e, "up"), void this._resetTransformEventData();
    if (this.isDrawingMode && this._isCurrentlyDrawing) return void this._onMouseUpInDrawingMode(e);
    if (!this._isMainEvent(e)) return;
    let c, u, h = !1;
    if (n && (this._finalizeCurrentTransform(e), h = n.actionPerformed), !s) {
      const d = i === this._activeObject;
      this.handleSelection(e), h || (h = this._shouldRender(i) || !d && i === this._activeObject);
    }
    if (i) {
      const d = i.findControl(this.getViewportPoint(e), Ml(e)), { key: p, control: g } = d || {};
      if (u = p, i.selectable && i !== this._activeObject && i.activeOn === "up") this.setActiveObject(i, e), h = !0;
      else if (g) {
        const v = g.getMouseUpHandler(e, i, g);
        v && (c = this.getScenePoint(e), v.call(g, e, n, c.x, c.y));
      }
      i.isMoving = !1;
    }
    if (n && (n.target !== i || n.corner !== u)) {
      const d = n.target && n.target.controls[n.corner], p = d && d.getMouseUpHandler(e, n.target, d);
      c = c || this.getScenePoint(e), p && p.call(d, e, n, c.x, c.y);
    }
    this._setCursorFromEvent(e, i), this._handleEvent(e, "up"), this._groupSelector = null, this._currentTransform = null, i && (i.__corner = void 0), h ? this.requestRenderAll() : s || (t = this._activeObject) !== null && t !== void 0 && t.isEditing || this.renderTop();
  }
  _basicEventHandler(e, t) {
    const { target: n, subTargets: s = [] } = t;
    this.fire(e, t), n && n.fire(e, t);
    for (let i = 0; i < s.length; i++) s[i] !== n && s[i].fire(e, t);
    return t;
  }
  _handleEvent(e, t) {
    const n = this._target, s = this.targets || [], i = L(L({ e, target: n, subTargets: s }, Ji(this, e)), {}, { transform: this._currentTransform }, t === "up:before" || t === "up" ? { isClick: this._isClick, currentTarget: this.findTarget(e), currentSubTargets: this.targets } : {});
    this.fire("mouse:".concat(t), i), n && n.fire("mouse".concat(t), i);
    for (let a = 0; a < s.length; a++) s[a] !== n && s[a].fire("mouse".concat(t), i);
  }
  _onMouseDownInDrawingMode(e) {
    this._isCurrentlyDrawing = !0, this.getActiveObject() && (this.discardActiveObject(e), this.requestRenderAll());
    const t = this.getScenePoint(e);
    this.freeDrawingBrush && this.freeDrawingBrush.onMouseDown(t, { e, pointer: t }), this._handleEvent(e, "down");
  }
  _onMouseMoveInDrawingMode(e) {
    if (this._isCurrentlyDrawing) {
      const t = this.getScenePoint(e);
      this.freeDrawingBrush && this.freeDrawingBrush.onMouseMove(t, { e, pointer: t });
    }
    this.setCursor(this.freeDrawingCursor), this._handleEvent(e, "move");
  }
  _onMouseUpInDrawingMode(e) {
    const t = this.getScenePoint(e);
    this.freeDrawingBrush ? this._isCurrentlyDrawing = !!this.freeDrawingBrush.onMouseUp({ e, pointer: t }) : this._isCurrentlyDrawing = !1, this._handleEvent(e, "up");
  }
  __onMouseDown(e) {
    this._isClick = !0, this._cacheTransformEventData(e), this._handleEvent(e, "down:before");
    let t = this._target;
    const { button: n } = e;
    if (n) return (this.fireMiddleClick && n === 1 || this.fireRightClick && n === 2) && this._handleEvent(e, "down"), void this._resetTransformEventData();
    if (this.isDrawingMode) return void this._onMouseDownInDrawingMode(e);
    if (!this._isMainEvent(e) || this._currentTransform) return;
    let s = this._shouldRender(t), i = !1;
    if (this.handleMultiSelection(e, t) ? (t = this._activeObject, i = !0, s = !0) : this._shouldClearSelection(e, t) && this.discardActiveObject(e), this.selection && (!t || !t.selectable && !t.isEditing && t !== this._activeObject)) {
      const a = this.getScenePoint(e);
      this._groupSelector = { x: a.x, y: a.y, deltaY: 0, deltaX: 0 };
    }
    if (t) {
      const a = t === this._activeObject;
      t.selectable && t.activeOn === "down" && this.setActiveObject(t, e);
      const c = t.findControl(this.getViewportPoint(e), Ml(e));
      if (t === this._activeObject && (c || !i)) {
        this._setupCurrentTransform(e, t, a);
        const u = c ? c.control : void 0, h = this.getScenePoint(e), d = u && u.getMouseDownHandler(e, t, u);
        d && d.call(u, e, this._currentTransform, h.x, h.y);
      }
    }
    s && (this._objectsToRender = void 0), this._handleEvent(e, "down"), s && this.requestRenderAll();
  }
  _resetTransformEventData() {
    this._target = this._pointer = this._absolutePointer = void 0;
  }
  _cacheTransformEventData(e) {
    this._resetTransformEventData(), this._pointer = this.getViewportPoint(e), this._absolutePointer = ns(this._pointer, void 0, this.viewportTransform), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e);
  }
  __onMouseMove(e) {
    if (this._isClick = !1, this._cacheTransformEventData(e), this._handleEvent(e, "move:before"), this.isDrawingMode) return void this._onMouseMoveInDrawingMode(e);
    if (!this._isMainEvent(e)) return;
    const t = this._groupSelector;
    if (t) {
      const n = this.getScenePoint(e);
      t.deltaX = n.x - t.x, t.deltaY = n.y - t.y, this.renderTop();
    } else if (this._currentTransform) this._transformObject(e);
    else {
      const n = this.findTarget(e);
      this._setCursorFromEvent(e, n), this._fireOverOutEvents(e, n);
    }
    this.textEditingManager.onMouseMove(e), this._handleEvent(e, "move"), this._resetTransformEventData();
  }
  _fireOverOutEvents(e, t) {
    const n = this._hoveredTarget, s = this._hoveredTargets, i = this.targets, a = Math.max(s.length, i.length);
    this.fireSyntheticInOutEvents("mouse", { e, target: t, oldTarget: n, fireCanvas: !0 });
    for (let c = 0; c < a; c++) this.fireSyntheticInOutEvents("mouse", { e, target: i[c], oldTarget: s[c] });
    this._hoveredTarget = t, this._hoveredTargets = this.targets.concat();
  }
  _fireEnterLeaveEvents(e, t) {
    const n = this._draggedoverTarget, s = this._hoveredTargets, i = this.targets, a = Math.max(s.length, i.length);
    this.fireSyntheticInOutEvents("drag", L(L({}, t), {}, { target: e, oldTarget: n, fireCanvas: !0 }));
    for (let c = 0; c < a; c++) this.fireSyntheticInOutEvents("drag", L(L({}, t), {}, { target: i[c], oldTarget: s[c] }));
    this._draggedoverTarget = e;
  }
  fireSyntheticInOutEvents(e, t) {
    let { target: n, oldTarget: s, fireCanvas: i, e: a } = t, c = yt(t, t4);
    const { targetIn: u, targetOut: h, canvasIn: d, canvasOut: p } = r4[e], g = s !== n;
    if (s && g) {
      const v = L(L({}, c), {}, { e: a, target: s, nextTarget: n }, Ji(this, a));
      i && this.fire(p, v), s.fire(h, v);
    }
    if (n && g) {
      const v = L(L({}, c), {}, { e: a, target: n, previousTarget: s }, Ji(this, a));
      i && this.fire(d, v), n.fire(u, v);
    }
  }
  __onMouseWheel(e) {
    this._cacheTransformEventData(e), this._handleEvent(e, "wheel"), this._resetTransformEventData();
  }
  _transformObject(e) {
    const t = this.getScenePoint(e), n = this._currentTransform, s = n.target, i = s.group ? ns(t, void 0, s.group.calcTransformMatrix()) : t;
    n.shiftKey = e.shiftKey, n.altKey = !!this.centeredKey && e[this.centeredKey], this._performTransformAction(e, n, i), n.actionPerformed && this.requestRenderAll();
  }
  _performTransformAction(e, t, n) {
    const { action: s, actionHandler: i, target: a } = t, c = !!i && i(e, t, n.x, n.y);
    c && a.setCoords(), s === "drag" && c && (t.target.isMoving = !0, this.setCursor(t.target.moveCursor || this.moveCursor)), t.actionPerformed = t.actionPerformed || c;
  }
  _setCursorFromEvent(e, t) {
    if (!t) return void this.setCursor(this.defaultCursor);
    let n = t.hoverCursor || this.hoverCursor;
    const s = ri(this._activeObject) ? this._activeObject : null, i = (!s || t.group !== s) && t.findControl(this.getViewportPoint(e));
    if (i) {
      const a = i.control;
      this.setCursor(a.cursorStyleHandler(e, a, t));
    } else t.subTargetCheck && this.targets.concat().reverse().map((a) => {
      n = a.hoverCursor || n;
    }), this.setCursor(n);
  }
  handleMultiSelection(e, t) {
    const n = this._activeObject, s = ri(n);
    if (n && this._isSelectionKeyPressed(e) && this.selection && t && t.selectable && (n !== t || s) && (s || !t.isDescendantOf(n) && !n.isDescendantOf(t)) && !t.onSelect({ e }) && !n.getActiveControl()) {
      if (s) {
        const i = n.getObjects();
        if (t === n) {
          const a = this.getViewportPoint(e);
          if (!(t = this.searchPossibleTargets(i, a) || this.searchPossibleTargets(this._objects, a)) || !t.selectable) return !1;
        }
        t.group === n ? (n.remove(t), this._hoveredTarget = t, this._hoveredTargets = [...this.targets], n.size() === 1 && this._setActiveObject(n.item(0), e)) : (n.multiSelectAdd(t), this._hoveredTarget = n, this._hoveredTargets = [...this.targets]), this._fireSelectionEvents(i, e);
      } else {
        n.isEditing && n.exitEditing();
        const i = new (le.getClass("ActiveSelection"))([], { canvas: this });
        i.multiSelectAdd(n, t), this._hoveredTarget = i, this._setActiveObject(i, e), this._fireSelectionEvents([n], e);
      }
      return !0;
    }
    return !1;
  }
  handleSelection(e) {
    if (!this.selection || !this._groupSelector) return !1;
    const { x: t, y: n, deltaX: s, deltaY: i } = this._groupSelector, a = new $(t, n), c = a.add(new $(s, i)), u = a.min(c), h = a.max(c).subtract(u), d = this.collectObjects({ left: u.x, top: u.y, width: h.x, height: h.y }, { includeIntersecting: !this.selectionFullyContained }), p = a.eq(c) ? d[0] ? [d[0]] : [] : d.length > 1 ? d.filter((g) => !g.onSelect({ e })).reverse() : d;
    if (p.length === 1) this.setActiveObject(p[0], e);
    else if (p.length > 1) {
      const g = le.getClass("ActiveSelection");
      this.setActiveObject(new g(p, { canvas: this }), e);
    }
    return this._groupSelector = null, !0;
  }
  clear() {
    this.textEditingManager.clear(), super.clear();
  }
  destroy() {
    this.removeListeners(), this.textEditingManager.dispose(), super.destroy();
  }
}
const cx = { x1: 0, y1: 0, x2: 0, y2: 0 }, n4 = L(L({}, cx), {}, { r1: 0, r2: 0 }), ro = (r, e) => isNaN(r) && typeof e == "number" ? e : r, s4 = /^(\d+\.\d+)%|(\d+)%$/;
function lx(r) {
  return r && s4.test(r);
}
function ux(r, e) {
  const t = typeof r == "number" ? r : typeof r == "string" ? parseFloat(r) / (lx(r) ? 100 : 1) : NaN;
  return gi(0, ro(t, e), 1);
}
const i4 = /\s*;\s*/, o4 = /\s*:\s*/;
function a4(r, e) {
  let t, n;
  const s = r.getAttribute("style");
  if (s) {
    const a = s.split(i4);
    a[a.length - 1] === "" && a.pop();
    for (let c = a.length; c--; ) {
      const [u, h] = a[c].split(o4).map((d) => d.trim());
      u === "stop-color" ? t = h : u === "stop-opacity" && (n = h);
    }
  }
  const i = new lt(t || r.getAttribute("stop-color") || "rgb(0,0,0)");
  return { offset: ux(r.getAttribute("offset"), 0), color: i.toRgb(), opacity: ro(parseFloat(n || r.getAttribute("stop-opacity") || ""), 1) * i.getAlpha() * e };
}
function c4(r, e) {
  const t = [], n = r.getElementsByTagName("stop"), s = ux(e, 1);
  for (let i = n.length; i--; ) t.push(a4(n[i], s));
  return t;
}
function hx(r) {
  return r.nodeName === "linearGradient" || r.nodeName === "LINEARGRADIENT" ? "linear" : "radial";
}
function dx(r) {
  return r.getAttribute("gradientUnits") === "userSpaceOnUse" ? "pixels" : "percentage";
}
function gn(r, e) {
  return r.getAttribute(e);
}
function l4(r, e) {
  return function(t, n) {
    let s, { width: i, height: a, gradientUnits: c } = n;
    return Object.keys(t).reduce((u, h) => {
      const d = t[h];
      return d === "Infinity" ? s = 1 : d === "-Infinity" ? s = 0 : (s = typeof d == "string" ? parseFloat(d) : d, typeof d == "string" && lx(d) && (s *= 0.01, c === "pixels" && (h !== "x1" && h !== "x2" && h !== "r2" || (s *= i), h !== "y1" && h !== "y2" || (s *= a)))), u[h] = s, u;
    }, {});
  }(hx(r) === "linear" ? function(t) {
    return { x1: gn(t, "x1") || 0, y1: gn(t, "y1") || 0, x2: gn(t, "x2") || "100%", y2: gn(t, "y2") || 0 };
  }(r) : function(t) {
    return { x1: gn(t, "fx") || gn(t, "cx") || "50%", y1: gn(t, "fy") || gn(t, "cy") || "50%", r1: 0, x2: gn(t, "cx") || "50%", y2: gn(t, "cy") || "50%", r2: gn(t, "r") || "50%" };
  }(r), L(L({}, e), {}, { gradientUnits: dx(r) }));
}
class Wc {
  constructor(e) {
    const { type: t = "linear", gradientUnits: n = "pixels", coords: s = {}, colorStops: i = [], offsetX: a = 0, offsetY: c = 0, gradientTransform: u, id: h } = e || {};
    Object.assign(this, { type: t, gradientUnits: n, coords: L(L({}, t === "radial" ? n4 : cx), s), colorStops: i, offsetX: a, offsetY: c, gradientTransform: u, id: h ? "".concat(h, "_").concat(Ms()) : Ms() });
  }
  addColorStop(e) {
    for (const t in e) {
      const n = new lt(e[t]);
      this.colorStops.push({ offset: parseFloat(t), color: n.toRgb(), opacity: n.getAlpha() });
    }
    return this;
  }
  toObject(e) {
    return L(L({}, ki(this, e)), {}, { type: this.type, coords: L({}, this.coords), colorStops: this.colorStops.map((t) => L({}, t)), offsetX: this.offsetX, offsetY: this.offsetY, gradientUnits: this.gradientUnits, gradientTransform: this.gradientTransform ? [...this.gradientTransform] : void 0 });
  }
  toSVG(e) {
    let { additionalTransform: t } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = [], s = this.gradientTransform ? this.gradientTransform.concat() : _r.concat(), i = this.gradientUnits === "pixels" ? "userSpaceOnUse" : "objectBoundingBox", a = this.colorStops.map((p) => L({}, p)).sort((p, g) => p.offset - g.offset);
    let c = -this.offsetX, u = -this.offsetY;
    var h;
    i === "objectBoundingBox" ? (c /= e.width, u /= e.height) : (c += e.width / 2, u += e.height / 2), (h = e) && typeof h._renderPathCommands == "function" && this.gradientUnits !== "percentage" && (c -= e.pathOffset.x, u -= e.pathOffset.y), s[4] -= c, s[5] -= u;
    const d = ['id="SVGID_'.concat(this.id, '"'), 'gradientUnits="'.concat(i, '"'), 'gradientTransform="'.concat(t ? t + " " : "").concat(Ca(s), '"'), ""].join(" ");
    if (this.type === "linear") {
      const { x1: p, y1: g, x2: v, y2: b } = this.coords;
      n.push("<linearGradient ", d, ' x1="', p, '" y1="', g, '" x2="', v, '" y2="', b, `">
`);
    } else if (this.type === "radial") {
      const { x1: p, y1: g, x2: v, y2: b, r1: _, r2: C } = this.coords, T = _ > C;
      n.push("<radialGradient ", d, ' cx="', T ? p : v, '" cy="', T ? g : b, '" r="', T ? _ : C, '" fx="', T ? v : p, '" fy="', T ? b : g, `">
`), T && (a.reverse(), a.forEach((M) => {
        M.offset = 1 - M.offset;
      }));
      const k = Math.min(_, C);
      if (k > 0) {
        const M = k / Math.max(_, C);
        a.forEach((A) => {
          A.offset += M * (1 - A.offset);
        });
      }
    }
    return a.forEach((p) => {
      let { color: g, offset: v, opacity: b } = p;
      n.push("<stop ", 'offset="', 100 * v + "%", '" style="stop-color:', g, b !== void 0 ? ";stop-opacity: " + b : ";", `"/>
`);
    }), n.push(this.type === "linear" ? "</linearGradient>" : "</radialGradient>", `
`), n.join("");
  }
  toLive(e) {
    const { x1: t, y1: n, x2: s, y2: i, r1: a, r2: c } = this.coords, u = this.type === "linear" ? e.createLinearGradient(t, n, s, i) : e.createRadialGradient(t, n, a, s, i, c);
    return this.colorStops.forEach((h) => {
      let { color: d, opacity: p, offset: g } = h;
      u.addColorStop(g, p !== void 0 ? new lt(d).setAlpha(p).toRgba() : d);
    }), u;
  }
  static async fromObject(e) {
    const { colorStops: t, gradientTransform: n } = e;
    return new this(L(L({}, e), {}, { colorStops: t ? t.map((s) => L({}, s)) : void 0, gradientTransform: n ? [...n] : void 0 }));
  }
  static fromElement(e, t, n) {
    const s = dx(e), i = t._findCenterFromElement();
    return new this(L({ id: e.getAttribute("id") || void 0, type: hx(e), coords: l4(e, { width: n.viewBoxWidth || n.width, height: n.viewBoxHeight || n.height }), colorStops: c4(e, n.opacity), gradientUnits: s, gradientTransform: df(e.getAttribute("gradientTransform") || "") }, s === "pixels" ? { offsetX: t.width / 2 - i.x, offsetY: t.height / 2 - i.y } : { offsetX: 0, offsetY: 0 }));
  }
}
N(Wc, "type", "Gradient"), le.setClass(Wc, "gradient"), le.setClass(Wc, "linear"), le.setClass(Wc, "radial");
const u4 = ["type", "source", "patternTransform"];
class ld {
  get type() {
    return "pattern";
  }
  set type(e) {
    ks("warn", "Setting type has no effect", e);
  }
  constructor(e) {
    N(this, "repeat", "repeat"), N(this, "offsetX", 0), N(this, "offsetY", 0), N(this, "crossOrigin", ""), this.id = Ms(), Object.assign(this, e);
  }
  isImageSource() {
    return !!this.source && typeof this.source.src == "string";
  }
  isCanvasSource() {
    return !!this.source && !!this.source.toDataURL;
  }
  sourceToString() {
    return this.isImageSource() ? this.source.src : this.isCanvasSource() ? this.source.toDataURL() : "";
  }
  toLive(e) {
    return this.source && (!this.isImageSource() || this.source.complete && this.source.naturalWidth !== 0 && this.source.naturalHeight !== 0) ? e.createPattern(this.source, this.repeat) : null;
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const { repeat: t, crossOrigin: n } = this;
    return L(L({}, ki(this, e)), {}, { type: "pattern", source: this.sourceToString(), repeat: t, crossOrigin: n, offsetX: vt(this.offsetX, et.NUM_FRACTION_DIGITS), offsetY: vt(this.offsetY, et.NUM_FRACTION_DIGITS), patternTransform: this.patternTransform ? [...this.patternTransform] : null });
  }
  toSVG(e) {
    let { width: t, height: n } = e;
    const { source: s, repeat: i, id: a } = this, c = ro(this.offsetX / t, 0), u = ro(this.offsetY / n, 0), h = i === "repeat-y" || i === "no-repeat" ? 1 + Math.abs(c || 0) : ro(s.width / t, 0), d = i === "repeat-x" || i === "no-repeat" ? 1 + Math.abs(u || 0) : ro(s.height / n, 0);
    return ['<pattern id="SVGID_'.concat(a, '" x="').concat(c, '" y="').concat(u, '" width="').concat(h, '" height="').concat(d, '">'), '<image x="0" y="0" width="'.concat(s.width, '" height="').concat(s.height, '" xlink:href="').concat(this.sourceToString(), '"></image>'), "</pattern>", ""].join(`
`);
  }
  static async fromObject(e, t) {
    let { type: n, source: s, patternTransform: i } = e, a = yt(e, u4);
    const c = await ma(s, L(L({}, t), {}, { crossOrigin: a.crossOrigin }));
    return new this(L(L({}, a), {}, { patternTransform: i && i.slice(0), source: c }));
  }
}
N(ld, "type", "Pattern"), le.setClass(ld), le.setClass(ld, "pattern");
const h4 = ["path", "left", "top"], d4 = ["d"];
class ni extends ht {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { path: n, left: s, top: i } = t, a = yt(t, h4);
    super(), Object.assign(this, ni.ownDefaults), this.setOptions(a), this._setPath(e || [], !0), typeof s == "number" && this.set(at, s), typeof i == "number" && this.set(Pr, i);
  }
  _setPath(e, t) {
    this.path = Qw(Array.isArray(e) ? e : ix(e)), this.setBoundingBox(t);
  }
  _findCenterFromElement() {
    const e = this._calcBoundsFromPath();
    return new $(e.left + e.width / 2, e.top + e.height / 2);
  }
  _renderPathCommands(e) {
    const t = -this.pathOffset.x, n = -this.pathOffset.y;
    e.beginPath();
    for (const s of this.path) switch (s[0]) {
      case "L":
        e.lineTo(s[1] + t, s[2] + n);
        break;
      case "M":
        e.moveTo(s[1] + t, s[2] + n);
        break;
      case "C":
        e.bezierCurveTo(s[1] + t, s[2] + n, s[3] + t, s[4] + n, s[5] + t, s[6] + n);
        break;
      case "Q":
        e.quadraticCurveTo(s[1] + t, s[2] + n, s[3] + t, s[4] + n);
        break;
      case "Z":
        e.closePath();
    }
  }
  _render(e) {
    this._renderPathCommands(e), this._renderPaintInOrder(e);
  }
  toString() {
    return "#<Path (".concat(this.complexity(), '): { "top": ').concat(this.top, ', "left": ').concat(this.left, " }>");
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return L(L({}, super.toObject(e)), {}, { path: this.path.map((t) => t.slice()) });
  }
  toDatalessObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = this.toObject(e);
    return this.sourcePath && (delete t.path, t.sourcePath = this.sourcePath), t;
  }
  _toSVG() {
    const e = ox(this.path, et.NUM_FRACTION_DIGITS);
    return ["<path ", "COMMON_PARTS", 'd="'.concat(e, `" stroke-linecap="round" />
`)];
  }
  _getOffsetTransform() {
    const e = et.NUM_FRACTION_DIGITS;
    return " translate(".concat(vt(-this.pathOffset.x, e), ", ").concat(vt(-this.pathOffset.y, e), ")");
  }
  toClipPathSVG(e) {
    const t = this._getOffsetTransform();
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(), { reviver: e, additionalTransform: t });
  }
  toSVG(e) {
    const t = this._getOffsetTransform();
    return this._createBaseSVGMarkup(this._toSVG(), { reviver: e, additionalTransform: t });
  }
  complexity() {
    return this.path.length;
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(e) {
    const { width: t, height: n, pathOffset: s } = this._calcDimensions();
    this.set({ width: t, height: n, pathOffset: s }), e && this.setPositionByOrigin(s, Be, Be);
  }
  _calcBoundsFromPath() {
    const e = [];
    let t = 0, n = 0, s = 0, i = 0;
    for (const a of this.path) switch (a[0]) {
      case "L":
        s = a[1], i = a[2], e.push({ x: t, y: n }, { x: s, y: i });
        break;
      case "M":
        s = a[1], i = a[2], t = s, n = i;
        break;
      case "C":
        e.push(...gf(s, i, a[1], a[2], a[3], a[4], a[5], a[6])), s = a[5], i = a[6];
        break;
      case "Q":
        e.push(...gf(s, i, a[1], a[2], a[1], a[2], a[3], a[4])), s = a[3], i = a[4];
        break;
      case "Z":
        s = t, i = n;
    }
    return jn(e);
  }
  _calcDimensions() {
    const e = this._calcBoundsFromPath();
    return L(L({}, e), {}, { pathOffset: new $(e.left + e.width / 2, e.top + e.height / 2) });
  }
  static fromObject(e) {
    return this._fromObject(e, { extraParam: "path" });
  }
  static async fromElement(e, t, n) {
    const s = cs(e, this.ATTRIBUTE_NAMES, n), { d: i } = s;
    return new this(i, L(L(L({}, yt(s, d4)), t), {}, { left: void 0, top: void 0 }));
  }
}
N(ni, "type", "Path"), N(ni, "cacheProperties", [...as, "path", "fillRule"]), N(ni, "ATTRIBUTE_NAMES", [...Bs, "d"]), le.setClass(ni), le.setSVGClass(ni);
const f4 = ["left", "top", "radius"], fx = ["radius", "startAngle", "endAngle", "counterClockwise"];
class Qn extends ht {
  static getDefaults() {
    return L(L({}, super.getDefaults()), Qn.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, Qn.ownDefaults), this.setOptions(e);
  }
  _set(e, t) {
    return super._set(e, t), e === "radius" && this.setRadius(t), this;
  }
  _render(e) {
    e.beginPath(), e.arc(0, 0, this.radius, Mt(this.startAngle), Mt(this.endAngle), this.counterClockwise), this._renderPaintInOrder(e);
  }
  getRadiusX() {
    return this.get("radius") * this.get(Sr);
  }
  getRadiusY() {
    return this.get("radius") * this.get($r);
  }
  setRadius(e) {
    this.radius = e, this.set({ width: 2 * e, height: 2 * e });
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...fx, ...e]);
  }
  _toSVG() {
    const e = (this.endAngle - this.startAngle) % 360;
    if (e === 0) return ["<circle ", "COMMON_PARTS", 'cx="0" cy="0" ', 'r="', "".concat(this.radius), `" />
`];
    {
      const { radius: t } = this, n = Mt(this.startAngle), s = Mt(this.endAngle), i = wn(n) * t, a = xn(n) * t, c = wn(s) * t, u = xn(s) * t, h = e > 180 ? 1 : 0, d = this.counterClockwise ? 0 : 1;
      return ['<path d="M '.concat(i, " ").concat(a, " A ").concat(t, " ").concat(t, " 0 ").concat(h, " ").concat(d, " ").concat(c, " ").concat(u, '" '), "COMMON_PARTS", ` />
`];
    }
  }
  static async fromElement(e, t, n) {
    const s = cs(e, this.ATTRIBUTE_NAMES, n), { left: i = 0, top: a = 0, radius: c = 0 } = s;
    return new this(L(L({}, yt(s, f4)), {}, { radius: c, left: i - c, top: a - c }));
  }
  static fromObject(e) {
    return super._fromObject(e);
  }
}
N(Qn, "type", "Circle"), N(Qn, "cacheProperties", [...as, ...fx]), N(Qn, "ownDefaults", { radius: 0, startAngle: 0, endAngle: 360, counterClockwise: !1 }), N(Qn, "ATTRIBUTE_NAMES", ["cx", "cy", "r", ...Bs]), le.setClass(Qn), le.setSVGClass(Qn);
const p4 = ["x1", "y1", "x2", "y2"], g4 = ["x1", "y1", "x2", "y2"], vf = ["x1", "x2", "y1", "y2"];
class si extends ht {
  constructor() {
    let [e, t, n, s] = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0, 0], i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, si.ownDefaults), this.setOptions(i), this.x1 = e, this.x2 = n, this.y1 = t, this.y2 = s, this._setWidthHeight();
    const { left: a, top: c } = i;
    typeof a == "number" && this.set(at, a), typeof c == "number" && this.set(Pr, c);
  }
  _setWidthHeight() {
    const { x1: e, y1: t, x2: n, y2: s } = this;
    this.width = Math.abs(n - e), this.height = Math.abs(s - t);
    const { left: i, top: a, width: c, height: u } = jn([{ x: e, y: t }, { x: n, y: s }]), h = new $(i + c / 2, a + u / 2);
    this.setPositionByOrigin(h, Be, Be);
  }
  _set(e, t) {
    return super._set(e, t), vf.includes(e) && this._setWidthHeight(), this;
  }
  _render(e) {
    e.beginPath();
    const t = this.calcLinePoints();
    e.moveTo(t.x1, t.y1), e.lineTo(t.x2, t.y2), e.lineWidth = this.strokeWidth;
    const n = e.strokeStyle;
    var s;
    on(this.stroke) ? e.strokeStyle = this.stroke.toLive(e) : e.strokeStyle = (s = this.stroke) !== null && s !== void 0 ? s : e.fillStyle, this.stroke && this._renderStroke(e), e.strokeStyle = n;
  }
  _findCenterFromElement() {
    return new $((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return L(L({}, super.toObject(e)), this.calcLinePoints());
  }
  _getNonTransformedDimensions() {
    const e = super._getNonTransformedDimensions();
    return this.strokeLineCap === "butt" && (this.width === 0 && (e.y -= this.strokeWidth), this.height === 0 && (e.x -= this.strokeWidth)), e;
  }
  calcLinePoints() {
    const { x1: e, x2: t, y1: n, y2: s, width: i, height: a } = this, c = e <= t ? -1 : 1, u = n <= s ? -1 : 1;
    return { x1: c * i / 2, x2: c * -i / 2, y1: u * a / 2, y2: u * -a / 2 };
  }
  _toSVG() {
    const { x1: e, x2: t, y1: n, y2: s } = this.calcLinePoints();
    return ["<line ", "COMMON_PARTS", 'x1="'.concat(e, '" y1="').concat(n, '" x2="').concat(t, '" y2="').concat(s, `" />
`)];
  }
  static async fromElement(e, t, n) {
    const s = cs(e, this.ATTRIBUTE_NAMES, n), { x1: i = 0, y1: a = 0, x2: c = 0, y2: u = 0 } = s;
    return new this([i, a, c, u], yt(s, p4));
  }
  static fromObject(e) {
    let { x1: t, y1: n, x2: s, y2: i } = e, a = yt(e, g4);
    return this._fromObject(L(L({}, a), {}, { points: [t, n, s, i] }), { extraParam: "points" });
  }
}
N(si, "type", "Line"), N(si, "cacheProperties", [...as, ...vf]), N(si, "ATTRIBUTE_NAMES", Bs.concat(vf)), le.setClass(si), le.setSVGClass(si);
class ci extends ht {
  static getDefaults() {
    return L(L({}, super.getDefaults()), ci.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, ci.ownDefaults), this.setOptions(e);
  }
  _render(e) {
    const t = this.width / 2, n = this.height / 2;
    e.beginPath(), e.moveTo(-t, n), e.lineTo(0, -n), e.lineTo(t, n), e.closePath(), this._renderPaintInOrder(e);
  }
  _toSVG() {
    const e = this.width / 2, t = this.height / 2;
    return ["<polygon ", "COMMON_PARTS", 'points="', "".concat(-e, " ").concat(t, ",0 ").concat(-t, ",").concat(e, " ").concat(t), '" />'];
  }
}
N(ci, "type", "Triangle"), N(ci, "ownDefaults", { width: 100, height: 100 }), le.setClass(ci), le.setSVGClass(ci);
const px = ["rx", "ry"];
class es extends ht {
  static getDefaults() {
    return L(L({}, super.getDefaults()), es.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, es.ownDefaults), this.setOptions(e);
  }
  _set(e, t) {
    switch (super._set(e, t), e) {
      case "rx":
        this.rx = t, this.set("width", 2 * t);
        break;
      case "ry":
        this.ry = t, this.set("height", 2 * t);
    }
    return this;
  }
  getRx() {
    return this.get("rx") * this.get(Sr);
  }
  getRy() {
    return this.get("ry") * this.get($r);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...px, ...e]);
  }
  _toSVG() {
    return ["<ellipse ", "COMMON_PARTS", 'cx="0" cy="0" rx="'.concat(this.rx, '" ry="').concat(this.ry, `" />
`)];
  }
  _render(e) {
    e.beginPath(), e.save(), e.transform(1, 0, 0, this.ry / this.rx, 0, 0), e.arc(0, 0, this.rx, 0, os, !1), e.restore(), this._renderPaintInOrder(e);
  }
  static async fromElement(e, t, n) {
    const s = cs(e, this.ATTRIBUTE_NAMES, n);
    return s.left = (s.left || 0) - s.rx, s.top = (s.top || 0) - s.ry, new this(s);
  }
}
function m4(r) {
  if (!r) return [];
  const e = r.replace(/,/g, " ").trim().split(/\s+/), t = [];
  for (let n = 0; n < e.length; n += 2) t.push({ x: parseFloat(e[n]), y: parseFloat(e[n + 1]) });
  return t;
}
N(es, "type", "Ellipse"), N(es, "cacheProperties", [...as, ...px]), N(es, "ownDefaults", { rx: 0, ry: 0 }), N(es, "ATTRIBUTE_NAMES", [...Bs, "cx", "cy", "rx", "ry"]), le.setClass(es), le.setSVGClass(es);
const v4 = ["left", "top"], gx = { exactBoundingBox: !1 };
class mn extends ht {
  static getDefaults() {
    return L(L({}, super.getDefaults()), mn.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), N(this, "strokeDiff", void 0), Object.assign(this, mn.ownDefaults), this.setOptions(t), this.points = e;
    const { left: n, top: s } = t;
    this.initialized = !0, this.setBoundingBox(!0), typeof n == "number" && this.set(at, n), typeof s == "number" && this.set(Pr, s);
  }
  isOpen() {
    return !0;
  }
  _projectStrokeOnPoints(e) {
    return Uw(this.points, e, this.isOpen());
  }
  _calcDimensions(e) {
    e = L({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, strokeLineCap: this.strokeLineCap, strokeLineJoin: this.strokeLineJoin, strokeMiterLimit: this.strokeMiterLimit, strokeUniform: this.strokeUniform, strokeWidth: this.strokeWidth }, e || {});
    const t = this.exactBoundingBox ? this._projectStrokeOnPoints(e).map((h) => h.projectedPoint) : this.points;
    if (t.length === 0) return { left: 0, top: 0, width: 0, height: 0, pathOffset: new $(), strokeOffset: new $(), strokeDiff: new $() };
    const n = jn(t), s = za(L(L({}, e), {}, { scaleX: 1, scaleY: 1 })), i = jn(this.points.map((h) => ur(h, s, !0))), a = new $(this.scaleX, this.scaleY);
    let c = n.left + n.width / 2, u = n.top + n.height / 2;
    return this.exactBoundingBox && (c -= u * Math.tan(Mt(this.skewX)), u -= c * Math.tan(Mt(this.skewY))), L(L({}, n), {}, { pathOffset: new $(c, u), strokeOffset: new $(i.left, i.top).subtract(new $(n.left, n.top)).multiply(a), strokeDiff: new $(n.width, n.height).subtract(new $(i.width, i.height)).multiply(a) });
  }
  _findCenterFromElement() {
    const e = jn(this.points);
    return new $(e.left + e.width / 2, e.top + e.height / 2);
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(e) {
    const { left: t, top: n, width: s, height: i, pathOffset: a, strokeOffset: c, strokeDiff: u } = this._calcDimensions();
    this.set({ width: s, height: i, pathOffset: a, strokeOffset: c, strokeDiff: u }), e && this.setPositionByOrigin(new $(t + s / 2, n + i / 2), Be, Be);
  }
  isStrokeAccountedForInDimensions() {
    return this.exactBoundingBox;
  }
  _getNonTransformedDimensions() {
    return this.exactBoundingBox ? new $(this.width, this.height) : super._getNonTransformedDimensions();
  }
  _getTransformedDimensions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this.exactBoundingBox) {
      let a;
      if (Object.keys(e).some((c) => this.strokeUniform || this.constructor.layoutProperties.includes(c))) {
        var t, n;
        const { width: c, height: u } = this._calcDimensions(e);
        a = new $((t = e.width) !== null && t !== void 0 ? t : c, (n = e.height) !== null && n !== void 0 ? n : u);
      } else {
        var s, i;
        a = new $((s = e.width) !== null && s !== void 0 ? s : this.width, (i = e.height) !== null && i !== void 0 ? i : this.height);
      }
      return a.multiply(new $(e.scaleX || this.scaleX, e.scaleY || this.scaleY));
    }
    return super._getTransformedDimensions(e);
  }
  _set(e, t) {
    const n = this.initialized && this[e] !== t, s = super._set(e, t);
    return this.exactBoundingBox && n && ((e === Sr || e === $r) && this.strokeUniform && this.constructor.layoutProperties.includes("strokeUniform") || this.constructor.layoutProperties.includes(e)) && this.setDimensions(), s;
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return L(L({}, super.toObject(e)), {}, { points: this.points.map((t) => {
      let { x: n, y: s } = t;
      return { x: n, y: s };
    }) });
  }
  _toSVG() {
    const e = [], t = this.pathOffset.x, n = this.pathOffset.y, s = et.NUM_FRACTION_DIGITS;
    for (let i = 0, a = this.points.length; i < a; i++) e.push(vt(this.points[i].x - t, s), ",", vt(this.points[i].y - n, s), " ");
    return ["<".concat(this.constructor.type.toLowerCase(), " "), "COMMON_PARTS", 'points="'.concat(e.join(""), `" />
`)];
  }
  _render(e) {
    const t = this.points.length, n = this.pathOffset.x, s = this.pathOffset.y;
    if (t && !isNaN(this.points[t - 1].y)) {
      e.beginPath(), e.moveTo(this.points[0].x - n, this.points[0].y - s);
      for (let i = 0; i < t; i++) {
        const a = this.points[i];
        e.lineTo(a.x - n, a.y - s);
      }
      !this.isOpen() && e.closePath(), this._renderPaintInOrder(e);
    }
  }
  complexity() {
    return this.points.length;
  }
  static async fromElement(e, t, n) {
    return new this(m4(e.getAttribute("points")), L(L({}, yt(cs(e, this.ATTRIBUTE_NAMES, n), v4)), t));
  }
  static fromObject(e) {
    return this._fromObject(e, { extraParam: "points" });
  }
}
N(mn, "ownDefaults", gx), N(mn, "type", "Polyline"), N(mn, "layoutProperties", [ko, Oo, "strokeLineCap", "strokeLineJoin", "strokeMiterLimit", "strokeWidth", "strokeUniform", "points"]), N(mn, "cacheProperties", [...as, "points"]), N(mn, "ATTRIBUTE_NAMES", [...Bs]), le.setClass(mn), le.setSVGClass(mn);
class Hc extends mn {
  isOpen() {
    return !1;
  }
}
N(Hc, "ownDefaults", gx), N(Hc, "type", "Polygon"), le.setClass(Hc), le.setSVGClass(Hc);
const mx = ["fontSize", "fontWeight", "fontFamily", "fontStyle"], vx = ["underline", "overline", "linethrough"], yx = [...mx, "lineHeight", "text", "charSpacing", "textAlign", "styles", "path", "pathStartOffset", "pathSide", "pathAlign"], bx = [...yx, ...vx, "textBackgroundColor", "direction"], y4 = [...mx, ...vx, Rr, "strokeWidth", Xt, "deltaY", "textBackgroundColor"], b4 = { _reNewline: hp, _reSpacesAndTabs: /[ \t\r]/g, _reSpaceAndTab: /[ \t\r]/, _reWords: /\S+/g, fontSize: 40, fontWeight: "normal", fontFamily: "Times New Roman", underline: !1, overline: !1, linethrough: !1, textAlign: at, fontStyle: "normal", lineHeight: 1.16, superscript: { size: 0.6, baseline: -0.35 }, subscript: { size: 0.6, baseline: 0.11 }, textBackgroundColor: "", stroke: null, shadow: null, path: void 0, pathStartOffset: 0, pathSide: at, pathAlign: "baseline", _fontSizeFraction: 0.222, offsets: { underline: 0.1, linethrough: -0.315, overline: -0.88 }, _fontSizeMult: 1.13, charSpacing: 0, deltaY: 0, direction: "ltr", CACHE_FONT_SIZE: 400, MIN_TEXT_WIDTH: 2 }, An = "justify", Nl = "justify-left", va = "justify-right", ya = "justify-center";
class wx extends ht {
  isEmptyStyles(e) {
    if (!this.styles || e !== void 0 && !this.styles[e]) return !0;
    const t = e === void 0 ? this.styles : { line: this.styles[e] };
    for (const n in t) for (const s in t[n]) for (const i in t[n][s]) return !1;
    return !0;
  }
  styleHas(e, t) {
    if (!this.styles || t !== void 0 && !this.styles[t]) return !1;
    const n = t === void 0 ? this.styles : { 0: this.styles[t] };
    for (const s in n) for (const i in n[s]) if (n[s][i][e] !== void 0) return !0;
    return !1;
  }
  cleanStyle(e) {
    if (!this.styles) return !1;
    const t = this.styles;
    let n, s, i = 0, a = !0, c = 0;
    for (const u in t) {
      n = 0;
      for (const h in t[u]) {
        const d = t[u][h] || {};
        i++, d[e] !== void 0 ? (s ? d[e] !== s && (a = !1) : s = d[e], d[e] === this[e] && delete d[e]) : a = !1, Object.keys(d).length !== 0 ? n++ : delete t[u][h];
      }
      n === 0 && delete t[u];
    }
    for (let u = 0; u < this._textLines.length; u++) c += this._textLines[u].length;
    a && i === c && (this[e] = s, this.removeStyle(e));
  }
  removeStyle(e) {
    if (!this.styles) return;
    const t = this.styles;
    let n, s, i;
    for (s in t) {
      for (i in n = t[s], n) delete n[i][e], Object.keys(n[i]).length === 0 && delete n[i];
      Object.keys(n).length === 0 && delete t[s];
    }
  }
  _extendStyles(e, t) {
    const { lineIndex: n, charIndex: s } = this.get2DCursorLocation(e);
    this._getLineStyle(n) || this._setLineStyle(n);
    const i = vp(L(L({}, this._getStyleDeclaration(n, s)), t), (a) => a !== void 0);
    this._setStyleDeclaration(n, s, i);
  }
  getSelectionStyles(e, t, n) {
    const s = [];
    for (let i = e; i < (t || e); i++) s.push(this.getStyleAtPosition(i, n));
    return s;
  }
  getStyleAtPosition(e, t) {
    const { lineIndex: n, charIndex: s } = this.get2DCursorLocation(e);
    return t ? this.getCompleteStyleDeclaration(n, s) : this._getStyleDeclaration(n, s);
  }
  setSelectionStyles(e, t, n) {
    for (let s = t; s < (n || t); s++) this._extendStyles(s, e);
    this._forceClearCache = !0;
  }
  _getStyleDeclaration(e, t) {
    var n;
    const s = this.styles && this.styles[e];
    return s && (n = s[t]) !== null && n !== void 0 ? n : {};
  }
  getCompleteStyleDeclaration(e, t) {
    return L(L({}, ki(this, this.constructor._styleProperties)), this._getStyleDeclaration(e, t));
  }
  _setStyleDeclaration(e, t, n) {
    this.styles[e][t] = n;
  }
  _deleteStyleDeclaration(e, t) {
    delete this.styles[e][t];
  }
  _getLineStyle(e) {
    return !!this.styles[e];
  }
  _setLineStyle(e) {
    this.styles[e] = {};
  }
  _deleteLineStyle(e) {
    delete this.styles[e];
  }
}
N(wx, "_styleProperties", y4);
const w4 = /  +/g, x4 = /"/g;
function ud(r, e, t, n, s) {
  return "		".concat(function(i, a) {
    let { left: c, top: u, width: h, height: d } = a, p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : et.NUM_FRACTION_DIGITS;
    const g = Ta(Xt, i, !1), [v, b, _, C] = [c, u, h, d].map((T) => vt(T, p));
    return "<rect ".concat(g, ' x="').concat(v, '" y="').concat(b, '" width="').concat(_, '" height="').concat(C, '"></rect>');
  }(r, { left: e, top: t, width: n, height: s }), `
`);
}
const _4 = ["textAnchor", "textDecoration", "dx", "dy", "top", "left", "fontSize", "strokeWidth"];
let hd;
class yr extends wx {
  static getDefaults() {
    return L(L({}, super.getDefaults()), yr.ownDefaults);
  }
  constructor(e, t) {
    super(), N(this, "__charBounds", []), Object.assign(this, yr.ownDefaults), this.setOptions(t), this.styles || (this.styles = {}), this.text = e, this.initialized = !0, this.path && this.setPathInfo(), this.initDimensions(), this.setCoords();
  }
  setPathInfo() {
    const e = this.path;
    e && (e.segmentsInfo = Ap(e.path));
  }
  _splitText() {
    const e = this._splitTextIntoLines(this.text);
    return this.textLines = e.lines, this._textLines = e.graphemeLines, this._unwrappedTextLines = e._unwrappedLines, this._text = e.graphemeText, e;
  }
  initDimensions() {
    this._splitText(), this._clearCache(), this.dirty = !0, this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), this.textAlign.includes(An) && this.enlargeSpaces();
  }
  enlargeSpaces() {
    let e, t, n, s, i, a, c;
    for (let u = 0, h = this._textLines.length; u < h; u++) if ((this.textAlign === An || u !== h - 1 && !this.isEndOfWrapping(u)) && (s = 0, i = this._textLines[u], t = this.getLineWidth(u), t < this.width && (c = this.textLines[u].match(this._reSpacesAndTabs)))) {
      n = c.length, e = (this.width - t) / n;
      for (let d = 0; d <= i.length; d++) a = this.__charBounds[u][d], this._reSpaceAndTab.test(i[d]) ? (a.width += e, a.kernedWidth += e, a.left += s, s += e) : a.left += s;
    }
  }
  isEndOfWrapping(e) {
    return e === this._textLines.length - 1;
  }
  missingNewlineOffset(e) {
    return 1;
  }
  get2DCursorLocation(e, t) {
    const n = t ? this._unwrappedTextLines : this._textLines;
    let s;
    for (s = 0; s < n.length; s++) {
      if (e <= n[s].length) return { lineIndex: s, charIndex: e };
      e -= n[s].length + this.missingNewlineOffset(s, t);
    }
    return { lineIndex: s - 1, charIndex: n[s - 1].length < e ? n[s - 1].length : e };
  }
  toString() {
    return "#<Text (".concat(this.complexity(), '): { "text": "').concat(this.text, '", "fontFamily": "').concat(this.fontFamily, '" }>');
  }
  _getCacheCanvasDimensions() {
    const e = super._getCacheCanvasDimensions(), t = this.fontSize;
    return e.width += t * e.zoomX, e.height += t * e.zoomY, e;
  }
  _render(e) {
    const t = this.path;
    t && !t.isNotVisible() && t._render(e), this._setTextStyles(e), this._renderTextLinesBackground(e), this._renderTextDecoration(e, "underline"), this._renderText(e), this._renderTextDecoration(e, "overline"), this._renderTextDecoration(e, "linethrough");
  }
  _renderText(e) {
    this.paintFirst === Rr ? (this._renderTextStroke(e), this._renderTextFill(e)) : (this._renderTextFill(e), this._renderTextStroke(e));
  }
  _setTextStyles(e, t, n) {
    if (e.textBaseline = "alphabetic", this.path) switch (this.pathAlign) {
      case Be:
        e.textBaseline = "middle";
        break;
      case "ascender":
        e.textBaseline = Pr;
        break;
      case "descender":
        e.textBaseline = rf;
    }
    e.font = this._getFontDeclaration(t, n);
  }
  calcTextWidth() {
    let e = this.getLineWidth(0);
    for (let t = 1, n = this._textLines.length; t < n; t++) {
      const s = this.getLineWidth(t);
      s > e && (e = s);
    }
    return e;
  }
  _renderTextLine(e, t, n, s, i, a) {
    this._renderChars(e, t, n, s, i, a);
  }
  _renderTextLinesBackground(e) {
    if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor")) return;
    const t = e.fillStyle, n = this._getLeftOffset();
    let s = this._getTopOffset();
    for (let i = 0, a = this._textLines.length; i < a; i++) {
      const c = this.getHeightOfLine(i);
      if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor", i)) {
        s += c;
        continue;
      }
      const u = this._textLines[i].length, h = this._getLineLeftOffset(i);
      let d, p, g = 0, v = 0, b = this.getValueOfPropertyAt(i, 0, "textBackgroundColor");
      for (let _ = 0; _ < u; _++) {
        const C = this.__charBounds[i][_];
        p = this.getValueOfPropertyAt(i, _, "textBackgroundColor"), this.path ? (e.save(), e.translate(C.renderLeft, C.renderTop), e.rotate(C.angle), e.fillStyle = p, p && e.fillRect(-C.width / 2, -c / this.lineHeight * (1 - this._fontSizeFraction), C.width, c / this.lineHeight), e.restore()) : p !== b ? (d = n + h + v, this.direction === "rtl" && (d = this.width - d - g), e.fillStyle = b, b && e.fillRect(d, s, g, c / this.lineHeight), v = C.left, g = C.width, b = p) : g += C.kernedWidth;
      }
      p && !this.path && (d = n + h + v, this.direction === "rtl" && (d = this.width - d - g), e.fillStyle = p, e.fillRect(d, s, g, c / this.lineHeight)), s += c;
    }
    e.fillStyle = t, this._removeShadow(e);
  }
  _measureChar(e, t, n, s) {
    const i = pa.getFontCache(t), a = this._getFontDeclaration(t), c = n + e, u = n && a === this._getFontDeclaration(s), h = t.fontSize / this.CACHE_FONT_SIZE;
    let d, p, g, v;
    if (n && i[n] !== void 0 && (g = i[n]), i[e] !== void 0 && (v = d = i[e]), u && i[c] !== void 0 && (p = i[c], v = p - g), d === void 0 || g === void 0 || p === void 0) {
      const b = function() {
        return hd || (hd = _n({ width: 0, height: 0 }).getContext("2d")), hd;
      }();
      this._setTextStyles(b, t, !0), d === void 0 && (v = d = b.measureText(e).width, i[e] = d), g === void 0 && u && n && (g = b.measureText(n).width, i[n] = g), u && p === void 0 && (p = b.measureText(c).width, i[c] = p, v = p - g);
    }
    return { width: d * h, kernedWidth: v * h };
  }
  getHeightOfChar(e, t) {
    return this.getValueOfPropertyAt(e, t, "fontSize");
  }
  measureLine(e) {
    const t = this._measureLine(e);
    return this.charSpacing !== 0 && (t.width -= this._getWidthOfCharSpacing()), t.width < 0 && (t.width = 0), t;
  }
  _measureLine(e) {
    let t, n, s = 0;
    const i = this.pathSide === Rt, a = this.path, c = this._textLines[e], u = c.length, h = new Array(u);
    this.__charBounds[e] = h;
    for (let d = 0; d < u; d++) {
      const p = c[d];
      n = this._getGraphemeBox(p, e, d, t), h[d] = n, s += n.kernedWidth, t = p;
    }
    if (h[u] = { left: n ? n.left + n.width : 0, width: 0, kernedWidth: 0, height: this.fontSize, deltaY: 0 }, a && a.segmentsInfo) {
      let d = 0;
      const p = a.segmentsInfo[a.segmentsInfo.length - 1].length;
      switch (this.textAlign) {
        case at:
          d = i ? p - s : 0;
          break;
        case Be:
          d = (p - s) / 2;
          break;
        case Rt:
          d = i ? 0 : p - s;
      }
      d += this.pathStartOffset * (i ? -1 : 1);
      for (let g = i ? u - 1 : 0; i ? g >= 0 : g < u; i ? g-- : g++) n = h[g], d > p ? d %= p : d < 0 && (d += p), this._setGraphemeOnPath(d, n), d += n.kernedWidth;
    }
    return { width: s, numOfSpaces: 0 };
  }
  _setGraphemeOnPath(e, t) {
    const n = e + t.kernedWidth / 2, s = this.path, i = sx(s.path, n, s.segmentsInfo);
    t.renderLeft = i.x - s.pathOffset.x, t.renderTop = i.y - s.pathOffset.y, t.angle = i.angle + (this.pathSide === Rt ? Math.PI : 0);
  }
  _getGraphemeBox(e, t, n, s, i) {
    const a = this.getCompleteStyleDeclaration(t, n), c = s ? this.getCompleteStyleDeclaration(t, n - 1) : {}, u = this._measureChar(e, a, s, c);
    let h, d = u.kernedWidth, p = u.width;
    this.charSpacing !== 0 && (h = this._getWidthOfCharSpacing(), p += h, d += h);
    const g = { width: p, left: 0, height: a.fontSize, kernedWidth: d, deltaY: a.deltaY };
    if (n > 0 && !i) {
      const v = this.__charBounds[t][n - 1];
      g.left = v.left + v.width + u.kernedWidth - u.width;
    }
    return g;
  }
  getHeightOfLine(e) {
    if (this.__lineHeights[e]) return this.__lineHeights[e];
    let t = this.getHeightOfChar(e, 0);
    for (let n = 1, s = this._textLines[e].length; n < s; n++) t = Math.max(this.getHeightOfChar(e, n), t);
    return this.__lineHeights[e] = t * this.lineHeight * this._fontSizeMult;
  }
  calcTextHeight() {
    let e, t = 0;
    for (let n = 0, s = this._textLines.length; n < s; n++) e = this.getHeightOfLine(n), t += n === s - 1 ? e / this.lineHeight : e;
    return t;
  }
  _getLeftOffset() {
    return this.direction === "ltr" ? -this.width / 2 : this.width / 2;
  }
  _getTopOffset() {
    return -this.height / 2;
  }
  _renderTextCommon(e, t) {
    e.save();
    let n = 0;
    const s = this._getLeftOffset(), i = this._getTopOffset();
    for (let a = 0, c = this._textLines.length; a < c; a++) {
      const u = this.getHeightOfLine(a), h = u / this.lineHeight, d = this._getLineLeftOffset(a);
      this._renderTextLine(t, e, this._textLines[a], s + d, i + n + h, a), n += u;
    }
    e.restore();
  }
  _renderTextFill(e) {
    (this.fill || this.styleHas(Xt)) && this._renderTextCommon(e, "fillText");
  }
  _renderTextStroke(e) {
    (this.stroke && this.strokeWidth !== 0 || !this.isEmptyStyles()) && (this.shadow && !this.shadow.affectStroke && this._removeShadow(e), e.save(), this._setLineDash(e, this.strokeDashArray), e.beginPath(), this._renderTextCommon(e, "strokeText"), e.closePath(), e.restore());
  }
  _renderChars(e, t, n, s, i, a) {
    const c = this.getHeightOfLine(a), u = this.textAlign.includes(An), h = this.path, d = !u && this.charSpacing === 0 && this.isEmptyStyles(a) && !h, p = this.direction === "ltr", g = this.direction === "ltr" ? 1 : -1, v = t.direction;
    let b, _, C, T, k, M = "", A = 0;
    if (t.save(), v !== this.direction && (t.canvas.setAttribute("dir", p ? "ltr" : "rtl"), t.direction = p ? "ltr" : "rtl", t.textAlign = p ? at : Rt), i -= c * this._fontSizeFraction / this.lineHeight, d) return this._renderChar(e, t, a, 0, n.join(""), s, i), void t.restore();
    for (let D = 0, F = n.length - 1; D <= F; D++) T = D === F || this.charSpacing || h, M += n[D], C = this.__charBounds[a][D], A === 0 ? (s += g * (C.kernedWidth - C.width), A += C.width) : A += C.kernedWidth, u && !T && this._reSpaceAndTab.test(n[D]) && (T = !0), T || (b = b || this.getCompleteStyleDeclaration(a, D), _ = this.getCompleteStyleDeclaration(a, D + 1), T = Tu(b, _, !1)), T && (h ? (t.save(), t.translate(C.renderLeft, C.renderTop), t.rotate(C.angle), this._renderChar(e, t, a, D, M, -A / 2, 0), t.restore()) : (k = s, this._renderChar(e, t, a, D, M, k, i)), M = "", b = _, s += g * A, A = 0);
    t.restore();
  }
  _applyPatternGradientTransformText(e) {
    const t = this.width + this.strokeWidth, n = this.height + this.strokeWidth, s = _n({ width: t, height: n }), i = s.getContext("2d");
    return s.width = t, s.height = n, i.beginPath(), i.moveTo(0, 0), i.lineTo(t, 0), i.lineTo(t, n), i.lineTo(0, n), i.closePath(), i.translate(t / 2, n / 2), i.fillStyle = e.toLive(i), this._applyPatternGradientTransform(i, e), i.fill(), i.createPattern(s, "no-repeat");
  }
  handleFiller(e, t, n) {
    let s, i;
    return on(n) ? n.gradientUnits === "percentage" || n.gradientTransform || n.patternTransform ? (s = -this.width / 2, i = -this.height / 2, e.translate(s, i), e[t] = this._applyPatternGradientTransformText(n), { offsetX: s, offsetY: i }) : (e[t] = n.toLive(e), this._applyPatternGradientTransform(e, n)) : (e[t] = n, { offsetX: 0, offsetY: 0 });
  }
  _setStrokeStyles(e, t) {
    let { stroke: n, strokeWidth: s } = t;
    return e.lineWidth = s, e.lineCap = this.strokeLineCap, e.lineDashOffset = this.strokeDashOffset, e.lineJoin = this.strokeLineJoin, e.miterLimit = this.strokeMiterLimit, this.handleFiller(e, "strokeStyle", n);
  }
  _setFillStyles(e, t) {
    let { fill: n } = t;
    return this.handleFiller(e, "fillStyle", n);
  }
  _renderChar(e, t, n, s, i, a, c) {
    const u = this._getStyleDeclaration(n, s), h = this.getCompleteStyleDeclaration(n, s), d = e === "fillText" && h.fill, p = e === "strokeText" && h.stroke && h.strokeWidth;
    if (p || d) {
      if (t.save(), t.font = this._getFontDeclaration(h), u.textBackgroundColor && this._removeShadow(t), u.deltaY && (c += u.deltaY), d) {
        const g = this._setFillStyles(t, h);
        t.fillText(i, a - g.offsetX, c - g.offsetY);
      }
      if (p) {
        const g = this._setStrokeStyles(t, h);
        t.strokeText(i, a - g.offsetX, c - g.offsetY);
      }
      t.restore();
    }
  }
  setSuperscript(e, t) {
    this._setScript(e, t, this.superscript);
  }
  setSubscript(e, t) {
    this._setScript(e, t, this.subscript);
  }
  _setScript(e, t, n) {
    const s = this.get2DCursorLocation(e, !0), i = this.getValueOfPropertyAt(s.lineIndex, s.charIndex, "fontSize"), a = this.getValueOfPropertyAt(s.lineIndex, s.charIndex, "deltaY"), c = { fontSize: i * n.size, deltaY: a + i * n.baseline };
    this.setSelectionStyles(c, e, t);
  }
  _getLineLeftOffset(e) {
    const t = this.getLineWidth(e), n = this.width - t, s = this.textAlign, i = this.direction, a = this.isEndOfWrapping(e);
    let c = 0;
    return s === An || s === ya && !a || s === va && !a || s === Nl && !a ? 0 : (s === Be && (c = n / 2), s === Rt && (c = n), s === ya && (c = n / 2), s === va && (c = n), i === "rtl" && (s === Rt || s === An || s === va ? c = 0 : s === at || s === Nl ? c = -n : s !== Be && s !== ya || (c = -n / 2)), c);
  }
  _clearCache() {
    this._forceClearCache = !1, this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [];
  }
  getLineWidth(e) {
    if (this.__lineWidths[e] !== void 0) return this.__lineWidths[e];
    const { width: t } = this.measureLine(e);
    return this.__lineWidths[e] = t, t;
  }
  _getWidthOfCharSpacing() {
    return this.charSpacing !== 0 ? this.fontSize * this.charSpacing / 1e3 : 0;
  }
  getValueOfPropertyAt(e, t, n) {
    var s;
    return (s = this._getStyleDeclaration(e, t)[n]) !== null && s !== void 0 ? s : this[n];
  }
  _renderTextDecoration(e, t) {
    if (!this[t] && !this.styleHas(t)) return;
    let n = this._getTopOffset();
    const s = this._getLeftOffset(), i = this.path, a = this._getWidthOfCharSpacing(), c = this.offsets[t];
    for (let u = 0, h = this._textLines.length; u < h; u++) {
      const d = this.getHeightOfLine(u);
      if (!this[t] && !this.styleHas(t, u)) {
        n += d;
        continue;
      }
      const p = this._textLines[u], g = d / this.lineHeight, v = this._getLineLeftOffset(u);
      let b, _, C = 0, T = 0, k = this.getValueOfPropertyAt(u, 0, t), M = this.getValueOfPropertyAt(u, 0, Xt);
      const A = n + g * (1 - this._fontSizeFraction);
      let D = this.getHeightOfChar(u, 0), F = this.getValueOfPropertyAt(u, 0, "deltaY");
      for (let B = 0, X = p.length; B < X; B++) {
        const Y = this.__charBounds[u][B];
        b = this.getValueOfPropertyAt(u, B, t), _ = this.getValueOfPropertyAt(u, B, Xt);
        const Z = this.getHeightOfChar(u, B), G = this.getValueOfPropertyAt(u, B, "deltaY");
        if (i && b && _) e.save(), e.fillStyle = M, e.translate(Y.renderLeft, Y.renderTop), e.rotate(Y.angle), e.fillRect(-Y.kernedWidth / 2, c * Z + G, Y.kernedWidth, this.fontSize / 15), e.restore();
        else if ((b !== k || _ !== M || Z !== D || G !== F) && T > 0) {
          let K = s + v + C;
          this.direction === "rtl" && (K = this.width - K - T), k && M && (e.fillStyle = M, e.fillRect(K, A + c * D + F, T, this.fontSize / 15)), C = Y.left, T = Y.width, k = b, M = _, D = Z, F = G;
        } else T += Y.kernedWidth;
      }
      let U = s + v + C;
      this.direction === "rtl" && (U = this.width - U - T), e.fillStyle = _, b && _ && e.fillRect(U, A + c * D + F, T - a, this.fontSize / 15), n += d;
    }
    this._removeShadow(e);
  }
  _getFontDeclaration() {
    let { fontFamily: e = this.fontFamily, fontStyle: t = this.fontStyle, fontWeight: n = this.fontWeight, fontSize: s = this.fontSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, i = arguments.length > 1 ? arguments[1] : void 0;
    const a = e.includes("'") || e.includes('"') || e.includes(",") || yr.genericFonts.includes(e.toLowerCase()) ? e : '"'.concat(e, '"');
    return [t, n, "".concat(i ? this.CACHE_FONT_SIZE : s, "px"), a].join(" ");
  }
  render(e) {
    this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._forceClearCache && this.initDimensions(), super.render(e)));
  }
  graphemeSplit(e) {
    return Cu(e);
  }
  _splitTextIntoLines(e) {
    const t = e.split(this._reNewline), n = new Array(t.length), s = [`
`];
    let i = [];
    for (let a = 0; a < t.length; a++) n[a] = this.graphemeSplit(t[a]), i = i.concat(n[a], s);
    return i.pop(), { _unwrappedLines: n, lines: t, graphemeText: i, graphemeLines: n };
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return L(L({}, super.toObject([...bx, ...e])), {}, { styles: Yw(this.styles, this.text) }, this.path ? { path: this.path.toObject() } : {});
  }
  set(e, t) {
    const { textLayoutProperties: n } = this.constructor;
    super.set(e, t);
    let s = !1, i = !1;
    if (typeof e == "object") for (const a in e) a === "path" && this.setPathInfo(), s = s || n.includes(a), i = i || a === "path";
    else s = n.includes(e), i = e === "path";
    return i && this.setPathInfo(), s && this.initialized && (this.initDimensions(), this.setCoords()), this;
  }
  complexity() {
    return 1;
  }
  static async fromElement(e, t, n) {
    const s = cs(e, yr.ATTRIBUTE_NAMES, n), i = L(L({}, t), s), { textAnchor: a = at, textDecoration: c = "", dx: u = 0, dy: h = 0, top: d = 0, left: p = 0, fontSize: g = up, strokeWidth: v = 1 } = i, b = yt(i, _4), _ = new this((e.textContent || "").replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " "), L({ left: p + u, top: d + h, underline: c.includes("underline"), overline: c.includes("overline"), linethrough: c.includes("line-through"), strokeWidth: 0, fontSize: g }, b)), C = _.getScaledHeight() / _.height, T = ((_.height + _.strokeWidth) * _.lineHeight - _.height) * C, k = _.getScaledHeight() + T;
    let M = 0;
    return a === Be && (M = _.getScaledWidth() / 2), a === Rt && (M = _.getScaledWidth()), _.set({ left: _.left - M, top: _.top - (k - _.fontSize * (0.07 + _._fontSizeFraction)) / _.lineHeight, strokeWidth: v }), _;
  }
  static fromObject(e) {
    return this._fromObject(L(L({}, e), {}, { styles: Xw(e.styles || {}, e.text) }), { extraParam: "text" });
  }
}
N(yr, "textLayoutProperties", yx), N(yr, "cacheProperties", [...as, ...bx]), N(yr, "ownDefaults", b4), N(yr, "type", "Text"), N(yr, "genericFonts", ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]), N(yr, "ATTRIBUTE_NAMES", Bs.concat("x", "y", "dx", "dy", "font-family", "font-style", "font-weight", "font-size", "letter-spacing", "text-decoration", "text-anchor")), zw(yr, [class extends xw {
  _toSVG() {
    const r = this._getSVGLeftTopOffsets(), e = this._getSVGTextAndBg(r.textTop, r.textLeft);
    return this._wrapSVGTextAndBg(e);
  }
  toSVG(r) {
    return this._createBaseSVGMarkup(this._toSVG(), { reviver: r, noStyle: !0, withShadow: !0 });
  }
  _getSVGLeftTopOffsets() {
    return { textLeft: -this.width / 2, textTop: -this.height / 2, lineTop: this.getHeightOfLine(0) };
  }
  _wrapSVGTextAndBg(r) {
    let { textBgRects: e, textSpans: t } = r;
    const n = this.getSvgTextDecoration(this);
    return [e.join(""), '		<text xml:space="preserve" ', this.fontFamily ? 'font-family="'.concat(this.fontFamily.replace(x4, "'"), '" ') : "", this.fontSize ? 'font-size="'.concat(this.fontSize, '" ') : "", this.fontStyle ? 'font-style="'.concat(this.fontStyle, '" ') : "", this.fontWeight ? 'font-weight="'.concat(this.fontWeight, '" ') : "", n ? 'text-decoration="'.concat(n, '" ') : "", this.direction === "rtl" ? 'direction="'.concat(this.direction, '" ') : "", 'style="', this.getSvgStyles(!0), '"', this.addPaintOrder(), " >", t.join(""), `</text>
`];
  }
  _getSVGTextAndBg(r, e) {
    const t = [], n = [];
    let s, i = r;
    this.backgroundColor && n.push(...ud(this.backgroundColor, -this.width / 2, -this.height / 2, this.width, this.height));
    for (let a = 0, c = this._textLines.length; a < c; a++) s = this._getLineLeftOffset(a), this.direction === "rtl" && (s += this.width), (this.textBackgroundColor || this.styleHas("textBackgroundColor", a)) && this._setSVGTextLineBg(n, a, e + s, i), this._setSVGTextLineText(t, a, e + s, i), i += this.getHeightOfLine(a);
    return { textSpans: t, textBgRects: n };
  }
  _createTextCharSpan(r, e, t, n) {
    const s = this.getSvgSpanStyles(e, r !== r.trim() || !!r.match(w4)), i = s ? 'style="'.concat(s, '"') : "", a = e.deltaY, c = a ? ' dy="'.concat(vt(a, et.NUM_FRACTION_DIGITS), '" ') : "";
    return '<tspan x="'.concat(vt(t, et.NUM_FRACTION_DIGITS), '" y="').concat(vt(n, et.NUM_FRACTION_DIGITS), '" ').concat(c).concat(i, ">").concat($w(r), "</tspan>");
  }
  _setSVGTextLineText(r, e, t, n) {
    const s = this.getHeightOfLine(e), i = this.textAlign.includes(An), a = this._textLines[e];
    let c, u, h, d, p, g = "", v = 0;
    n += s * (1 - this._fontSizeFraction) / this.lineHeight;
    for (let b = 0, _ = a.length - 1; b <= _; b++) p = b === _ || this.charSpacing, g += a[b], h = this.__charBounds[e][b], v === 0 ? (t += h.kernedWidth - h.width, v += h.width) : v += h.kernedWidth, i && !p && this._reSpaceAndTab.test(a[b]) && (p = !0), p || (c = c || this.getCompleteStyleDeclaration(e, b), u = this.getCompleteStyleDeclaration(e, b + 1), p = Tu(c, u, !0)), p && (d = this._getStyleDeclaration(e, b), r.push(this._createTextCharSpan(g, d, t, n)), g = "", c = u, this.direction === "rtl" ? t -= v : t += v, v = 0);
  }
  _setSVGTextLineBg(r, e, t, n) {
    const s = this._textLines[e], i = this.getHeightOfLine(e) / this.lineHeight;
    let a, c = 0, u = 0, h = this.getValueOfPropertyAt(e, 0, "textBackgroundColor");
    for (let d = 0; d < s.length; d++) {
      const { left: p, width: g, kernedWidth: v } = this.__charBounds[e][d];
      a = this.getValueOfPropertyAt(e, d, "textBackgroundColor"), a !== h ? (h && r.push(...ud(h, t + u, n, c, i)), u = p, c = g, h = a) : c += v;
    }
    a && r.push(...ud(h, t + u, n, c, i));
  }
  _getSVGLineTopOffset(r) {
    let e, t = 0;
    for (e = 0; e < r; e++) t += this.getHeightOfLine(e);
    const n = this.getHeightOfLine(e);
    return { lineTop: t, offset: (this._fontSizeMult - this._fontSizeFraction) * n / (this.lineHeight * this._fontSizeMult) };
  }
  getSvgStyles(r) {
    return "".concat(super.getSvgStyles(r), " white-space: pre;");
  }
  getSvgSpanStyles(r, e) {
    const { fontFamily: t, strokeWidth: n, stroke: s, fill: i, fontSize: a, fontStyle: c, fontWeight: u, deltaY: h } = r, d = this.getSvgTextDecoration(r);
    return [s ? Ta(Rr, s) : "", n ? "stroke-width: ".concat(n, "; ") : "", t ? "font-family: ".concat(t.includes("'") || t.includes('"') ? t : "'".concat(t, "'"), "; ") : "", a ? "font-size: ".concat(a, "px; ") : "", c ? "font-style: ".concat(c, "; ") : "", u ? "font-weight: ".concat(u, "; ") : "", d && "text-decoration: ".concat(d, "; "), i ? Ta(Xt, i) : "", h ? "baseline-shift: ".concat(-h, "; ") : "", e ? "white-space: pre; " : ""].join("");
  }
  getSvgTextDecoration(r) {
    return ["overline", "underline", "line-through"].filter((e) => r[e.replace("-", "")]).join(" ");
  }
}]), le.setClass(yr), le.setSVGClass(yr);
class S4 {
  constructor(e) {
    N(this, "target", void 0), N(this, "__mouseDownInPlace", !1), N(this, "__dragStartFired", !1), N(this, "__isDraggingOver", !1), N(this, "__dragStartSelection", void 0), N(this, "__dragImageDisposer", void 0), N(this, "_dispose", void 0), this.target = e;
    const t = [this.target.on("dragenter", this.dragEnterHandler.bind(this)), this.target.on("dragover", this.dragOverHandler.bind(this)), this.target.on("dragleave", this.dragLeaveHandler.bind(this)), this.target.on("dragend", this.dragEndHandler.bind(this)), this.target.on("drop", this.dropHandler.bind(this))];
    this._dispose = () => {
      t.forEach((n) => n()), this._dispose = void 0;
    };
  }
  isPointerOverSelection(e) {
    const t = this.target, n = t.getSelectionStartFromPointer(e);
    return t.isEditing && n >= t.selectionStart && n <= t.selectionEnd && t.selectionStart < t.selectionEnd;
  }
  start(e) {
    return this.__mouseDownInPlace = this.isPointerOverSelection(e);
  }
  isActive() {
    return this.__mouseDownInPlace;
  }
  end(e) {
    const t = this.isActive();
    return t && !this.__dragStartFired && (this.target.setCursorByClick(e), this.target.initDelayedCursor(!0)), this.__mouseDownInPlace = !1, this.__dragStartFired = !1, this.__isDraggingOver = !1, t;
  }
  getDragStartSelection() {
    return this.__dragStartSelection;
  }
  setDragImage(e, t) {
    var n;
    let { selectionStart: s, selectionEnd: i } = t;
    const a = this.target, c = a.canvas, u = new $(a.flipX ? -1 : 1, a.flipY ? -1 : 1), h = a._getCursorBoundaries(s), d = new $(h.left + h.leftOffset, h.top + h.topOffset).multiply(u).transform(a.calcTransformMatrix()), p = c.getScenePoint(e).subtract(d), g = a.getCanvasRetinaScaling(), v = a.getBoundingRect(), b = d.subtract(new $(v.left, v.top)), _ = c.viewportTransform, C = b.add(p).transform(_, !0), T = a.backgroundColor, k = kp(a.styles);
    a.backgroundColor = "";
    const M = { stroke: "transparent", fill: "transparent", textBackgroundColor: "transparent" };
    a.setSelectionStyles(M, 0, s), a.setSelectionStyles(M, i, a.text.length), a.dirty = !0;
    const A = a.toCanvasElement({ enableRetinaScaling: c.enableRetinaScaling, viewportTransform: !0 });
    a.backgroundColor = T, a.styles = k, a.dirty = !0, Fl(A, { position: "fixed", left: "".concat(-A.width, "px"), border: Dr, width: "".concat(A.width / g, "px"), height: "".concat(A.height / g, "px") }), this.__dragImageDisposer && this.__dragImageDisposer(), this.__dragImageDisposer = () => {
      A.remove();
    }, vn(e.target || this.target.hiddenTextarea).body.appendChild(A), (n = e.dataTransfer) === null || n === void 0 || n.setDragImage(A, C.x, C.y);
  }
  onDragStart(e) {
    this.__dragStartFired = !0;
    const t = this.target, n = this.isActive();
    if (n && e.dataTransfer) {
      const s = this.__dragStartSelection = { selectionStart: t.selectionStart, selectionEnd: t.selectionEnd }, i = t._text.slice(s.selectionStart, s.selectionEnd).join(""), a = L({ text: t.text, value: i }, s);
      e.dataTransfer.setData("text/plain", i), e.dataTransfer.setData("application/fabric", JSON.stringify({ value: i, styles: t.getSelectionStyles(s.selectionStart, s.selectionEnd, !0) })), e.dataTransfer.effectAllowed = "copyMove", this.setDragImage(e, a);
    }
    return t.abortCursorAnimation(), n;
  }
  canDrop(e) {
    if (this.target.editable && !this.target.getActiveControl() && !e.defaultPrevented) {
      if (this.isActive() && this.__dragStartSelection) {
        const t = this.target.getSelectionStartFromPointer(e), n = this.__dragStartSelection;
        return t < n.selectionStart || t > n.selectionEnd;
      }
      return !0;
    }
    return !1;
  }
  targetCanDrop(e) {
    return this.target.canDrop(e);
  }
  dragEnterHandler(e) {
    let { e: t } = e;
    const n = this.targetCanDrop(t);
    !this.__isDraggingOver && n && (this.__isDraggingOver = !0);
  }
  dragOverHandler(e) {
    const { e: t } = e, n = this.targetCanDrop(t);
    !this.__isDraggingOver && n ? this.__isDraggingOver = !0 : this.__isDraggingOver && !n && (this.__isDraggingOver = !1), this.__isDraggingOver && (t.preventDefault(), e.canDrop = !0, e.dropTarget = this.target);
  }
  dragLeaveHandler() {
    (this.__isDraggingOver || this.isActive()) && (this.__isDraggingOver = !1);
  }
  dropHandler(e) {
    var t;
    const { e: n } = e, s = n.defaultPrevented;
    this.__isDraggingOver = !1, n.preventDefault();
    let i = (t = n.dataTransfer) === null || t === void 0 ? void 0 : t.getData("text/plain");
    if (i && !s) {
      const a = this.target, c = a.canvas;
      let u = a.getSelectionStartFromPointer(n);
      const { styles: h } = n.dataTransfer.types.includes("application/fabric") ? JSON.parse(n.dataTransfer.getData("application/fabric")) : {}, d = i[Math.max(0, i.length - 1)], p = 0;
      if (this.__dragStartSelection) {
        const g = this.__dragStartSelection.selectionStart, v = this.__dragStartSelection.selectionEnd;
        u > g && u <= v ? u = g : u > v && (u -= v - g), a.removeChars(g, v), delete this.__dragStartSelection;
      }
      a._reNewline.test(d) && (a._reNewline.test(a._text[u]) || u === a._text.length) && (i = i.trimEnd()), e.didDrop = !0, e.dropTarget = a, a.insertChars(i, h, u), c.setActiveObject(a), a.enterEditing(n), a.selectionStart = Math.min(u + p, a._text.length), a.selectionEnd = Math.min(a.selectionStart + i.length, a._text.length), a.hiddenTextarea.value = a.text, a._updateTextarea(), a.hiddenTextarea.focus(), a.fire(El, { index: u + p, action: "drop" }), c.fire("text:changed", { target: a }), c.contextTopDirty = !0, c.requestRenderAll();
    }
  }
  dragEndHandler(e) {
    let { e: t } = e;
    if (this.isActive() && this.__dragStartFired && this.__dragStartSelection) {
      var n;
      const s = this.target, i = this.target.canvas, { selectionStart: a, selectionEnd: c } = this.__dragStartSelection, u = ((n = t.dataTransfer) === null || n === void 0 ? void 0 : n.dropEffect) || Dr;
      u === Dr ? (s.selectionStart = a, s.selectionEnd = c, s._updateTextarea(), s.hiddenTextarea.focus()) : (s.clearContextTop(), u === "move" && (s.removeChars(a, c), s.selectionStart = s.selectionEnd = a, s.hiddenTextarea && (s.hiddenTextarea.value = s.text), s._updateTextarea(), s.fire(El, { index: a, action: "dragend" }), i.fire("text:changed", { target: s }), i.requestRenderAll()), s.exitEditing());
    }
    this.__dragImageDisposer && this.__dragImageDisposer(), delete this.__dragImageDisposer, delete this.__dragStartSelection, this.__isDraggingOver = !1;
  }
  dispose() {
    this._dispose && this._dispose();
  }
}
const X0 = /[ \n\.,;!\?\-]/;
class C4 extends yr {
  constructor() {
    super(...arguments), N(this, "_currentCursorOpacity", 1);
  }
  initBehavior() {
    this._tick = this._tick.bind(this), this._onTickComplete = this._onTickComplete.bind(this), this.updateSelectionOnMouseMove = this.updateSelectionOnMouseMove.bind(this);
  }
  onDeselect(e) {
    return this.isEditing && this.exitEditing(), this.selected = !1, super.onDeselect(e);
  }
  _animateCursor(e) {
    let { toValue: t, duration: n, delay: s, onComplete: i } = e;
    return Cp({ startValue: this._currentCursorOpacity, endValue: t, duration: n, delay: s, onComplete: i, abort: () => !this.canvas || this.selectionStart !== this.selectionEnd, onChange: (a) => {
      this._currentCursorOpacity = a, this.renderCursorOrSelection();
    } });
  }
  _tick(e) {
    this._currentTickState = this._animateCursor({ toValue: 0, duration: this.cursorDuration / 2, delay: Math.max(e || 0, 100), onComplete: this._onTickComplete });
  }
  _onTickComplete() {
    var e;
    (e = this._currentTickCompleteState) === null || e === void 0 || e.abort(), this._currentTickCompleteState = this._animateCursor({ toValue: 1, duration: this.cursorDuration, onComplete: this._tick });
  }
  initDelayedCursor(e) {
    this.abortCursorAnimation(), this._tick(e ? 0 : this.cursorDelay);
  }
  abortCursorAnimation() {
    let e = !1;
    [this._currentTickState, this._currentTickCompleteState].forEach((t) => {
      t && !t.isDone() && (e = !0, t.abort());
    }), this._currentCursorOpacity = 1, e && this.clearContextTop();
  }
  restartCursorIfNeeded() {
    [this._currentTickState, this._currentTickCompleteState].some((e) => !e || e.isDone()) && this.initDelayedCursor();
  }
  selectAll() {
    return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this;
  }
  getSelectedText() {
    return this._text.slice(this.selectionStart, this.selectionEnd).join("");
  }
  findWordBoundaryLeft(e) {
    let t = 0, n = e - 1;
    if (this._reSpace.test(this._text[n])) for (; this._reSpace.test(this._text[n]); ) t++, n--;
    for (; /\S/.test(this._text[n]) && n > -1; ) t++, n--;
    return e - t;
  }
  findWordBoundaryRight(e) {
    let t = 0, n = e;
    if (this._reSpace.test(this._text[n])) for (; this._reSpace.test(this._text[n]); ) t++, n++;
    for (; /\S/.test(this._text[n]) && n < this._text.length; ) t++, n++;
    return e + t;
  }
  findLineBoundaryLeft(e) {
    let t = 0, n = e - 1;
    for (; !/\n/.test(this._text[n]) && n > -1; ) t++, n--;
    return e - t;
  }
  findLineBoundaryRight(e) {
    let t = 0, n = e;
    for (; !/\n/.test(this._text[n]) && n < this._text.length; ) t++, n++;
    return e + t;
  }
  searchWordBoundary(e, t) {
    const n = this._text;
    let s = e > 0 && this._reSpace.test(n[e]) && (t === -1 || !hp.test(n[e - 1])) ? e - 1 : e, i = n[s];
    for (; s > 0 && s < n.length && !X0.test(i); ) s += t, i = n[s];
    return t === -1 && X0.test(i) && s++, s;
  }
  selectWord(e) {
    e = e || this.selectionStart;
    const t = this.searchWordBoundary(e, -1), n = Math.max(t, this.searchWordBoundary(e, 1));
    this.selectionStart = t, this.selectionEnd = n, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection();
  }
  selectLine(e) {
    e = e || this.selectionStart;
    const t = this.findLineBoundaryLeft(e), n = this.findLineBoundaryRight(e);
    return this.selectionStart = t, this.selectionEnd = n, this._fireSelectionChanged(), this._updateTextarea(), this;
  }
  enterEditing(e) {
    !this.isEditing && this.editable && (this.enterEditingImpl(), this.fire("editing:entered", e ? { e } : void 0), this._fireSelectionChanged(), this.canvas && (this.canvas.fire("text:editing:entered", { target: this, e }), this.canvas.requestRenderAll()));
  }
  enterEditingImpl() {
    this.canvas && (this.canvas.calcOffset(), this.canvas.textEditingManager.exitTextEditing()), this.isEditing = !0, this.initHiddenTextarea(), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick();
  }
  updateSelectionOnMouseMove(e) {
    if (this.getActiveControl()) return;
    const t = this.hiddenTextarea;
    vn(t).activeElement !== t && t.focus();
    const n = this.getSelectionStartFromPointer(e), s = this.selectionStart, i = this.selectionEnd;
    (n === this.__selectionStartOnMouseDown && s !== i || s !== n && i !== n) && (n > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = n) : (this.selectionStart = n, this.selectionEnd = this.__selectionStartOnMouseDown), this.selectionStart === s && this.selectionEnd === i || (this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()));
  }
  _setEditingProps() {
    this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0;
  }
  fromStringToGraphemeSelection(e, t, n) {
    const s = n.slice(0, e), i = this.graphemeSplit(s).length;
    if (e === t) return { selectionStart: i, selectionEnd: i };
    const a = n.slice(e, t);
    return { selectionStart: i, selectionEnd: i + this.graphemeSplit(a).length };
  }
  fromGraphemeToStringSelection(e, t, n) {
    const s = n.slice(0, e).join("").length;
    return e === t ? { selectionStart: s, selectionEnd: s } : { selectionStart: s, selectionEnd: s + n.slice(e, t).join("").length };
  }
  _updateTextarea() {
    if (this.cursorOffsetCache = {}, this.hiddenTextarea) {
      if (!this.inCompositionMode) {
        const e = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
        this.hiddenTextarea.selectionStart = e.selectionStart, this.hiddenTextarea.selectionEnd = e.selectionEnd;
      }
      this.updateTextareaPosition();
    }
  }
  updateFromTextArea() {
    if (!this.hiddenTextarea) return;
    this.cursorOffsetCache = {};
    const e = this.hiddenTextarea;
    this.text = e.value, this.set("dirty", !0), this.initDimensions(), this.setCoords();
    const t = this.fromStringToGraphemeSelection(e.selectionStart, e.selectionEnd, e.value);
    this.selectionEnd = this.selectionStart = t.selectionEnd, this.inCompositionMode || (this.selectionStart = t.selectionStart), this.updateTextareaPosition();
  }
  updateTextareaPosition() {
    if (this.selectionStart === this.selectionEnd) {
      const e = this._calcTextareaPosition();
      this.hiddenTextarea.style.left = e.left, this.hiddenTextarea.style.top = e.top;
    }
  }
  _calcTextareaPosition() {
    if (!this.canvas) return { left: "1px", top: "1px" };
    const e = this.inCompositionMode ? this.compositionStart : this.selectionStart, t = this._getCursorBoundaries(e), n = this.get2DCursorLocation(e), s = n.lineIndex, i = n.charIndex, a = this.getValueOfPropertyAt(s, i, "fontSize") * this.lineHeight, c = t.leftOffset, u = this.getCanvasRetinaScaling(), h = this.canvas.upperCanvasEl, d = h.width / u, p = h.height / u, g = d - a, v = p - a, b = new $(t.left + c, t.top + t.topOffset + a).transform(this.calcTransformMatrix()).transform(this.canvas.viewportTransform).multiply(new $(h.clientWidth / d, h.clientHeight / p));
    return b.x < 0 && (b.x = 0), b.x > g && (b.x = g), b.y < 0 && (b.y = 0), b.y > v && (b.y = v), b.x += this.canvas._offset.left, b.y += this.canvas._offset.top, { left: "".concat(b.x, "px"), top: "".concat(b.y, "px"), fontSize: "".concat(a, "px"), charHeight: a };
  }
  _saveEditingProps() {
    this._savedProps = { hasControls: this.hasControls, borderColor: this.borderColor, lockMovementX: this.lockMovementX, lockMovementY: this.lockMovementY, hoverCursor: this.hoverCursor, selectable: this.selectable, defaultCursor: this.canvas && this.canvas.defaultCursor, moveCursor: this.canvas && this.canvas.moveCursor };
  }
  _restoreEditingProps() {
    this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor || this.canvas.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor || this.canvas.moveCursor), delete this._savedProps);
  }
  _exitEditing() {
    const e = this.hiddenTextarea;
    this.selected = !1, this.isEditing = !1, e && (e.blur && e.blur(), e.parentNode && e.parentNode.removeChild(e)), this.hiddenTextarea = null, this.abortCursorAnimation(), this.selectionStart !== this.selectionEnd && this.clearContextTop();
  }
  exitEditingImpl() {
    this._exitEditing(), this.selectionEnd = this.selectionStart, this._restoreEditingProps(), this._forceClearCache && (this.initDimensions(), this.setCoords());
  }
  exitEditing() {
    const e = this._textBeforeEdit !== this.text;
    return this.exitEditingImpl(), this.fire("editing:exited"), e && this.fire(kl), this.canvas && (this.canvas.fire("text:editing:exited", { target: this }), e && this.canvas.fire("object:modified", { target: this })), this;
  }
  _removeExtraneousStyles() {
    for (const e in this.styles) this._textLines[e] || delete this.styles[e];
  }
  removeStyleFromTo(e, t) {
    const { lineIndex: n, charIndex: s } = this.get2DCursorLocation(e, !0), { lineIndex: i, charIndex: a } = this.get2DCursorLocation(t, !0);
    if (n !== i) {
      if (this.styles[n]) for (let c = s; c < this._unwrappedTextLines[n].length; c++) delete this.styles[n][c];
      if (this.styles[i]) for (let c = a; c < this._unwrappedTextLines[i].length; c++) {
        const u = this.styles[i][c];
        u && (this.styles[n] || (this.styles[n] = {}), this.styles[n][s + c - a] = u);
      }
      for (let c = n + 1; c <= i; c++) delete this.styles[c];
      this.shiftLineStyles(i, n - i);
    } else if (this.styles[n]) {
      const c = this.styles[n], u = a - s;
      for (let h = s; h < a; h++) delete c[h];
      for (const h in this.styles[n]) {
        const d = parseInt(h, 10);
        d >= a && (c[d - u] = c[h], delete c[h]);
      }
    }
  }
  shiftLineStyles(e, t) {
    const n = Object.assign({}, this.styles);
    for (const s in this.styles) {
      const i = parseInt(s, 10);
      i > e && (this.styles[i + t] = n[i], n[i - t] || delete this.styles[i]);
    }
  }
  insertNewlineStyleObject(e, t, n, s) {
    const i = {}, a = this._unwrappedTextLines[e].length, c = a === t;
    let u = !1;
    n || (n = 1), this.shiftLineStyles(e, n);
    const h = this.styles[e] ? this.styles[e][t === 0 ? t : t - 1] : void 0;
    for (const p in this.styles[e]) {
      const g = parseInt(p, 10);
      g >= t && (u = !0, i[g - t] = this.styles[e][p], c && t === 0 || delete this.styles[e][p]);
    }
    let d = !1;
    for (u && !c && (this.styles[e + n] = i, d = !0), (d || a > t) && n--; n > 0; ) s && s[n - 1] ? this.styles[e + n] = { 0: L({}, s[n - 1]) } : h ? this.styles[e + n] = { 0: L({}, h) } : delete this.styles[e + n], n--;
    this._forceClearCache = !0;
  }
  insertCharStyleObject(e, t, n, s) {
    this.styles || (this.styles = {});
    const i = this.styles[e], a = i ? L({}, i) : {};
    n || (n = 1);
    for (const u in a) {
      const h = parseInt(u, 10);
      h >= t && (i[h + n] = a[h], a[h - n] || delete i[h]);
    }
    if (this._forceClearCache = !0, s) {
      for (; n--; ) Object.keys(s[n]).length && (this.styles[e] || (this.styles[e] = {}), this.styles[e][t + n] = L({}, s[n]));
      return;
    }
    if (!i) return;
    const c = i[t ? t - 1 : 1];
    for (; c && n--; ) this.styles[e][t + n] = L({}, c);
  }
  insertNewStyleBlock(e, t, n) {
    const s = this.get2DCursorLocation(t, !0), i = [0];
    let a, c = 0;
    for (let u = 0; u < e.length; u++) e[u] === `
` ? (c++, i[c] = 0) : i[c]++;
    for (i[0] > 0 && (this.insertCharStyleObject(s.lineIndex, s.charIndex, i[0], n), n = n && n.slice(i[0] + 1)), c && this.insertNewlineStyleObject(s.lineIndex, s.charIndex + i[0], c), a = 1; a < c; a++) i[a] > 0 ? this.insertCharStyleObject(s.lineIndex + a, 0, i[a], n) : n && this.styles[s.lineIndex + a] && n[0] && (this.styles[s.lineIndex + a][0] = n[0]), n = n && n.slice(i[a] + 1);
    i[a] > 0 && this.insertCharStyleObject(s.lineIndex + a, 0, i[a], n);
  }
  removeChars(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e + 1;
    this.removeStyleFromTo(e, t), this._text.splice(e, t - e), this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  insertChars(e, t, n) {
    let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : n;
    s > n && this.removeStyleFromTo(n, s);
    const i = this.graphemeSplit(e);
    this.insertNewStyleBlock(i, n, t), this._text = [...this._text.slice(0, n), ...i, ...this._text.slice(s)], this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  setSelectionStartEndWithShift(e, t, n) {
    n <= e ? (t === e ? this._selectionDirection = at : this._selectionDirection === Rt && (this._selectionDirection = at, this.selectionEnd = e), this.selectionStart = n) : n > e && n < t ? this._selectionDirection === Rt ? this.selectionEnd = n : this.selectionStart = n : (t === e ? this._selectionDirection = Rt : this._selectionDirection === at && (this._selectionDirection = Rt, this.selectionStart = t), this.selectionEnd = n);
  }
}
class T4 extends C4 {
  initHiddenTextarea() {
    const e = this.canvas && vn(this.canvas.getElement()) || Eo(), t = e.createElement("textarea");
    Object.entries({ autocapitalize: "off", autocorrect: "off", autocomplete: "off", spellcheck: "false", "data-fabric": "textarea", wrap: "off" }).map((a) => {
      let [c, u] = a;
      return t.setAttribute(c, u);
    });
    const { top: n, left: s, fontSize: i } = this._calcTextareaPosition();
    t.style.cssText = "position: absolute; top: ".concat(n, "; left: ").concat(s, "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: ").concat(i, ";"), (this.hiddenTextareaContainer || e.body).appendChild(t), Object.entries({ blur: "blur", keydown: "onKeyDown", keyup: "onKeyUp", input: "onInput", copy: "copy", cut: "copy", paste: "paste", compositionstart: "onCompositionStart", compositionupdate: "onCompositionUpdate", compositionend: "onCompositionEnd" }).map((a) => {
      let [c, u] = a;
      return t.addEventListener(c, this[u].bind(this));
    }), this.hiddenTextarea = t;
  }
  blur() {
    this.abortCursorAnimation();
  }
  onKeyDown(e) {
    if (!this.isEditing) return;
    const t = this.direction === "rtl" ? this.keysMapRtl : this.keysMap;
    if (e.keyCode in t) this[t[e.keyCode]](e);
    else {
      if (!(e.keyCode in this.ctrlKeysMapDown) || !e.ctrlKey && !e.metaKey) return;
      this[this.ctrlKeysMapDown[e.keyCode]](e);
    }
    e.stopImmediatePropagation(), e.preventDefault(), e.keyCode >= 33 && e.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll();
  }
  onKeyUp(e) {
    !this.isEditing || this._copyDone || this.inCompositionMode ? this._copyDone = !1 : e.keyCode in this.ctrlKeysMapUp && (e.ctrlKey || e.metaKey) && (this[this.ctrlKeysMapUp[e.keyCode]](e), e.stopImmediatePropagation(), e.preventDefault(), this.canvas && this.canvas.requestRenderAll());
  }
  onInput(e) {
    const t = this.fromPaste;
    if (this.fromPaste = !1, e && e.stopPropagation(), !this.isEditing) return;
    const n = () => {
      this.updateFromTextArea(), this.fire(El), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll());
    };
    if (this.hiddenTextarea.value === "") return this.styles = {}, void n();
    const s = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, i = this._text.length, a = s.length, c = this.selectionStart, u = this.selectionEnd, h = c !== u;
    let d, p, g, v, b = a - i;
    const _ = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value), C = c > _.selectionStart;
    h ? (p = this._text.slice(c, u), b += u - c) : a < i && (p = C ? this._text.slice(u + b, u) : this._text.slice(c, c - b));
    const T = s.slice(_.selectionEnd - b, _.selectionEnd);
    if (p && p.length && (T.length && (d = this.getSelectionStyles(c, c + 1, !1), d = T.map(() => d[0])), h ? (g = c, v = u) : C ? (g = u - p.length, v = u) : (g = u, v = u + p.length), this.removeStyleFromTo(g, v)), T.length) {
      const { copyPasteData: k } = Fn();
      t && T.join("") === k.copiedText && !et.disableStyleCopyPaste && (d = k.copiedTextStyle), this.insertNewStyleBlock(T, c, d);
    }
    n();
  }
  onCompositionStart() {
    this.inCompositionMode = !0;
  }
  onCompositionEnd() {
    this.inCompositionMode = !1;
  }
  onCompositionUpdate(e) {
    let { target: t } = e;
    const { selectionStart: n, selectionEnd: s } = t;
    this.compositionStart = n, this.compositionEnd = s, this.updateTextareaPosition();
  }
  copy() {
    if (this.selectionStart === this.selectionEnd) return;
    const { copyPasteData: e } = Fn();
    e.copiedText = this.getSelectedText(), et.disableStyleCopyPaste ? e.copiedTextStyle = void 0 : e.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0;
  }
  paste() {
    this.fromPaste = !0;
  }
  _getWidthBeforeCursor(e, t) {
    let n, s = this._getLineLeftOffset(e);
    return t > 0 && (n = this.__charBounds[e][t - 1], s += n.left + n.width), s;
  }
  getDownCursorOffset(e, t) {
    const n = this._getSelectionForOffset(e, t), s = this.get2DCursorLocation(n), i = s.lineIndex;
    if (i === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) return this._text.length - n;
    const a = s.charIndex, c = this._getWidthBeforeCursor(i, a), u = this._getIndexOnLine(i + 1, c);
    return this._textLines[i].slice(a).length + u + 1 + this.missingNewlineOffset(i);
  }
  _getSelectionForOffset(e, t) {
    return e.shiftKey && this.selectionStart !== this.selectionEnd && t ? this.selectionEnd : this.selectionStart;
  }
  getUpCursorOffset(e, t) {
    const n = this._getSelectionForOffset(e, t), s = this.get2DCursorLocation(n), i = s.lineIndex;
    if (i === 0 || e.metaKey || e.keyCode === 33) return -n;
    const a = s.charIndex, c = this._getWidthBeforeCursor(i, a), u = this._getIndexOnLine(i - 1, c), h = this._textLines[i].slice(0, a), d = this.missingNewlineOffset(i - 1);
    return -this._textLines[i - 1].length + u - h.length + (1 - d);
  }
  _getIndexOnLine(e, t) {
    const n = this._textLines[e];
    let s, i, a = this._getLineLeftOffset(e), c = 0;
    for (let u = 0, h = n.length; u < h; u++) if (s = this.__charBounds[e][u].width, a += s, a > t) {
      i = !0;
      const d = a - s, p = a, g = Math.abs(d - t);
      c = Math.abs(p - t) < g ? u : u - 1;
      break;
    }
    return i || (c = n.length - 1), c;
  }
  moveCursorDown(e) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", e);
  }
  moveCursorUp(e) {
    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorUpOrDown("Up", e);
  }
  _moveCursorUpOrDown(e, t) {
    const n = this["get".concat(e, "CursorOffset")](t, this._selectionDirection === Rt);
    if (t.shiftKey ? this.moveCursorWithShift(n) : this.moveCursorWithoutShift(n), n !== 0) {
      const s = this.text.length;
      this.selectionStart = gi(0, this.selectionStart, s), this.selectionEnd = gi(0, this.selectionEnd, s), this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea();
    }
  }
  moveCursorWithShift(e) {
    const t = this._selectionDirection === at ? this.selectionStart + e : this.selectionEnd + e;
    return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, t), e !== 0;
  }
  moveCursorWithoutShift(e) {
    return e < 0 ? (this.selectionStart += e, this.selectionEnd = this.selectionStart) : (this.selectionEnd += e, this.selectionStart = this.selectionEnd), e !== 0;
  }
  moveCursorLeft(e) {
    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorLeftOrRight("Left", e);
  }
  _move(e, t, n) {
    let s;
    if (e.altKey) s = this["findWordBoundary".concat(n)](this[t]);
    else {
      if (!e.metaKey && e.keyCode !== 35 && e.keyCode !== 36) return this[t] += n === "Left" ? -1 : 1, !0;
      s = this["findLineBoundary".concat(n)](this[t]);
    }
    return s !== void 0 && this[t] !== s && (this[t] = s, !0);
  }
  _moveLeft(e, t) {
    return this._move(e, t, "Left");
  }
  _moveRight(e, t) {
    return this._move(e, t, "Right");
  }
  moveCursorLeftWithoutShift(e) {
    let t = !0;
    return this._selectionDirection = at, this.selectionEnd === this.selectionStart && this.selectionStart !== 0 && (t = this._moveLeft(e, "selectionStart")), this.selectionEnd = this.selectionStart, t;
  }
  moveCursorLeftWithShift(e) {
    return this._selectionDirection === Rt && this.selectionStart !== this.selectionEnd ? this._moveLeft(e, "selectionEnd") : this.selectionStart !== 0 ? (this._selectionDirection = at, this._moveLeft(e, "selectionStart")) : void 0;
  }
  moveCursorRight(e) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", e);
  }
  _moveCursorLeftOrRight(e, t) {
    const n = "moveCursor".concat(e).concat(t.shiftKey ? "WithShift" : "WithoutShift");
    this._currentCursorOpacity = 1, this[n](t) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());
  }
  moveCursorRightWithShift(e) {
    return this._selectionDirection === at && this.selectionStart !== this.selectionEnd ? this._moveRight(e, "selectionStart") : this.selectionEnd !== this._text.length ? (this._selectionDirection = Rt, this._moveRight(e, "selectionEnd")) : void 0;
  }
  moveCursorRightWithoutShift(e) {
    let t = !0;
    return this._selectionDirection = Rt, this.selectionStart === this.selectionEnd ? (t = this._moveRight(e, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, t;
  }
}
const dd = (r) => !!r.button;
class E4 extends T4 {
  constructor() {
    super(...arguments), N(this, "draggableTextDelegate", void 0);
  }
  initBehavior() {
    this.on("mousedown", this._mouseDownHandler), this.on("mousedown:before", this._mouseDownHandlerBefore), this.on("mouseup", this.mouseUpHandler), this.on("mousedblclick", this.doubleClickHandler), this.on("tripleclick", this.tripleClickHandler), this.__lastClickTime = +/* @__PURE__ */ new Date(), this.__lastLastClickTime = +/* @__PURE__ */ new Date(), this.__lastPointer = {}, this.on("mousedown", this.onMouseDown), this.draggableTextDelegate = new S4(this), super.initBehavior();
  }
  shouldStartDragging() {
    return this.draggableTextDelegate.isActive();
  }
  onDragStart(e) {
    return this.draggableTextDelegate.onDragStart(e);
  }
  canDrop(e) {
    return this.draggableTextDelegate.canDrop(e);
  }
  onMouseDown(e) {
    if (!this.canvas) return;
    this.__newClickTime = +/* @__PURE__ */ new Date();
    const t = e.pointer;
    this.isTripleClick(t) && (this.fire("tripleclick", e), sf(e.e)), this.__lastLastClickTime = this.__lastClickTime, this.__lastClickTime = this.__newClickTime, this.__lastPointer = t, this.__lastSelected = this.selected && !this.getActiveControl();
  }
  isTripleClick(e) {
    return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === e.x && this.__lastPointer.y === e.y;
  }
  doubleClickHandler(e) {
    this.isEditing && this.selectWord(this.getSelectionStartFromPointer(e.e));
  }
  tripleClickHandler(e) {
    this.isEditing && this.selectLine(this.getSelectionStartFromPointer(e.e));
  }
  _mouseDownHandler(e) {
    let { e: t } = e;
    this.canvas && this.editable && !dd(t) && !this.getActiveControl() && (this.draggableTextDelegate.start(t) || (this.canvas.textEditingManager.register(this), this.selected && (this.inCompositionMode = !1, this.setCursorByClick(t)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection())));
  }
  _mouseDownHandlerBefore(e) {
    let { e: t } = e;
    this.canvas && this.editable && !dd(t) && (this.selected = this === this.canvas._activeObject);
  }
  mouseUpHandler(e) {
    let { e: t, transform: n } = e;
    const s = this.draggableTextDelegate.end(t);
    if (this.canvas) {
      this.canvas.textEditingManager.unregister(this);
      const i = this.canvas._activeObject;
      if (i && i !== this) return;
    }
    !this.editable || this.group && !this.group.interactive || n && n.actionPerformed || dd(t) || s || (this.__lastSelected && !this.getActiveControl() ? (this.selected = !1, this.__lastSelected = !1, this.enterEditing(t), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection()) : this.selected = !0);
  }
  setCursorByClick(e) {
    const t = this.getSelectionStartFromPointer(e), n = this.selectionStart, s = this.selectionEnd;
    e.shiftKey ? this.setSelectionStartEndWithShift(n, s, t) : (this.selectionStart = t, this.selectionEnd = t), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea());
  }
  getSelectionStartFromPointer(e) {
    const t = this.canvas.getScenePoint(e).transform(Ur(this.calcTransformMatrix())).add(new $(-this._getLeftOffset(), -this._getTopOffset()));
    let n = 0, s = 0, i = 0;
    for (let h = 0; h < this._textLines.length && n <= t.y; h++) n += this.getHeightOfLine(h), i = h, h > 0 && (s += this._textLines[h - 1].length + this.missingNewlineOffset(h - 1));
    let a = Math.abs(this._getLineLeftOffset(i));
    const c = this._textLines[i].length, u = this.__charBounds[i];
    for (let h = 0; h < c; h++) {
      const d = a + u[h].kernedWidth;
      if (t.x <= d) {
        Math.abs(t.x - d) <= Math.abs(t.x - a) && s++;
        break;
      }
      a = d, s++;
    }
    return Math.min(this.flipX ? c - s : s, this._text.length);
  }
}
const Uc = "moveCursorUp", $c = "moveCursorDown", Yc = "moveCursorLeft", Xc = "moveCursorRight", Gc = "exitEditing", k4 = L({ selectionStart: 0, selectionEnd: 0, selectionColor: "rgba(17,119,255,0.3)", isEditing: !1, editable: !0, editingBorderColor: "rgba(102,153,255,0.25)", cursorWidth: 2, cursorColor: "", cursorDelay: 1e3, cursorDuration: 600, caching: !0, hiddenTextareaContainer: null, keysMap: { 9: Gc, 27: Gc, 33: Uc, 34: $c, 35: Xc, 36: Yc, 37: Yc, 38: Uc, 39: Xc, 40: $c }, keysMapRtl: { 9: Gc, 27: Gc, 33: Uc, 34: $c, 35: Yc, 36: Xc, 37: Xc, 38: Uc, 39: Yc, 40: $c }, ctrlKeysMapDown: { 65: "selectAll" }, ctrlKeysMapUp: { 67: "copy", 88: "cut" } }, { _selectionDirection: null, _reSpace: /\s|\r?\n/, inCompositionMode: !1 });
class rs extends E4 {
  static getDefaults() {
    return L(L({}, super.getDefaults()), rs.ownDefaults);
  }
  get type() {
    const e = super.type;
    return e === "itext" ? "i-text" : e;
  }
  constructor(e, t) {
    super(e, L(L({}, rs.ownDefaults), t)), this.initBehavior();
  }
  _set(e, t) {
    return this.isEditing && this._savedProps && e in this._savedProps ? (this._savedProps[e] = t, this) : (e === "canvas" && (this.canvas instanceof mf && this.canvas.textEditingManager.remove(this), t instanceof mf && t.textEditingManager.add(this)), super._set(e, t));
  }
  setSelectionStart(e) {
    e = Math.max(e, 0), this._updateAndFire("selectionStart", e);
  }
  setSelectionEnd(e) {
    e = Math.min(e, this.text.length), this._updateAndFire("selectionEnd", e);
  }
  _updateAndFire(e, t) {
    this[e] !== t && (this._fireSelectionChanged(), this[e] = t), this._updateTextarea();
  }
  _fireSelectionChanged() {
    this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this });
  }
  initDimensions() {
    this.isEditing && this.initDelayedCursor(), super.initDimensions();
  }
  getSelectionStyles() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart || 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionEnd, n = arguments.length > 2 ? arguments[2] : void 0;
    return super.getSelectionStyles(e, t, n);
  }
  setSelectionStyles(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionStart || 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.selectionEnd;
    return super.setSelectionStyles(e, t, n);
  }
  get2DCursorLocation() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, t = arguments.length > 1 ? arguments[1] : void 0;
    return super.get2DCursorLocation(e, t);
  }
  render(e) {
    super.render(e), this.cursorOffsetCache = {}, this.renderCursorOrSelection();
  }
  toCanvasElement(e) {
    const t = this.isEditing;
    this.isEditing = !1;
    const n = super.toCanvasElement(e);
    return this.isEditing = t, n;
  }
  renderCursorOrSelection() {
    if (!this.isEditing) return;
    const e = this.clearContextTop(!0);
    if (!e) return;
    const t = this._getCursorBoundaries();
    this.selectionStart !== this.selectionEnd || this.inCompositionMode ? this.renderSelection(e, t) : this.renderCursor(e, t), this.canvas.contextTopDirty = !0, e.restore();
  }
  _getCursorBoundaries() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, t = arguments.length > 1 ? arguments[1] : void 0;
    const n = this._getLeftOffset(), s = this._getTopOffset(), i = this._getCursorBoundariesOffsets(e, t);
    return { left: n, top: s, leftOffset: i.left, topOffset: i.top };
  }
  _getCursorBoundariesOffsets(e, t) {
    return t ? this.__getCursorBoundariesOffsets(e) : this.cursorOffsetCache && "top" in this.cursorOffsetCache ? this.cursorOffsetCache : this.cursorOffsetCache = this.__getCursorBoundariesOffsets(e);
  }
  __getCursorBoundariesOffsets(e) {
    let t = 0, n = 0;
    const { charIndex: s, lineIndex: i } = this.get2DCursorLocation(e);
    for (let h = 0; h < i; h++) t += this.getHeightOfLine(h);
    const a = this._getLineLeftOffset(i), c = this.__charBounds[i][s];
    c && (n = c.left), this.charSpacing !== 0 && s === this._textLines[i].length && (n -= this._getWidthOfCharSpacing());
    const u = { top: t, left: a + (n > 0 ? n : 0) };
    return this.direction === "rtl" && (this.textAlign === Rt || this.textAlign === An || this.textAlign === va ? u.left *= -1 : this.textAlign === at || this.textAlign === Nl ? u.left = a - (n > 0 ? n : 0) : this.textAlign !== Be && this.textAlign !== ya || (u.left = a - (n > 0 ? n : 0))), u;
  }
  renderCursorAt(e) {
    this._renderCursor(this.canvas.contextTop, this._getCursorBoundaries(e, !0), e);
  }
  renderCursor(e, t) {
    this._renderCursor(e, t, this.selectionStart);
  }
  getCursorRenderingData() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getCursorBoundaries(e);
    const n = this.get2DCursorLocation(e), s = n.lineIndex, i = n.charIndex > 0 ? n.charIndex - 1 : 0, a = this.getValueOfPropertyAt(s, i, "fontSize"), c = this.getObjectScaling().x * this.canvas.getZoom(), u = this.cursorWidth / c, h = this.getValueOfPropertyAt(s, i, "deltaY"), d = t.topOffset + (1 - this._fontSizeFraction) * this.getHeightOfLine(s) / this.lineHeight - a * (1 - this._fontSizeFraction);
    return { color: this.cursorColor || this.getValueOfPropertyAt(s, i, "fill"), opacity: this._currentCursorOpacity, left: t.left + t.leftOffset - u / 2, top: d + t.top + h, width: u, height: a };
  }
  _renderCursor(e, t, n) {
    const { color: s, opacity: i, left: a, top: c, width: u, height: h } = this.getCursorRenderingData(n, t);
    e.fillStyle = s, e.globalAlpha = i, e.fillRect(a, c, u, h);
  }
  renderSelection(e, t) {
    const n = { selectionStart: this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd: this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd };
    this._renderSelection(e, n, t);
  }
  renderDragSourceEffect() {
    const e = this.draggableTextDelegate.getDragStartSelection();
    this._renderSelection(this.canvas.contextTop, e, this._getCursorBoundaries(e.selectionStart, !0));
  }
  renderDropTargetEffect(e) {
    const t = this.getSelectionStartFromPointer(e);
    this.renderCursorAt(t);
  }
  _renderSelection(e, t, n) {
    const s = t.selectionStart, i = t.selectionEnd, a = this.textAlign.includes(An), c = this.get2DCursorLocation(s), u = this.get2DCursorLocation(i), h = c.lineIndex, d = u.lineIndex, p = c.charIndex < 0 ? 0 : c.charIndex, g = u.charIndex < 0 ? 0 : u.charIndex;
    for (let v = h; v <= d; v++) {
      const b = this._getLineLeftOffset(v) || 0;
      let _ = this.getHeightOfLine(v), C = 0, T = 0, k = 0;
      if (v === h && (T = this.__charBounds[h][p].left), v >= h && v < d) k = a && !this.isEndOfWrapping(v) ? this.width : this.getLineWidth(v) || 5;
      else if (v === d) if (g === 0) k = this.__charBounds[d][g].left;
      else {
        const U = this._getWidthOfCharSpacing();
        k = this.__charBounds[d][g - 1].left + this.__charBounds[d][g - 1].width - U;
      }
      C = _, (this.lineHeight < 1 || v === d && this.lineHeight > 1) && (_ /= this.lineHeight);
      let M = n.left + b + T, A = _, D = 0;
      const F = k - T;
      this.inCompositionMode ? (e.fillStyle = this.compositionColor || "black", A = 1, D = _) : e.fillStyle = this.selectionColor, this.direction === "rtl" && (this.textAlign === Rt || this.textAlign === An || this.textAlign === va ? M = this.width - M - F : this.textAlign === at || this.textAlign === Nl ? M = n.left + b - k : this.textAlign !== Be && this.textAlign !== ya || (M = n.left + b - k)), e.fillRect(M, n.top + n.topOffset + D, F, A), n.topOffset += C;
    }
  }
  getCurrentCharFontSize() {
    const e = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(e.l, e.c, "fontSize");
  }
  getCurrentCharColor() {
    const e = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(e.l, e.c, Xt);
  }
  _getCurrentCharIndex() {
    const e = this.get2DCursorLocation(this.selectionStart, !0), t = e.charIndex > 0 ? e.charIndex - 1 : 0;
    return { l: e.lineIndex, c: t };
  }
  dispose() {
    this.exitEditingImpl(), this.draggableTextDelegate.dispose(), super.dispose();
  }
}
N(rs, "ownDefaults", k4), N(rs, "type", "IText"), le.setClass(rs), le.setClass(rs, "i-text");
class li extends rs {
  static getDefaults() {
    return L(L({}, super.getDefaults()), li.ownDefaults);
  }
  constructor(e, t) {
    super(e, L(L({}, li.ownDefaults), t));
  }
  static createControls() {
    return { controls: Vw() };
  }
  initDimensions() {
    this.initialized && (this.isEditing && this.initDelayedCursor(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), this.textAlign.includes(An) && this.enlargeSpaces(), this.height = this.calcTextHeight());
  }
  _generateStyleMap(e) {
    let t = 0, n = 0, s = 0;
    const i = {};
    for (let a = 0; a < e.graphemeLines.length; a++) e.graphemeText[s] === `
` && a > 0 ? (n = 0, s++, t++) : !this.splitByGrapheme && this._reSpaceAndTab.test(e.graphemeText[s]) && a > 0 && (n++, s++), i[a] = { line: t, offset: n }, s += e.graphemeLines[a].length, n += e.graphemeLines[a].length;
    return i;
  }
  styleHas(e, t) {
    if (this._styleMap && !this.isWrapping) {
      const n = this._styleMap[t];
      n && (t = n.line);
    }
    return super.styleHas(e, t);
  }
  isEmptyStyles(e) {
    if (!this.styles) return !0;
    let t, n = 0, s = e + 1, i = !1;
    const a = this._styleMap[e], c = this._styleMap[e + 1];
    a && (e = a.line, n = a.offset), c && (s = c.line, i = s === e, t = c.offset);
    const u = e === void 0 ? this.styles : { line: this.styles[e] };
    for (const h in u) for (const d in u[h]) {
      const p = parseInt(d, 10);
      if (p >= n && (!i || p < t)) for (const g in u[h][d]) return !1;
    }
    return !0;
  }
  _getStyleDeclaration(e, t) {
    if (this._styleMap && !this.isWrapping) {
      const n = this._styleMap[e];
      if (!n) return {};
      e = n.line, t = n.offset + t;
    }
    return super._getStyleDeclaration(e, t);
  }
  _setStyleDeclaration(e, t, n) {
    const s = this._styleMap[e];
    super._setStyleDeclaration(s.line, s.offset + t, n);
  }
  _deleteStyleDeclaration(e, t) {
    const n = this._styleMap[e];
    super._deleteStyleDeclaration(n.line, n.offset + t);
  }
  _getLineStyle(e) {
    const t = this._styleMap[e];
    return !!this.styles[t.line];
  }
  _setLineStyle(e) {
    const t = this._styleMap[e];
    super._setLineStyle(t.line);
  }
  _wrapText(e, t) {
    this.isWrapping = !0;
    const n = this.getGraphemeDataForRender(e), s = [];
    for (let i = 0; i < n.wordsData.length; i++) s.push(...this._wrapLine(i, t, n));
    return this.isWrapping = !1, s;
  }
  getGraphemeDataForRender(e) {
    const t = this.splitByGrapheme, n = t ? "" : " ";
    let s = 0;
    return { wordsData: e.map((i, a) => {
      let c = 0;
      const u = t ? this.graphemeSplit(i) : this.wordSplit(i);
      return u.length === 0 ? [{ word: [], width: 0 }] : u.map((h) => {
        const d = t ? [h] : this.graphemeSplit(h), p = this._measureWord(d, a, c);
        return s = Math.max(p, s), c += d.length + n.length, { word: d, width: p };
      });
    }), largestWordWidth: s };
  }
  _measureWord(e, t) {
    let n, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = 0;
    for (let a = 0, c = e.length; a < c; a++)
      i += this._getGraphemeBox(e[a], t, a + s, n, !0).kernedWidth, n = e[a];
    return i;
  }
  wordSplit(e) {
    return e.split(this._wordJoiners);
  }
  _wrapLine(e, t, n) {
    let { largestWordWidth: s, wordsData: i } = n, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    const c = this._getWidthOfCharSpacing(), u = this.splitByGrapheme, h = [], d = u ? "" : " ";
    let p = 0, g = [], v = 0, b = 0, _ = !0;
    t -= a;
    const C = Math.max(t, s, this.dynamicMinWidth), T = i[e];
    let k;
    for (v = 0, k = 0; k < T.length; k++) {
      const { word: M, width: A } = T[k];
      v += M.length, p += b + A - c, p > C && !_ ? (h.push(g), g = [], p = A, _ = !0) : p += c, _ || u || g.push(d), g = g.concat(M), b = u ? 0 : this._measureWord([d], e, v), v++, _ = !1;
    }
    return k && h.push(g), s + a > this.dynamicMinWidth && (this.dynamicMinWidth = s - c + a), h;
  }
  isEndOfWrapping(e) {
    return !this._styleMap[e + 1] || this._styleMap[e + 1].line !== this._styleMap[e].line;
  }
  missingNewlineOffset(e, t) {
    return this.splitByGrapheme && !t ? this.isEndOfWrapping(e) ? 1 : 0 : 1;
  }
  _splitTextIntoLines(e) {
    const t = super._splitTextIntoLines(e), n = this._wrapText(t.lines, this.width), s = new Array(n.length);
    for (let i = 0; i < n.length; i++) s[i] = n[i].join("");
    return t.lines = s, t.graphemeLines = n, t;
  }
  getMinWidth() {
    return Math.max(this.minWidth, this.dynamicMinWidth);
  }
  _removeExtraneousStyles() {
    const e = /* @__PURE__ */ new Map();
    for (const t in this._styleMap) {
      const n = parseInt(t, 10);
      if (this._textLines[n]) {
        const s = this._styleMap[t].line;
        e.set("".concat(s), !0);
      }
    }
    for (const t in this.styles) e.has(t) || delete this.styles[t];
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject(["minWidth", "splitByGrapheme", ...e]);
  }
}
N(li, "type", "Textbox"), N(li, "textLayoutProperties", [...rs.textLayoutProperties, "width"]), N(li, "ownDefaults", { minWidth: 20, dynamicMinWidth: 2, lockScalingFlip: !0, noScaleCache: !1, _wordJoiners: /[ \t\r]/, splitByGrapheme: !1 }), le.setClass(li);
class G0 extends Eu {
  shouldPerformLayout(e) {
    return !!e.target.clipPath && super.shouldPerformLayout(e);
  }
  shouldLayoutClipPath() {
    return !1;
  }
  calcLayoutResult(e, t) {
    const { target: n } = e, { clipPath: s, group: i } = n;
    if (!s || !this.shouldPerformLayout(e)) return;
    const { width: a, height: c } = jn(qw(n, s)), u = new $(a, c);
    if (s.absolutePositioned)
      return { center: ns(s.getRelativeCenterPoint(), void 0, i ? i.calcTransformMatrix() : void 0), size: u };
    {
      const h = s.getRelativeCenterPoint().transform(n.calcOwnMatrix(), !0);
      if (this.shouldPerformLayout(e)) {
        const { center: d = new $(), correction: p = new $() } = this.calcBoundingBox(t, e) || {};
        return { center: d.add(h), correction: p.subtract(h), size: u };
      }
      return { center: n.getRelativeCenterPoint().add(h), size: u };
    }
  }
}
N(G0, "type", "clip-path"), le.setClass(G0);
class q0 extends Eu {
  getInitialSize(e, t) {
    let { target: n } = e, { size: s } = t;
    return new $(n.width || s.x, n.height || s.y);
  }
}
N(q0, "type", "fixed"), le.setClass(q0);
class O4 extends ka {
  subscribeTargets(e) {
    const t = e.target;
    e.targets.reduce((n, s) => (s.parent && n.add(s.parent), n), /* @__PURE__ */ new Set()).forEach((n) => {
      n.layoutManager.subscribeTargets({ target: n, targets: [t] });
    });
  }
  unsubscribeTargets(e) {
    const t = e.target, n = t.getObjects();
    e.targets.reduce((s, i) => (i.parent && s.add(i.parent), s), /* @__PURE__ */ new Set()).forEach((s) => {
      !n.some((i) => i.parent === s) && s.layoutManager.unsubscribeTargets({ target: s, targets: [t] });
    });
  }
}
class Dn extends an {
  static getDefaults() {
    return L(L({}, super.getDefaults()), Dn.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, Dn.ownDefaults), this.setOptions(t);
    const { left: n, top: s, layoutManager: i } = t;
    this.groupInit(e, { left: n, top: s, layoutManager: i ?? new O4() });
  }
  _shouldSetNestedCoords() {
    return !0;
  }
  __objectSelectionMonitor() {
  }
  multiSelectAdd() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    this.multiSelectionStacking === "selection-order" ? this.add(...t) : t.forEach((s) => {
      const i = this._objects.findIndex((c) => c.isInFrontOf(s)), a = i === -1 ? this.size() : i;
      this.insertAt(a, s);
    });
  }
  canEnterGroup(e) {
    return this.getObjects().some((t) => t.isDescendantOf(e) || e.isDescendantOf(t)) ? (ks("error", "ActiveSelection: circular object trees are not supported, this call has no effect"), !1) : super.canEnterGroup(e);
  }
  enterGroup(e, t) {
    e.parent && e.parent === e.group ? e.parent._exitGroup(e) : e.group && e.parent !== e.group && e.group.remove(e), this._enterGroup(e, t);
  }
  exitGroup(e, t) {
    this._exitGroup(e, t), e.parent && e.parent._enterGroup(e, !0);
  }
  _onAfterObjectsChange(e, t) {
    super._onAfterObjectsChange(e, t);
    const n = /* @__PURE__ */ new Set();
    t.forEach((s) => {
      const { parent: i } = s;
      i && n.add(i);
    }), e === Mp ? n.forEach((s) => {
      s._onAfterObjectsChange(Rl, t);
    }) : n.forEach((s) => {
      s._set("dirty", !0);
    });
  }
  onDeselect() {
    return this.removeAll(), !1;
  }
  toString() {
    return "#<ActiveSelection: (".concat(this.complexity(), ")>");
  }
  shouldCache() {
    return !1;
  }
  isOnACache() {
    return !1;
  }
  _renderControls(e, t, n) {
    e.save(), e.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
    const s = L(L({ hasControls: !1 }, n), {}, { forActiveSelection: !0 });
    for (let i = 0; i < this._objects.length; i++) this._objects[i]._renderControls(e, s);
    super._renderControls(e, t), e.restore();
  }
}
N(Dn, "type", "ActiveSelection"), N(Dn, "ownDefaults", { multiSelectionStacking: "canvas-stacking" }), le.setClass(Dn), le.setClass(Dn, "activeSelection");
class M4 {
  constructor() {
    N(this, "resources", {});
  }
  applyFilters(e, t, n, s, i) {
    const a = i.getContext("2d");
    if (!a) return;
    a.drawImage(t, 0, 0, n, s);
    const c = { sourceWidth: n, sourceHeight: s, imageData: a.getImageData(0, 0, n, s), originalEl: t, originalImageData: a.getImageData(0, 0, n, s), canvasEl: i, ctx: a, filterBackend: this };
    e.forEach((h) => {
      h.applyTo(c);
    });
    const { imageData: u } = c;
    return u.width === n && u.height === s || (i.width = u.width, i.height = u.height), a.putImageData(u, 0, 0), c;
  }
}
class xx {
  constructor() {
    let { tileSize: e = et.textureSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    N(this, "aPosition", new Float32Array([0, 0, 0, 1, 1, 0, 1, 1])), N(this, "resources", {}), this.tileSize = e, this.setupGLContext(e, e), this.captureGPUInfo();
  }
  setupGLContext(e, t) {
    this.dispose(), this.createWebGLCanvas(e, t);
  }
  createWebGLCanvas(e, t) {
    const n = _n({ width: e, height: t }), s = n.getContext("webgl", { alpha: !0, premultipliedAlpha: !1, depth: !1, stencil: !1, antialias: !1 });
    s && (s.clearColor(0, 0, 0, 0), this.canvas = n, this.gl = s);
  }
  applyFilters(e, t, n, s, i, a) {
    const c = this.gl, u = i.getContext("2d");
    if (!c || !u) return;
    let h;
    a && (h = this.getCachedTexture(a, t));
    const d = { originalWidth: t.width || t.naturalWidth || 0, originalHeight: t.height || t.naturalHeight || 0, sourceWidth: n, sourceHeight: s, destinationWidth: n, destinationHeight: s, context: c, sourceTexture: this.createTexture(c, n, s, h ? void 0 : t), targetTexture: this.createTexture(c, n, s), originalTexture: h || this.createTexture(c, n, s, h ? void 0 : t), passes: e.length, webgl: !0, aPosition: this.aPosition, programCache: this.programCache, pass: 0, filterBackend: this, targetCanvas: i }, p = c.createFramebuffer();
    return c.bindFramebuffer(c.FRAMEBUFFER, p), e.forEach((g) => {
      g && g.applyTo(d);
    }), function(g) {
      const v = g.targetCanvas, b = v.width, _ = v.height, C = g.destinationWidth, T = g.destinationHeight;
      b === C && _ === T || (v.width = C, v.height = T);
    }(d), this.copyGLTo2D(c, d), c.bindTexture(c.TEXTURE_2D, null), c.deleteTexture(d.sourceTexture), c.deleteTexture(d.targetTexture), c.deleteFramebuffer(p), u.setTransform(1, 0, 0, 1, 0, 0), d;
  }
  dispose() {
    this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches();
  }
  clearWebGLCaches() {
    this.programCache = {}, this.textureCache = {};
  }
  createTexture(e, t, n, s, i) {
    const { NEAREST: a, TEXTURE_2D: c, RGBA: u, UNSIGNED_BYTE: h, CLAMP_TO_EDGE: d, TEXTURE_MAG_FILTER: p, TEXTURE_MIN_FILTER: g, TEXTURE_WRAP_S: v, TEXTURE_WRAP_T: b } = e, _ = e.createTexture();
    return e.bindTexture(c, _), e.texParameteri(c, p, i || a), e.texParameteri(c, g, i || a), e.texParameteri(c, v, d), e.texParameteri(c, b, d), s ? e.texImage2D(c, 0, u, u, h, s) : e.texImage2D(c, 0, u, t, n, 0, u, h, null), _;
  }
  getCachedTexture(e, t, n) {
    const { textureCache: s } = this;
    if (s[e]) return s[e];
    {
      const i = this.createTexture(this.gl, t.width, t.height, t, n);
      return i && (s[e] = i), i;
    }
  }
  evictCachesForKey(e) {
    this.textureCache[e] && (this.gl.deleteTexture(this.textureCache[e]), delete this.textureCache[e]);
  }
  copyGLTo2D(e, t) {
    const n = e.canvas, s = t.targetCanvas, i = s.getContext("2d");
    if (!i) return;
    i.translate(0, s.height), i.scale(1, -1);
    const a = n.height - s.height;
    i.drawImage(n, 0, a, s.width, s.height, 0, 0, s.width, s.height);
  }
  copyGLTo2DPutImageData(e, t) {
    const n = t.targetCanvas.getContext("2d"), s = t.destinationWidth, i = t.destinationHeight, a = s * i * 4;
    if (!n) return;
    const c = new Uint8Array(this.imageBuffer, 0, a), u = new Uint8ClampedArray(this.imageBuffer, 0, a);
    e.readPixels(0, 0, s, i, e.RGBA, e.UNSIGNED_BYTE, c);
    const h = new ImageData(u, s, i);
    n.putImageData(h, 0, 0);
  }
  captureGPUInfo() {
    if (this.gpuInfo) return this.gpuInfo;
    const e = this.gl, t = { renderer: "", vendor: "" };
    if (!e) return t;
    const n = e.getExtension("WEBGL_debug_renderer_info");
    if (n) {
      const s = e.getParameter(n.UNMASKED_RENDERER_WEBGL), i = e.getParameter(n.UNMASKED_VENDOR_WEBGL);
      s && (t.renderer = s.toLowerCase()), i && (t.vendor = i.toLowerCase());
    }
    return this.gpuInfo = t, t;
  }
}
let fd;
function A4() {
  const { WebGLProbe: r } = Fn();
  return r.queryWebGL(cn()), et.enableGLFiltering && r.isSupported(et.textureSize) ? new xx({ tileSize: et.textureSize }) : new M4();
}
function pd() {
  return !fd && (!(arguments.length > 0 && arguments[0] !== void 0) || arguments[0]) && (fd = A4()), fd;
}
const I4 = ["filters", "resizeFilter", "src", "crossOrigin", "type"], _x = ["cropX", "cropY"];
class sn extends ht {
  static getDefaults() {
    return L(L({}, super.getDefaults()), sn.ownDefaults);
  }
  constructor(e, t) {
    super(), N(this, "_lastScaleX", 1), N(this, "_lastScaleY", 1), N(this, "_filterScalingX", 1), N(this, "_filterScalingY", 1), this.filters = [], Object.assign(this, sn.ownDefaults), this.setOptions(t), this.cacheKey = "texture".concat(Ms()), this.setElement(typeof e == "string" ? (this.canvas && vn(this.canvas.getElement()) || Eo()).getElementById(e) : e, t);
  }
  getElement() {
    return this._element;
  }
  setElement(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._element = e, this._originalElement = e, this._setWidthHeight(t), e.classList.add(sn.CSS_CANVAS), this.filters.length !== 0 && this.applyFilters(), this.resizeFilter && this.applyResizeFilters();
  }
  removeTexture(e) {
    const t = pd(!1);
    t instanceof xx && t.evictCachesForKey(e);
  }
  dispose() {
    super.dispose(), this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._cacheContext = null, ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach((e) => {
      const t = this[e];
      t && Fn().dispose(t), this[e] = void 0;
    });
  }
  getCrossOrigin() {
    return this._originalElement && (this._originalElement.crossOrigin || null);
  }
  getOriginalSize() {
    const e = this.getElement();
    return e ? { width: e.naturalWidth || e.width, height: e.naturalHeight || e.height } : { width: 0, height: 0 };
  }
  _stroke(e) {
    if (!this.stroke || this.strokeWidth === 0) return;
    const t = this.width / 2, n = this.height / 2;
    e.beginPath(), e.moveTo(-t, -n), e.lineTo(t, -n), e.lineTo(t, n), e.lineTo(-t, n), e.lineTo(-t, -n), e.closePath();
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = [];
    return this.filters.forEach((n) => {
      n && t.push(n.toObject());
    }), L(L({}, super.toObject([..._x, ...e])), {}, { src: this.getSrc(), crossOrigin: this.getCrossOrigin(), filters: t }, this.resizeFilter ? { resizeFilter: this.resizeFilter.toObject() } : {});
  }
  hasCrop() {
    return !!this.cropX || !!this.cropY || this.width < this._element.width || this.height < this._element.height;
  }
  _toSVG() {
    const e = [], t = this._element, n = -this.width / 2, s = -this.height / 2;
    let i = [], a = [], c = "", u = "";
    if (!t) return [];
    if (this.hasCrop()) {
      const h = Ms();
      i.push('<clipPath id="imageCrop_' + h + `">
`, '	<rect x="' + n + '" y="' + s + '" width="' + this.width + '" height="' + this.height + `" />
`, `</clipPath>
`), c = ' clip-path="url(#imageCrop_' + h + ')" ';
    }
    if (this.imageSmoothing || (u = ' image-rendering="optimizeSpeed"'), e.push("	<image ", "COMMON_PARTS", 'xlink:href="'.concat(this.getSvgSrc(!0), '" x="').concat(n - this.cropX, '" y="').concat(s - this.cropY, '" width="').concat(t.width || t.naturalWidth, '" height="').concat(t.height || t.naturalHeight, '"').concat(u).concat(c, `></image>
`)), this.stroke || this.strokeDashArray) {
      const h = this.fill;
      this.fill = null, a = ['	<rect x="'.concat(n, '" y="').concat(s, '" width="').concat(this.width, '" height="').concat(this.height, '" style="').concat(this.getSvgStyles(), `" />
`)], this.fill = h;
    }
    return i = this.paintFirst !== Xt ? i.concat(a, e) : i.concat(e, a), i;
  }
  getSrc(e) {
    const t = e ? this._element : this._originalElement;
    return t ? t.toDataURL ? t.toDataURL() : this.srcFromAttribute ? t.getAttribute("src") || "" : t.src : this.src || "";
  }
  getSvgSrc(e) {
    return this.getSrc(e);
  }
  setSrc(e) {
    let { crossOrigin: t, signal: n } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return ma(e, { crossOrigin: t, signal: n }).then((s) => {
      t !== void 0 && this.set({ crossOrigin: t }), this.setElement(s);
    });
  }
  toString() {
    return '#<Image: { src: "'.concat(this.getSrc(), '" }>');
  }
  applyResizeFilters() {
    const e = this.resizeFilter, t = this.minimumScaleTrigger, n = this.getTotalObjectScaling(), s = n.x, i = n.y, a = this._filteredEl || this._originalElement;
    if (this.group && this.set("dirty", !0), !e || s > t && i > t) return this._element = a, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = s, void (this._lastScaleY = i);
    const c = _n(a), { width: u, height: h } = a;
    this._element = c, this._lastScaleX = e.scaleX = s, this._lastScaleY = e.scaleY = i, pd().applyFilters([e], a, u, h, this._element), this._filterScalingX = c.width / this._originalElement.width, this._filterScalingY = c.height / this._originalElement.height;
  }
  applyFilters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.filters || [];
    if (e = e.filter((i) => i && !i.isNeutralState()), this.set("dirty", !0), this.removeTexture("".concat(this.cacheKey, "_filtered")), e.length === 0) return this._element = this._originalElement, this._filteredEl = void 0, this._filterScalingX = 1, void (this._filterScalingY = 1);
    const t = this._originalElement, n = t.naturalWidth || t.width, s = t.naturalHeight || t.height;
    if (this._element === this._originalElement) {
      const i = _n({ width: n, height: s });
      this._element = i, this._filteredEl = i;
    } else this._filteredEl && (this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, n, s), this._lastScaleX = 1, this._lastScaleY = 1);
    pd().applyFilters(e, this._originalElement, n, s, this._element), this._originalElement.width === this._element.width && this._originalElement.height === this._element.height || (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height);
  }
  _render(e) {
    e.imageSmoothingEnabled = this.imageSmoothing, this.isMoving !== !0 && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(e), this._renderPaintInOrder(e);
  }
  drawCacheOnCanvas(e) {
    e.imageSmoothingEnabled = this.imageSmoothing, super.drawCacheOnCanvas(e);
  }
  shouldCache() {
    return this.needsItsOwnCache();
  }
  _renderFill(e) {
    const t = this._element;
    if (!t) return;
    const n = this._filterScalingX, s = this._filterScalingY, i = this.width, a = this.height, c = Math.max(this.cropX, 0), u = Math.max(this.cropY, 0), h = t.naturalWidth || t.width, d = t.naturalHeight || t.height, p = c * n, g = u * s, v = Math.min(i * n, h - p), b = Math.min(a * s, d - g), _ = -i / 2, C = -a / 2, T = Math.min(i, h / n - c), k = Math.min(a, d / s - u);
    t && e.drawImage(t, p, g, v, b, _, C, T, k);
  }
  _needsResize() {
    const e = this.getTotalObjectScaling();
    return e.x !== this._lastScaleX || e.y !== this._lastScaleY;
  }
  _resetWidthHeight() {
    this.set(this.getOriginalSize());
  }
  _setWidthHeight() {
    let { width: e, height: t } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = this.getOriginalSize();
    this.width = e || n.width, this.height = t || n.height;
  }
  parsePreserveAspectRatioAttribute() {
    const e = lw(this.preserveAspectRatio || ""), t = this.width, n = this.height, s = { width: t, height: n };
    let i, a = this._element.width, c = this._element.height, u = 1, h = 1, d = 0, p = 0, g = 0, v = 0;
    return !e || e.alignX === Dr && e.alignY === Dr ? (u = t / a, h = n / c) : (e.meetOrSlice === "meet" && (u = h = Zw(this._element, s), i = (t - a * u) / 2, e.alignX === "Min" && (d = -i), e.alignX === "Max" && (d = i), i = (n - c * h) / 2, e.alignY === "Min" && (p = -i), e.alignY === "Max" && (p = i)), e.meetOrSlice === "slice" && (u = h = Jw(this._element, s), i = a - t / u, e.alignX === "Mid" && (g = i / 2), e.alignX === "Max" && (g = i), i = c - n / h, e.alignY === "Mid" && (v = i / 2), e.alignY === "Max" && (v = i), a = t / u, c = n / h)), { width: a, height: c, scaleX: u, scaleY: h, offsetLeft: d, offsetTop: p, cropX: g, cropY: v };
  }
  static fromObject(e, t) {
    let { filters: n, resizeFilter: s, src: i, crossOrigin: a, type: c } = e, u = yt(e, I4);
    return Promise.all([ma(i, L(L({}, t), {}, { crossOrigin: a })), n && uo(n, t), s && uo([s], t), Wa(u, t)]).then((h) => {
      let [d, p = [], [g] = [], v = {}] = h;
      return new this(d, L(L({}, u), {}, { src: i, filters: p, resizeFilter: g }, v));
    });
  }
  static fromURL(e) {
    let { crossOrigin: t = null, signal: n } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = arguments.length > 2 ? arguments[2] : void 0;
    return ma(e, { crossOrigin: t, signal: n }).then((i) => new this(i, s));
  }
  static async fromElement(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;
    const s = cs(e, this.ATTRIBUTE_NAMES, n);
    return this.fromURL(s["xlink:href"], t, s).catch((i) => (ks("log", "Unable to parse Image", i), null));
  }
}
N(sn, "type", "Image"), N(sn, "cacheProperties", [...as, ..._x]), N(sn, "ownDefaults", { strokeWidth: 0, srcFromAttribute: !1, minimumScaleTrigger: 0.5, cropX: 0, cropY: 0, imageSmoothing: !0 }), N(sn, "CSS_CANVAS", "canvas-img"), N(sn, "ATTRIBUTE_NAMES", [...Bs, "x", "y", "width", "height", "preserveAspectRatio", "xlink:href", "crossOrigin", "image-rendering"]), le.setClass(sn), le.setSVGClass(sn);
xu(["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"]);
const Sx = ew, K0 = (r) => function(e, t, n) {
  const { points: s, pathOffset: i } = n;
  return new $(s[r]).subtract(i).transform(At(n.getViewportTransform(), n.calcTransformMatrix()));
}, Cx = (r, e, t, n) => {
  const { target: s, pointIndex: i } = e, a = s, c = ns(new $(t, n), void 0, a.calcOwnMatrix());
  return a.points[i] = c.add(a.pathOffset), a.setDimensions(), !0;
}, Tx = (r, e) => function(t, n, s, i) {
  const a = n.target, c = new $(a.points[(r > 0 ? r : a.points.length) - 1]), u = c.subtract(a.pathOffset).transform(a.calcOwnMatrix()), h = e(t, L(L({}, n), {}, { pointIndex: r }), s, i), d = c.subtract(a.pathOffset).transform(a.calcOwnMatrix()).subtract(u);
  return a.left -= d.x, a.top -= d.y, h;
}, Z0 = (r) => Ns(Sx, Tx(r, Cx)), yf = (r, e, t) => {
  const { path: n, pathOffset: s } = r, i = n[e];
  return new $(i[t] - s.x, i[t + 1] - s.y).transform(At(r.getViewportTransform(), r.calcTransformMatrix()));
};
function P4(r, e, t) {
  const { commandIndex: n, pointIndex: s } = this;
  return yf(t, n, s);
}
function D4(r, e, t, n) {
  const { target: s } = e, { commandIndex: i, pointIndex: a } = this, c = ((u, h, d, p, g) => {
    const { path: v, pathOffset: b } = u, _ = v[(p > 0 ? p : v.length) - 1], C = new $(_[g], _[g + 1]), T = C.subtract(b).transform(u.calcOwnMatrix()), k = ns(new $(h, d), void 0, u.calcOwnMatrix());
    v[p][g] = k.x + b.x, v[p][g + 1] = k.y + b.y, u.setDimensions();
    const M = C.subtract(u.pathOffset).transform(u.calcOwnMatrix()).subtract(T);
    return u.left -= M.x, u.top -= M.y, u.set("dirty", !0), !0;
  })(s, t, n, i, a);
  return bp(this.actionName, L(L({}, wp(r, e, t, n)), {}, { commandIndex: i, pointIndex: a })), c;
}
class Ex extends Ct {
  constructor(e) {
    super(e);
  }
  render(e, t, n, s, i) {
    const a = L(L({}, s), {}, { cornerColor: this.controlFill, cornerStrokeColor: this.controlStroke, transparentCorners: !this.controlFill });
    super.render(e, t, n, a, i);
  }
}
class R4 extends Ex {
  constructor(e) {
    super(e);
  }
  render(e, t, n, s, i) {
    const { path: a } = i, { commandIndex: c, pointIndex: u, connectToCommandIndex: h, connectToPointIndex: d } = this;
    e.save(), e.strokeStyle = this.controlStroke, this.connectionDashArray && e.setLineDash(this.connectionDashArray);
    const [p] = a[c], g = yf(i, h, d);
    if (p === "Q") {
      const v = yf(i, c, u + 2);
      e.moveTo(v.x, v.y), e.lineTo(t, n);
    } else e.moveTo(t, n);
    e.lineTo(g.x, g.y), e.stroke(), e.restore(), super.render(e, t, n, s, i);
  }
}
const qc = (r, e, t, n, s, i) => new (t ? R4 : Ex)(L(L({ commandIndex: r, pointIndex: e, actionName: "modifyPath", positionHandler: P4, actionHandler: D4, connectToCommandIndex: s, connectToPointIndex: i }, n), t ? n.controlPointStyle : n.pointStyle));
var hr = Object.freeze({ __proto__: null, changeWidth: lf, createObjectDefaultControls: Ep, createPathControls: function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = {};
  let n = "M";
  return r.path.forEach((s, i) => {
    const a = s[0];
    switch (a !== "Z" && (t["c_".concat(i, "_").concat(a)] = qc(i, s.length - 2, !1, e)), a) {
      case "C":
        t["c_".concat(i, "_C_CP_1")] = qc(i, 1, !0, e, i - 1, /* @__PURE__ */ ((c) => c === "C" ? 5 : c === "Q" ? 3 : 1)(n)), t["c_".concat(i, "_C_CP_2")] = qc(i, 3, !0, e, i, 5);
        break;
      case "Q":
        t["c_".concat(i, "_Q_CP_1")] = qc(i, 1, !0, e, i, 3);
    }
    n = a;
  }), t;
}, createPolyActionHandler: Z0, createPolyControls: function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = {};
  for (let n = 0; n < (typeof r == "number" ? r : r.points.length); n++) t["p".concat(n)] = new Ct(L({ actionName: Sx, positionHandler: K0(n), actionHandler: Z0(n) }, e));
  return t;
}, createPolyPositionHandler: K0, createResizeControls: Bw, createTextboxDefaultControls: Vw, dragHandler: ww, factoryPolyActionHandler: Tx, getLocalPoint: wu, polyActionHandler: Cx, renderCircleControl: kw, renderSquareControl: Ow, rotationStyleHandler: Mw, rotationWithSnapping: Aw, scaleCursorStyleHandler: to, scaleOrSkewActionName: ua, scaleSkewCursorStyleHandler: ai, scalingEqually: la, scalingX: Dw, scalingXOrSkewingY: uf, scalingY: Rw, scalingYOrSkewingX: hf, skewCursorStyleHandler: jw, skewHandlerX: Fw, skewHandlerY: Nw, wrapWithFireEvent: Ns, wrapWithFixedAnchor: Oi });
const Ou = (r) => r.webgl !== void 0, Ip = "precision highp float", j4 = `
    `.concat(Ip, `;
    varying vec2 vTexCoord;
    uniform sampler2D uTexture;
    void main() {
      gl_FragColor = texture2D(uTexture, vTexCoord);
    }`), L4 = ["type"], F4 = ["type"], N4 = new RegExp(Ip, "g");
class Gt {
  get type() {
    return this.constructor.type;
  }
  constructor() {
    let e = yt(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, L4);
    Object.assign(this, this.constructor.defaults, e);
  }
  getFragmentSource() {
    return j4;
  }
  getVertexSource() {
    return `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    void main() {
      vTexCoord = aPosition;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }`;
  }
  createProgram(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getFragmentSource(), n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.getVertexSource();
    const { WebGLProbe: { GLPrecision: s = "highp" } } = Fn();
    s !== "highp" && (t = t.replace(N4, Ip.replace("highp", s)));
    const i = e.createShader(e.VERTEX_SHADER), a = e.createShader(e.FRAGMENT_SHADER), c = e.createProgram();
    if (!i || !a || !c) throw new Pn("Vertex, fragment shader or program creation error");
    if (e.shaderSource(i, n), e.compileShader(i), !e.getShaderParameter(i, e.COMPILE_STATUS)) throw new Pn("Vertex shader compile error for ".concat(this.type, ": ").concat(e.getShaderInfoLog(i)));
    if (e.shaderSource(a, t), e.compileShader(a), !e.getShaderParameter(a, e.COMPILE_STATUS)) throw new Pn("Fragment shader compile error for ".concat(this.type, ": ").concat(e.getShaderInfoLog(a)));
    if (e.attachShader(c, i), e.attachShader(c, a), e.linkProgram(c), !e.getProgramParameter(c, e.LINK_STATUS)) throw new Pn('Shader link error for "'.concat(this.type, '" ').concat(e.getProgramInfoLog(c)));
    const u = this.getUniformLocations(e, c) || {};
    return u.uStepW = e.getUniformLocation(c, "uStepW"), u.uStepH = e.getUniformLocation(c, "uStepH"), { program: c, attributeLocations: this.getAttributeLocations(e, c), uniformLocations: u };
  }
  getAttributeLocations(e, t) {
    return { aPosition: e.getAttribLocation(t, "aPosition") };
  }
  getUniformLocations(e, t) {
    const n = this.constructor.uniformLocations, s = {};
    for (let i = 0; i < n.length; i++) s[n[i]] = e.getUniformLocation(t, n[i]);
    return s;
  }
  sendAttributeData(e, t, n) {
    const s = t.aPosition, i = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, i), e.enableVertexAttribArray(s), e.vertexAttribPointer(s, 2, e.FLOAT, !1, 0, 0), e.bufferData(e.ARRAY_BUFFER, n, e.STATIC_DRAW);
  }
  _setupFrameBuffer(e) {
    const t = e.context;
    if (e.passes > 1) {
      const n = e.destinationWidth, s = e.destinationHeight;
      e.sourceWidth === n && e.sourceHeight === s || (t.deleteTexture(e.targetTexture), e.targetTexture = e.filterBackend.createTexture(t, n, s)), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e.targetTexture, 0);
    } else t.bindFramebuffer(t.FRAMEBUFFER, null), t.finish();
  }
  _swapTextures(e) {
    e.passes--, e.pass++;
    const t = e.targetTexture;
    e.targetTexture = e.sourceTexture, e.sourceTexture = t;
  }
  isNeutralState(e) {
    return !1;
  }
  applyTo(e) {
    Ou(e) ? (this._setupFrameBuffer(e), this.applyToWebGL(e), this._swapTextures(e)) : this.applyTo2d(e);
  }
  applyTo2d(e) {
  }
  getCacheKey() {
    return this.type;
  }
  retrieveShader(e) {
    const t = this.getCacheKey();
    return e.programCache[t] || (e.programCache[t] = this.createProgram(e.context)), e.programCache[t];
  }
  applyToWebGL(e) {
    const t = e.context, n = this.retrieveShader(e);
    e.pass === 0 && e.originalTexture ? t.bindTexture(t.TEXTURE_2D, e.originalTexture) : t.bindTexture(t.TEXTURE_2D, e.sourceTexture), t.useProgram(n.program), this.sendAttributeData(t, n.attributeLocations, e.aPosition), t.uniform1f(n.uniformLocations.uStepW, 1 / e.sourceWidth), t.uniform1f(n.uniformLocations.uStepH, 1 / e.sourceHeight), this.sendUniformData(t, n.uniformLocations), t.viewport(0, 0, e.destinationWidth, e.destinationHeight), t.drawArrays(t.TRIANGLE_STRIP, 0, 4);
  }
  bindAdditionalTexture(e, t, n) {
    e.activeTexture(n), e.bindTexture(e.TEXTURE_2D, t), e.activeTexture(e.TEXTURE0);
  }
  unbindAdditionalTexture(e, t) {
    e.activeTexture(t), e.bindTexture(e.TEXTURE_2D, null), e.activeTexture(e.TEXTURE0);
  }
  sendUniformData(e, t) {
  }
  createHelpLayer(e) {
    if (!e.helpLayer) {
      const { sourceWidth: t, sourceHeight: n } = e, s = _n({ width: t, height: n });
      e.helpLayer = s;
    }
  }
  toObject() {
    const e = Object.keys(this.constructor.defaults || {});
    return L({ type: this.type }, e.reduce((t, n) => (t[n] = this[n], t), {}));
  }
  toJSON() {
    return this.toObject();
  }
  static async fromObject(e, t) {
    return new this(yt(e, F4));
  }
}
N(Gt, "type", "BaseFilter"), N(Gt, "uniformLocations", []);
const B4 = { multiply: `gl_FragColor.rgb *= uColor.rgb;
`, screen: `gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);
`, add: `gl_FragColor.rgb += uColor.rgb;
`, difference: `gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);
`, subtract: `gl_FragColor.rgb -= uColor.rgb;
`, lighten: `gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);
`, darken: `gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);
`, exclusion: `gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);
`, overlay: `
    if (uColor.r < 0.5) {
      gl_FragColor.r *= 2.0 * uColor.r;
    } else {
      gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);
    }
    if (uColor.g < 0.5) {
      gl_FragColor.g *= 2.0 * uColor.g;
    } else {
      gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);
    }
    if (uColor.b < 0.5) {
      gl_FragColor.b *= 2.0 * uColor.b;
    } else {
      gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);
    }
    `, tint: `
    gl_FragColor.rgb *= (1.0 - uColor.a);
    gl_FragColor.rgb += uColor.rgb;
    ` };
class Kc extends Gt {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return `
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec4 uColor;
      varying vec2 vTexCoord;
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        gl_FragColor = color;
        if (color.a > 0.0) {
          `.concat(B4[this.mode], `
        }
      }
      `);
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = new lt(this.color).getSource(), s = this.alpha, i = n[0] * s, a = n[1] * s, c = n[2] * s, u = 1 - s;
    for (let h = 0; h < t.length; h += 4) {
      const d = t[h], p = t[h + 1], g = t[h + 2];
      let v, b, _;
      switch (this.mode) {
        case "multiply":
          v = d * i / 255, b = p * a / 255, _ = g * c / 255;
          break;
        case "screen":
          v = 255 - (255 - d) * (255 - i) / 255, b = 255 - (255 - p) * (255 - a) / 255, _ = 255 - (255 - g) * (255 - c) / 255;
          break;
        case "add":
          v = d + i, b = p + a, _ = g + c;
          break;
        case "difference":
          v = Math.abs(d - i), b = Math.abs(p - a), _ = Math.abs(g - c);
          break;
        case "subtract":
          v = d - i, b = p - a, _ = g - c;
          break;
        case "darken":
          v = Math.min(d, i), b = Math.min(p, a), _ = Math.min(g, c);
          break;
        case "lighten":
          v = Math.max(d, i), b = Math.max(p, a), _ = Math.max(g, c);
          break;
        case "overlay":
          v = i < 128 ? 2 * d * i / 255 : 255 - 2 * (255 - d) * (255 - i) / 255, b = a < 128 ? 2 * p * a / 255 : 255 - 2 * (255 - p) * (255 - a) / 255, _ = c < 128 ? 2 * g * c / 255 : 255 - 2 * (255 - g) * (255 - c) / 255;
          break;
        case "exclusion":
          v = i + d - 2 * i * d / 255, b = a + p - 2 * a * p / 255, _ = c + g - 2 * c * g / 255;
          break;
        case "tint":
          v = i + d * u, b = a + p * u, _ = c + g * u;
      }
      t[h] = v, t[h + 1] = b, t[h + 2] = _;
    }
  }
  sendUniformData(e, t) {
    const n = new lt(this.color).getSource();
    n[0] = this.alpha * n[0] / 255, n[1] = this.alpha * n[1] / 255, n[2] = this.alpha * n[2] / 255, n[3] = this.alpha, e.uniform4fv(t.uColor, n);
  }
}
N(Kc, "defaults", { color: "#F95C63", mode: "multiply", alpha: 1 }), N(Kc, "type", "BlendColor"), N(Kc, "uniformLocations", ["uColor"]), le.setClass(Kc);
const V4 = { multiply: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.rgba *= color2.rgba;
      gl_FragColor = color;
    }
    `, mask: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.a = color2.a;
      gl_FragColor = color;
    }
    ` }, z4 = ["type", "image"];
class Zc extends Gt {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return V4[this.mode];
  }
  getVertexSource() {
    return `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    uniform mat3 uTransformMatrix;
    void main() {
      vTexCoord = aPosition;
      vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }
    `;
  }
  applyToWebGL(e) {
    const t = e.context, n = this.createTexture(e.filterBackend, this.image);
    this.bindAdditionalTexture(t, n, t.TEXTURE1), super.applyToWebGL(e), this.unbindAdditionalTexture(t, t.TEXTURE1);
  }
  createTexture(e, t) {
    return e.getCachedTexture(t.cacheKey, t.getElement());
  }
  calculateMatrix() {
    const e = this.image, { width: t, height: n } = e.getElement();
    return [1 / e.scaleX, 0, 0, 0, 1 / e.scaleY, 0, -e.left / t, -e.top / n, 1];
  }
  applyTo2d(e) {
    let { imageData: { data: t, width: n, height: s }, filterBackend: { resources: i } } = e;
    const a = this.image;
    i.blendImage || (i.blendImage = cn());
    const c = i.blendImage, u = c.getContext("2d");
    c.width !== n || c.height !== s ? (c.width = n, c.height = s) : u.clearRect(0, 0, n, s), u.setTransform(a.scaleX, 0, 0, a.scaleY, a.left, a.top), u.drawImage(a.getElement(), 0, 0, n, s);
    const h = u.getImageData(0, 0, n, s).data;
    for (let d = 0; d < t.length; d += 4) {
      const p = t[d], g = t[d + 1], v = t[d + 2], b = t[d + 3], _ = h[d], C = h[d + 1], T = h[d + 2], k = h[d + 3];
      switch (this.mode) {
        case "multiply":
          t[d] = p * _ / 255, t[d + 1] = g * C / 255, t[d + 2] = v * T / 255, t[d + 3] = b * k / 255;
          break;
        case "mask":
          t[d + 3] = k;
      }
    }
  }
  sendUniformData(e, t) {
    const n = this.calculateMatrix();
    e.uniform1i(t.uImage, 1), e.uniformMatrix3fv(t.uTransformMatrix, !1, n);
  }
  toObject() {
    return L(L({}, super.toObject()), {}, { image: this.image && this.image.toObject() });
  }
  static async fromObject(e, t) {
    let { type: n, image: s } = e, i = yt(e, z4);
    return sn.fromObject(s, t).then((a) => new this(L(L({}, i), {}, { image: a })));
  }
}
N(Zc, "type", "BlendImage"), N(Zc, "defaults", { mode: "multiply", alpha: 1 }), N(Zc, "uniformLocations", ["uTransformMatrix", "uImage"]), le.setClass(Zc);
class Jc extends Gt {
  getFragmentSource() {
    return `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uDelta;
    varying vec2 vTexCoord;
    const float nSamples = 15.0;
    vec3 v3offset = vec3(12.9898, 78.233, 151.7182);
    float random(vec3 scale) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);
    }
    void main() {
      vec4 color = vec4(0.0);
      float total = 0.0;
      float offset = random(v3offset);
      for (float t = -nSamples; t <= nSamples; t++) {
        float percent = (t + offset - 0.5) / nSamples;
        float weight = 1.0 - abs(percent);
        color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;
        total += weight;
      }
      gl_FragColor = color / total;
    }
  `;
  }
  applyTo(e) {
    Ou(e) ? (this.aspectRatio = e.sourceWidth / e.sourceHeight, e.passes++, this._setupFrameBuffer(e), this.horizontal = !0, this.applyToWebGL(e), this._swapTextures(e), this._setupFrameBuffer(e), this.horizontal = !1, this.applyToWebGL(e), this._swapTextures(e)) : this.applyTo2d(e);
  }
  applyTo2d(e) {
    e.imageData = this.simpleBlur(e);
  }
  simpleBlur(e) {
    let { ctx: t, imageData: n, filterBackend: { resources: s } } = e;
    const { width: i, height: a } = n;
    s.blurLayer1 || (s.blurLayer1 = cn(), s.blurLayer2 = cn());
    const c = s.blurLayer1, u = s.blurLayer2;
    c.width === i && c.height === a || (u.width = c.width = i, u.height = c.height = a);
    const h = c.getContext("2d"), d = u.getContext("2d"), p = 15, g = 0.06 * this.blur * 0.5;
    let v, b, _, C;
    for (h.putImageData(n, 0, 0), d.clearRect(0, 0, i, a), C = -15; C <= p; C++) v = (Math.random() - 0.5) / 4, b = C / p, _ = g * b * i + v, d.globalAlpha = 1 - Math.abs(b), d.drawImage(c, _, v), h.drawImage(u, 0, 0), d.globalAlpha = 1, d.clearRect(0, 0, u.width, u.height);
    for (C = -15; C <= p; C++) v = (Math.random() - 0.5) / 4, b = C / p, _ = g * b * a + v, d.globalAlpha = 1 - Math.abs(b), d.drawImage(c, v, _), h.drawImage(u, 0, 0), d.globalAlpha = 1, d.clearRect(0, 0, u.width, u.height);
    t.drawImage(c, 0, 0);
    const T = t.getImageData(0, 0, c.width, c.height);
    return h.globalAlpha = 1, h.clearRect(0, 0, c.width, c.height), T;
  }
  sendUniformData(e, t) {
    const n = this.chooseRightDelta();
    e.uniform2fv(t.uDelta, n);
  }
  isNeutralState() {
    return this.blur === 0;
  }
  chooseRightDelta() {
    let e = 1;
    const t = [0, 0];
    this.horizontal ? this.aspectRatio > 1 && (e = 1 / this.aspectRatio) : this.aspectRatio < 1 && (e = this.aspectRatio);
    const n = e * this.blur * 0.12;
    return this.horizontal ? t[0] = n : t[1] = n, t;
  }
}
N(Jc, "type", "Blur"), N(Jc, "defaults", { blur: 0 }), N(Jc, "uniformLocations", ["uDelta"]), le.setClass(Jc);
class Qc extends Gt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBrightness;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += uBrightness;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = Math.round(255 * this.brightness);
    for (let s = 0; s < t.length; s += 4) t[s] += n, t[s + 1] += n, t[s + 2] += n;
  }
  isNeutralState() {
    return this.brightness === 0;
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uBrightness, this.brightness);
  }
}
N(Qc, "type", "Brightness"), N(Qc, "defaults", { brightness: 0 }), N(Qc, "uniformLocations", ["uBrightness"]), le.setClass(Qc);
const kx = { matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], colorsOnly: !0 };
class no extends Gt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  varying vec2 vTexCoord;
  uniform mat4 uColorMatrix;
  uniform vec4 uConstants;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color *= uColorMatrix;
    color += uConstants;
    gl_FragColor = color;
  }`;
  }
  applyTo2d(e) {
    const t = e.imageData.data, n = this.matrix, s = this.colorsOnly;
    for (let i = 0; i < t.length; i += 4) {
      const a = t[i], c = t[i + 1], u = t[i + 2];
      if (t[i] = a * n[0] + c * n[1] + u * n[2] + 255 * n[4], t[i + 1] = a * n[5] + c * n[6] + u * n[7] + 255 * n[9], t[i + 2] = a * n[10] + c * n[11] + u * n[12] + 255 * n[14], !s) {
        const h = t[i + 3];
        t[i] += h * n[3], t[i + 1] += h * n[8], t[i + 2] += h * n[13], t[i + 3] = a * n[15] + c * n[16] + u * n[17] + h * n[18] + 255 * n[19];
      }
    }
  }
  sendUniformData(e, t) {
    const n = this.matrix, s = [n[0], n[1], n[2], n[3], n[5], n[6], n[7], n[8], n[10], n[11], n[12], n[13], n[15], n[16], n[17], n[18]], i = [n[4], n[9], n[14], n[19]];
    e.uniformMatrix4fv(t.uColorMatrix, !1, s), e.uniform4fv(t.uConstants, i);
  }
  toObject() {
    return L(L({}, super.toObject()), {}, { matrix: [...this.matrix] });
  }
}
function Mi(r, e) {
  var t;
  const n = (N(t = class extends no {
    toObject() {
      return { type: this.type, colorsOnly: this.colorsOnly };
    }
  }, "type", r), N(t, "defaults", { colorsOnly: !1, matrix: e }), t);
  return le.setClass(n, r), n;
}
N(no, "type", "ColorMatrix"), N(no, "defaults", kx), N(no, "uniformLocations", ["uColorMatrix", "uConstants"]), le.setClass(no);
Mi("Brownie", [0.5997, 0.34553, -0.27082, 0, 0.186, -0.0377, 0.86095, 0.15059, 0, -0.1449, 0.24113, -0.07441, 0.44972, 0, -0.02965, 0, 0, 0, 1, 0]);
Mi("Vintage", [0.62793, 0.32021, -0.03965, 0, 0.03784, 0.02578, 0.64411, 0.03259, 0, 0.02926, 0.0466, -0.08512, 0.52416, 0, 0.02023, 0, 0, 0, 1, 0]);
Mi("Kodachrome", [1.12855, -0.39673, -0.03992, 0, 0.24991, -0.16404, 1.08352, -0.05498, 0, 0.09698, -0.16786, -0.56034, 1.60148, 0, 0.13972, 0, 0, 0, 1, 0]);
Mi("Technicolor", [1.91252, -0.85453, -0.09155, 0, 0.04624, -0.30878, 1.76589, -0.10601, 0, -0.27589, -0.2311, -0.75018, 1.84759, 0, 0.12137, 0, 0, 0, 1, 0]);
Mi("Polaroid", [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0]);
Mi("Sepia", [0.393, 0.769, 0.189, 0, 0, 0.349, 0.686, 0.168, 0, 0, 0.272, 0.534, 0.131, 0, 0, 0, 0, 0, 1, 0]);
Mi("BlackWhite", [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0]);
class J0 extends Gt {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e), this.subFilters = e.subFilters || [];
  }
  applyTo(e) {
    Ou(e) && (e.passes += this.subFilters.length - 1), this.subFilters.forEach((t) => {
      t.applyTo(e);
    });
  }
  toObject() {
    return { type: this.type, subFilters: this.subFilters.map((e) => e.toObject()) };
  }
  isNeutralState() {
    return !this.subFilters.some((e) => !e.isNeutralState());
  }
  static fromObject(e, t) {
    return Promise.all((e.subFilters || []).map((n) => le.getClass(n.type).fromObject(n, t))).then((n) => new this({ subFilters: n }));
  }
}
N(J0, "type", "Composed"), le.setClass(J0);
class el extends Gt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uContrast;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));
    color.rgb = contrastF * (color.rgb - 0.5) + 0.5;
    gl_FragColor = color;
  }`;
  }
  isNeutralState() {
    return this.contrast === 0;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = Math.floor(255 * this.contrast), s = 259 * (n + 255) / (255 * (259 - n));
    for (let i = 0; i < t.length; i += 4) t[i] = s * (t[i] - 128) + 128, t[i + 1] = s * (t[i + 1] - 128) + 128, t[i + 2] = s * (t[i + 2] - 128) + 128;
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uContrast, this.contrast);
  }
}
N(el, "type", "Contrast"), N(el, "defaults", { contrast: 0 }), N(el, "uniformLocations", ["uContrast"]), le.setClass(el);
const W4 = { Convolute_3_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_3_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_5_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_5_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_7_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_7_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_9_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_9_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    ` };
class tl extends Gt {
  getCacheKey() {
    return "".concat(this.type, "_").concat(Math.sqrt(this.matrix.length), "_").concat(this.opaque ? 1 : 0);
  }
  getFragmentSource() {
    return W4[this.getCacheKey()];
  }
  applyTo2d(e) {
    const t = e.imageData, n = t.data, s = this.matrix, i = Math.round(Math.sqrt(s.length)), a = Math.floor(i / 2), c = t.width, u = t.height, h = e.ctx.createImageData(c, u), d = h.data, p = this.opaque ? 1 : 0;
    let g, v, b, _, C, T, k, M, A, D, F, U, B;
    for (F = 0; F < u; F++) for (D = 0; D < c; D++) {
      for (C = 4 * (F * c + D), g = 0, v = 0, b = 0, _ = 0, B = 0; B < i; B++) for (U = 0; U < i; U++) k = F + B - a, T = D + U - a, k < 0 || k >= u || T < 0 || T >= c || (M = 4 * (k * c + T), A = s[B * i + U], g += n[M] * A, v += n[M + 1] * A, b += n[M + 2] * A, p || (_ += n[M + 3] * A));
      d[C] = g, d[C + 1] = v, d[C + 2] = b, d[C + 3] = p ? n[C + 3] : _;
    }
    e.imageData = h;
  }
  sendUniformData(e, t) {
    e.uniform1fv(t.uMatrix, this.matrix);
  }
  toObject() {
    return L(L({}, super.toObject()), {}, { opaque: this.opaque, matrix: [...this.matrix] });
  }
}
N(tl, "type", "Convolute"), N(tl, "defaults", { opaque: !1, matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0] }), N(tl, "uniformLocations", ["uMatrix", "uOpaque", "uHalfSize", "uSize"]), le.setClass(tl);
const Ox = "Gamma";
class rl extends Gt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform vec3 uGamma;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    vec3 correction = (1.0 / uGamma);
    color.r = pow(color.r, correction.r);
    color.g = pow(color.g, correction.g);
    color.b = pow(color.b, correction.b);
    gl_FragColor = color;
    gl_FragColor.rgb *= color.a;
  }
`;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e), this.gamma = e.gamma || this.constructor.defaults.gamma.concat();
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = this.gamma, s = 1 / n[0], i = 1 / n[1], a = 1 / n[2];
    this.rgbValues || (this.rgbValues = { r: new Uint8Array(256), g: new Uint8Array(256), b: new Uint8Array(256) });
    const c = this.rgbValues;
    for (let u = 0; u < 256; u++) c.r[u] = 255 * Math.pow(u / 255, s), c.g[u] = 255 * Math.pow(u / 255, i), c.b[u] = 255 * Math.pow(u / 255, a);
    for (let u = 0; u < t.length; u += 4) t[u] = c.r[t[u]], t[u + 1] = c.g[t[u + 1]], t[u + 2] = c.b[t[u + 2]];
  }
  sendUniformData(e, t) {
    e.uniform3fv(t.uGamma, this.gamma);
  }
  isNeutralState() {
    const { gamma: e } = this;
    return e[0] === 1 && e[1] === 1 && e[2] === 1;
  }
  toObject() {
    return { type: Ox, gamma: this.gamma.concat() };
  }
}
N(rl, "type", Ox), N(rl, "defaults", { gamma: [1, 1, 1] }), N(rl, "uniformLocations", ["uGamma"]), le.setClass(rl);
const H4 = { average: `
    precision highp float;
    uniform sampler2D uTexture;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      float average = (color.r + color.b + color.g) / 3.0;
      gl_FragColor = vec4(average, average, average, color.a);
    }
    `, lightness: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    `, luminosity: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    ` };
class nl extends Gt {
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    for (let n, s = 0; s < t.length; s += 4) {
      const i = t[s], a = t[s + 1], c = t[s + 2];
      switch (this.mode) {
        case "average":
          n = (i + a + c) / 3;
          break;
        case "lightness":
          n = (Math.min(i, a, c) + Math.max(i, a, c)) / 2;
          break;
        case "luminosity":
          n = 0.21 * i + 0.72 * a + 0.07 * c;
      }
      t[s + 2] = t[s + 1] = t[s] = n;
    }
  }
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return H4[this.mode];
  }
  sendUniformData(e, t) {
    e.uniform1i(t.uMode, 1);
  }
  isNeutralState() {
    return !1;
  }
}
N(nl, "type", "Grayscale"), N(nl, "defaults", { mode: "average" }), N(nl, "uniformLocations", ["uMode"]), le.setClass(nl);
const U4 = L(L({}, kx), {}, { rotation: 0 });
class gd extends no {
  calculateMatrix() {
    const e = this.rotation * Math.PI, t = wn(e), n = xn(e), s = 1 / 3, i = Math.sqrt(s) * n, a = 1 - t;
    this.matrix = [t + a / 3, s * a - i, s * a + i, 0, 0, s * a + i, t + s * a, s * a - i, 0, 0, s * a - i, s * a + i, t + s * a, 0, 0, 0, 0, 0, 1, 0];
  }
  isNeutralState() {
    return this.rotation === 0;
  }
  applyTo(e) {
    this.calculateMatrix(), super.applyTo(e);
  }
  toObject() {
    return { type: this.type, rotation: this.rotation };
  }
}
N(gd, "type", "HueRotation"), N(gd, "defaults", U4), le.setClass(gd);
class sl extends Gt {
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    for (let n = 0; n < t.length; n += 4) t[n] = 255 - t[n], t[n + 1] = 255 - t[n + 1], t[n + 2] = 255 - t[n + 2], this.alpha && (t[n + 3] = 255 - t[n + 3]);
  }
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform int uInvert;
  uniform int uAlpha;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    if (uInvert == 1) {
      if (uAlpha == 1) {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,1.0 -color.a);
      } else {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);
      }
    } else {
      gl_FragColor = color;
    }
  }
`;
  }
  isNeutralState() {
    return !this.invert;
  }
  sendUniformData(e, t) {
    e.uniform1i(t.uInvert, Number(this.invert)), e.uniform1i(t.uAlpha, Number(this.alpha));
  }
}
N(sl, "type", "Invert"), N(sl, "defaults", { alpha: !1, invert: !0 }), N(sl, "uniformLocations", ["uInvert", "uAlpha"]), le.setClass(sl);
class il extends Gt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uStepH;
  uniform float uNoise;
  uniform float uSeed;
  varying vec2 vTexCoord;
  float rand(vec2 co, float seed, float vScale) {
    return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);
  }
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = this.noise;
    for (let s = 0; s < t.length; s += 4) {
      const i = (0.5 - Math.random()) * n;
      t[s] += i, t[s + 1] += i, t[s + 2] += i;
    }
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uNoise, this.noise / 255), e.uniform1f(t.uSeed, Math.random());
  }
  isNeutralState() {
    return this.noise === 0;
  }
}
N(il, "type", "Noise"), N(il, "defaults", { noise: 0 }), N(il, "uniformLocations", ["uNoise", "uSeed"]), le.setClass(il);
class ol extends Gt {
  applyTo2d(e) {
    let { imageData: { data: t, width: n, height: s } } = e;
    for (let i = 0; i < s; i += this.blocksize) for (let a = 0; a < n; a += this.blocksize) {
      const c = 4 * i * n + 4 * a, u = t[c], h = t[c + 1], d = t[c + 2], p = t[c + 3];
      for (let g = i; g < Math.min(i + this.blocksize, s); g++) for (let v = a; v < Math.min(a + this.blocksize, n); v++) {
        const b = 4 * g * n + 4 * v;
        t[b] = u, t[b + 1] = h, t[b + 2] = d, t[b + 3] = p;
      }
    }
  }
  isNeutralState() {
    return this.blocksize === 1;
  }
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBlocksize;
  uniform float uStepW;
  uniform float uStepH;
  varying vec2 vTexCoord;
  void main() {
    float blockW = uBlocksize * uStepW;
    float blockH = uBlocksize * uStepH;
    int posX = int(vTexCoord.x / blockW);
    int posY = int(vTexCoord.y / blockH);
    float fposX = float(posX);
    float fposY = float(posY);
    vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);
    vec4 color = texture2D(uTexture, squareCoords);
    gl_FragColor = color;
  }
`;
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uBlocksize, this.blocksize);
  }
}
N(ol, "type", "Pixelate"), N(ol, "defaults", { blocksize: 4 }), N(ol, "uniformLocations", ["uBlocksize"]), le.setClass(ol);
class al extends Gt {
  getFragmentSource() {
    return `
precision highp float;
uniform sampler2D uTexture;
uniform vec4 uLow;
uniform vec4 uHigh;
varying vec2 vTexCoord;
void main() {
  gl_FragColor = texture2D(uTexture, vTexCoord);
  if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {
    gl_FragColor.a = 0.0;
  }
}
`;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = 255 * this.distance, s = new lt(this.color).getSource(), i = [s[0] - n, s[1] - n, s[2] - n], a = [s[0] + n, s[1] + n, s[2] + n];
    for (let c = 0; c < t.length; c += 4) {
      const u = t[c], h = t[c + 1], d = t[c + 2];
      u > i[0] && h > i[1] && d > i[2] && u < a[0] && h < a[1] && d < a[2] && (t[c + 3] = 0);
    }
  }
  sendUniformData(e, t) {
    const n = new lt(this.color).getSource(), s = this.distance, i = [0 + n[0] / 255 - s, 0 + n[1] / 255 - s, 0 + n[2] / 255 - s, 1], a = [n[0] / 255 + s, n[1] / 255 + s, n[2] / 255 + s, 1];
    e.uniform4fv(t.uLow, i), e.uniform4fv(t.uHigh, a);
  }
}
N(al, "type", "RemoveColor"), N(al, "defaults", { color: "#FFFFFF", distance: 0.02, useAlpha: !1 }), N(al, "uniformLocations", ["uLow", "uHigh"]), le.setClass(al);
class cl extends Gt {
  sendUniformData(e, t) {
    e.uniform2fv(t.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), e.uniform1fv(t.uTaps, this.taps);
  }
  getFilterWindow() {
    const e = this.tempScale;
    return Math.ceil(this.lanczosLobes / e);
  }
  getCacheKey() {
    const e = this.getFilterWindow();
    return "".concat(this.type, "_").concat(e);
  }
  getFragmentSource() {
    const e = this.getFilterWindow();
    return this.generateShader(e);
  }
  getTaps() {
    const e = this.lanczosCreate(this.lanczosLobes), t = this.tempScale, n = this.getFilterWindow(), s = new Array(n);
    for (let i = 1; i <= n; i++) s[i - 1] = e(i * t);
    return s;
  }
  generateShader(e) {
    const t = new Array(e);
    for (let n = 1; n <= e; n++) t[n - 1] = "".concat(n, ".0 * uDelta");
    return `
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec2 uDelta;
      varying vec2 vTexCoord;
      uniform float uTaps[`.concat(e, `];
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        float sum = 1.0;
        `).concat(t.map((n, s) => `
              color += texture2D(uTexture, vTexCoord + `.concat(n, ") * uTaps[").concat(s, "] + texture2D(uTexture, vTexCoord - ").concat(n, ") * uTaps[").concat(s, `];
              sum += 2.0 * uTaps[`).concat(s, `];
            `)).join(`
`), `
        gl_FragColor = color / sum;
      }
    `);
  }
  applyToForWebgl(e) {
    e.passes++, this.width = e.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = e.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), e.destinationWidth = this.dW, super.applyTo(e), e.sourceWidth = e.destinationWidth, this.height = e.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), e.destinationHeight = this.dH, super.applyTo(e), e.sourceHeight = e.destinationHeight;
  }
  applyTo(e) {
    Ou(e) ? this.applyToForWebgl(e) : this.applyTo2d(e);
  }
  isNeutralState() {
    return this.scaleX === 1 && this.scaleY === 1;
  }
  lanczosCreate(e) {
    return (t) => {
      if (t >= e || t <= -e) return 0;
      if (t < 11920929e-14 && t > -11920929e-14) return 1;
      const n = (t *= Math.PI) / e;
      return Math.sin(t) / t * Math.sin(n) / n;
    };
  }
  applyTo2d(e) {
    const t = e.imageData, n = this.scaleX, s = this.scaleY;
    this.rcpScaleX = 1 / n, this.rcpScaleY = 1 / s;
    const i = t.width, a = t.height, c = Math.round(i * n), u = Math.round(a * s);
    let h;
    h = this.resizeType === "sliceHack" ? this.sliceByTwo(e, i, a, c, u) : this.resizeType === "hermite" ? this.hermiteFastResize(e, i, a, c, u) : this.resizeType === "bilinear" ? this.bilinearFiltering(e, i, a, c, u) : this.resizeType === "lanczos" ? this.lanczosResize(e, i, a, c, u) : new ImageData(c, u), e.imageData = h;
  }
  sliceByTwo(e, t, n, s, i) {
    const a = e.imageData, c = 0.5;
    let u = !1, h = !1, d = t * c, p = n * c;
    const g = e.filterBackend.resources;
    let v = 0, b = 0;
    const _ = t;
    let C = 0;
    g.sliceByTwo || (g.sliceByTwo = cn());
    const T = g.sliceByTwo;
    (T.width < 1.5 * t || T.height < n) && (T.width = 1.5 * t, T.height = n);
    const k = T.getContext("2d");
    for (k.clearRect(0, 0, 1.5 * t, n), k.putImageData(a, 0, 0), s = Math.floor(s), i = Math.floor(i); !u || !h; ) t = d, n = p, s < Math.floor(d * c) ? d = Math.floor(d * c) : (d = s, u = !0), i < Math.floor(p * c) ? p = Math.floor(p * c) : (p = i, h = !0), k.drawImage(T, v, b, t, n, _, C, d, p), v = _, b = C, C += p;
    return k.getImageData(v, b, s, i);
  }
  lanczosResize(e, t, n, s, i) {
    const a = e.imageData.data, c = e.ctx.createImageData(s, i), u = c.data, h = this.lanczosCreate(this.lanczosLobes), d = this.rcpScaleX, p = this.rcpScaleY, g = 2 / this.rcpScaleX, v = 2 / this.rcpScaleY, b = Math.ceil(d * this.lanczosLobes / 2), _ = Math.ceil(p * this.lanczosLobes / 2), C = {}, T = { x: 0, y: 0 }, k = { x: 0, y: 0 };
    return function M(A) {
      let D, F, U, B, X, Y, Z, G, K, oe, ve;
      for (T.x = (A + 0.5) * d, k.x = Math.floor(T.x), D = 0; D < i; D++) {
        for (T.y = (D + 0.5) * p, k.y = Math.floor(T.y), X = 0, Y = 0, Z = 0, G = 0, K = 0, F = k.x - b; F <= k.x + b; F++) if (!(F < 0 || F >= t)) {
          oe = Math.floor(1e3 * Math.abs(F - T.x)), C[oe] || (C[oe] = {});
          for (let Q = k.y - _; Q <= k.y + _; Q++) Q < 0 || Q >= n || (ve = Math.floor(1e3 * Math.abs(Q - T.y)), C[oe][ve] || (C[oe][ve] = h(Math.sqrt(Math.pow(oe * g, 2) + Math.pow(ve * v, 2)) / 1e3)), U = C[oe][ve], U > 0 && (B = 4 * (Q * t + F), X += U, Y += U * a[B], Z += U * a[B + 1], G += U * a[B + 2], K += U * a[B + 3]));
        }
        B = 4 * (D * s + A), u[B] = Y / X, u[B + 1] = Z / X, u[B + 2] = G / X, u[B + 3] = K / X;
      }
      return ++A < s ? M(A) : c;
    }(0);
  }
  bilinearFiltering(e, t, n, s, i) {
    let a, c, u, h, d, p, g, v, b, _, C, T, k, M = 0;
    const A = this.rcpScaleX, D = this.rcpScaleY, F = 4 * (t - 1), U = e.imageData.data, B = e.ctx.createImageData(s, i), X = B.data;
    for (g = 0; g < i; g++) for (v = 0; v < s; v++) for (d = Math.floor(A * v), p = Math.floor(D * g), b = A * v - d, _ = D * g - p, k = 4 * (p * t + d), C = 0; C < 4; C++) a = U[k + C], c = U[k + 4 + C], u = U[k + F + C], h = U[k + F + 4 + C], T = a * (1 - b) * (1 - _) + c * b * (1 - _) + u * _ * (1 - b) + h * b * _, X[M++] = T;
    return B;
  }
  hermiteFastResize(e, t, n, s, i) {
    const a = this.rcpScaleX, c = this.rcpScaleY, u = Math.ceil(a / 2), h = Math.ceil(c / 2), d = e.imageData.data, p = e.ctx.createImageData(s, i), g = p.data;
    for (let v = 0; v < i; v++) for (let b = 0; b < s; b++) {
      const _ = 4 * (b + v * s);
      let C = 0, T = 0, k = 0, M = 0, A = 0, D = 0, F = 0;
      const U = (v + 0.5) * c;
      for (let B = Math.floor(v * c); B < (v + 1) * c; B++) {
        const X = Math.abs(U - (B + 0.5)) / h, Y = (b + 0.5) * a, Z = X * X;
        for (let G = Math.floor(b * a); G < (b + 1) * a; G++) {
          let K = Math.abs(Y - (G + 0.5)) / u;
          const oe = Math.sqrt(Z + K * K);
          oe > 1 && oe < -1 || (C = 2 * oe * oe * oe - 3 * oe * oe + 1, C > 0 && (K = 4 * (G + B * t), F += C * d[K + 3], k += C, d[K + 3] < 255 && (C = C * d[K + 3] / 250), M += C * d[K], A += C * d[K + 1], D += C * d[K + 2], T += C));
        }
      }
      g[_] = M / T, g[_ + 1] = A / T, g[_ + 2] = D / T, g[_ + 3] = F / k;
    }
    return p;
  }
}
N(cl, "type", "Resize"), N(cl, "defaults", { resizeType: "hermite", scaleX: 1, scaleY: 1, lanczosLobes: 3 }), N(cl, "uniformLocations", ["uDelta", "uTaps"]), le.setClass(cl);
class ll extends Gt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uSaturation;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float rgMax = max(color.r, color.g);
    float rgbMax = max(rgMax, color.b);
    color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;
    color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;
    color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = -this.saturation;
    for (let s = 0; s < t.length; s += 4) {
      const i = t[s], a = t[s + 1], c = t[s + 2], u = Math.max(i, a, c);
      t[s] += u !== i ? (u - i) * n : 0, t[s + 1] += u !== a ? (u - a) * n : 0, t[s + 2] += u !== c ? (u - c) * n : 0;
    }
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uSaturation, -this.saturation);
  }
  isNeutralState() {
    return this.saturation === 0;
  }
}
N(ll, "type", "Saturation"), N(ll, "defaults", { saturation: 0 }), N(ll, "uniformLocations", ["uSaturation"]), le.setClass(ll);
class ul extends Gt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uVibrance;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float max = max(color.r, max(color.g, color.b));
    float avg = (color.r + color.g + color.b) / 3.0;
    float amt = (abs(max - avg) * 2.0) * uVibrance;
    color.r += max != color.r ? (max - color.r) * amt : 0.00;
    color.g += max != color.g ? (max - color.g) * amt : 0.00;
    color.b += max != color.b ? (max - color.b) * amt : 0.00;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = -this.vibrance;
    for (let s = 0; s < t.length; s += 4) {
      const i = t[s], a = t[s + 1], c = t[s + 2], u = Math.max(i, a, c), h = (i + a + c) / 3, d = 2 * Math.abs(u - h) / 255 * n;
      t[s] += u !== i ? (u - i) * d : 0, t[s + 1] += u !== a ? (u - a) * d : 0, t[s + 2] += u !== c ? (u - c) * d : 0;
    }
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uVibrance, -this.vibrance);
  }
  isNeutralState() {
    return this.vibrance === 0;
  }
}
N(ul, "type", "Vibrance"), N(ul, "defaults", { vibrance: 0 }), N(ul, "uniformLocations", ["uVibrance"]), le.setClass(ul);
class $4 {
  ___eventListeners;
  ___activeObjects;
  constructor() {
    this.___activeObjects = [], this.___eventListeners = {};
  }
  pauseEventListeners() {
    this.___eventListeners = this.__eventListeners, this.__eventListeners = {};
    const e = this.getActiveObjects();
    this.discardActiveObject(), this.___activeObjects = e;
  }
  resumeEventListeners() {
    this.__eventListeners = this.___eventListeners, this.___eventListeners = {};
    const e = this.___activeObjects;
    if (!e.length)
      return this.requestRenderAll(), !1;
    if (e.length === 1)
      this.setActiveObject(e[0]);
    else {
      const t = new Dn(e);
      this.setActiveObject(t);
    }
    this.requestRenderAll();
  }
}
class fo extends Ft {
  isSelected = !1;
  text;
  tScale;
  display;
  id;
  backgroundColor;
  static ownDefaults = {
    rx: 6,
    ry: 6,
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 0,
    fill: "#27272a",
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    fontSize: 16,
    fontFamily: "Arial",
    fontColor: "#ffffff",
    textAlign: "center"
  };
  static type = "Text";
  constructor(e) {
    super(e), Object.assign(this, fo.ownDefaults), this.id = e.id, this.tScale = e.tScale, this.display = e.display, this.text = e.text || "", this.backgroundColor = e.backgroundColor || "transparent";
  }
  static createControls() {
    return {
      controls: Mx()
    };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...fo.ownDefaults
    };
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      6
    ), e.lineWidth = 2, e.strokeStyle = "rgba(0, 216, 214,1.0)", e.stroke(), e.restore());
  }
}
function Is(r, e, t, n, s) {
  r.save(), r.translate(e, t), r.rotate(ax.degreesToRadians(90 + s.angle)), r.beginPath(), r.lineWidth = 4, r.lineCap = "round", r.strokeStyle = "#dfe2e8", r.moveTo(-6, 0), r.lineTo(6, 0), r.stroke(), r.restore();
}
function Mx() {
  return {
    mr: new Ct({
      x: 0.5,
      y: 0,
      actionHandler: Bl,
      cursorStyleHandler: hr.scaleSkewCursorStyleHandler,
      actionName: "resizing",
      render: Is
    }),
    ml: new Ct({
      x: -0.5,
      y: 0,
      actionHandler: Bl,
      cursorStyleHandler: hr.scaleSkewCursorStyleHandler,
      actionName: "resizing",
      render: Is
    })
  };
}
const Bl = hr.wrapWithFireEvent(
  "resizing",
  hr.wrapWithFixedAnchor((r, e, t, n) => {
    const s = hr.getLocalPoint(
      e,
      e.originX,
      e.originY,
      t,
      n
    );
    if (X4(e.originX) || q4(e.originX) && s.x < 0 || G4(e.originX) && s.x > 0) {
      const i = e.target, a = i.strokeWidth / (i.strokeUniform ? i.scaleX : 1), c = K4(e) ? 2 : 1, u = i.width, h = Math.ceil(
        Math.abs(s.x * c / i.scaleX) - a
      );
      if (e.corner === "ml") {
        const p = u - h;
        if (i.left + p < 0)
          return i.set("width", i.width + i.left), !0;
      }
      return i.set("width", Math.max(h, 0)), u !== i.width;
    }
    return !1;
  })
), Y4 = {
  left: -0.5,
  top: -0.5,
  center: 0,
  bottom: 0.5,
  right: 0.5
}, Ye = (r) => typeof r == "string" ? Y4[r] : r - 0.5, X4 = (r) => Ye(r) === Ye("center"), G4 = (r) => Ye(r) === Ye("left"), q4 = (r) => Ye(r) === Ye("right");
function K4(r) {
  return Ye(r.originX) === Ye("center") && Ye(r.originY) === Ye("center");
}
le.setClass(fo, "Text");
class Sn extends Ft {
  static type = "Transition";
  id;
  duration;
  fromId;
  toId;
  static ownDefaults = {
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 1.5,
    fill: "rgba(0, 0, 0, 0.5)",
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    lockMovementX: !0,
    lockMovementY: !0,
    duration: 1500,
    rx: 8,
    ry: 8
  };
  isSelected = !1;
  constructor(e) {
    super(e), this.id = e.id, this.fromId = e.fromId, this.toId = e.toId, Object.assign(this, {
      duration: e.duration,
      fromId: e.fromId,
      toId: e.toId,
      kind: e.kind,
      tScale: e.tScale,
      strokeDashArray: e.strokeDashArray || [],
      isSelected: !1,
      centeredScaling: !0,
      strokeWidth: 0
    }), Object.assign(this, Sn.ownDefaults);
  }
  static createControls() {
    return {
      controls: Z4()
    };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...Sn.ownDefaults
    };
  }
  updateCoords() {
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  updateSelected(e) {
    e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = 2, this.strokeDashArray && e.setLineDash(this.strokeDashArray), e.strokeStyle = this.isSelected ? "rgba(255, 255, 255,1.0)" : "rgba(255, 255, 255,0.15)", e.stroke(), e.restore();
  }
}
le.setClass(Sn, "Transition");
const Z4 = () => ({
  mr: new Ct({
    x: 0.5,
    y: 0,
    actionHandler: Q0,
    cursorStyleHandler: hr.scaleSkewCursorStyleHandler,
    actionName: "resizing",
    render: Is
  }),
  ml: new Ct({
    x: -0.5,
    y: 0,
    actionHandler: Q0,
    cursorStyleHandler: hr.scaleSkewCursorStyleHandler,
    actionName: "resizing",
    render: Is
  })
});
le.setClass(Sn, "Transition");
const { wrapWithFireEvent: J4, getLocalPoint: Q4 } = hr, bf = "center", ej = "left", tj = "right";
function rj(r) {
  return (e, t, n, s) => {
    const { target: i, originX: a, originY: c } = t, u = i.getRelativeCenterPoint(), h = i.translateToOriginPoint(
      u,
      a,
      c
    ), d = r(e, t, n, s);
    return i.setPositionByOrigin(h, a, c), d;
  };
}
const nj = (r, e, t, n) => {
  const s = Q4(
    e,
    e.originX,
    e.originY,
    t,
    n
  );
  if (Ye(e.originX) === Ye(bf) || Ye(e.originX) === Ye(tj) && s.x < 0 || Ye(e.originX) === Ye(ej) && s.x > 0) {
    const { target: i } = e, a = i.strokeWidth / (i.strokeUniform ? i.scaleX : 1), c = sj(e) ? 2 : 1, u = i.width, h = Math.ceil(
      Math.abs(s.x * c / i.scaleX) - a
    ), d = di(h, i.tScale);
    return d >= 1500 || d < 500 ? !1 : (i.set("width", Math.max(h, 0)), i.set("duration", d), i.setCoords(), i.canvas && i.canvas.renderAll(), u !== i.width);
  }
  return !1;
};
function sj(r) {
  return Ye(r.originX) === Ye(bf) && Ye(r.originY) === Ye(bf);
}
const Q0 = J4(
  "resizing",
  rj(nj)
);
class Oa extends Ft {
  static type = "Placeholder";
  guideItemId;
  distXToActCenter;
  trackItemType;
  defaultPos;
  draggedObject = null;
  for;
  id;
  static ownDefaults = {
    rx: 6,
    ry: 6,
    objectCaching: !1,
    borderColor: "transparent",
    strokeWidth: 0,
    fill: "rgba(255, 211, 42, 0.1)",
    stroke: "rgba(255, 211, 42, 1.0)",
    selectable: !1,
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    strokeDashArray: [5, 1],
    evented: !1
  };
  constructor(e) {
    super(e), this.id = e.id, this.for = e.for, Object.assign(this, Oa.ownDefaults);
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...Oa.ownDefaults
    };
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = 2, this.strokeDashArray && e.setLineDash(this.strokeDashArray), e.strokeStyle = "rgba(0, 216, 214,1.0)", e.stroke(), e.restore();
  }
}
le.setClass(Oa, "Placeholder");
const ij = {
  top: { top: 35, guideHeight: 2, bottom: 3 },
  center: { top: 3, guideHeight: 2, bottom: 3 },
  bottom: { top: 3, guideHeight: 2, bottom: 35 }
}, Mu = "rgba(0, 216, 214, 1.0)", md = (r, e, t) => new Ft({
  top: r,
  left: 0,
  strokeWidth: 0,
  fill: "transparent",
  selectable: !0,
  height: t,
  width: e
});
class ba extends an {
  static type = "Helper";
  static defaultSettings = {
    selectable: !1,
    evented: !1
  };
  static ownDefaults = { ...ba.defaultSettings };
  guide;
  topGuide;
  bottomGuide;
  id;
  metadata = {};
  tScale;
  kind;
  constructor(e) {
    const t = ij[e.kind], n = md(0, e.width, t.top), s = md(t.top, e.width, t.guideHeight), i = md(
      t.top + t.guideHeight,
      e.width,
      t.bottom
    );
    super([n, s, i], {
      ...ba.defaultSettings,
      ...e
    }), this.topGuide = n, this.guide = s, this.bottomGuide = i, this.id = e.id, this.metadata = e.metadata ?? {}, this.tScale = e.tScale, this.kind = e.kind;
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...ba.defaultSettings
    };
  }
  updateCoords(e) {
    this.scaleToWidth(e), this.set("scaleY", 1);
  }
  setSelected(e) {
    this.guide.set("fill", e ? Mu : "transparent");
  }
}
const $a = ba;
le.setClass($a, "Helper");
class mi extends Ft {
  static ownDefaults = {
    selectable: !1,
    evented: !1,
    strokeWidth: 0,
    stroke: "transparent"
  };
  static type = "Track";
  id;
  accepts;
  metadata;
  items;
  borderColor = "transparent";
  stroke = "transparent";
  strokeWidth = 0;
  constructor(e) {
    super(e), Object.assign(this, mi.ownDefaults), this.id = e.id, this.accepts = e.accepts || ["audio", "video", "image", "text"], this.items = e.items || [], this.metadata = e.metadata;
  }
  static getDefaults() {
    return { ...super.getDefaults(), ...mi.ownDefaults };
  }
  updateCoords(e) {
    this.width = e;
  }
}
le.setClass(mi, "Track");
class Vl extends Ft {
  isSelected;
  tScale;
  display;
  id;
  src;
  itemType;
  static ownDefaults = {
    rx: 8,
    ry: 8,
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 0,
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    fill: "#27272a"
  };
  static type = "Image";
  constructor(e) {
    super(e), this.itemType = "image", this.isSelected = !1, Object.assign(this, Vl.ownDefaults), this.id = e.id, this.src = e.src, this.display = e.display, this.tScale = e.tScale;
  }
  static createControls() {
    return {
      controls: Mx()
    };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...Vl.ownDefaults
    };
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = 2, e.strokeStyle = Mu, e.stroke(), e.restore());
  }
}
const Pp = Vl;
le.setClass(Pp, "Image");
class Io extends Ft {
  id;
  tScale;
  isSelected = !1;
  display;
  trim;
  static type = "Video";
  static defaultProps = {
    objectCaching: !1,
    rx: 8,
    ry: 8,
    fill: "#27272a"
  };
  constructor(e) {
    super(Object.assign({}, Io.defaultProps, e)), this.id = e.id, this.tScale = e.tScale, this.display = e.display, this.trim = e.trim;
  }
  static createControls() {
    return { controls: oj() };
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = 2, e.strokeStyle = Mu, e.stroke(), e.restore());
  }
}
le.setClass(Io, "Video");
const oj = () => ({
  mr: new Ct({
    x: 0.5,
    y: 0,
    render: Is,
    actionHandler: ey,
    cursorStyleHandler: hr.scaleSkewCursorStyleHandler,
    actionName: "resizing"
  }),
  ml: new Ct({
    x: -0.5,
    y: 0,
    render: Is,
    actionHandler: ey,
    cursorStyleHandler: hr.scaleSkewCursorStyleHandler,
    actionName: "resizing"
  })
}), { wrapWithFireEvent: aj, getLocalPoint: cj } = hr, lj = (r, e, t, n) => {
  const s = cj(
    e,
    e.originX,
    e.originY,
    t,
    n
  );
  if (Ye(e.originX) === Ye("center") || Ye(e.originX) === Ye("right") && s.x < 0 || Ye(e.originX) === Ye("left") && s.x > 0) {
    const { target: i } = e;
    return i.width !== i.width;
  }
  return !1;
};
function Ax(r) {
  return (e, t, n, s) => {
    const { target: i, originX: a, originY: c } = t, u = i.getRelativeCenterPoint(), h = i.translateToOriginPoint(
      u,
      a,
      c
    ), d = r(e, t, n, s);
    return i.setPositionByOrigin(h, a, c), d;
  };
}
const ey = aj(
  "resizing",
  Ax(lj)
);
class Ts extends Ft {
  id;
  itemType = "audio";
  isSelected = !1;
  trim;
  src;
  tScale;
  display;
  static ownDefaults = {
    rx: 6,
    ry: 6,
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 0,
    fill: "#27272a",
    borderOpacityWhenMoving: 1,
    hoverCursor: "default"
  };
  static type = "Audio";
  constructor(e) {
    super({
      ...Ts.getDefaults(),
      ...e
    }), this.id = e.id, this.tScale = e.tScale, this.display = e.display, this.trim = e.trim, this.src = e.src;
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...Ts.ownDefaults
    };
  }
  static createControls() {
    return { controls: uj() };
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      Ts.ownDefaults.rx
    ), e.lineWidth = 2, e.strokeStyle = Mu, e.stroke(), e.restore());
  }
}
le.setClass(Ts, "Audio");
const uj = () => ({
  mr: new Ct({
    x: 0.5,
    y: 0,
    render: Is,
    actionHandler: ty,
    cursorStyleHandler: hr.scaleSkewCursorStyleHandler,
    actionName: "resizing"
  }),
  ml: new Ct({
    x: -0.5,
    y: 0,
    render: Is,
    actionHandler: ty,
    cursorStyleHandler: hr.scaleSkewCursorStyleHandler,
    actionName: "resizing"
  })
}), { wrapWithFireEvent: hj, getLocalPoint: dj } = hr, fj = (r, e, t, n) => {
  const s = dj(
    e,
    e.originX,
    e.originY,
    t,
    n
  );
  if (Ye(e.originX) === Ye("center") || Ye(e.originX) === Ye("right") && s.x < 0 || Ye(e.originX) === Ye("left") && s.x > 0) {
    const { target: i } = e, a = i.strokeWidth / (i.strokeUniform ? i.scaleX : 1), c = pj(e) ? 2 : 1, u = i.width, h = Math.ceil(
      Math.abs(s.x * c / i.scaleX) - a
    );
    if (e.corner === "mr") {
      const d = i.trim.to, p = h - u, g = di(p, i.tScale), v = d + g;
      if (v > i.duration) return !1;
      i.set("width", Math.max(h, 0)), i.trim.to = v;
    } else {
      if (i.left < 0) return !1;
      const d = u - h;
      if (i.left + d < 0)
        return i.set("width", i.width + i.left), !0;
      const p = h - u, g = i.trim.from, v = di(p, i.tScale), b = g - v;
      if (b < 0) return !1;
      i.set("width", Math.max(h, 0)), i.trim.from = b;
    }
    return u !== i.width;
  }
  return !1;
};
function pj(r) {
  return Ye(r.originX) === Ye("center") && Ye(r.originY) === Ye("center");
}
const ty = hj(
  "resizing",
  Ax(fj)
);
class zl extends Ft {
  static type = "TransitionGuide";
  static ownDefaults = {
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 1.5,
    fill: "rgba(0,0,0,0.85)",
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    lockMovementX: !0,
    lockMovementY: !0,
    duration: 1500,
    rx: 8,
    ry: 8
  };
  tScale;
  duration = 0;
  fromId;
  toId;
  itemType = "none";
  isSelected = !1;
  id;
  constructor(e) {
    super(e), Object.assign(this, zl.ownDefaults), this.id = e.id;
  }
  static createControls() {
    return {
      controls: gj()
    };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...zl.ownDefaults
    };
  }
  updateCoords() {
    const e = this.canvas;
    if (!e) return;
    const t = e.getObjects().find((i) => i.id === this.fromId);
    if (!t) return;
    const n = Nt(this.duration, this.tScale), s = t.left + t.width - n / 2;
    this.set({
      width: n,
      left: s
    });
  }
  _render(e) {
    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);
  }
  drawTextIdentity(e) {
    const t = new Path2D(
      "M3 5.30359C3 3.93159 4.659 3.24359 5.629 4.21359L11.997 10.5826L10.583 11.9966L5 6.41359V17.5856L10.586 11.9996L10.583 11.9966L11.997 10.5826L12 10.5856L18.371 4.21459C19.341 3.24459 21 3.93159 21 5.30359V18.6956C21 20.0676 19.341 20.7556 18.371 19.7856L12 13.5L13.414 11.9996L19 17.5866V6.41359L13.414 11.9996L13.421 12.0056L12.006 13.4206L12 13.4136L5.629 19.7846C4.659 20.7546 3 20.0676 3 18.6956V5.30359Z"
    );
    e.save(), e.translate(-12, -12), e.fillStyle = "#ffffff", e.fill(t), e.restore();
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = 1, e.strokeStyle = "rgba(255, 255, 255,1.0)", e.stroke(), e.restore());
  }
}
function gj() {
  return {
    mr: new Ct({
      x: 0.5,
      y: 0,
      actionHandler: Bl,
      cursorStyleHandler: hr.scaleSkewCursorStyleHandler,
      actionName: "resizing",
      render: ry
    }),
    ml: new Ct({
      x: -0.5,
      y: 0,
      actionHandler: Bl,
      cursorStyleHandler: hr.scaleSkewCursorStyleHandler,
      actionName: "resizing",
      render: ry
    })
  };
}
function ry(r, e, t, n, s) {
  r.save(), r.translate(e, t), r.rotate(ax.degreesToRadians(90 + s.angle)), r.lineWidth = 6, r.lineCap = "round", r.strokeStyle = "white", r.beginPath(), r.moveTo(-6, 0), r.lineTo(6, 0), r.stroke(), r.lineWidth = 4, r.strokeStyle = "black", r.beginPath(), r.moveTo(-6, 0), r.lineTo(6, 0), r.stroke(), r.restore();
}
class Wl extends Ft {
  static type = "PreviewTrackItem";
  static ownDefaults = {
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 0,
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    rx: 4,
    ry: 4
  };
  duration = 0;
  fromId = "";
  toId = "";
  isSelected = !1;
  name;
  durationString;
  id;
  constructor(e) {
    super(e), Object.assign(this, Wl.ownDefaults), this.id = e.id, this.name = e.name || "item", this.durationString = "00:05", this.fill = "#27272a";
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...Wl.ownDefaults
    };
  }
  _render(e) {
    e.save(), super._render(e), e.beginPath(), e.rect(-this.width / 2, -this.height / 2, this.width, this.height), e.clip(), this.drawTextIdentity(e), e.restore();
  }
  drawTextIdentity(e) {
    e.font = "600 12px 'Geist variable'", e.textAlign = "left";
    const u = e.measureText(this.name).width, h = e.measureText(this.durationString).width, d = -this.height / 2 + 4, p = -this.width / 2, g = p + u + 8 * 2 + 4, v = u + 8 * 2;
    this.drawRoundedRect(
      e,
      p,
      d,
      v,
      20,
      4
    ), e.fillStyle = "#f4f4f5", e.fillText(this.name, p + 8, d + 12 + 2);
    const b = h + 8 * 2;
    this.drawRoundedRect(
      e,
      g,
      d,
      b,
      20,
      4
    ), e.fillStyle = "#f4f4f5", e.fillText(
      this.durationString,
      g + 8,
      d + 12 + 2
    );
  }
  drawRoundedRect(e, t, n, s, i, a) {
    e.fillStyle = "rgba(0, 0, 0, 0.5)", e.roundRect ? (e.beginPath(), e.roundRect(t, n, s, i, a), e.fill()) : e.fillRect(t, n, s, i);
  }
}
function mj(r, e) {
  e.forEach((t) => {
    Object.getOwnPropertyNames(t.prototype).forEach((n) => {
      if (n !== "constructor") {
        const s = Object.getOwnPropertyDescriptor(
          t.prototype,
          n
        );
        s && Object.defineProperty(r.prototype, n, s);
      }
    });
  });
}
const Dp = (r, e) => {
  const t = {
    x: r.size.width / 2,
    y: r.size.height / 2
  }, n = {
    x: e.width / 2,
    y: e.height / 2
  }, s = t.x - n.x, i = t.y - n.y, a = Math.min(
    r.size.width / e.width,
    r.size.height / e.height
  );
  return {
    top: `${i}px`,
    left: `${s}px`,
    transform: `scale(${a})`
  };
}, vj = (r) => new Promise((e, t) => {
  const n = new Audio();
  n.preload = "auto", n.addEventListener("loadedmetadata", () => {
    const s = n.duration * 1e3;
    e({
      duration: s
    });
  }), n.addEventListener("error", (s) => {
    t(s);
  }), n.src = r, n.crossOrigin = "anonymous", n.load();
}), yj = (r) => new Promise((e, t) => {
  const n = new Image();
  console.warn("Consider updating CDN config for CORS issues?"), n.onload = () => {
    const s = n.width, i = n.height;
    e({ width: s, height: i });
  }, n.onerror = (s) => {
    t(s);
  }, n.crossOrigin = "anonymous", n.src = r;
}), bj = (r) => new Promise((e, t) => {
  const n = document.createElement("video");
  n.preload = "auto", n.addEventListener("loadedmetadata", () => {
    const s = n.duration * 1e3, i = n.videoWidth, a = n.videoHeight;
    e({
      duration: s,
      width: i,
      height: a
    });
  }), n.addEventListener("error", (s) => {
    t(s);
  }), n.src = r, n.load();
}), ml = (r, e) => {
  const t = document.createElement("div");
  Object.keys(e).forEach((s) => {
    s !== "height" && (t.style[s] = e[s]);
  }), document.body.appendChild(t), t.textContent = r, t.style.width = `${e.width}px`, t.style.fontSize = `${e.fontSize}px`;
  const n = getComputedStyle(t).height;
  return document.body.removeChild(t), parseFloat(n);
}, Nn = (r) => Object.keys(r).reduce((e, t) => {
  const {
    display: { to: n }
  } = r[t];
  return Math.max(e, n);
}, 0), wj = (r, e) => {
  if (!r)
    return {
      from: 0,
      to: e.duration
    };
  const { from: t, to: n } = r;
  return {
    from: t ?? 0,
    to: n ?? e.duration
  };
}, xj = (r, e) => {
  const { duration: t, trim: n } = e, s = n ? n.to - n.from : t || 5e3, i = {
    from: 0,
    to: s
  };
  if (!r)
    return i;
  if (r.from !== void 0 && r.from < 0)
    return console.error(
      "'from' must be a non-negative number. Returning default display."
    ), i;
  if (r.from !== void 0 && r.to === void 0)
    return {
      from: r.from,
      to: r.from + s
    };
  if (r.to !== void 0) {
    if (r.to < 0)
      return console.error(
        "'to' must be a non-negative number. Returning default display."
      ), i;
    if (r.to < r.from)
      return console.error(
        "'to' must be greater than or equal to 'from'. Returning default display."
      ), i;
  }
  return r;
};
function _j(r, e) {
  return r.map((t) => {
    const n = t.items.filter(
      (s) => !e.includes(s)
    );
    return { ...t, items: n };
  }).filter((t) => t.items.length > 0);
}
const Sj = async (r, e) => {
  const t = r.details, n = await yj(t.src), s = Dp(e, n);
  return {
    id: r.id,
    type: "image",
    name: "",
    display: {
      from: e.origin || 0,
      to: (e.origin || 5e3) + 5e3
    },
    details: {
      src: t.src || "",
      width: t.width || n.width || 100,
      height: t.height || n.height || 100,
      opacity: t.opacity ?? 100,
      transform: s.transform,
      border: t.border || "none",
      borderRadius: t.borderRadius || "0",
      boxShadow: t.boxShadow || "none",
      top: s.top || "0px",
      left: s.left || "0px"
    },
    metadata: r.metadata || {}
  };
}, Cj = async (r, e) => {
  const t = r.details.src, n = await bj(t), s = Dp(e, {
    ...n
  }), i = wj(r.trim, { duration: n.duration }), a = {
    width: n.width,
    height: n.height,
    duration: n.duration,
    src: t,
    volume: r.details.volume ?? 100,
    top: r.details.top || s.top || "0px",
    left: r.details.left || s.left || "0px",
    text: r.details.text
    // Default volume
  };
  return {
    ...r,
    trim: i,
    type: "video",
    details: a,
    display: xj(r?.display, {
      duration: n.duration,
      trim: i
    })
  };
}, Tj = async (r) => {
  const e = r.details, t = (await vj(e.src)).duration, n = r?.display?.from ?? 0;
  return {
    id: r.id,
    name: "",
    type: "audio",
    display: {
      from: n,
      to: n + t
    },
    trim: {
      from: 0,
      to: t
    },
    details: {
      src: e.src,
      duration: t,
      volume: e.volume ?? 100,
      text: e.text
      // Default volume
    },
    metadata: {
      ...r.metadata
    }
  };
}, Ej = 5e3, Ix = async (r, e) => {
  const t = r.id;
  await h5([
    {
      fontFamily: r.details.fontFamily ?? "",
      fontUrl: r.details.fontUrl ?? ""
    }
  ]);
  const n = {
    fontFamily: r.details.fontFamily ?? "Arial",
    fontSize: r.details.fontSize ?? "16px",
    fontWeight: r.details.fontWeight ?? "normal",
    fontStyle: r.details.fontStyle ?? "normal",
    textDecoration: r.details.textDecoration ?? "none",
    textAlign: r.details.textAlign ?? "left",
    lineHeight: r.details.lineHeight ?? "normal",
    letterSpacing: r.details.letterSpacing ?? "normal",
    wordSpacing: r.details.wordSpacing ?? "normal",
    color: r.details.color ?? "#ffffff",
    backgroundColor: r.details.backgroundColor ?? "transparent",
    border: r.details.border ?? "none",
    textShadow: r.details.textShadow ?? "none",
    text: r.details.text ?? "",
    opacity: r.details.opacity ?? 100,
    width: r.details.width ?? 300,
    wordWrap: r.details.wordWrap ?? "normal",
    wordBreak: r.details.wordBreak ?? "normal",
    WebkitTextStrokeColor: r.details.WebkitTextStrokeColor ?? "#ffffff",
    WebkitTextStrokeWidth: r.details.WebkitTextStrokeWidth ?? "0px",
    top: r.details.top ?? "0px",
    left: r.details.left ?? "0px"
  }, s = ml(r.details.text ?? "", n), i = Dp(e, {
    width: n.width ?? 0,
    height: s
  });
  return {
    id: t,
    name: "",
    type: "text",
    display: {
      from: 0,
      to: Ej
    },
    details: {
      ...n,
      height: s,
      top: i.top,
      left: i.left,
      fontUrl: r.details.fontUrl,
      text: r.details.text ?? ""
    },
    metadata: {}
  };
}, kj = (r, e) => {
  const t = r.display, n = Nt(t.from, e.tScale), s = Nt(t.to - t.from, e.tScale), i = le.getClass("Audio") || Ts;
  return new i({
    width: s,
    height: 42,
    top: 10,
    left: n,
    id: r.id,
    display: t,
    text: r.details.text,
    trim: r.trim || {
      from: 0,
      to: r.details.duration
    },
    duration: r.details.duration,
    src: r.details.src,
    tScale: e.tScale
  });
}, Oj = (r, e) => {
  const t = Nt(r.display.from, e.tScale), n = Nt(r.details.duration || 5e3, e.tScale), s = le.getClass("Image") || Pp;
  return new s({
    width: n,
    height: 42,
    id: r.id,
    src: r.details.src,
    tScale: e.tScale,
    top: 10,
    left: t,
    display: r.display
  });
}, Mj = (r, e) => {
  const t = Nt(r.trim.from, e.tScale), n = Nt(r.trim.to - r.trim.from, e.tScale), s = le.getClass("Video") || Io;
  return new s({
    width: n,
    height: 42,
    id: r.id,
    tScale: e.tScale,
    fill: "#333333",
    top: 10,
    left: t,
    display: r.trim,
    trim: r.trim,
    text: r.details.text
  });
}, Aj = (r, e) => {
  const t = r.display, n = Nt(t.from, e.tScale), s = Nt(t.to - t.from, e.tScale), i = le.getClass("Text") || fo;
  return new i({
    width: s,
    height: 42,
    id: r.id,
    display: t,
    top: 10,
    left: n,
    text: r.details.text,
    tScale: e.tScale
  });
}, Ij = {
  video: 42,
  image: 42,
  audio: 42,
  text: 42,
  caption: 42,
  template: 42
}, Pj = (r = {}) => {
  const e = { ...Ij, ...r };
  return Object.fromEntries(
    Object.entries(e).filter(([, t]) => typeof t == "number")
  );
};
let Dj = class extends Ts {
  static type = "Audio";
  text;
  constructor(e) {
    super(e), this.text = e.text ?? "Audio";
  }
  _render(e) {
    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);
  }
  drawTextIdentity(e) {
    const t = new Path2D(
      "M8.24092 0C8.24092 2.51565 10.2795 4.55419 12.7951 4.55419C12.9677 4.55419 13.1331 4.62274 13.2552 4.74475C13.3772 4.86676 13.4457 5.03224 13.4457 5.20479C13.4457 5.37734 13.3772 5.54282 13.2552 5.66483C13.1331 5.78685 12.9677 5.85539 12.7951 5.85539C11.9218 5.85605 11.0594 5.66105 10.2713 5.28471C9.48319 4.90838 8.78942 4.36027 8.24092 3.68066V13.8794C8.24094 14.8271 7.91431 15.7458 7.31606 16.4808C6.71781 17.2157 5.88451 17.722 4.95657 17.9143C4.02863 18.1066 3.06276 17.9731 2.22172 17.5364C1.38067 17.0997 0.715856 16.3865 0.339286 15.5169C-0.0372842 14.6473 -0.10259 13.6744 0.154372 12.7622C0.411334 11.8501 0.974857 11.0544 1.74999 10.5092C2.52512 9.96403 3.46449 9.7027 4.40981 9.76924C5.35512 9.83579 6.24861 10.2261 6.93972 10.8745V0H8.24092ZM6.93972 13.8794C6.93972 13.1317 6.6427 12.4146 6.11398 11.8859C5.58527 11.3572 4.86818 11.0602 4.12046 11.0602C3.37275 11.0602 2.65566 11.3572 2.12694 11.8859C1.59823 12.4146 1.3012 13.1317 1.3012 13.8794C1.3012 14.6272 1.59823 15.3443 2.12694 15.873C2.65566 16.4017 3.37275 16.6987 4.12046 16.6987C4.86818 16.6987 5.58527 16.4017 6.11398 15.873C6.6427 15.3443 6.93972 14.6272 6.93972 13.8794Z"
    );
    e.save(), e.translate(-this.width / 2, -this.height / 2), e.translate(0, 10), e.font = "600 12px 'Geist variable'", e.fillStyle = "#f4f4f5", e.textAlign = "left", e.clip(), e.fillText(this.text, 36, 14), e.translate(10, 1), e.fillStyle = "#f4f4f5", e.fill(t), e.restore();
  }
};
class Rj extends Io {
  static type = "Video";
  text;
  constructor(e) {
    super(e), this.text = e.text ?? "Video";
  }
  _render(e) {
    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);
  }
  drawTextIdentity(e) {
    const t = new Path2D(
      "M16.5625 0.925L12.5 3.275V0.625L11.875 0H0.625L0 0.625V9.375L0.625 10H11.875L12.5 9.375V6.875L16.5625 9.2125L17.5 8.625V1.475L16.5625 0.925ZM11.25 8.75H1.25V1.25H11.25V8.75ZM16.25 7.5L12.5 5.375V4.725L16.25 2.5V7.5Z"
    );
    e.save(), e.translate(-this.width / 2, -this.height / 2), e.translate(0, 14), e.font = "600 12px 'Geist variable'", e.fillStyle = "#f4f4f5", e.textAlign = "left", e.clip(), e.fillText(this.text, 36, 10), e.translate(8, 1), e.fillStyle = "#f4f4f5", e.fill(t), e.restore();
  }
}
class Px extends fo {
  static type = "Text";
  constructor(e) {
    super(e), this.fill = "#303030";
  }
  _render(e) {
    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);
  }
  drawTextIdentity(e) {
    const t = new Path2D(
      "M6.23982 0.361968C6.18894 0.253743 6.10832 0.162234 6.00736 0.0981357C5.9064 0.034038 5.78929 0 5.6697 0C5.55012 0 5.433 0.034038 5.33204 0.0981357C5.23109 0.162234 5.15046 0.253743 5.09959 0.361968L0.0599035 11.0713C0.0246926 11.1462 0.00457285 11.2272 0.000693114 11.3099C-0.00318662 11.3925 0.00924959 11.4751 0.0372917 11.553C0.0939253 11.7102 0.210687 11.8384 0.361891 11.9095C0.513095 11.9806 0.686354 11.9888 0.843555 11.9322C1.00076 11.8755 1.12902 11.7588 1.20013 11.6075L2.51202 8.81998H8.82738L10.1393 11.6075C10.1745 11.6824 10.2241 11.7496 10.2853 11.8053C10.3465 11.861 10.418 11.9041 10.4958 11.9322C10.5737 11.9602 10.6563 11.9726 10.7389 11.9687C10.8216 11.9649 10.9026 11.9447 10.9775 11.9095C11.0524 11.8743 11.1196 11.8247 11.1753 11.7635C11.231 11.7023 11.2741 11.6308 11.3021 11.553C11.3302 11.4751 11.3426 11.3925 11.3387 11.3099C11.3348 11.2272 11.3147 11.1462 11.2795 11.0713L6.23982 0.361968ZM3.10498 7.56005L5.6697 2.11011L8.23443 7.56005H3.10498ZM15.1191 3.78029C14.1143 3.78029 13.3292 4.05354 12.7859 4.59294C12.6721 4.71153 12.6092 4.86987 12.6106 5.03419C12.6119 5.19851 12.6774 5.3558 12.7931 5.4725C12.9088 5.58921 13.0655 5.6561 13.2298 5.6589C13.3941 5.6617 13.553 5.60018 13.6726 5.48748C13.9718 5.19062 14.46 5.04021 15.1191 5.04021C16.1609 5.04021 17.009 5.74892 17.009 6.61511V6.86867C16.45 6.49465 15.7917 6.29663 15.1191 6.30013C13.382 6.30013 11.9693 7.57187 11.9693 9.13495C11.9693 10.698 13.382 11.9698 15.1191 11.9698C15.792 11.9727 16.4503 11.7739 17.009 11.3989C17.0168 11.566 17.0907 11.7231 17.2144 11.8357C17.3381 11.9483 17.5014 12.0071 17.6685 11.9993C17.8356 11.9915 17.9927 11.9176 18.1053 11.7939C18.2179 11.6702 18.2767 11.5069 18.2689 11.3398V6.61511C18.2689 5.05202 16.8562 3.78029 15.1191 3.78029ZM15.1191 10.7099C14.0773 10.7099 13.2292 10.0012 13.2292 9.13495C13.2292 8.26876 14.0773 7.56005 15.1191 7.56005C16.1609 7.56005 17.009 8.26876 17.009 9.13495C17.009 10.0012 16.1609 10.7099 15.1191 10.7099Z"
    );
    e.save(), e.translate(-this.width / 2, -this.height / 2), e.translate(0, 12), e.font = "600 12px 'Geist variable'", e.fillStyle = "#f4f4f5", e.textAlign = "left", e.clip(), e.fillText(this.text, 36, 12), e.translate(8, 1), e.fillStyle = "#f4f4f5", e.fill(t), e.restore();
  }
}
let jj = class extends Pp {
  static type = "Image";
  text;
  constructor(e) {
    super(e), this.text = e.text ?? "Image";
  }
  _render(e) {
    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);
  }
  drawTextIdentity(e) {
    const t = new Path2D(
      "M1.55556 0H14.4444C15.3031 0 16 0.696889 16 1.55556V14.4444C16 14.857 15.8361 15.2527 15.5444 15.5444C15.2527 15.8361 14.857 16 14.4444 16H1.55556C1.143 16 0.747335 15.8361 0.455612 15.5444C0.163889 15.2527 0 14.857 0 14.4444V1.55556C0 0.696889 0.696889 0 1.55556 0ZM14.4444 1.33333H1.55556C1.49662 1.33333 1.4401 1.35675 1.39842 1.39842C1.35675 1.4401 1.33333 1.49662 1.33333 1.55556V14.4444C1.33333 14.5671 1.43289 14.6667 1.55556 14.6667H1.72444L10.456 5.93511C10.6004 5.79065 10.7719 5.67605 10.9607 5.59787C11.1494 5.51968 11.3517 5.47944 11.556 5.47944C11.7603 5.47944 11.9626 5.51968 12.1513 5.59787C12.3401 5.67605 12.5116 5.79065 12.656 5.93511L14.6667 7.94578V1.55556C14.6667 1.49662 14.6433 1.4401 14.6016 1.39842C14.5599 1.35675 14.5034 1.33333 14.4444 1.33333ZM14.6667 9.83111L11.7129 6.87733C11.6922 6.85664 11.6677 6.84022 11.6407 6.82902C11.6137 6.81781 11.5848 6.81205 11.5556 6.81205C11.5263 6.81205 11.4974 6.81781 11.4704 6.82902C11.4434 6.84022 11.4189 6.85664 11.3982 6.87733L3.60978 14.6667H14.4444C14.5034 14.6667 14.5599 14.6433 14.6016 14.6016C14.6433 14.5599 14.6667 14.5034 14.6667 14.4444V9.83111ZM4.88889 7.11111C4.29952 7.11111 3.73429 6.87699 3.31754 6.46024C2.90079 6.04349 2.66667 5.47826 2.66667 4.88889C2.66667 4.29952 2.90079 3.73429 3.31754 3.31754C3.73429 2.90079 4.29952 2.66667 4.88889 2.66667C5.47826 2.66667 6.04349 2.90079 6.46024 3.31754C6.87699 3.73429 7.11111 4.29952 7.11111 4.88889C7.11111 5.47826 6.87699 6.04349 6.46024 6.46024C6.04349 6.87699 5.47826 7.11111 4.88889 7.11111ZM4.88889 5.77778C5.12464 5.77778 5.35073 5.68413 5.51743 5.51743C5.68413 5.35073 5.77778 5.12464 5.77778 4.88889C5.77778 4.65314 5.68413 4.42705 5.51743 4.26035C5.35073 4.09365 5.12464 4 4.88889 4C4.65314 4 4.42705 4.09365 4.26035 4.26035C4.09365 4.42705 4 4.65314 4 4.88889C4 5.12464 4.09365 5.35073 4.26035 5.51743C4.42705 5.68413 4.65314 5.77778 4.88889 5.77778Z"
    );
    e.save(), e.translate(-this.width / 2, -this.height / 2), e.translate(0, 12), e.font = "600 12px 'Geist variable'", e.fillStyle = "#f4f4f5", e.textAlign = "left", e.clip(), e.fillText(this.text, 36, 12), e.translate(8, 1), e.fillStyle = "#f4f4f5", e.fill(t), e.restore();
  }
};
class Lj extends mi {
  static type = "Track";
  constructor(e) {
    super(e), this.fill = "#18181b";
  }
  _render(e) {
    super._render(e);
    const t = new Path2D(
      "M14.4444 13.3263H11.0667C12.5384 12.3991 13.6259 10.9716 14.1289 9.30644C14.632 7.64131 14.5169 5.85051 13.8048 4.26348C13.0927 2.67645 11.8314 1.39993 10.2531 0.668736C8.67478 -0.0624548 6.8855 -0.199136 5.21442 0.283835C3.54334 0.766806 2.10285 1.83695 1.15794 3.2974C0.213035 4.75785 -0.172743 6.51038 0.0715766 8.23261C0.315896 9.95484 1.17388 11.5309 2.4877 12.671C3.80151 13.811 5.4828 14.4383 7.22227 14.4374H14.4444C14.5918 14.4374 14.7331 14.3789 14.8373 14.2747C14.9415 14.1705 15 14.0292 15 13.8819C15 13.7345 14.9415 13.5932 14.8373 13.489C14.7331 13.3848 14.5918 13.3263 14.4444 13.3263ZM1.1112 7.21523C1.1112 6.00658 1.46961 4.82506 2.14111 3.8201C2.8126 2.81514 3.76702 2.03187 4.88367 1.56934C6.00032 1.10681 7.22905 0.985789 8.41449 1.22159C9.59992 1.45738 10.6888 2.03941 11.5435 2.89405C12.3981 3.7487 12.9801 4.83759 13.2159 6.02302C13.4517 7.20845 13.3307 8.43719 12.8682 9.55384C12.4056 10.6705 11.6224 11.6249 10.6174 12.2964C9.61244 12.9679 8.43093 13.3263 7.22227 13.3263C5.60208 13.3245 4.04878 12.68 2.90313 11.5344C1.75748 10.3887 1.11304 8.83542 1.1112 7.21523ZM7.22227 5.54858C7.55191 5.54858 7.87414 5.45083 8.14822 5.2677C8.4223 5.08456 8.63592 4.82426 8.76206 4.51972C8.88821 4.21518 8.92121 3.88007 8.85691 3.55677C8.7926 3.23347 8.63386 2.9365 8.40078 2.70342C8.16769 2.47033 7.87072 2.3116 7.54742 2.24729C7.22412 2.18298 6.88901 2.21599 6.58447 2.34213C6.27993 2.46828 6.01964 2.6819 5.8365 2.95598C5.65337 3.23006 5.55562 3.55229 5.55562 3.88192C5.55562 4.32395 5.73121 4.74787 6.04377 5.06043C6.35633 5.37298 6.78025 5.54858 7.22227 5.54858ZM7.22227 3.32637C7.33215 3.32637 7.43956 3.35895 7.53092 3.42C7.62228 3.48104 7.69349 3.56781 7.73554 3.66932C7.77759 3.77084 7.78859 3.88254 7.76715 3.9903C7.74572 4.09807 7.6928 4.19706 7.61511 4.27476C7.53741 4.35245 7.43842 4.40536 7.33066 4.4268C7.22289 4.44824 7.11119 4.43723 7.00967 4.39519C6.90816 4.35314 6.82139 4.28193 6.76035 4.19057C6.69931 4.09921 6.66672 3.9918 6.66672 3.88192C6.66672 3.73458 6.72525 3.59327 6.82944 3.48909C6.93363 3.3849 7.07493 3.32637 7.22227 3.32637ZM8.88893 10.5485C8.88893 10.2189 8.79118 9.89668 8.60805 9.6226C8.42491 9.34852 8.16462 9.1349 7.86008 9.00875C7.55553 8.88261 7.22043 8.8496 6.89713 8.91391C6.57383 8.97822 6.27686 9.13695 6.04377 9.37004C5.81069 9.60313 5.65195 9.9001 5.58764 10.2234C5.52334 10.5467 5.55634 10.8818 5.68249 11.1863C5.80863 11.4909 6.02225 11.7512 6.29633 11.9343C6.57041 12.1175 6.89264 12.2152 7.22227 12.2152C7.6643 12.2152 8.08822 12.0396 8.40078 11.727C8.71334 11.4145 8.88893 10.9906 8.88893 10.5485ZM6.66672 10.5485C6.66672 10.4387 6.69931 10.3313 6.76035 10.2399C6.82139 10.1485 6.90816 10.0773 7.00967 10.0353C7.11119 9.99323 7.22289 9.98223 7.33066 10.0037C7.43842 10.0251 7.53741 10.078 7.61511 10.1557C7.6928 10.2334 7.74572 10.3324 7.76715 10.4402C7.78859 10.5479 7.77759 10.6596 7.73554 10.7611C7.69349 10.8627 7.62228 10.9494 7.53092 11.0105C7.43956 11.0715 7.33215 11.1041 7.22227 11.1041C7.07493 11.1041 6.93363 11.0456 6.82944 10.9414C6.72525 10.8372 6.66672 10.6959 6.66672 10.5485ZM10.5556 8.88189C10.8852 8.88189 11.2074 8.78414 11.4815 8.60101C11.7556 8.41787 11.9692 8.15758 12.0954 7.85303C12.2215 7.54849 12.2545 7.21338 12.1902 6.89008C12.1259 6.56678 11.9672 6.26982 11.7341 6.03673C11.501 5.80364 11.204 5.64491 10.8807 5.5806C10.5574 5.51629 10.2223 5.5493 9.91778 5.67544C9.61324 5.80159 9.35295 6.01521 9.16981 6.28929C8.98668 6.56337 8.88893 6.8856 8.88893 7.21523C8.88893 7.65726 9.06452 8.08118 9.37708 8.39374C9.68964 8.70629 10.1136 8.88189 10.5556 8.88189ZM10.5556 6.65968C10.6655 6.65968 10.7729 6.69226 10.8642 6.75331C10.9556 6.81435 11.0268 6.90112 11.0688 7.00263C11.1109 7.10415 11.1219 7.21585 11.1005 7.32362C11.079 7.43138 11.0261 7.53037 10.9484 7.60807C10.8707 7.68576 10.7717 7.73867 10.664 7.76011C10.5562 7.78155 10.4445 7.77054 10.343 7.7285C10.2415 7.68645 10.1547 7.61524 10.0937 7.52388C10.0326 7.43252 10 7.32511 10 7.21523C10 7.06789 10.0586 6.92658 10.1628 6.8224C10.2669 6.71821 10.4082 6.65968 10.5556 6.65968ZM3.88896 5.54858C3.55933 5.54858 3.2371 5.64633 2.96302 5.82946C2.68894 6.01259 2.47532 6.27289 2.34918 6.57743C2.22303 6.88197 2.19002 7.21708 2.25433 7.54038C2.31864 7.86368 2.47737 8.16065 2.71046 8.39374C2.94355 8.62682 3.24052 8.78556 3.56382 8.84986C3.88711 8.91417 4.22222 8.88117 4.52677 8.75502C4.83131 8.62888 5.0916 8.41526 5.27474 8.14118C5.45787 7.8671 5.55562 7.54487 5.55562 7.21523C5.55562 6.77321 5.38003 6.34929 5.06747 6.03673C4.75491 5.72417 4.33099 5.54858 3.88896 5.54858ZM3.88896 7.77078C3.77909 7.77078 3.67168 7.7382 3.58032 7.67716C3.48896 7.61611 3.41775 7.52935 3.3757 7.42783C3.33365 7.32632 3.32265 7.21462 3.34409 7.10685C3.36552 6.99908 3.41843 6.90009 3.49613 6.8224C3.57382 6.7447 3.67281 6.69179 3.78058 6.67036C3.88835 6.64892 4.00005 6.65992 4.10156 6.70197C4.20308 6.74402 4.28984 6.81522 4.35089 6.90658C4.41193 6.99794 4.44452 7.10535 4.44452 7.21523C4.44452 7.36257 4.38598 7.50388 4.2818 7.60807C4.17761 7.71225 4.03631 7.77078 3.88896 7.77078Z"
    );
    this.items.length || (e.save(), e.translate(-this.width / 2, -this.height / 2), e.translate(0, 12), e.font = "600 12px 'Geist variable'", e.fillStyle = "#A0A4A2", e.textAlign = "left", e.clip(), e.fillText("Drag and drop media here", 32, 12), e.translate(8, 1), e.fillStyle = "#A0A4A2", e.fill(t), e.restore());
  }
}
class Fj extends $a {
  static type = "Helper";
  constructor(e) {
    e.activeGuideFill = "#ffffff", super(e);
  }
}
class Nj {
  addTrackItem(e) {
    const t = e.id, n = vd(e, {
      tScale: this.tScale,
      sizesMap: this.sizesMap
    });
    this.add(n), this.trackItemIds.push(t), this.renderTracks(), this.alignItemsToTrack(), this.calcBounding(), this.duration = Nn(this.trackItemsMap);
  }
  alignItemsToTrack() {
    this.pauseEventListeners();
    const e = new Map(
      this.getObjects("Track").map((n) => [n.id, n])
    ), t = this.getObjects("Image", "Video", "Text", "Audio");
    this.trackItemIds.forEach((n) => {
      const s = this.tracks.find((c) => c.items.includes(n));
      if (!s) return;
      const i = e.get(s.id);
      this.duration;
      const a = this.getObjects().find((c) => c.id === n);
      a && i && (a.isMain = !1, this.trackItemsMap[n].isMain = !1, a.set({ top: i.top }), a.setCoords());
    }), e.forEach((n) => {
      n.items = t.filter((s) => s.top === n.top).map((s) => s.id);
    }), this.resumeEventListeners();
  }
  updateTrackItemsPosition() {
    const e = this.getObjects("Image", "Text", "Video", "Audio");
    e.sort((t, n) => t.top - n.top), this.trackItemIds = e.map((t) => t.id).reverse();
  }
  restoreTrackItemPositions() {
  }
  updateTrackItemsState() {
    this.pauseEventListeners();
    const e = this.getObjects("Image", "Video", "Text", "Audio"), t = {};
    e.forEach((n) => {
      const { id: s, left: i, width: a } = n, c = this.trackItemsMap[s], u = di(i, this.tScale), h = u + di(a, this.tScale), d = { from: u, to: h }, p = {
        ...c,
        display: d,
        trim: n instanceof Io || n instanceof Ts ? n.trim : void 0
      };
      n.display = d, t[s] = p;
    }), this.trackItemsMap = t, this.resumeEventListeners();
  }
  deleteActiveTrackItem() {
    const e = this.getActiveObjects();
    if (!e.length) return !1;
    const t = e.map((s) => s.id), n = xl(this.tracks, t);
    this.trackItemsMap = Object.keys(this.trackItemsMap).reduce((s, i) => (t.includes(i) || (s[i] = this.trackItemsMap[i]), s), {}), this.trackItemIds = this.trackItemIds.filter(
      (s) => !t.includes(s)
    ), this.tracks = n, this.discardActiveObject(), this.remove(...e), this.setActiveIds([]), this.renderTracks(), this.alignItemsToTrack(), this.updateState({ updateHistory: !0, kind: "remove" });
  }
  updateTrackItemsToHistory() {
    this.pauseEventListeners();
    const e = this.getObjects();
    this.trackItemIds.forEach((t) => {
      const n = this.tracks.find(
        (h) => h.items.includes(t)
      ), s = e.find(
        (h) => h.id === n?.id
      )?.top;
      if (!s) {
        console.warn(`Track top not found for trackItemId: ${t}`);
        return;
      }
      const i = this.trackItemsMap[t], a = e.find((h) => h.id === t);
      if (!a) {
        console.warn(`Object not found for trackItemId: ${t}`);
        return;
      }
      const c = Nt(i.display.from, this.tScale), u = Nt(
        i.display.to - i.display.from,
        this.tScale
      );
      a.set({ left: c, width: u, top: s }), a.setCoords();
    }), this.requestRenderAll(), this.resumeEventListeners();
  }
  cloneActiveTrackItem(e) {
    const t = e?.trackItemId || this.activeIds[0];
    if (!t) return !1;
    const s = {
      ...this.trackItemsMap[t],
      id: Yt()
    }, i = this.tracks.find(
      (d) => d.items.includes(t)
    ), a = this.tracks.findIndex((d) => d.id === i?.id) + 1;
    this.findOrCreateTrack(s, { trackIndex: a });
    const c = vd(s, {
      tScale: this.tScale
    });
    c && this.add(c);
    const { audioData: u, ...h } = s.metadata || {};
    s.metadata = h, this.trackItemsMap[s.id] = s, this.trackItemIds.push(s.id), this.alignItemsToTrack(), this.updateTransitions(), this.updateState();
  }
  splitActiveTrackItem(e) {
    const t = e.trackItemId ?? this.activeIds[0];
    if (!t || this.activeIds.length > 1) return !1;
    const n = this.trackItemsMap[t], s = e.time;
    if (n.display.from >= s || n.display.to <= s)
      return !1;
    const i = {
      ...n,
      display: { from: n.display.from, to: s }
    }, a = {
      ...n,
      display: { from: s, to: n.display.to },
      id: Yt()
    };
    if (n.type === "video" || n.type === "audio") {
      const d = s - i.display.from;
      i.trim = {
        from: n.trim.from,
        to: n.trim.from + d
      }, a.trim = {
        from: i.trim.to,
        to: n.trim.to
      };
    }
    const c = this.getObjects().find(
      (d) => d.id === t
    );
    c.display = i.display, this.tracks.find(
      (d) => d.items.includes(t)
    )?.items.push(a.id);
    const h = vd(a, {
      tScale: this.tScale
    });
    h && this.add(h), this.trackItemsMap[a.id] = a, this.trackItemsMap[t] = i, this.trackItemIds.push(a.id), this.updateTrackItemCoords(i.id), this.alignItemsToTrack(), this.updateTransitions(), this.updateState();
  }
  updateTrackItemCoords(e) {
    const t = this.getObjects().find((a) => a.id === e), n = this.trackItemsMap[e], s = Nt(n.display.from, this.tScale), i = Nt(
      n.display.to - n.display.from,
      this.tScale
    );
    t?.set({ left: s, width: i }), t?.setCoords();
  }
  updateTrackItemDetails(e, t) {
    const n = t?.trackItemId;
    if (!n) return !1;
    const s = this.trackItemsMap[n], i = { ...s.details, ...e.details };
    ("fontSize" in i || "lineHeight" in i) && (i.height = ml(
      i.text,
      i
    )), this.trackItemsMap[n] = {
      ...s,
      ...e,
      details: i
    }, this.updateState();
  }
  updateTrackItem(e, t) {
    const n = t.trackItemId;
    if (!n) return !1;
    const s = this.trackItemsMap[n], i = { ...s.details, ...e.details };
    if (s.type === "text" && e.details.text) {
      const a = this.getObjects("Text").find(
        (c) => c.id === n
      );
      a instanceof Px && (a.text = e.details.text, this.requestRenderAll());
    }
    ("fontSize" in i || "lineHeight" in i) && (i.height = ml(
      i.text,
      i
    )), this.trackItemsMap[n] = {
      ...s,
      ...e,
      details: i
    }, this.updateState();
  }
  updateTrackItemsDetails(e, t) {
    t?.trackItemIds?.forEach((n, s) => {
      const i = this.trackItemsMap[n], a = {
        ...i.details,
        ...e[s].details
      };
      ("fontSize" in a || "lineHeight" in a) && (a.height = ml(
        a.text,
        a
      )), this.trackItemsMap[n] = {
        ...i,
        ...e[s],
        details: a
      };
    }), this.updateState();
  }
  getTrackItems() {
    return this.getObjects(...Bj);
  }
  setActiveTrackItemCoords() {
    this.getActiveObjects().forEach((e) => e.setCoords());
  }
  deleteTrackItemById(e) {
    const t = this.getObjects().filter(
      (n) => e.includes(n.id)
    );
    this.tracks = xl(this.tracks, e), this.trackItemsMap = Object.keys(this.trackItemsMap).filter((n) => !e.includes(n)).reduce((n, s) => (n[s] = this.trackItemsMap[s], n), {}), this.trackItemIds = this.trackItemIds.filter((n) => !e.includes(n)), this.discardActiveObject(), this.remove(...t), this.renderTracks(), this.alignItemsToTrack(), this.calcBounding(), this.duration = Nn(this.trackItemsMap);
  }
  selectTrackItemByIds(e) {
    const t = this.getActiveObjects().map((s) => s.id);
    if (st.isEqual(t, e)) return;
    const n = this.getTrackItems().filter(
      (s) => e.includes(s.id)
    );
    if (n.length === 0)
      this.discardActiveObject();
    else if (n.length === 1)
      this.setActiveObject(n[0]);
    else {
      const s = new Dn(n);
      this.setActiveObject(s);
    }
    this.requestRenderAll();
  }
}
const Bj = ["Image", "Text", "Video", "Audio", "Caption", "Template"], vd = (r, e) => {
  const n = {
    text: Aj,
    video: Mj,
    image: Oj,
    audio: kj
  }[r.type];
  return n(r, e);
}, Qi = {
  text: 32,
  image: 40,
  video: 40,
  audio: 32,
  main: 40
}, ny = (r) => {
  switch (r) {
    case "text":
      return Qi.text;
    case "image":
      return Qi.image;
    case "video":
      return Qi.video;
    case "audio":
      return Qi.audio;
    case "helperTop":
      return 40;
    case "helperBottom":
      return 40;
    case "helperCenter":
      return 8;
    case "main":
      return Qi.main;
    default:
      return Qi.text;
  }
};
class Vj {
  // Метод для нахождения или создания нового трека
  findOrCreateTrack(e, { trackId: t, trackIndex: n }) {
    const s = t;
    if (s) {
      const a = this.tracks.find((c) => c.id === s);
      if (a)
        return a.items.push(e.id), s;
    }
    const i = {
      id: Yt(),
      // Генерация уникального ID
      items: [e.id],
      type: e.type,
      accepts: this.acceptsMap?.[e.type]
    };
    return n !== void 0 ? this.tracks.splice(n, 0, i) : this.tracks.push(i), this.renderTracks(), i.id;
  }
  // Метод для удаления всех треков и вспомогательных объектов
  removeTracks() {
    this.getObjects("Track", "Helper")?.forEach((e) => this.remove(e));
  }
  // Метод для отображения треков
  renderTracks() {
    this.updateTracksState(), this.removeTracks();
    const e = this.width, t = this.tracks.flatMap((c) => [
      c,
      {
        id: `after-${c.id}`,
        type: "helper",
        items: [],
        accepts: []
      }
    ]).slice(0, -1);
    let n = 0;
    const s = le.getClass("Helper") || $a, i = new s({
      id: "helperLineTop",
      top: n,
      selectable: !1,
      evented: !1,
      tScale: this.tScale,
      width: e,
      kind: "top",
      metadata: {}
    });
    n += ny("helperTop"), this.insertAt(0, i), t.forEach((c, u) => {
      if (c.type === "helper") {
        const h = ny("helperCenter"), d = new s({
          id: c.id,
          top: n,
          tScale: this.tScale,
          width: e,
          height: h,
          metadata: { order: (u + 1) / 2 },
          kind: "center"
        });
        n += h, this.insertAt(0, d);
      } else {
        const h = le.getClass("Track") || mi, d = new h({
          id: c.id,
          top: n,
          left: 0,
          fill: "#18181b",
          height: 42,
          width: e,
          tScale: this.tScale,
          accepts: this.acceptsMap?.[c.type] || [],
          items: c.items
        });
        n += 42, this.insertAt(0, d);
      }
    });
    const a = new s({
      id: "helperLineBottom",
      top: n,
      selectable: !1,
      evented: !1,
      tScale: this.tScale,
      width: e,
      kind: "bottom",
      metadata: {}
    });
    this.insertAt(0, a);
  }
  // Метод для обновления состояния треков
  updateTracksState() {
    const e = this.tracks.filter(
      (n) => n.items.length || n.type === "main"
    ), t = /* @__PURE__ */ new Map();
    e.forEach((n) => t.set(n.id, n)), this.tracks = Array.from(t.values());
  }
  // Метод для обновления координат треков
  updateTrackCoords() {
    const e = this.bounding.width + this.spacing.right;
    this.getObjects("Track", "Helper").forEach((t) => {
      t.updateCoords(e), t.setCoords();
    });
  }
}
const zj = 60, Wj = 188;
function sy(r, e = 1, t = 1) {
  const n = Wj * e;
  return r * (zj / 1e3) * n / t;
}
class Hj {
  // Удаление всех переходов
  removeTransitions() {
    const e = this.getObjects("Transition");
    this.remove(...e);
  }
  // Рендеринг переходов
  renderTransitions() {
    this.removeTransitions(), this.transitionIds.forEach((e) => {
      const t = this.transitionsMap[e], n = t.fromId, s = t.toId, i = this.getObjects(), a = i.find((g) => g.id === n), c = i.find((g) => g.id === s);
      if (!a || !c) return;
      const u = sy(t.duration, this.tScale), h = a.left + a.width - u / 2, d = a.height, p = new Sn({
        id: t.id,
        left: h,
        top: a.top,
        height: d,
        width: u,
        tScale: this.tScale,
        duration: t.duration,
        fromId: a.id,
        toId: c.id,
        kind: t.kind
      });
      t.kind === "none" && (p.visible = !1), this.add(p);
    });
  }
  // Обновление координат переходов
  updateTransitionCoordinates() {
    this.pauseEventListeners(), this.getObjects("Transition").forEach((e) => {
      e.tScale = this.tScale, e.updateCoords(), e.setCoords();
    }), this.resumeEventListeners();
  }
  // Выравнивание переходов по треку
  alignTransitionsToTrack() {
    this.pauseEventListeners(), this.transitionIds.forEach((e) => {
      const t = this.getObjects("Transition").find(
        (n) => n.id === e
      );
      if (t instanceof Sn) {
        const n = this.getObjects().find(
          (a) => a.id === t.fromId
        );
        if (!n) return;
        const s = sy(t.duration, this.tScale), i = n.left + n.width - s / 2;
        t.set({ left: i, top: n.top }), t.setCoords();
      }
    }), this.resumeEventListeners();
  }
  // Обновление переходов
  updateTransitions(e = !0) {
    e && this.pauseEventListeners();
    const t = this.getObjects("Track"), n = this.getObjects("Video", "Image");
    this.removeTransitions();
    const s = {}, i = [];
    t.forEach((a) => {
      const c = n.filter((u) => a.items.includes(u.id)).sort((u, h) => u.left - h.left);
      for (let u = 0; u < c.length - 1; u++) {
        const h = c[u], d = c[u + 1];
        if (Math.abs(h.left + h.width - d.left) <= 1) {
          const p = `${h.id}-${d.id}`;
          if (this.transitionIds.includes(p))
            s[p] = this.transitionsMap[p];
          else {
            const g = {
              id: p,
              duration: 1500,
              fromId: h.id,
              toId: d.id,
              kind: "none",
              trackId: a.id,
              type: "transition"
            };
            s[p] = g;
          }
          i.push(p);
        }
      }
    }), this.transitionIds = i, this.transitionsMap = s, this.renderTransitions(), e && this.resumeEventListeners();
  }
}
const ie = {
  canvas: null,
  enableGuideRedraw: !0,
  isPointerOverHelperTrack: !1,
  draggingOverTrack: null,
  primaryMovingObjects: [],
  secondaryMovingObjects: [],
  placeholderMovingObjects: [],
  objectInitialPositions: {},
  originTrack: {},
  trackToItemsMap: {},
  activeTrackToItemsMap: {},
  trackTopToIdMap: {},
  trackTops: [],
  activeObjects: [],
  primaryTracks: {},
  secondaryTracks: {}
}, jt = {
  guide: null,
  object: null,
  objects: []
}, n9 = () => ie, s9 = (r) => {
  Object.assign(ie, r);
}, Uj = (r) => {
  r.on("before:transform", Dx.bind(r));
}, $j = (r) => {
  r.off("before:transform", Dx.bind(r));
};
function Dx(r) {
  ie.canvas = this, ie.activeTrackToItemsMap = {}, ie.primaryTracks = {}, ie.secondaryTracks = {}, ie.trackTops = [], ie.trackToItemsMap = {}, ie.activeObjects = [], ie.trackTopToIdMap = {}, ie.canvas.trackIdAfterTransform = "", ie.canvas.positionAfterTransform = {};
  const e = ie.canvas.getActiveObject();
  if (!e) return;
  ie.activeObjects = e instanceof Dn ? e.getObjects() : [e];
  const t = ie.canvas.getScenePoint(r.e), n = ie.canvas.getObjects("Track");
  ie.originTrack = n.find((a) => {
    const c = a.getBoundingRect();
    return t.x >= c.left && t.x <= c.left + c.width && t.y >= c.top && t.y <= c.top + c.height;
  }) ?? {};
  const s = ie.canvas.getObjects(
    "Video",
    "Image",
    "Audio",
    "Text",
    "Element"
  );
  n.forEach((a) => {
    const c = s.filter(
      (u) => a.items.includes(u.id)
    );
    ie.trackToItemsMap[a.id] = c, ie.trackTopToIdMap[a.top] = a.id, ie.trackTops.push(a.top);
  }), ie.trackTops.sort((a, c) => a - c), ie.activeObjects.forEach((a) => {
    const c = n?.find(
      (h) => h.items.includes(a.id)
    );
    if (!c) return;
    const u = c.id;
    ie.activeTrackToItemsMap[u] ? ie.activeTrackToItemsMap[u].push(a) : ie.activeTrackToItemsMap[u] = [a];
  }), ie.primaryMovingObjects = ie.activeObjects.filter(
    (a) => {
      const c = a.getBoundingRect();
      return t.y >= c.top && t.y <= c.top + c.height && !(a instanceof Sn);
    }
  ), ie.primaryMovingObjects.forEach((a) => {
    const c = a.getBoundingRect().top, u = ie.trackTopToIdMap[c];
    if (ie.primaryTracks[u])
      ie.primaryTracks[u].objects.push(a);
    else {
      const h = wf(
        ie.trackTops,
        ie.originTrack.top,
        c
      );
      if (typeof h != "number") return;
      ie.primaryTracks[u] = { objects: [a], index: h };
    }
  }), ie.primaryMovingObjects = ie.primaryMovingObjects.sort(
    (a, c) => a.left - c.left
  ), ie.secondaryMovingObjects = ie.activeObjects.filter(
    (a) => !ie.primaryMovingObjects.includes(a) && !(a instanceof Sn)
  ), ie.secondaryMovingObjects.forEach((a) => {
    const c = a.getBoundingRect().top, u = ie.trackTopToIdMap[a.getBoundingRect().top];
    if (ie.secondaryTracks[u])
      ie.secondaryTracks[u].objects.push(a);
    else {
      const h = wf(
        ie.trackTops,
        ie.originTrack.top,
        c
      );
      if (typeof h != "number") return;
      ie.secondaryTracks[u] = { objects: [a], index: h };
    }
  }), ie.originTrack && (ie.canvas.trackOriginBeforeTransform = ie.originTrack.id), e && (ie.canvas.positionBeforeTransform = {
    top: e.top,
    left: e.left
  }), ("transform" in r ? r.transform : {}).action === "drag" && (ie.placeholderMovingObjects = ie.primaryMovingObjects.map(
    (a) => {
      const c = a.getBoundingRect();
      ie.objectInitialPositions[a.id] = {
        top: c.top,
        left: c.left
      };
      const u = new Oa({
        id: `${a.id}-placeholder`,
        left: c.left,
        top: c.top,
        width: c.width,
        height: c.height,
        for: Yj[a.type]
      });
      return u.draggedObject = a, u;
    }
  ), ie.canvas.add(...ie.placeholderMovingObjects));
}
function wf(r, e, t) {
  const n = r.indexOf(e), s = r.indexOf(t);
  return n === -1 || s === -1 ? null : s - n;
}
const Yj = {
  trackitemvideo: "video",
  trackitemimage: "image",
  trackitemaudio: "audio",
  trackitemtext: "text"
};
function Rx(r) {
  if (!jt.guide) return !1;
  r.e.preventDefault();
  const e = this, t = e.getViewportPoint(r.e);
  jt.guide.set({
    left: t.x - 16,
    top: t.y - jt.guide.height / 2
  });
  const n = Xj(
    t,
    jt.objects
  );
  n && (jt.object = n, n.strokeDashArray = [5, 1], n.setSelected(!0)), jt.objects.forEach((s) => {
    s !== n && s.setSelected(!1);
  }), e.requestRenderAll();
}
function Xj(r, e) {
  let t = 1 / 0, n = null;
  const s = new $(r.x, r.y);
  return e.forEach((i) => {
    const a = Gj(i, s);
    a < t && (t = a, n = i);
  }), n;
}
function Gj(r, e) {
  return Math.sqrt(
    Math.pow(r.left - e.x, 2) + Math.pow(r.top - e.y, 2)
  );
}
const qj = [
  "transition",
  "image",
  "video",
  "audio",
  "caption",
  "text"
];
function jx(r) {
  const e = r.e.dataTransfer?.types[0];
  if (!e) return;
  const t = JSON.parse(e), { type: n, duration: s = 5e3 } = t;
  if (!qj.includes(n)) return;
  const i = this;
  i.discardActiveObject();
  const a = Nt(s, i.tScale);
  jt.guide = Kj({
    width: a,
    height: 48,
    id: "TransitionGuide",
    left: 0,
    top: 0,
    type: n
  }), i.add(jt.guide), n === "transition" && (jt.objects = i.getObjects("Transition"), jt.objects.forEach((c) => {
    c.visible = !0;
  })), Ze.dispatch(P1);
}
function Kj({ width: r, height: e, id: t, left: n, top: s, type: i }) {
  return i === "transition" ? new zl({
    top: 0,
    left: 0,
    height: 48,
    width: 48,
    id: "TransitionGuide"
  }) : new Wl({
    top: s,
    left: n,
    height: e,
    width: r,
    id: t,
    name: "Rivers in the mountains"
  });
}
function Lx() {
  if (!jt.guide) return;
  Ze.dispatch(wl);
  const r = this;
  Zj(jt.objects), r.remove(jt.guide);
}
function Zj(r) {
  r.forEach((e) => {
    e.strokeDashArray = [], e.setSelected(!1), e.kind === "none" && (e.visible = !1);
  });
}
var Jj = typeof global == "object" && global && global.Object === Object && global, Qj = typeof self == "object" && self && self.Object === Object && self, Rp = Jj || Qj || Function("return this")(), Ps = Rp.Symbol, Fx = Object.prototype, e6 = Fx.hasOwnProperty, t6 = Fx.toString, oa = Ps ? Ps.toStringTag : void 0;
function r6(r) {
  var e = e6.call(r, oa), t = r[oa];
  try {
    r[oa] = void 0;
    var n = !0;
  } catch {
  }
  var s = t6.call(r);
  return n && (e ? r[oa] = t : delete r[oa]), s;
}
var n6 = Object.prototype, s6 = n6.toString;
function i6(r) {
  return s6.call(r);
}
var o6 = "[object Null]", a6 = "[object Undefined]", iy = Ps ? Ps.toStringTag : void 0;
function jp(r) {
  return r == null ? r === void 0 ? a6 : o6 : iy && iy in Object(r) ? r6(r) : i6(r);
}
function Lp(r) {
  return r != null && typeof r == "object";
}
var c6 = "[object Symbol]";
function Fp(r) {
  return typeof r == "symbol" || Lp(r) && jp(r) == c6;
}
function l6(r, e) {
  for (var t = -1, n = r == null ? 0 : r.length, s = Array(n); ++t < n; )
    s[t] = e(r[t], t, r);
  return s;
}
var Ya = Array.isArray, oy = Ps ? Ps.prototype : void 0, ay = oy ? oy.toString : void 0;
function Nx(r) {
  if (typeof r == "string")
    return r;
  if (Ya(r))
    return l6(r, Nx) + "";
  if (Fp(r))
    return ay ? ay.call(r) : "";
  var e = r + "";
  return e == "0" && 1 / r == -1 / 0 ? "-0" : e;
}
function Hl(r) {
  var e = typeof r;
  return r != null && (e == "object" || e == "function");
}
function u6(r) {
  return r;
}
var h6 = "[object AsyncFunction]", d6 = "[object Function]", f6 = "[object GeneratorFunction]", p6 = "[object Proxy]";
function g6(r) {
  if (!Hl(r))
    return !1;
  var e = jp(r);
  return e == d6 || e == f6 || e == h6 || e == p6;
}
var yd = Rp["__core-js_shared__"], cy = function() {
  var r = /[^.]+$/.exec(yd && yd.keys && yd.keys.IE_PROTO || "");
  return r ? "Symbol(src)_1." + r : "";
}();
function m6(r) {
  return !!cy && cy in r;
}
var v6 = Function.prototype, y6 = v6.toString;
function b6(r) {
  if (r != null) {
    try {
      return y6.call(r);
    } catch {
    }
    try {
      return r + "";
    } catch {
    }
  }
  return "";
}
var w6 = /[\\^$.*+?()[\]{}|]/g, x6 = /^\[object .+?Constructor\]$/, _6 = Function.prototype, S6 = Object.prototype, C6 = _6.toString, T6 = S6.hasOwnProperty, E6 = RegExp(
  "^" + C6.call(T6).replace(w6, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function k6(r) {
  if (!Hl(r) || m6(r))
    return !1;
  var e = g6(r) ? E6 : x6;
  return e.test(b6(r));
}
function O6(r, e) {
  return r?.[e];
}
function Np(r, e) {
  var t = O6(r, e);
  return k6(t) ? t : void 0;
}
function M6(r, e, t) {
  switch (t.length) {
    case 0:
      return r.call(e);
    case 1:
      return r.call(e, t[0]);
    case 2:
      return r.call(e, t[0], t[1]);
    case 3:
      return r.call(e, t[0], t[1], t[2]);
  }
  return r.apply(e, t);
}
var A6 = 800, I6 = 16, P6 = Date.now;
function D6(r) {
  var e = 0, t = 0;
  return function() {
    var n = P6(), s = I6 - (n - t);
    if (t = n, s > 0) {
      if (++e >= A6)
        return arguments[0];
    } else
      e = 0;
    return r.apply(void 0, arguments);
  };
}
function R6(r) {
  return function() {
    return r;
  };
}
var Ul = function() {
  try {
    var r = Np(Object, "defineProperty");
    return r({}, "", {}), r;
  } catch {
  }
}(), j6 = Ul ? function(r, e) {
  return Ul(r, "toString", {
    configurable: !0,
    enumerable: !1,
    value: R6(e),
    writable: !0
  });
} : u6, L6 = D6(j6), F6 = 9007199254740991, N6 = /^(?:0|[1-9]\d*)$/;
function Bx(r, e) {
  var t = typeof r;
  return e = e ?? F6, !!e && (t == "number" || t != "symbol" && N6.test(r)) && r > -1 && r % 1 == 0 && r < e;
}
function B6(r, e, t) {
  e == "__proto__" && Ul ? Ul(r, e, {
    configurable: !0,
    enumerable: !0,
    value: t,
    writable: !0
  }) : r[e] = t;
}
function Vx(r, e) {
  return r === e || r !== r && e !== e;
}
var V6 = Object.prototype, z6 = V6.hasOwnProperty;
function W6(r, e, t) {
  var n = r[e];
  (!(z6.call(r, e) && Vx(n, t)) || t === void 0 && !(e in r)) && B6(r, e, t);
}
var ly = Math.max;
function H6(r, e, t) {
  return e = ly(e === void 0 ? r.length - 1 : e, 0), function() {
    for (var n = arguments, s = -1, i = ly(n.length - e, 0), a = Array(i); ++s < i; )
      a[s] = n[e + s];
    s = -1;
    for (var c = Array(e + 1); ++s < e; )
      c[s] = n[s];
    return c[e] = t(a), M6(r, this, c);
  };
}
var U6 = 9007199254740991;
function $6(r) {
  return typeof r == "number" && r > -1 && r % 1 == 0 && r <= U6;
}
var Y6 = "[object Arguments]";
function uy(r) {
  return Lp(r) && jp(r) == Y6;
}
var zx = Object.prototype, X6 = zx.hasOwnProperty, G6 = zx.propertyIsEnumerable, Wx = uy(/* @__PURE__ */ function() {
  return arguments;
}()) ? uy : function(r) {
  return Lp(r) && X6.call(r, "callee") && !G6.call(r, "callee");
}, q6 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, K6 = /^\w*$/;
function Z6(r, e) {
  if (Ya(r))
    return !1;
  var t = typeof r;
  return t == "number" || t == "symbol" || t == "boolean" || r == null || Fp(r) ? !0 : K6.test(r) || !q6.test(r) || e != null && r in Object(e);
}
var Ma = Np(Object, "create");
function J6() {
  this.__data__ = Ma ? Ma(null) : {}, this.size = 0;
}
function Q6(r) {
  var e = this.has(r) && delete this.__data__[r];
  return this.size -= e ? 1 : 0, e;
}
var eL = "__lodash_hash_undefined__", tL = Object.prototype, rL = tL.hasOwnProperty;
function nL(r) {
  var e = this.__data__;
  if (Ma) {
    var t = e[r];
    return t === eL ? void 0 : t;
  }
  return rL.call(e, r) ? e[r] : void 0;
}
var sL = Object.prototype, iL = sL.hasOwnProperty;
function oL(r) {
  var e = this.__data__;
  return Ma ? e[r] !== void 0 : iL.call(e, r);
}
var aL = "__lodash_hash_undefined__";
function cL(r, e) {
  var t = this.__data__;
  return this.size += this.has(r) ? 0 : 1, t[r] = Ma && e === void 0 ? aL : e, this;
}
function vi(r) {
  var e = -1, t = r == null ? 0 : r.length;
  for (this.clear(); ++e < t; ) {
    var n = r[e];
    this.set(n[0], n[1]);
  }
}
vi.prototype.clear = J6;
vi.prototype.delete = Q6;
vi.prototype.get = nL;
vi.prototype.has = oL;
vi.prototype.set = cL;
function lL() {
  this.__data__ = [], this.size = 0;
}
function Au(r, e) {
  for (var t = r.length; t--; )
    if (Vx(r[t][0], e))
      return t;
  return -1;
}
var uL = Array.prototype, hL = uL.splice;
function dL(r) {
  var e = this.__data__, t = Au(e, r);
  if (t < 0)
    return !1;
  var n = e.length - 1;
  return t == n ? e.pop() : hL.call(e, t, 1), --this.size, !0;
}
function fL(r) {
  var e = this.__data__, t = Au(e, r);
  return t < 0 ? void 0 : e[t][1];
}
function pL(r) {
  return Au(this.__data__, r) > -1;
}
function gL(r, e) {
  var t = this.__data__, n = Au(t, r);
  return n < 0 ? (++this.size, t.push([r, e])) : t[n][1] = e, this;
}
function Po(r) {
  var e = -1, t = r == null ? 0 : r.length;
  for (this.clear(); ++e < t; ) {
    var n = r[e];
    this.set(n[0], n[1]);
  }
}
Po.prototype.clear = lL;
Po.prototype.delete = dL;
Po.prototype.get = fL;
Po.prototype.has = pL;
Po.prototype.set = gL;
var mL = Np(Rp, "Map");
function vL() {
  this.size = 0, this.__data__ = {
    hash: new vi(),
    map: new (mL || Po)(),
    string: new vi()
  };
}
function yL(r) {
  var e = typeof r;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? r !== "__proto__" : r === null;
}
function Iu(r, e) {
  var t = r.__data__;
  return yL(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
function bL(r) {
  var e = Iu(this, r).delete(r);
  return this.size -= e ? 1 : 0, e;
}
function wL(r) {
  return Iu(this, r).get(r);
}
function xL(r) {
  return Iu(this, r).has(r);
}
function _L(r, e) {
  var t = Iu(this, r), n = t.size;
  return t.set(r, e), this.size += t.size == n ? 0 : 1, this;
}
function Ai(r) {
  var e = -1, t = r == null ? 0 : r.length;
  for (this.clear(); ++e < t; ) {
    var n = r[e];
    this.set(n[0], n[1]);
  }
}
Ai.prototype.clear = vL;
Ai.prototype.delete = bL;
Ai.prototype.get = wL;
Ai.prototype.has = xL;
Ai.prototype.set = _L;
var SL = "Expected a function";
function Bp(r, e) {
  if (typeof r != "function" || e != null && typeof e != "function")
    throw new TypeError(SL);
  var t = function() {
    var n = arguments, s = e ? e.apply(this, n) : n[0], i = t.cache;
    if (i.has(s))
      return i.get(s);
    var a = r.apply(this, n);
    return t.cache = i.set(s, a) || i, a;
  };
  return t.cache = new (Bp.Cache || Ai)(), t;
}
Bp.Cache = Ai;
var CL = 500;
function TL(r) {
  var e = Bp(r, function(n) {
    return t.size === CL && t.clear(), n;
  }), t = e.cache;
  return e;
}
var EL = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, kL = /\\(\\)?/g, OL = TL(function(r) {
  var e = [];
  return r.charCodeAt(0) === 46 && e.push(""), r.replace(EL, function(t, n, s, i) {
    e.push(s ? i.replace(kL, "$1") : n || t);
  }), e;
});
function ML(r) {
  return r == null ? "" : Nx(r);
}
function Pu(r, e) {
  return Ya(r) ? r : Z6(r, e) ? [r] : OL(ML(r));
}
function Vp(r) {
  if (typeof r == "string" || Fp(r))
    return r;
  var e = r + "";
  return e == "0" && 1 / r == -1 / 0 ? "-0" : e;
}
function AL(r, e) {
  e = Pu(e, r);
  for (var t = 0, n = e.length; r != null && t < n; )
    r = r[Vp(e[t++])];
  return t && t == n ? r : void 0;
}
function IL(r, e) {
  for (var t = -1, n = e.length, s = r.length; ++t < n; )
    r[s + t] = e[t];
  return r;
}
var hy = Ps ? Ps.isConcatSpreadable : void 0;
function PL(r) {
  return Ya(r) || Wx(r) || !!(hy && r && r[hy]);
}
function DL(r, e, t, n, s) {
  var i = -1, a = r.length;
  for (t || (t = PL), s || (s = []); ++i < a; ) {
    var c = r[i];
    t(c) ? IL(s, c) : s[s.length] = c;
  }
  return s;
}
function RL(r) {
  var e = r == null ? 0 : r.length;
  return e ? DL(r) : [];
}
function jL(r) {
  return L6(H6(r, void 0, RL), r + "");
}
function LL(r, e) {
  return r != null && e in Object(r);
}
function FL(r, e, t) {
  e = Pu(e, r);
  for (var n = -1, s = e.length, i = !1; ++n < s; ) {
    var a = Vp(e[n]);
    if (!(i = r != null && t(r, a)))
      break;
    r = r[a];
  }
  return i || ++n != s ? i : (s = r == null ? 0 : r.length, !!s && $6(s) && Bx(a, s) && (Ya(r) || Wx(r)));
}
function NL(r, e) {
  return r != null && FL(r, e, LL);
}
function BL(r, e, t, n) {
  if (!Hl(r))
    return r;
  e = Pu(e, r);
  for (var s = -1, i = e.length, a = i - 1, c = r; c != null && ++s < i; ) {
    var u = Vp(e[s]), h = t;
    if (u === "__proto__" || u === "constructor" || u === "prototype")
      return r;
    if (s != a) {
      var d = c[u];
      h = void 0, h === void 0 && (h = Hl(d) ? d : Bx(e[s + 1]) ? [] : {});
    }
    W6(c, u, h), c = c[u];
  }
  return r;
}
function VL(r, e, t) {
  for (var n = -1, s = e.length, i = {}; ++n < s; ) {
    var a = e[n], c = AL(r, a);
    t(c, a) && BL(i, Pu(a, r), c);
  }
  return i;
}
function zL(r, e) {
  return VL(r, e, function(t, n) {
    return NL(r, n);
  });
}
var WL = jL(function(r, e) {
  return r == null ? {} : zL(r, e);
});
function Hx(r) {
  const e = r.e.dataTransfer?.types[0];
  if (!e) return;
  const t = JSON.parse(
    r.e.dataTransfer.getData(e)
  ), n = this;
  if (t.type !== "transition") {
    HL(t), n.remove(jt.guide), n.requestRenderAll(), Ze.dispatch(wl);
    return;
  }
  jt.guide && (jt.object && UL(t, n), jt.objects.forEach((s) => {
    s.strokeDashArray = [], s.setSelected(!1), s.kind === "none" && (s.visible = !1);
  }), n.remove(jt.guide), n.requestRenderAll(), Ze.dispatch(wl));
}
function HL(r) {
  const e = { ...r, id: Yt() };
  switch (r.type) {
    case "image":
      Ze.dispatch(Fa, { payload: e });
      break;
    case "video":
      Ze.dispatch(ja, { payload: e });
      break;
    case "audio":
      Ze.dispatch(La, { payload: e });
      break;
  }
}
function UL(r, e) {
  const t = jt.object?.id, n = WL(r, ["kind", "direction"]);
  Object.entries(n).forEach(([s, i]) => {
    s === "kind" ? jt.object.kind = i : jt.object[s] = i;
  }), e.transitionsMap[t] = {
    ...e.transitionsMap[t],
    ...n
  }, e.updateState();
}
const $L = (r) => {
  r.on("dragover", Rx), r.on("dragenter", jx), r.on("dragleave", Lx), r.on("drop", Hx);
}, YL = (r) => {
  r.off("dragover", Rx), r.off("dragenter", jx), r.off("dragleave", Lx), r.off("drop", Hx);
}, Ux = (r) => {
  const e = r.target.canvas, t = r.target;
  if (r.action === "resizing" && t instanceof Sn && e) {
    const n = t.id, s = e.getObjects("Transition").find((i) => i.id === n);
    if (s && s instanceof Sn) {
      const i = st.cloneDeep(e.transitionsMap), a = {
        ...i,
        [n]: {
          ...i[n],
          width: s.width,
          duration: s.duration
        }
      };
      e.transitionsMap = a, e.updateState();
    }
  }
  e && (XL(e, e.getObjects()), GL(e.getObjects("Helper")), ie.isPointerOverHelperTrack = !1, ie.draggingOverTrack = null);
}, XL = (r, e) => {
  e.forEach((t) => {
    t.isAlignmentAuxiliary && r.remove(t);
  });
}, GL = (r) => {
  r.forEach((e) => e.setSelected(!1));
};
function $x(r) {
  const e = r.target.canvas;
  if (!e) return;
  const t = e.getActiveObject();
  if (!t || !e.positionBeforeTransform) return;
  const n = e.getScenePoint(r.e), s = e.getObjects("Track", "Helper").find((i) => {
    const a = i.getBoundingRect();
    return n.x >= a.left && n.x <= a.left + a.width && n.y >= a.top && n.y <= a.top + a.height;
  });
  if (r.action === "resizing") {
    const i = (ie.trackToItemsMap[ie.originTrack.id] || []).filter((c) => c !== t);
    t.setCoords();
    const a = Du(
      i,
      t.getBoundingRect()
    );
    return e.fire("track-items:resized", {
      trackId: ie.originTrack.id,
      trackItemIds: [t.id],
      isOverlapped: !!a
    }), !1;
  }
  if (!s)
    return t && (t?.set(e.positionBeforeTransform), t?.setCoords()), !1;
  if (s instanceof $a) {
    let i;
    switch (s.kind) {
      case "top":
        i = 0;
        break;
      case "center":
        i = s.metadata.order || 0;
        break;
      case "bottom":
        i = -1;
        break;
      default:
        return;
    }
    const a = {
      isSecondaryOverlapped: !1,
      secondaryTracks: ie.secondaryTracks,
      primaryTracks: ie.primaryTracks,
      primaryPositions: {
        trackIndex: i,
        trackId: e.trackIdAfterTransform,
        positions: e.positionAfterTransform
      }
    };
    JL(a);
  } else if (s instanceof mi) {
    const i = {
      isSecondaryOverlapped: KL(),
      secondaryTracks: ie.secondaryTracks,
      primaryTracks: ie.primaryTracks,
      primaryPositions: {
        trackId: e.trackIdAfterTransform,
        positions: e.positionAfterTransform
      }
    };
    qL(i);
  }
}
const qL = (r) => {
  ie.canvas && ie.canvas.fire("track-items:moved", r);
};
function KL() {
  const r = ZL();
  return Object.keys(r).some((e) => {
    const t = ie.trackToItemsMap[e], n = r[e].objects;
    return t?.length ? t.filter((s) => !n.includes(s)).some(
      (s) => Du(n, s.getBoundingRect())
    ) : !0;
  });
}
function ZL() {
  const [r] = ie.primaryMovingObjects, e = r.id, n = ie.canvas.positionAfterTransform[e].top - r.getBoundingRect().top, s = {};
  return ie.secondaryMovingObjects.forEach((i) => {
    const a = i.getBoundingRect().top + n, c = ie.trackTopToIdMap[a], u = wf(
      ie.trackTops,
      ie.originTrack.top,
      a
    );
    s[c] ? s[c].objects.push(i) : s[c] = {
      objects: [i],
      index: u
    };
  }), s;
}
const JL = (r) => {
  ie.canvas && ie.canvas.fire("track:create", r);
};
function Du(r, e) {
  return r.find((t) => {
    const n = t.getBoundingRect();
    return e.left < n.left + n.width && e.left + e.width > n.left && e.top < n.top + n.height && e.top + e.height > n.top;
  });
}
const QL = (r) => {
  r.on("object:modified", Ux), r.on("object:modified", $x);
}, eF = (r) => {
  r.off("object:modified", Ux), r.off("object:modified", $x);
};
function tF(r, e) {
  r.remove(...e), e.length = 0;
}
function Yx() {
  tF(this, ie.placeholderMovingObjects);
}
function Xx(r) {
  const e = this.height < this.bounding.height, t = this.width < this.bounding.width;
  if (!e && !t) return;
  const n = this.viewportTransform;
  let s = n[4], i = n[5];
  const a = 2;
  r.e.shiftKey ? s = n[4] - r.e.deltaY * a : (e && (i = n[5] - r.e.deltaY * a), s = n[4] - r.e.deltaX * a), this.setViewportPos(s, i);
}
const rF = (r) => {
  r.on("mouse:wheel", Xx), r.on("mouse:up", Yx.bind(r));
}, nF = (r) => {
  r.off("mouse:wheel", Xx), r.off("mouse:up", Yx.bind(r));
};
function Gx(r) {
  const e = this;
  if (!e) return;
  const t = e.getScenePoint(r.e), n = e.getObjects("Helper", "Track");
  ie.draggingOverTrack = n.find((h) => {
    const d = h.getBoundingRect();
    return t.x >= d.left && t.x <= d.left + d.width && t.y >= d.top && t.y <= d.top + d.height;
  }) ?? null, n.forEach((h) => {
    if (fy(h)) {
      const d = ie.draggingOverTrack;
      h.setSelected(h === d);
    }
  }), ie.isPointerOverHelperTrack = fy(
    ie.draggingOverTrack
  ), e.getObjects();
  const s = r.target;
  s.getBoundingRect(), s.setCoords();
  const i = [
    s,
    ...e.getActiveObjects(),
    ...e.getObjects("Track", "Helper", "Transition", "Placeholder")
  ], a = sF(i, e), c = oF(s);
  iF(
    a,
    c
  ).forEach((h) => {
    h.orientation === "V" ? s.left = h.lineGuide + h.offset : s.top = h.lineGuide + h.offset;
  });
}
const sF = (r, e) => {
  const t = [], n = [];
  return e.getObjects().filter((s) => s.visible).forEach((s) => {
    if (r.some(
      (c) => c.id === s.id
    ) || s.isAlignmentAuxiliary) return;
    const a = s.getBoundingRect();
    t.push(
      dy(
        a.left,
        a.width,
        a.top,
        a.height
      )
    ), n.push(
      dy(
        a.top,
        a.height,
        a.left,
        a.width
      )
    );
  }), {
    vertical: t.flat(),
    horizontal: []
  };
}, dy = (r, e, t, n) => [r, r + e].map((s) => ({
  val: s,
  start: t,
  end: t + n
})), iF = (r, e) => {
  const t = [], n = [];
  r.vertical.forEach((u) => {
    e.vertical.forEach((h) => {
      const d = Math.abs(u.val - h.guide);
      d < 10 && t.push({
        lineGuide: u.val,
        diff: d,
        orientation: "V",
        snap: h.snap,
        offset: h.offset,
        targetDim: {
          start: u.start,
          end: u.end
        }
      });
    });
  }), r.horizontal.forEach((u) => {
    e.horizontal.forEach((h) => {
      const d = Math.abs(u.val - h.guide);
      d < 10 && n.push({
        lineGuide: u.val,
        diff: d,
        orientation: "H",
        snap: h.snap,
        offset: h.offset,
        targetDim: {
          start: u.start,
          end: u.end
        }
      });
    });
  });
  const i = [], a = t.sort(
    (u, h) => u.diff - h.diff
  )[0], c = n.sort(
    (u, h) => u.diff - h.diff
  )[0];
  return a && i.push({
    lineGuide: a.lineGuide,
    offset: a.offset,
    orientation: "V",
    snap: a.snap,
    targetDim: a.targetDim
  }), c && i.push({
    lineGuide: c.lineGuide,
    offset: c.offset,
    orientation: "H",
    snap: c.snap,
    targetDim: c.targetDim
  }), i;
}, oF = (r) => {
  const e = r.getBoundingRect();
  return {
    vertical: [
      {
        guide: Math.round(e.left),
        offset: Math.round(r.left - e.left),
        snap: "start"
      },
      {
        guide: Math.round(e.left + e.width),
        offset: Math.round(
          r.left - e.left - e.width
        ),
        snap: "end"
      }
    ],
    horizontal: [
      {
        guide: Math.round(e.top),
        offset: Math.round(r.top - e.top),
        snap: "start"
      },
      {
        guide: Math.round(e.top + e.height),
        offset: Math.round(r.top - e.top - e.height),
        snap: "end"
      }
    ]
  };
}, fy = (r) => r instanceof $a;
function aF(r) {
  r.opacity = ie.isPointerOverHelperTrack ? 0 : 1;
}
const qx = pF((r) => {
  const e = r.target.canvas;
  if (gF(r), !ie.draggingOverTrack) return;
  const t = ie.placeholderMovingObjects.map(
    (i) => i.draggedObject
  ), n = (ie.trackToItemsMap[ie.draggingOverTrack.id] || []).filter((i) => !t.includes(i)), s = n.find(
    (i) => Du(t, i.getBoundingRect())
  );
  ie.placeholderMovingObjects.forEach((i) => {
    const a = i.draggedObject;
    a?.setCoords(), aF(i);
    const c = cF(
      a,
      n,
      s,
      ie.placeholderMovingObjects.length > 1
    );
    e.trackIdAfterTransform = ie.trackTopToIdMap[c.top], e.positionAfterTransform[a?.id] = {
      top: c.top,
      left: c.left
    }, i.left = c.left, i.top = c.top;
  });
}, 5), cF = (r, e, t, n) => !lF(r) || n && t ? Kx(r) : t ? uF(r, t, e) : fF(r), lF = (r) => ie.draggingOverTrack ? ie.draggingOverTrack.accepts?.includes(r.type) ?? !1 : !1, Kx = (r) => ({
  top: ie.objectInitialPositions[r.id].top,
  left: ie.objectInitialPositions[r.id].left
}), uF = (r, e, t) => {
  const n = hF(r, e);
  return !dF(t, r, n) || ie.activeObjects.length !== 1 ? Kx(r) : {
    left: n,
    top: e.top
  };
}, hF = (r, e) => {
  const t = r.left + r.width / 2, n = e.left + e.width / 2;
  return t < n ? e.left - r.width : e.left + e.width;
}, dF = (r, e, t) => !(t < 0 || Du(r, {
  ...e.getBoundingRect(),
  left: t
})), fF = (r) => ({
  left: r.getBoundingRect().left,
  top: ie.draggingOverTrack?.top ?? 0
});
function pF(r, e) {
  let t = null;
  return function(...n) {
    const s = Date.now();
    (t === null || s - t >= e) && (t = s, r(...n));
  };
}
function gF(r) {
  const e = r.target, t = e.canvas, n = e.top, s = -e.height * 0.75, i = t.height + e.height * 0.75;
  e.top = Math.min(Math.max(n, s), i - e.height);
  const a = e.left;
  e.left = Math.max(a, 0);
}
const mF = (r) => {
  r.on("object:moving", Gx.bind(r)), r.on("object:moving", qx);
}, vF = (r) => {
  r.off("object:moving", Gx.bind(r)), r.off("object:moving", qx);
};
function Zx() {
  const r = this, e = r.getActiveObject(), t = r.getActiveObjects().map((n) => n.id);
  e instanceof an ? (e.borderColor = "rgba(0, 216, 214, 0.75)", e.hasControls = !1, e.hoverCursor = "default", e.borderScaleFactor = 1, e.padding = 0, e.getObjects().forEach((n) => {
    n.setSelected(!0);
  })) : e?.setSelected(!0), this.setActiveIds(t);
}
function Jx(r) {
  const e = this, t = e.getActiveObject();
  t instanceof an && (t.borderColor = "transparent", t.hasControls = !1, t.hoverCursor = "default"), r.selected.forEach((s) => {
    s.setSelected(!0);
  }), r.deselected.forEach((s) => {
    s.setSelected(!1);
  });
  const n = e.getActiveObjects().map((s) => s.id);
  this.setActiveIds(n);
}
function Qx(r) {
  this.getObjects().forEach((t) => {
    t.isSelected && (t.isSelected = !1);
  }), r.deselected.forEach((t) => {
    t.setSelected(!1);
  });
  const e = this.getActiveObjects().map((t) => t.id);
  this.setActiveIds(e);
}
const yF = (r) => {
  r.on("selection:created", Zx), r.on("selection:updated", Jx), r.on("selection:cleared", Qx);
}, bF = (r) => {
  r.off("selection:created", Zx), r.off("selection:updated", Jx), r.off("selection:cleared", Qx);
};
let e_, t_, r_;
const wF = (r) => {
  const { state: e } = r;
  e_ = e.subscribeToActiveIds(({ activeIds: t }) => {
    if (t.length === 1) {
      const n = t[0], { trackItemIds: s, trackItemsMap: i } = e.getState();
      s.forEach((a) => {
        i[a].type;
      }), r.selectTrackItemByIds([n]);
    } else
      r.selectTrackItemByIds(t);
  }), t_ = e.subscribeToHistory((t) => {
    const { tracks: n, trackItemsMap: s, trackItemIds: i, trackItemDetailsMap: a } = t;
    r.tracks = n, r.trackItemsMap = s, r.trackItemIds = i, r.trackItemDetailsMap = a, r.renderTracks(), r.updateTrackItemsToHistory(), r.alignItemsToTrack(), r.calcBounding(), r.updateTransitions(), r.duration = Nn(r.trackItemsMap);
  }), r_ = e.subscribeToAddOrRemoveItems(() => {
    const t = r.getTrackItems().map((c) => c.id), { trackItemIds: n, trackItemsMap: s, trackItemDetailsMap: i } = e.getState(), a = [];
    t.forEach((c) => {
      n.includes(c) || a.push(c);
    }), r.deleteTrackItemById(a), r.tracks = e.getState().tracks, r.trackItemsMap = s, r.trackItemDetailsMap = i, n.forEach((c) => {
      if (!t.includes(c)) {
        const u = {
          ...s[c],
          details: {
            ...i[c].details
          }
        };
        r.addTrackItem(u);
      }
    }), r.renderTracks(), r.alignItemsToTrack(), n.forEach((c) => {
      r.updateTrackItemCoords(c);
    }), r.updateTransitions(), r.updateTrackCoords();
  });
}, xF = (r) => {
  e_.unsubscribe(), t_.unsubscribe(), r_.unsubscribe();
};
function n_(r) {
  const {
    isSecondaryOverlapped: e,
    secondaryTracks: t,
    primaryTracks: n,
    primaryPositions: s
  } = r, { trackId: i, positions: a } = s, c = this.tracks.findIndex((v) => v.id === i), u = z1(
    Object.keys(t).map(
      (v) => t[v].objects.map((b) => b.id)
    )
  ), h = xl(this.tracks, [
    ...Object.keys(a),
    ...u
  ]);
  Object.keys(n).forEach((v) => {
    this.pauseEventListeners();
    const { objects: b } = n[v];
    b.forEach((C) => {
      const T = a[C.id];
      C.left = T.left;
    }), this.resumeEventListeners();
    const _ = h.find((C) => C.id === i);
    _ && _.items.push(...Object.keys(a)), this.tracks = h;
  });
  const d = this.tracks[c], p = [];
  Object.keys(t).forEach((v) => {
    const { objects: b, index: _ } = t[v], C = b.map((M) => M.id), [T] = C, k = this.trackItemsMap[T];
    if (e) {
      const M = {
        id: Yt(),
        items: C,
        type: k.type,
        accepts: this.acceptsMap?.[k.type],
        tempIndex: _
      };
      p.push(M);
    } else {
      const M = h[c + _];
      M && M.items.push(...C), this.tracks = h;
    }
  });
  const g = W1(
    d,
    p
  );
  g.length && h.splice(c, 1, ...g), this.tracks = h, this.renderTracks(), this.alignItemsToTrack(), this.updateTrackItemsPosition(), this.updateTransitions(), this.updateState({ updateHistory: !0, kind: "update" });
}
function s_({
  trackItemIds: r,
  isOverlapped: e
}) {
  const [t] = r;
  if (t) {
    if (!this.getObjects("Transition").find(
      (n) => n.id === t
    )) {
      const n = this.tracks.find((s) => s.items.includes(t));
      if (e) {
        const s = _F(this.tracks, r), i = {
          id: Yt(),
          items: [t],
          type: n?.type,
          accepts: n?.accepts
        }, a = this.tracks.findIndex((c) => c.id === n?.id);
        s.splice(a, 0, i), this.tracks = s;
      }
    }
    this.renderTracks(), this.alignItemsToTrack(), this.alignTransitionsToTrack(), this.updateTransitions(), this.updateTrackItemsPosition(), this.updateState({ updateHistory: !0, kind: "update" });
  }
}
function _F(r, e) {
  return r.map((t) => ({
    ...t,
    items: t.items.filter(
      (n) => !e.includes(n)
    )
  }));
}
function i_(r) {
  const {
    secondaryTracks: e,
    primaryTracks: t,
    primaryPositions: n
  } = r, { positions: s, trackIndex: i } = n, a = i === -1 ? this.tracks.length : i, [c] = Object.keys(t), u = this.tracks.find((_) => _.id == c), h = t[c], d = {
    id: Yt(),
    items: h.objects.map((_) => _.id),
    type: u?.type,
    accepts: u?.accepts
  }, p = z1(
    Object.keys(e).map(
      (_) => e[_].objects.map((C) => C.id)
    )
  ), g = xl(this.tracks, [
    ...Object.keys(s),
    ...p
  ]), v = [];
  Object.keys(e).forEach((_) => {
    const { objects: C, index: T } = e[_], k = this.tracks.find(
      (D) => D.id == _
    ), M = C.map((D) => D.id), A = {
      id: Yt(),
      items: M,
      type: k?.type,
      accepts: k?.accepts,
      tempIndex: T
    };
    v.push(A);
  });
  const b = W1(d, v);
  b.length && g.splice(a, 0, ...b), this.tracks = g, this.renderTracks(), this.alignItemsToTrack(), this.updateTrackItemsPosition(), this.updateTransitions(), this.updateState({ updateHistory: !0, kind: "update" });
}
const SF = (r) => {
  r.on("track:create", i_.bind(r)), r.on("track-items:resized", s_.bind(r)), r.on("track-items:moved", n_.bind(r));
}, CF = (r) => {
  r.off("track:create", i_.bind(r)), r.off("track-items:resized", s_.bind(r)), r.off("track-items:moved", n_.bind(r));
}, TF = (r) => {
  $L(r), QL(r), rF(r), mF(r), SF(r), yF(r), Uj(r), wF(r);
}, EF = (r) => {
  YL(r), eF(r), nF(r), vF(r), CF(r), bF(r), $j(r), xF();
}, kF = {
  video: ["*"],
  image: ["*"],
  audio: ["*"],
  text: ["*"]
}, OF = ["video", "image", "audio", "text"];
let zp = class extends mf {
  acceptsMap;
  tracks = [];
  trackItemsMap = {};
  trackItemIds = [];
  transitionIds = [];
  transitionsMap = {};
  trackItemDetailsMap = {};
  bounding;
  onScroll;
  tScale;
  store;
  state;
  activeIds = [];
  spacing;
  scale;
  sizesMap;
  duration;
  setupFabricDefaults() {
    ht.ownDefaults.borderColor = "transparent", ht.ownDefaults.cornerColor = "white", ht.ownDefaults.cornerStrokeColor = "transparent", ht.ownDefaults.strokeWidth = 0, ht.ownDefaults.borderOpacityWhenMoving = 1, ht.ownDefaults.borderScaleFactor = 1, ht.ownDefaults.cornerSize = 8, ht.ownDefaults.cornerStyle = "rect", ht.ownDefaults.centeredScaling = !1, ht.ownDefaults.centeredRotation = !0, ht.ownDefaults.transparentCorners = !1;
  }
  constructor(e, t) {
    super(e, t), this.bounding = t.bounding || {
      width: t.width || 0,
      height: t.height || 0
    }, this.spacing = {
      left: 16,
      right: 80,
      ...t.spacing
    };
    const n = this.viewportTransform;
    n[4] = this.spacing.left, this.tScale = t.tScale || 1 / 300, this.store = t.store, this.state = t.state, this.scale = t.scale, this.onScroll = t.onScroll, this.acceptsMap = this.createAcceptsItemMap(t.acceptsMap), this.sizesMap = Pj(t.sizesMap), this.setupFabricDefaults(), this.initEventListeners();
  }
  createAcceptsItemMap(e = kF) {
    const t = {};
    return Object.keys(e).forEach((n) => {
      const s = e[n];
      t[n] = s.includes("*") ? OF : s;
    }), t;
  }
  // setActiveIds(e: any) {
  //   this.activeIds = e;
  //   eventBus.dispatch(LAYER_SELECTION, {
  //     payload: {
  //       activeIds: this.activeIds,
  //     },
  //   });
  // }
  setActiveIds(e) {
    this.activeIds = e, this.getObjects("Transition").some(
      (n) => e.includes(n.id)
    ) || (this.state?.updateState({
      activeIds: st.cloneDeep(this.activeIds)
    }), Ze.dispatch(xA, {
      payload: {
        activeIds: this.activeIds
      }
    }));
  }
  purge() {
    EF(this), this.dispose();
  }
  static registerItems(e) {
    Object.keys(e).forEach((t) => {
      le.setClass(e[t], t);
    });
  }
  initEventListeners() {
    TF(this);
  }
  getUpdatedState() {
    const e = Nn(this.trackItemsMap);
    return {
      tracks: this.tracks,
      trackItemIds: this.trackItemIds,
      trackItemsMap: this.trackItemsMap,
      transitionIds: this.transitionIds,
      transitionsMap: this.transitionsMap,
      // tScale: this.tScale,
      scale: this.scale,
      duration: e
    };
  }
  getState() {
    const e = Nn(this.trackItemsMap);
    return {
      tracks: this.tracks,
      trackItemIds: this.trackItemIds,
      trackItemsMap: this.trackItemsMap,
      transitionIds: this.transitionIds,
      transitionsMap: this.transitionsMap,
      trackItemDetailsMap: this.trackItemDetailsMap,
      // tScale: this.tScale,
      scale: this.scale,
      duration: e
    };
  }
  notify(e = { updateHistory: !1 }) {
    const t = this.getUpdatedState();
    this.state.updateState(t, e);
  }
  updateState(e) {
    this.updateTracksState(), this.updateTrackItemsState(), this.requestRenderAll(), this.calcBounding(), this.updateTrackCoords();
    const t = this.getUpdatedState();
    this.state.updateState(t, e);
  }
  scrollTo({
    scrollLeft: e,
    scrollTop: t
  }) {
    const n = [...this.viewportTransform];
    let s = !1;
    if (typeof e == "number" && (n[4] = -e + this.spacing.left, s = !0), typeof t == "number" && (n[5] = -t, s = !0), s) {
      this.viewportTransform = n;
      const i = this.getActiveObject();
      i && i.setCoords(), this.requestRenderAll();
    }
  }
  setBoundingBox(e) {
    this.bounding = e;
  }
  calcBounding() {
    const e = this.getTrackItems().reduce(
      (t, n) => {
        const { left: s, top: i, width: a, height: c } = n.getBoundingRect();
        return {
          left: Math.min(t.left, s),
          top: Math.min(t.top, i),
          width: Math.max(t.width, s + a),
          height: Math.max(t.height, i + c)
        };
      },
      { left: 1 / 0, top: 1 / 0, width: this.width, height: 0 }
    );
    this.bounding = e, Ze.dispatch(D1, {
      payload: { bounding: e }
    });
  }
  setScale(e) {
    this.pauseEventListeners(), this.tScale = e.zoom, this.scale = e;
    const t = this.getState();
    this.getObjects("Video", "Image", "Text", "Audio").forEach(
      (n) => {
        const s = t.trackItemsMap[n.id], { from: i, to: a } = s.display, c = Nt(i, this.tScale), u = Nt(
          a - i,
          this.tScale,
          n.playbackRate
        );
        n.set({ left: c, width: u, tScale: e.zoom }), n.setCoords();
      }
    ), this.requestRenderAll(), this.calcBounding(), this.updateTrackCoords(), this.updateTransitions(!1), this.resumeEventListeners(), this.notify();
  }
  setViewportPos(e, t) {
    const n = this.getViewportPos(e, t), s = this.viewportTransform;
    s[4] = n.x, s[5] = n.y, this.requestRenderAll(), this.setActiveTrackItemCoords();
    const i = this.onScroll;
    i && i.call(this, {
      scrollTop: n.y,
      scrollLeft: n.x - this.spacing.left
    });
  }
  getViewportPos(e, t) {
    const n = this.bounding.width - 100 >= this.width ? this.spacing.right : 0, s = this.width - this.bounding.width - n, i = this.spacing.left, a = Math.max(s, Math.min(e, i));
    if (this.bounding.height < this.height) return { x: a, y: 0 };
    const c = this.height - this.bounding.height - 40, u = Math.max(c, Math.min(t, 0));
    return { x: a, y: u };
  }
};
mj(zp, [
  $4,
  Nj,
  Vj,
  Hj
]);
function MF(r) {
  const e = Ze.subject.pipe(ii(({ key: t }) => t.startsWith(SA))).subscribe((t) => {
    if (t.key === I1) {
      const n = t.value;
      r.setScale(n?.payload.scale ?? void 0);
    }
  });
  return {
    unsubscribe: () => {
      e.unsubscribe();
    }
  };
}
zp.registerItems({
  Text: Px,
  Image: jj,
  Video: Rj,
  Audio: Dj,
  Track: Lj,
  Helper: Fj
});
const o9 = ({ stateManager: r }) => {
  const e = m.useRef(!1), [t, n] = m.useState(0), s = m.useRef(null), i = m.useRef(null), a = m.useRef(null), c = m.useRef(null), u = m.useRef(null), [h, d] = m.useState({
    width: 0,
    height: 0
  }), [p, g] = m.useState({
    width: 0,
    height: 0
  }), {
    scale: v,
    playerRef: b,
    fps: _,
    setState: C,
    timeline: T
  } = fi(), { setTimeline: k } = fi(), M = Vf(b ?? void 0), A = (B) => {
    u.current && c.current && (c.current.scrollTop = -B.scrollTop, u.current.scrollLeft = -B.scrollLeft, n(-B.scrollLeft));
  };
  m.useEffect(() => {
    const B = Nt(M / _ * 1e3, v.zoom), X = i.current?.getBoundingClientRect().x + i.current?.clientWidth;
    if (B - t + 40 >= X) {
      const Z = u.current?.clientWidth, G = u.current?.scrollWidth, K = u.current?.scrollLeft, ve = (G - (Z + K)) / Z;
      ve >= 0 && (ve > 1 ? u.current?.scrollTo({
        left: K + Z
      }) : u.current?.scrollTo({
        left: G - Z
      }));
    }
  }, [M]), m.useEffect(() => {
    const B = i.current, X = s.current;
    if (!B || !X) return;
    const Y = X.clientWidth, Z = X.clientHeight, G = new zp(B, {
      width: Y,
      height: Z,
      bounding: {
        width: Y,
        height: 0
      },
      selectionColor: "rgba(0, 216, 214,0.1)",
      selectionBorderColor: "rgba(0, 216, 214,1.0)",
      onScroll: A,
      // tScale: scale.zoom,
      // store,
      state: r,
      scale: v,
      spacing: {
        left: Bf,
        right: Fv
      }
    }), K = MF(G);
    a.current = G, d({
      width: Y,
      height: Z
    }), g({
      width: Y,
      height: 0
    }), k(G);
    const oe = r.subscribeToSize(
      (W) => {
        C(W);
      }
    ), ve = r.subscribeToScale((W) => {
      C(W);
    }), Q = r.subscribeToTracks(
      (W) => {
        C(W);
      }
    ), ge = r.subscribeToDuration(
      (W) => {
        C(W);
      }
    ), de = r.subscribeToUpdateTrackItem(() => {
      const W = r.getState();
      C({
        duration: W.duration,
        trackItemsMap: W.trackItemsMap
      });
    }), ne = r.subscribeToAddOrRemoveItems(
      () => {
        const W = r.getState();
        C({
          trackItemDetailsMap: W.trackItemDetailsMap,
          trackItemsMap: W.trackItemsMap,
          trackItemIds: W.trackItemIds,
          tracks: W.tracks
        });
      }
    ), I = r.subscribeToUpdateItemDetails(() => {
      const W = r.getState();
      C({
        trackItemDetailsMap: W.trackItemDetailsMap
      });
    });
    return () => {
      K.unsubscribe(), G.purge(), ve.unsubscribe(), Q.unsubscribe(), ge.unsubscribe(), ne.unsubscribe(), de.unsubscribe(), I.unsubscribe(), oe.unsubscribe();
    };
  }, []), m.useEffect(() => {
    const X = Ze.subject.pipe(
      ii(({ key: Y }) => Y.startsWith(TA))
    ).subscribe((Y) => {
      if (Y.key === D1) {
        const Z = Y.value?.payload?.bounding;
        Z && g({
          width: Z.width,
          height: Z.height
        });
      }
    });
    return () => {
      X.unsubscribe();
    };
  }, []);
  const D = (B) => {
    const X = B.currentTarget.scrollLeft;
    e.current && a.current.scrollTo({ scrollLeft: X }), n(X);
  }, F = (B) => {
    const X = B.currentTarget.scrollTop;
    e.current && a.current.scrollTo({ scrollTop: X });
  };
  m.useEffect(() => {
    const B = u.current?.scrollWidth;
    if (!B || !T) return;
    const X = T.width;
    B < X + t && T.scrollTo({ scrollLeft: B - X });
  }, [v]);
  const U = (B) => {
    if (!a.current) return;
    const Y = di(B, v.zoom);
    b?.current?.seekTo(Y * _ / 1e3);
  };
  return /* @__PURE__ */ w.jsxs("div", { className: "relative overflow-hidden h-80 w-full", children: [
    /* @__PURE__ */ w.jsx(k5, {}),
    /* @__PURE__ */ w.jsx(
      DR,
      {
        onClick: U,
        scrollLeft: t
      }
    ),
    /* @__PURE__ */ w.jsx(PR, { scrollLeft: t }),
    /* @__PURE__ */ w.jsxs("div", { className: "flex", children: [
      /* @__PURE__ */ w.jsx("div", { className: "relative w-10 flex-none" }),
      /* @__PURE__ */ w.jsxs("div", { className: "relative h-[230px] flex-1", children: [
        /* @__PURE__ */ w.jsx(
          "div",
          {
            ref: s,
            className: "absolute top-0 h-[230px] w-full text-sm text-white ",
            children: /* @__PURE__ */ w.jsx(
              "canvas",
              {
                ref: i,
                id: "designcombo-timeline-canvas"
              }
            )
          }
        ),
        /* @__PURE__ */ w.jsxs(
          bl,
          {
            type: "always",
            style: {
              position: "absolute",
              width: "calc(100vw - 40px)",
              height: "10px"
            },
            className: "ScrollAreaRootH",
            children: [
              /* @__PURE__ */ w.jsx(
                Id,
                {
                  onScroll: D,
                  className: "ScrollAreaViewport",
                  id: "viewportH",
                  ref: u,
                  children: /* @__PURE__ */ w.jsx(
                    "div",
                    {
                      style: {
                        width: p.width > h.width ? p.width + Fv : p.width
                      },
                      className: "pointer-events-none h-[10px]"
                    }
                  )
                }
              ),
              /* @__PURE__ */ w.jsx(
                Ov,
                {
                  className: "ScrollAreaScrollbar",
                  orientation: "horizontal",
                  children: /* @__PURE__ */ w.jsx(
                    Mv,
                    {
                      className: "ScrollAreaThumb",
                      onMouseDown: () => {
                        e.current = !0;
                      },
                      onMouseUp: () => {
                        e.current = !1;
                      }
                    }
                  )
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ w.jsxs(
          bl,
          {
            type: "always",
            style: {
              position: "absolute",
              height: "230px",
              width: "10px"
            },
            className: "ScrollAreaRootV",
            children: [
              /* @__PURE__ */ w.jsx(
                Id,
                {
                  onScroll: F,
                  className: "ScrollAreaViewport",
                  ref: c,
                  children: /* @__PURE__ */ w.jsx(
                    "div",
                    {
                      style: {
                        height: p.height > h.height ? p.height + 40 : h.height
                      },
                      className: "pointer-events-none w-[10px]"
                    }
                  )
                }
              ),
              /* @__PURE__ */ w.jsx(
                Ov,
                {
                  className: "ScrollAreaScrollbar",
                  orientation: "vertical",
                  children: /* @__PURE__ */ w.jsx(
                    Mv,
                    {
                      className: "ScrollAreaThumb",
                      onMouseDown: () => {
                        e.current = !0;
                      },
                      onMouseUp: () => {
                        e.current = !1;
                      }
                    }
                  )
                }
              )
            ]
          }
        )
      ] })
    ] })
  ] });
}, AF = { Date: !0, RegExp: !0, String: !0, Number: !0 };
function o_(r, e, t = { cyclesFix: !0 }, n = []) {
  let s = [];
  const i = Array.isArray(r);
  for (const c in r) {
    const u = r[c], h = i ? +c : c;
    if (!(c in e)) {
      s.push({
        type: "REMOVE",
        path: [h],
        oldValue: r[c]
      });
      continue;
    }
    const d = e[c], p = typeof u == "object" && typeof d == "object" && Array.isArray(u) === Array.isArray(d);
    u && d && p && !AF[Object.getPrototypeOf(u)?.constructor?.name] && (!t.cyclesFix || !n.includes(u)) ? s.push.apply(s, o_(u, d, t, t.cyclesFix ? n.concat([u]) : []).map((g) => (g.path.unshift(h), g))) : u !== d && // treat NaN values as equivalent
    !(Number.isNaN(u) && Number.isNaN(d)) && !(p && (isNaN(u) ? u + "" == d + "" : +u == +d)) && s.push({
      path: [h],
      type: "CHANGE",
      value: d,
      oldValue: u
    });
  }
  const a = Array.isArray(e);
  for (const c in e)
    c in r || s.push({
      type: "CREATE",
      path: [a ? +c : c],
      value: e[c]
    });
  return s;
}
var Wp = Symbol.for("immer-nothing"), wa = Symbol.for("immer-draftable"), Yr = Symbol.for("immer-state"), a_ = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(r) {
    return `The plugin for '${r}' has not been loaded into Immer. To enable the plugin, import and call \`enable${r}()\` when initializing your application.`;
  },
  function(r) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${r}'`;
  },
  "This object has been frozen and should not be mutated",
  function(r) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + r;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(r) {
    return `'current' expects a draft, got: ${r}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(r) {
    return `'original' expects a draft, got: ${r}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function $t(r, ...e) {
  if (process.env.NODE_ENV !== "production") {
    const t = a_[r], n = typeof t == "function" ? t.apply(null, e) : t;
    throw new Error(`[Immer] ${n}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${r}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var yi = Object.getPrototypeOf;
function bi(r) {
  return !!r && !!r[Yr];
}
function Ds(r) {
  return r ? c_(r) || Array.isArray(r) || !!r[wa] || !!r.constructor?.[wa] || Xa(r) || Ga(r) : !1;
}
var IF = Object.prototype.constructor.toString();
function c_(r) {
  if (!r || typeof r != "object")
    return !1;
  const e = yi(r);
  if (e === null)
    return !0;
  const t = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return t === Object ? !0 : typeof t == "function" && Function.toString.call(t) === IF;
}
function Aa(r, e) {
  wi(r) === 0 ? Reflect.ownKeys(r).forEach((t) => {
    e(t, r[t], r);
  }) : r.forEach((t, n) => e(n, t, r));
}
function wi(r) {
  const e = r[Yr];
  return e ? e.type_ : Array.isArray(r) ? 1 : Xa(r) ? 2 : Ga(r) ? 3 : 0;
}
function Ia(r, e) {
  return wi(r) === 2 ? r.has(e) : Object.prototype.hasOwnProperty.call(r, e);
}
function bd(r, e) {
  return wi(r) === 2 ? r.get(e) : r[e];
}
function l_(r, e, t) {
  const n = wi(r);
  n === 2 ? r.set(e, t) : n === 3 ? r.add(t) : r[e] = t;
}
function PF(r, e) {
  return r === e ? r !== 0 || 1 / r === 1 / e : r !== r && e !== e;
}
function Xa(r) {
  return r instanceof Map;
}
function Ga(r) {
  return r instanceof Set;
}
function ei(r) {
  return r.copy_ || r.base_;
}
function xf(r, e) {
  if (Xa(r))
    return new Map(r);
  if (Ga(r))
    return new Set(r);
  if (Array.isArray(r))
    return Array.prototype.slice.call(r);
  const t = c_(r);
  if (e === !0 || e === "class_only" && !t) {
    const n = Object.getOwnPropertyDescriptors(r);
    delete n[Yr];
    let s = Reflect.ownKeys(n);
    for (let i = 0; i < s.length; i++) {
      const a = s[i], c = n[a];
      c.writable === !1 && (c.writable = !0, c.configurable = !0), (c.get || c.set) && (n[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: c.enumerable,
        value: r[a]
      });
    }
    return Object.create(yi(r), n);
  } else {
    const n = yi(r);
    if (n !== null && t)
      return { ...r };
    const s = Object.create(n);
    return Object.assign(s, r);
  }
}
function Hp(r, e = !1) {
  return Ru(r) || bi(r) || !Ds(r) || (wi(r) > 1 && (r.set = r.add = r.clear = r.delete = DF), Object.freeze(r), e && Object.entries(r).forEach(([t, n]) => Hp(n, !0))), r;
}
function DF() {
  $t(2);
}
function Ru(r) {
  return Object.isFrozen(r);
}
var _f = {};
function xi(r) {
  const e = _f[r];
  return e || $t(0, r), e;
}
function RF(r, e) {
  _f[r] || (_f[r] = e);
}
var Pa;
function u_() {
  return Pa;
}
function jF(r, e) {
  return {
    drafts_: [],
    parent_: r,
    immer_: e,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function py(r, e) {
  e && (xi("Patches"), r.patches_ = [], r.inversePatches_ = [], r.patchListener_ = e);
}
function Sf(r) {
  Cf(r), r.drafts_.forEach(LF), r.drafts_ = null;
}
function Cf(r) {
  r === Pa && (Pa = r.parent_);
}
function gy(r) {
  return Pa = jF(Pa, r);
}
function LF(r) {
  const e = r[Yr];
  e.type_ === 0 || e.type_ === 1 ? e.revoke_() : e.revoked_ = !0;
}
function my(r, e) {
  e.unfinalizedDrafts_ = e.drafts_.length;
  const t = e.drafts_[0];
  return r !== void 0 && r !== t ? (t[Yr].modified_ && (Sf(e), $t(4)), Ds(r) && (r = $l(e, r), e.parent_ || Yl(e, r)), e.patches_ && xi("Patches").generateReplacementPatches_(
    t[Yr].base_,
    r,
    e.patches_,
    e.inversePatches_
  )) : r = $l(e, t, []), Sf(e), e.patches_ && e.patchListener_(e.patches_, e.inversePatches_), r !== Wp ? r : void 0;
}
function $l(r, e, t) {
  if (Ru(e))
    return e;
  const n = e[Yr];
  if (!n)
    return Aa(
      e,
      (s, i) => vy(r, n, e, s, i, t)
    ), e;
  if (n.scope_ !== r)
    return e;
  if (!n.modified_)
    return Yl(r, n.base_, !0), n.base_;
  if (!n.finalized_) {
    n.finalized_ = !0, n.scope_.unfinalizedDrafts_--;
    const s = n.copy_;
    let i = s, a = !1;
    n.type_ === 3 && (i = new Set(s), s.clear(), a = !0), Aa(
      i,
      (c, u) => vy(r, n, s, c, u, t, a)
    ), Yl(r, s, !1), t && r.patches_ && xi("Patches").generatePatches_(
      n,
      t,
      r.patches_,
      r.inversePatches_
    );
  }
  return n.copy_;
}
function vy(r, e, t, n, s, i, a) {
  if (process.env.NODE_ENV !== "production" && s === t && $t(5), bi(s)) {
    const c = i && e && e.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Ia(e.assigned_, n) ? i.concat(n) : void 0, u = $l(r, s, c);
    if (l_(t, n, u), bi(u))
      r.canAutoFreeze_ = !1;
    else
      return;
  } else a && t.add(s);
  if (Ds(s) && !Ru(s)) {
    if (!r.immer_.autoFreeze_ && r.unfinalizedDrafts_ < 1)
      return;
    $l(r, s), (!e || !e.scope_.parent_) && typeof n != "symbol" && Object.prototype.propertyIsEnumerable.call(t, n) && Yl(r, s);
  }
}
function Yl(r, e, t = !1) {
  !r.parent_ && r.immer_.autoFreeze_ && r.canAutoFreeze_ && Hp(e, t);
}
function FF(r, e) {
  const t = Array.isArray(r), n = {
    type_: t ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: e ? e.scope_ : u_(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: e,
    // The base state.
    base_: r,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let s = n, i = Up;
  t && (s = [n], i = Da);
  const { revoke: a, proxy: c } = Proxy.revocable(s, i);
  return n.draft_ = c, n.revoke_ = a, c;
}
var Up = {
  get(r, e) {
    if (e === Yr)
      return r;
    const t = ei(r);
    if (!Ia(t, e))
      return NF(r, t, e);
    const n = t[e];
    return r.finalized_ || !Ds(n) ? n : n === wd(r.base_, e) ? (xd(r), r.copy_[e] = Ef(n, r)) : n;
  },
  has(r, e) {
    return e in ei(r);
  },
  ownKeys(r) {
    return Reflect.ownKeys(ei(r));
  },
  set(r, e, t) {
    const n = h_(ei(r), e);
    if (n?.set)
      return n.set.call(r.draft_, t), !0;
    if (!r.modified_) {
      const s = wd(ei(r), e), i = s?.[Yr];
      if (i && i.base_ === t)
        return r.copy_[e] = t, r.assigned_[e] = !1, !0;
      if (PF(t, s) && (t !== void 0 || Ia(r.base_, e)))
        return !0;
      xd(r), Tf(r);
    }
    return r.copy_[e] === t && // special case: handle new props with value 'undefined'
    (t !== void 0 || e in r.copy_) || // special case: NaN
    Number.isNaN(t) && Number.isNaN(r.copy_[e]) || (r.copy_[e] = t, r.assigned_[e] = !0), !0;
  },
  deleteProperty(r, e) {
    return wd(r.base_, e) !== void 0 || e in r.base_ ? (r.assigned_[e] = !1, xd(r), Tf(r)) : delete r.assigned_[e], r.copy_ && delete r.copy_[e], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(r, e) {
    const t = ei(r), n = Reflect.getOwnPropertyDescriptor(t, e);
    return n && {
      writable: !0,
      configurable: r.type_ !== 1 || e !== "length",
      enumerable: n.enumerable,
      value: t[e]
    };
  },
  defineProperty() {
    $t(11);
  },
  getPrototypeOf(r) {
    return yi(r.base_);
  },
  setPrototypeOf() {
    $t(12);
  }
}, Da = {};
Aa(Up, (r, e) => {
  Da[r] = function() {
    return arguments[0] = arguments[0][0], e.apply(this, arguments);
  };
});
Da.deleteProperty = function(r, e) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(e)) && $t(13), Da.set.call(this, r, e, void 0);
};
Da.set = function(r, e, t) {
  return process.env.NODE_ENV !== "production" && e !== "length" && isNaN(parseInt(e)) && $t(14), Up.set.call(this, r[0], e, t, r[0]);
};
function wd(r, e) {
  const t = r[Yr];
  return (t ? ei(t) : r)[e];
}
function NF(r, e, t) {
  const n = h_(e, t);
  return n ? "value" in n ? n.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    n.get?.call(r.draft_)
  ) : void 0;
}
function h_(r, e) {
  if (!(e in r))
    return;
  let t = yi(r);
  for (; t; ) {
    const n = Object.getOwnPropertyDescriptor(t, e);
    if (n)
      return n;
    t = yi(t);
  }
}
function Tf(r) {
  r.modified_ || (r.modified_ = !0, r.parent_ && Tf(r.parent_));
}
function xd(r) {
  r.copy_ || (r.copy_ = xf(
    r.base_,
    r.scope_.immer_.useStrictShallowCopy_
  ));
}
var BF = class {
  constructor(r) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (e, t, n) => {
      if (typeof e == "function" && typeof t != "function") {
        const i = t;
        t = e;
        const a = this;
        return function(u = i, ...h) {
          return a.produce(u, (d) => t.call(this, d, ...h));
        };
      }
      typeof t != "function" && $t(6), n !== void 0 && typeof n != "function" && $t(7);
      let s;
      if (Ds(e)) {
        const i = gy(this), a = Ef(e, void 0);
        let c = !0;
        try {
          s = t(a), c = !1;
        } finally {
          c ? Sf(i) : Cf(i);
        }
        return py(i, n), my(s, i);
      } else if (!e || typeof e != "object") {
        if (s = t(e), s === void 0 && (s = e), s === Wp && (s = void 0), this.autoFreeze_ && Hp(s, !0), n) {
          const i = [], a = [];
          xi("Patches").generateReplacementPatches_(e, s, i, a), n(i, a);
        }
        return s;
      } else
        $t(1, e);
    }, this.produceWithPatches = (e, t) => {
      if (typeof e == "function")
        return (a, ...c) => this.produceWithPatches(a, (u) => e(u, ...c));
      let n, s;
      return [this.produce(e, t, (a, c) => {
        n = a, s = c;
      }), n, s];
    }, typeof r?.autoFreeze == "boolean" && this.setAutoFreeze(r.autoFreeze), typeof r?.useStrictShallowCopy == "boolean" && this.setUseStrictShallowCopy(r.useStrictShallowCopy);
  }
  createDraft(r) {
    Ds(r) || $t(8), bi(r) && (r = VF(r));
    const e = gy(this), t = Ef(r, void 0);
    return t[Yr].isManual_ = !0, Cf(e), t;
  }
  finishDraft(r, e) {
    const t = r && r[Yr];
    (!t || !t.isManual_) && $t(9);
    const { scope_: n } = t;
    return py(n, e), my(void 0, n);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(r) {
    this.autoFreeze_ = r;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(r) {
    this.useStrictShallowCopy_ = r;
  }
  applyPatches(r, e) {
    let t;
    for (t = e.length - 1; t >= 0; t--) {
      const s = e[t];
      if (s.path.length === 0 && s.op === "replace") {
        r = s.value;
        break;
      }
    }
    t > -1 && (e = e.slice(t + 1));
    const n = xi("Patches").applyPatches_;
    return bi(r) ? n(r, e) : this.produce(
      r,
      (s) => n(s, e)
    );
  }
};
function Ef(r, e) {
  const t = Xa(r) ? xi("MapSet").proxyMap_(r, e) : Ga(r) ? xi("MapSet").proxySet_(r, e) : FF(r, e);
  return (e ? e.scope_ : u_()).drafts_.push(t), t;
}
function VF(r) {
  return bi(r) || $t(10, r), d_(r);
}
function d_(r) {
  if (!Ds(r) || Ru(r))
    return r;
  const e = r[Yr];
  let t;
  if (e) {
    if (!e.modified_)
      return e.base_;
    e.finalized_ = !0, t = xf(r, e.scope_.immer_.useStrictShallowCopy_);
  } else
    t = xf(r, !0);
  return Aa(t, (n, s) => {
    l_(t, n, d_(s));
  }), e && (e.finalized_ = !1), t;
}
function yy() {
  process.env.NODE_ENV !== "production" && a_.push(
    'Sets cannot have "replace" patches.',
    function(g) {
      return "Unsupported patch operation: " + g;
    },
    function(g) {
      return "Cannot apply patch, path doesn't resolve: " + g;
    },
    "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
  );
  const e = "replace", t = "add", n = "remove";
  function s(g, v, b, _) {
    switch (g.type_) {
      case 0:
      case 2:
        return a(
          g,
          v,
          b,
          _
        );
      case 1:
        return i(g, v, b, _);
      case 3:
        return c(
          g,
          v,
          b,
          _
        );
    }
  }
  function i(g, v, b, _) {
    let { base_: C, assigned_: T } = g, k = g.copy_;
    k.length < C.length && ([C, k] = [k, C], [b, _] = [_, b]);
    for (let M = 0; M < C.length; M++)
      if (T[M] && k[M] !== C[M]) {
        const A = v.concat([M]);
        b.push({
          op: e,
          path: A,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: p(k[M])
        }), _.push({
          op: e,
          path: A,
          value: p(C[M])
        });
      }
    for (let M = C.length; M < k.length; M++) {
      const A = v.concat([M]);
      b.push({
        op: t,
        path: A,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: p(k[M])
      });
    }
    for (let M = k.length - 1; C.length <= M; --M) {
      const A = v.concat([M]);
      _.push({
        op: n,
        path: A
      });
    }
  }
  function a(g, v, b, _) {
    const { base_: C, copy_: T } = g;
    Aa(g.assigned_, (k, M) => {
      const A = bd(C, k), D = bd(T, k), F = M ? Ia(C, k) ? e : t : n;
      if (A === D && F === e)
        return;
      const U = v.concat(k);
      b.push(F === n ? { op: F, path: U } : { op: F, path: U, value: D }), _.push(
        F === t ? { op: n, path: U } : F === n ? { op: t, path: U, value: p(A) } : { op: e, path: U, value: p(A) }
      );
    });
  }
  function c(g, v, b, _) {
    let { base_: C, copy_: T } = g, k = 0;
    C.forEach((M) => {
      if (!T.has(M)) {
        const A = v.concat([k]);
        b.push({
          op: n,
          path: A,
          value: M
        }), _.unshift({
          op: t,
          path: A,
          value: M
        });
      }
      k++;
    }), k = 0, T.forEach((M) => {
      if (!C.has(M)) {
        const A = v.concat([k]);
        b.push({
          op: t,
          path: A,
          value: M
        }), _.unshift({
          op: n,
          path: A,
          value: M
        });
      }
      k++;
    });
  }
  function u(g, v, b, _) {
    b.push({
      op: e,
      path: [],
      value: v === Wp ? void 0 : v
    }), _.push({
      op: e,
      path: [],
      value: g
    });
  }
  function h(g, v) {
    return v.forEach((b) => {
      const { path: _, op: C } = b;
      let T = g;
      for (let D = 0; D < _.length - 1; D++) {
        const F = wi(T);
        let U = _[D];
        typeof U != "string" && typeof U != "number" && (U = "" + U), (F === 0 || F === 1) && (U === "__proto__" || U === "constructor") && $t(19), typeof T == "function" && U === "prototype" && $t(19), T = bd(T, U), typeof T != "object" && $t(18, _.join("/"));
      }
      const k = wi(T), M = d(b.value), A = _[_.length - 1];
      switch (C) {
        case e:
          switch (k) {
            case 2:
              return T.set(A, M);
            case 3:
              $t(16);
            default:
              return T[A] = M;
          }
        case t:
          switch (k) {
            case 1:
              return A === "-" ? T.push(M) : T.splice(A, 0, M);
            case 2:
              return T.set(A, M);
            case 3:
              return T.add(M);
            default:
              return T[A] = M;
          }
        case n:
          switch (k) {
            case 1:
              return T.splice(A, 1);
            case 2:
              return T.delete(A);
            case 3:
              return T.delete(b.value);
            default:
              return delete T[A];
          }
        default:
          $t(17, C);
      }
    }), g;
  }
  function d(g) {
    if (!Ds(g))
      return g;
    if (Array.isArray(g))
      return g.map(d);
    if (Xa(g))
      return new Map(
        Array.from(g.entries()).map(([b, _]) => [b, d(_)])
      );
    if (Ga(g))
      return new Set(Array.from(g).map(d));
    const v = Object.create(yi(g));
    for (const b in g)
      v[b] = d(g[b]);
    return Ia(g, wa) && (v[wa] = g[wa]), v;
  }
  function p(g) {
    return bi(g) ? d(g) : g;
  }
  RF("Patches", {
    applyPatches_: h,
    generatePatches_: s,
    generateReplacementPatches_: u
  });
}
var Xr = new BF(), zF = Xr.produce;
Xr.produceWithPatches.bind(
  Xr
);
Xr.setAutoFreeze.bind(Xr);
Xr.setUseStrictShallowCopy.bind(Xr);
var WF = Xr.applyPatches.bind(Xr);
Xr.createDraft.bind(Xr);
Xr.finishDraft.bind(Xr);
function HF(r) {
  const e = r.value, t = [];
  if (e?.payload?.trackItemIds) {
    const n = e.payload.trackItemIds;
    t.push(n), this.updateState({ activeIds: t });
  }
  if (r.key === E1) {
    const n = r.value?.payload.trackItemIds, s = st.cloneDeep(this.getState()), i = n?.length ? n : s.activeIds, a = s.trackItemIds.filter(
      (p) => !i.includes(p)
    ), c = Object.fromEntries(
      Object.entries(s.trackItemDetailsMap).filter(
        ([p]) => !i.includes(p)
      )
    ), u = _j(s.tracks, i), h = Object.fromEntries(
      Object.entries(s.trackItemsMap).filter(
        ([p]) => !i.includes(p)
      )
    ), d = Nn(h);
    this.updateState(
      {
        trackItemIds: a,
        trackItemDetailsMap: c,
        activeIds: [],
        trackItemsMap: h,
        tracks: u,
        duration: d
      },
      { updateHistory: !0, kind: "remove" }
    );
  }
  if (r.key === k1) {
    const n = st.cloneDeep(this.getState()), s = [], i = r.value?.payload.trackItemIds || n.activeIds;
    if (i.length === 0) return;
    i.forEach((c) => {
      const u = n.trackItemsMap[c], h = n.trackItemDetailsMap[c], d = Yt();
      s.push(d), n.trackItemsMap = {
        ...n.trackItemsMap,
        [d]: { ...st.cloneDeep(u), id: d }
      }, n.trackItemDetailsMap = {
        ...n.trackItemDetailsMap,
        [d]: { ...st.cloneDeep(h) }
      }, n.trackItemIds.push(d);
    });
    const a = n.tracks.map((c) => {
      const u = {
        ...c,
        id: Yt(),
        items: c.items.filter((h) => i.includes(h)).map((h) => {
          const d = i.indexOf(h);
          return s[d];
        })
      };
      return u.items.length ? u : null;
    }).filter(Boolean);
    n.tracks.unshift(...a), this.updateState(
      {
        trackItemDetailsMap: n.trackItemDetailsMap,
        tracks: n.tracks,
        trackItemIds: n.trackItemIds,
        trackItemsMap: n.trackItemsMap
      },
      {
        updateHistory: !0,
        kind: "update"
      }
    );
  }
  if (r.key === O1) {
    const n = st.cloneDeep(this.getState()), s = r.value?.options.time;
    if (n.activeIds.length !== 1) return;
    const i = n.activeIds[0], a = n.trackItemsMap[i];
    if (s <= a.display.from || s >= a.display.to)
      return;
    const c = Yt(), u = {
      ...a,
      id: c,
      display: { from: s, to: a.display.to },
      trim: { from: s, to: a.display.to }
    };
    n.trackItemsMap[i].display.to = s, n.trackItemsMap[c] = u, n.trackItemDetailsMap[c] = n.trackItemDetailsMap[i], n.trackItemIds.push(c), n.tracks.forEach((h) => {
      h.items.includes(i) && h.items.push(c);
    }), this.updateState(
      {
        trackItemsMap: n.trackItemsMap,
        trackItemDetailsMap: n.trackItemDetailsMap,
        trackItemIds: n.trackItemIds,
        tracks: n.tracks
      },
      { updateHistory: !0, kind: "update" }
    );
  }
}
async function UF(r) {
  if (r.key === "scene:load") {
    const e = r.value?.payload, t = e.size, n = e.trackItemIds, s = e.trackItemsMap, i = e.trackItemDetailsMap;
    if (!n) return;
    const a = n?.map(async (u) => {
      try {
        const h = i[u], d = s[u];
        if (h.type === "text") {
          const p = await Ix(
            { id: u, details: h.details, ...d },
            {
              size: t
            }
          ), { details: g, ...v } = p;
          i[u] = { type: "text", details: g }, s[u] = v;
        }
        return !0;
      } catch {
        return !1;
      }
    });
    await Promise.all(a);
    const c = Nn(s);
    this.updateState({
      ...e,
      trackItemsMap: s,
      duration: c
    });
  }
}
async function $F(r) {
  const e = st.cloneDeep(this.getState()), t = r.value?.options?.trackId, n = r.value?.options?.trackIndex;
  let s = [], i;
  if (r.key === ja) {
    i = "video";
    const c = await Cj(r.value?.payload, {
      size: e.size
    }), { details: u, ...h } = c;
    e.trackItemDetailsMap[h.id] = {
      type: i,
      details: u
    }, e.trackItemsMap[h.id] = h, e.trackItemIds.push(h.id), s = [h.id];
  }
  if (r.key === Fa) {
    i = "image";
    const c = await Sj(r.value?.payload, {
      size: e.size
    }), { details: u, ...h } = c;
    e.trackItemDetailsMap[h.id] = {
      type: i,
      details: u
    }, e.trackItemsMap[h.id] = h, e.trackItemIds.push(h.id), s = [h.id];
  }
  if (r.key === La) {
    i = "audio";
    const c = await Tj(r.value?.payload), { details: u, ...h } = c;
    e.trackItemDetailsMap[h.id] = {
      type: i,
      details: u
    }, e.trackItemsMap[h.id] = h, e.trackItemIds.push(h.id), s = [h.id];
  }
  if (r.key === T1) {
    i = "text";
    const { details: c, ...u } = await Ix(
      r.value?.payload ?? void 0,
      {
        size: e.size
      }
    );
    e.trackItemDetailsMap[u.id] = { type: i, details: c }, e.trackItemsMap[u.id] = u, e.trackItemIds.push(u.id), s.push(u.id);
  }
  const a = YF(
    s,
    e.tracks,
    e.trackItemsMap,
    t,
    n
  );
  if (a.trackId)
    e.tracks.find((u) => u.id === a.trackId)?.items.push(...s);
  else if (a.trackIndex !== void 0) {
    const c = by(i, s);
    e.tracks.splice(a.trackIndex, 0, c);
  } else {
    const c = by(i, s);
    e.tracks.unshift(c);
  }
  e.duration = Nn(e.trackItemsMap), this.updateState(
    {
      trackItemIds: e.trackItemIds,
      trackItemDetailsMap: e.trackItemDetailsMap,
      trackItemsMap: e.trackItemsMap,
      tracks: e.tracks,
      duration: e.duration,
      structure: e.structure
    },
    {
      updateHistory: !0,
      kind: "add"
    }
  );
}
function by(r, e) {
  return {
    id: Yt(),
    accepts: ["text", "audio", "helper", "video", "image"],
    type: r,
    items: e,
    magnetic: !1,
    static: !1
  };
}
const YF = (r, e, t, n, s) => {
  if (n === void 0 && s === void 0)
    return { trackId: void 0, trackIndex: void 0 };
  const i = s !== void 0 ? e[Math.max(0, Math.min(s, e.length - 1))] : e.find((u) => u.id === n);
  if (!i)
    return {
      trackId: void 0,
      trackIndex: s !== void 0 ? Math.max(0, Math.min(s, e.length - 1)) : void 0
    };
  const a = i.items.map((u) => t[u]), c = r.map((u) => t[u]);
  for (const u of a) {
    const h = u.display.from, d = u.display.to;
    for (const p of c) {
      const g = p.display.from;
      if (!(p.display.to <= h || g >= d))
        return {
          trackId: void 0,
          trackIndex: e.indexOf(i)
        };
    }
  }
  return {
    trackId: i.id,
    trackIndex: e.indexOf(i)
  };
}, wy = [
  "tracks",
  "trackItemsMap",
  "trackItemDetailsMap",
  "transitionIds",
  "transitionsMap",
  "trackItemIds"
], XF = {
  size: {
    width: 1080,
    height: 1920
  },
  tracks: [],
  trackItemIds: [],
  trackItemsMap: {},
  transitionIds: [],
  transitionsMap: {},
  scale: {
    unit: 1,
    zoom: 1,
    segments: 1,
    index: 1
  },
  duration: 0,
  activeIds: [],
  trackItemDetailsMap: {},
  structure: []
};
class a9 {
  stateSubject;
  stateHistorySubject;
  prevState;
  undos;
  redos;
  listener;
  constructor(e) {
    this.stateSubject = null, this.stateHistorySubject = null, this.prevState = null, this.undos = [], this.redos = [], this.listener = null;
    const t = e || XF;
    this.stateSubject = new jv(t), this.stateHistorySubject = new jv({
      handleRedo: !1,
      handleUndo: !1
    }), this.prevState = t, this.initListeners();
  }
  initListeners() {
    GF(this);
  }
  destroyListeners() {
    this.listener && this.listener.unsubscribe();
  }
  purge() {
    this.destroyListeners();
  }
  updateHistory(e, t) {
    const n = st.pick(e, wy), s = st.pick(this.getState(), wy), i = o_(s, n);
    i.length && (this.undos.push({ undos: i, type: t }), this.redos = []);
  }
  getStateHistory() {
    return this.stateHistorySubject.getValue();
  }
  subscribeHistory(e) {
    return this.stateHistorySubject.subscribe(e);
  }
  getState() {
    return this.stateSubject.getValue();
  }
  subscribe(e) {
    return this.stateSubject.subscribe(e);
  }
  updateState(e, t = { updateHistory: !1, kind: void 0 }) {
    const n = this.getState(), s = { ...n, ...e };
    if (!st.isEqual(n, s)) {
      t.updateHistory && this.updateHistory(s, t.kind);
      const { duration: i, trackItemsMap: a, ...c } = n;
      this.prevState = {
        ...c,
        duration: this.prevState.duration,
        trackItemsMap: this.prevState.trackItemsMap
      }, this.stateSubject.next(s);
    }
  }
  subscribeToSize(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      st.isEqual(t.size, this.prevState.size) || e({ size: t.size });
    });
  }
  subscribeToScale(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      st.isEqual(t.scale, this.prevState.scale) || e({ scale: t.scale });
    });
  }
  subscribeToUpdateTrackItem(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      st.isEqual(t.trackItemsMap, this.prevState.trackItemsMap) || e({ trackItemsMap: t.trackItemsMap });
    });
  }
  subscribeToUpdateItemDetails(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      st.isEqual(
        t.trackItemDetailsMap,
        this.prevState.trackItemDetailsMap
      ) || e({ trackItemDetailsMap: t.trackItemDetailsMap });
    });
  }
  subscribeToDuration(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      t.duration !== this.prevState.duration && e({ duration: t.duration });
    });
  }
  subscribeToHistory(e) {
    return this.stateHistorySubject.asObservable().subscribe((t) => {
      if (t.handleRedo) {
        const n = this.undos[this.undos.length - 1]?.type;
        n === "update" && e({ ...this.getState(), type: n }), this.stateHistorySubject.next({
          handleRedo: !1,
          handleUndo: !1
        });
      }
      if (t.handleUndo) {
        const n = this.redos[this.redos.length - 1]?.type;
        n === "update" && e({ ...this.getState(), type: n }), this.stateHistorySubject.next({
          handleRedo: !1,
          handleUndo: !1
        });
      }
    });
  }
  subscribeToAddOrRemoveItems(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      (!t.trackItemIds?.every(
        (n) => this.prevState.trackItemIds?.includes(n)
      ) || !st.isEqual(t.tracks, this.prevState.tracks)) && e({ trackItemIds: t.trackItemIds });
    });
  }
  subscribeToActiveIds(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      st.isEqual(t.activeIds, this.prevState.activeIds) || e({ activeIds: t.activeIds });
    });
  }
  subscribeToTracks(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      (!st.isEqual(t.tracks, this.prevState.tracks) || !st.isEqual(t.trackItemIds, this.prevState.trackItemIds) || !st.isEqual(t.trackItemsMap, this.prevState.trackItemsMap) || !st.isEqual(t.transitionIds, this.prevState.transitionIds) || !st.isEqual(t.transitionsMap, this.prevState.transitionsMap) || !st.isEqual(
        t.trackItemDetailsMap,
        this.prevState.trackItemDetailsMap
      )) && e({
        tracks: t.tracks,
        trackItemIds: t.trackItemIds,
        trackItemsMap: t.trackItemsMap,
        transitionIds: t.transitionIds,
        transitionsMap: t.transitionsMap,
        trackItemDetailsMap: t.trackItemDetailsMap
        // structure: currentState.structure,
      });
    });
  }
  undo() {
    const e = this.undos.pop(), t = e?.undos, n = e?.type;
    if (!t || !n) return;
    yy();
    const {
      trackItemDetailsMap: s,
      trackItemIds: i,
      tracks: a,
      transitionIds: c,
      transitionsMap: u,
      trackItemsMap: h
    } = this.getState(), d = st.cloneDeep({
      trackItemDetailsMap: s,
      trackItemIds: i,
      tracks: a,
      transitionIds: c,
      transitionsMap: u,
      trackItemsMap: h
    }), p = [], g = [], v = [], b = [], _ = [], C = [];
    t.forEach((G) => {
      let K;
      const oe = G.path.slice(1);
      G.type === "CREATE" ? K = {
        path: oe,
        op: "remove",
        value: G.value
      } : G.type === "CHANGE" ? K = {
        path: oe,
        op: "replace",
        value: G.oldValue
      } : K = {
        path: oe,
        op: "add",
        value: G.oldValue
      }, G.path.includes("trackItemIds") ? v.push(K) : G.path.includes("transitionIds") ? g.push(K) : G.path.includes("trackItemsMap") ? _.push(K) : G.path.includes("transitionsMap") ? b.push(K) : G.path.includes("tracks") ? p.push(K) : G.path.includes("trackItemDetailsMap") && C.push(K);
    });
    const T = this.applyPatch(d.tracks, p), k = this.applyPatch(
      d.transitionIds,
      g
    ), M = this.applyPatch(
      d.trackItemIds,
      v
    ), A = this.applyPatch(
      d.transitionsMap,
      b
    ), D = this.applyPatch(
      d.trackItemsMap,
      _
    ), F = this.applyPatch(
      d.trackItemDetailsMap,
      C
    ), U = st.cloneDeep({
      tracks: T,
      transitionIds: k,
      trackItemIds: M,
      transitionsMap: A,
      trackItemsMap: D,
      trackItemDetailsMap: F
    }), B = st.cloneDeep(this.getState()), X = { ...B, ...U };
    this.prevState = B;
    const Y = { redos: t, type: n };
    this.redos.push(Y);
    const Z = Nn(X.trackItemsMap);
    this.stateSubject.next({ ...X, duration: Z }), this.stateHistorySubject.next({ handleRedo: !1, handleUndo: !0 });
  }
  redo() {
    const e = this.redos.pop();
    if (!e?.redos || !e?.type) return;
    yy();
    const t = this.getState(), {
      trackItemDetailsMap: n,
      trackItemIds: s,
      tracks: i,
      transitionIds: a,
      transitionsMap: c,
      trackItemsMap: u
    } = t, h = st.cloneDeep({
      trackItemDetailsMap: n,
      trackItemIds: s,
      tracks: i,
      transitionIds: a,
      transitionsMap: c,
      trackItemsMap: u
    }), d = [], p = [], g = [], v = [], b = [], _ = [];
    e.redos.forEach((A) => {
      const D = A.path.slice(1);
      let F = {};
      switch (A.type) {
        case "CREATE":
          F = {
            path: D,
            op: "add",
            value: A.value
          };
          break;
        case "CHANGE":
          F = {
            path: D,
            op: "replace",
            value: A.value
          };
          break;
        case "REMOVE":
          F = {
            path: D,
            op: "remove",
            value: A.oldValue
          };
          break;
        default:
          return null;
      }
      A.path.includes("trackItemIds") ? g.push(F) : A.path.includes("transitionIds") ? p.push(F) : A.path.includes("trackItemsMap") ? b.push(F) : A.path.includes("transitionsMap") ? v.push(F) : A.path.includes("trackItemDetailsMap") ? _.push(F) : d.push(F);
    });
    const C = {
      tracks: this.applyPatch(h.tracks, d),
      transitionIds: this.applyPatch(h.transitionIds, p),
      trackItemIds: this.applyPatch(h.trackItemIds, g),
      transitionsMap: this.applyPatch(h.transitionsMap, v),
      trackItemsMap: this.applyPatch(h.trackItemsMap, b),
      trackItemDetailsMap: this.applyPatch(h.trackItemDetailsMap, _)
    }, T = st.cloneDeep(C), k = { ...st.cloneDeep(t), ...T };
    this.prevState = t, this.undos.push({ undos: e.redos, type: e.type });
    const M = Nn(k.trackItemsMap);
    this.stateSubject.next({ ...k, duration: M }), this.stateHistorySubject.next({ handleRedo: !0, handleUndo: !1 });
  }
  applyPatch(e, t) {
    return t.reverse().reduce(
      (n, s) => zF(n, (i) => {
        WF(i, [s]);
      }),
      e
    );
  }
}
function GF(r) {
  const e = Ze.subject.pipe(ii(({ key: i }) => i.startsWith(_A))).subscribe((i) => {
    i.key === M1 && r.undo(), i.key === A1 && r.redo();
  }), t = Ze.subject.pipe(ii(({ key: i, value: a }) => i.startsWith(vA))).subscribe((i) => {
    $F.bind(r)(i);
  }), n = Ze.subject.pipe(
    ii(({ key: i, value: a }) => i.startsWith("scene"))
  ).subscribe(async (i) => {
    await UF.bind(r)(i);
  }), s = Ze.subject.pipe(ii(({ key: i }) => i.startsWith(wA))).subscribe(async (i) => {
    HF.bind(r)(i);
  });
  return () => {
    e.unsubscribe(), t.unsubscribe(), s.unsubscribe(), n.unsubscribe();
  };
}
export {
  k1 as ACTIVE_CLONE,
  E1 as ACTIVE_DELETE,
  x8 as ACTIVE_PASTE,
  wA as ACTIVE_PREFIX,
  w8 as ACTIVE_SET,
  O1 as ACTIVE_SPLIT,
  l8 as ADD_ANIMATION,
  La as ADD_AUDIO,
  Fa as ADD_IMAGE,
  a8 as ADD_MASK,
  o8 as ADD_PLACEHOLDER,
  vA as ADD_PREFIX,
  QF as ADD_SUFFIX,
  T1 as ADD_TEXT,
  c8 as ADD_TRANSITION,
  ja as ADD_VIDEO,
  M5 as AUDIOS,
  Dj as Audio,
  Ts as AudioObject,
  Y8 as BASE_TIMELINE_ELEMENT_DURATION_MS,
  br as Button,
  $4 as CanvasMixin,
  K8 as DEFAULT_AUDIO_BITRATE,
  q8 as DEFAULT_AUDIO_SAMPLE_RATE,
  F7 as DEFAULT_BLUR,
  L7 as DEFAULT_BLUR_STEP,
  v7 as DEFAULT_BRIGHTNESS,
  m7 as DEFAULT_BRIGHTNESS_STEP,
  M7 as DEFAULT_CONTRAST,
  O7 as DEFAULT_CONTRAST_STEP,
  o7 as DEFAULT_FADE_IN,
  a7 as DEFAULT_FADE_OUT,
  i7 as DEFAULT_FADE_STEP,
  d7 as DEFAULT_FLIP_X,
  f7 as DEFAULT_FLIP_Y,
  Nv as DEFAULT_FONT,
  QA as DEFAULT_FRAMERATE,
  j7 as DEFAULT_MAX_BLUR,
  g7 as DEFAULT_MAX_BRIGHTNESS,
  k7 as DEFAULT_MAX_CONTRAST,
  s7 as DEFAULT_MAX_FADE,
  I7 as DEFAULT_MAX_OPACITY,
  l7 as DEFAULT_MAX_ROTATION,
  b7 as DEFAULT_MAX_SATURATION,
  B7 as DEFAULT_MAX_SPEED,
  S7 as DEFAULT_MAX_TEMPERATURE,
  H7 as DEFAULT_MAX_VOLUME,
  e7 as DEFAULT_MEDIA_PANEL_WIDTH,
  R7 as DEFAULT_MIN_BLUR,
  p7 as DEFAULT_MIN_BRIGHTNESS,
  E7 as DEFAULT_MIN_CONTRAST,
  n7 as DEFAULT_MIN_FADE,
  A7 as DEFAULT_MIN_OPACITY,
  c7 as DEFAULT_MIN_ROTATION,
  y7 as DEFAULT_MIN_SATURATION,
  N7 as DEFAULT_MIN_SPEED,
  _7 as DEFAULT_MIN_TEMPERATURE,
  W7 as DEFAULT_MIN_VOLUME,
  D7 as DEFAULT_OPACITY,
  P7 as DEFAULT_OPACITY_STEP,
  J8 as DEFAULT_PREVIEW_HEIGHT,
  B1 as DEFAULT_PREVIEW_SCALE,
  Z8 as DEFAULT_PREVIEW_WIDTH,
  h7 as DEFAULT_ROTATION,
  u7 as DEFAULT_ROTATION_STEP,
  x7 as DEFAULT_SATURATION,
  w7 as DEFAULT_SATURATION_STEP,
  r7 as DEFAULT_SETTINGS_PANEL_WIDTH,
  z7 as DEFAULT_SPEED,
  V7 as DEFAULT_SPEED_STEP,
  T7 as DEFAULT_TEMPERATURE,
  C7 as DEFAULT_TEMPERATURE_STEP,
  JA as DEFAULT_VIDEO_HEIGHT,
  G8 as DEFAULT_VIDEO_MAX_BITRATE,
  X8 as DEFAULT_VIDEO_MIN_BITRATE,
  ZA as DEFAULT_VIDEO_WIDTH,
  $7 as DEFAULT_VOLUME,
  U7 as DEFAULT_VOLUME_STEP,
  $8 as DEFAULT_WEIGHT,
  wl as DRAG_END,
  CA as DRAG_PREFIX,
  P1 as DRAG_START,
  Jl as Draggable,
  GA as DroppableArea,
  h8 as EDIT_OBJECT,
  u8 as EDIT_PREFIX,
  f8 as EDIT_SHAPE,
  d8 as EDIT_TEXT,
  p8 as ENTER_EDIT_MODE,
  e5 as FRAME_INTERVAL,
  N8 as GIANT_ICON_SIZE,
  _A as HISTORY_PREFIX,
  A1 as HISTORY_REDO,
  L8 as HISTORY_RESET,
  M1 as HISTORY_UNDO,
  k5 as Header,
  Fj as Helper,
  $a as HelperObject,
  A5 as IMAGES,
  jj as Image,
  Pp as ImageObject,
  W8 as LARGER_FONT_SIZE,
  H8 as LARGE_FONT_SIZE,
  B8 as LARGE_ICON_SIZE,
  P8 as LAYER_CLONE,
  A8 as LAYER_COPY,
  R8 as LAYER_CUT,
  j8 as LAYER_DELETE,
  M8 as LAYER_EDITING_NAME,
  C8 as LAYER_HIDDEN,
  S8 as LAYER_LOCKED,
  T8 as LAYER_MOVE,
  I8 as LAYER_PASTE,
  _8 as LAYER_PREFIX,
  O8 as LAYER_RENAME,
  E8 as LAYER_SELECT,
  xA as LAYER_SELECTION,
  k8 as LAYER_SEND_TO,
  D8 as LAYER_SPLIT,
  t7 as MAX_MEDIA_PANEL_WIDTH,
  Q8 as MIN_MEDIA_PANEL_WIDTH,
  J7 as MenuItem,
  U8 as NORMAL_FONT_SIZE,
  V8 as NORMAL_ICON_SIZE,
  Q7 as NavbarComponent,
  bA as PLAYER_PAUSE,
  yA as PLAYER_PLAY,
  g8 as PLAYER_PREFIX,
  m8 as PLAYER_SEEK,
  y8 as PLAYER_SEEK_BY,
  v8 as PLAYER_SEEK_TO,
  b8 as PLAYER_TOGGLE_PLAY,
  tu as PREVIEW_FRAME_WIDTH,
  Oa as Placeholder,
  IR as Player,
  PR as PlayheadComponent,
  Wl as PreviewTrackItem,
  DR as RulerComponent,
  KA as SECONDARY_FONT,
  qA as SMALL_FONT_SIZE,
  z8 as SMALL_ICON_SIZE,
  i8 as STATE_CHANGED,
  s8 as STATE_PREFIX,
  e9 as Scene,
  F8 as SceneBoard,
  vo as ScrollArea,
  n1 as ScrollBar,
  iR as SequenceItem,
  FM as Slider,
  a9 as StateManager,
  D1 as TIMELINE_BOUNDING_CHANGED,
  Bf as TIMELINE_OFFSET_CANVAS_LEFT,
  Fv as TIMELINE_OFFSET_CANVAS_RIGHT,
  zd as TIMELINE_OFFSET_X,
  TA as TIMELINE_PREFIX,
  I1 as TIMELINE_SCALE_CHANGED,
  SA as TIMELINE_SCALE_PREFIX,
  Ln as TIMELINE_ZOOM_LEVELS,
  r8 as TRACKS_CHANGED,
  n8 as TRACK_ITEMS_CHANGED,
  t8 as TRACK_ITEMS_PREFIX,
  e8 as TRACK_PREFIX,
  P5 as TRANSITIONS,
  mA as Tabs,
  Rd as TabsContent,
  C1 as TabsList,
  Dd as TabsTrigger,
  Px as Text,
  fo as TextObject,
  zp as Timeline,
  o9 as TimelineComponent,
  Lj as Track,
  Nj as TrackItemsMixin,
  mi as TrackObject,
  Vj as TracksMixin,
  Sn as Transition,
  zl as TransitionGuide,
  Hj as TransitionsMixin,
  Z7 as UPLOADS,
  I5 as VIDEOS,
  Rj as Video,
  Io as VideoObject,
  TF as addEventListeners,
  mj as applyMixins,
  uM as buttonVariants,
  xj as calculateDisplayRange,
  Nn as calculateDuration,
  Dp as calculatePosition,
  u5 as calculateTimelineWidth,
  wj as calculateTrim,
  _i as cn,
  uj as createAudioControls,
  gj as createControls,
  oj as createMediaControls,
  Mx as createResizeControls,
  Mu as defaultColor,
  Ij as defaultSizes,
  _j as filterAndCleanTracks,
  V1 as findIndex,
  qF as formatBytes,
  Y7 as formatTimeToHumanReadable,
  t5 as formatTimelineUnit,
  r5 as frameToTimeString,
  s5 as getCurrentTime,
  X7 as getFitZoomLevel,
  n9 as getMovingState,
  a5 as getNextZoom,
  l5 as getNextZoomIndex,
  c5 as getNextZoomLevel,
  Ye as getOffset,
  o5 as getPreviousZoom,
  q7 as getPreviousZoomIndex,
  i5 as getPreviousZoomLevel,
  ml as getTextHeight,
  G7 as getZoomByIndex,
  MF as handleEvents,
  Bl as handleResize,
  vj as loadAudio,
  Tj as loadAudioItem,
  kj as loadAudioObject,
  h5 as loadFonts,
  yj as loadImage,
  Sj as loadImageItem,
  Oj as loadImageObject,
  Ix as loadTextItem,
  Aj as loadTextObject,
  bj as loadVideo,
  Cj as loadVideoItem,
  Mj as loadVideoObject,
  Pj as mergeSizes,
  z1 as mergeTrackObjects,
  ie as movingState,
  Y4 as positionOffsets,
  K7 as randomInt,
  EF as removeEventListeners,
  xl as removeItemsFromTrack,
  Is as renderControl,
  W1 as reorderTracksByIndex,
  GF as setupHistoryListeners,
  Nt as timeMsToUnits,
  n5 as timeToString,
  jt as transitionStore,
  di as unitsToTimeMs,
  s9 as updateMovingState,
  Vf as useCurrentPlayerFrame,
  ru as useIsDraggingOverTimeline,
  $1 as useLayoutStore,
  fi as useStore,
  Ax as wrapResizeWithAnchorPosition
};
