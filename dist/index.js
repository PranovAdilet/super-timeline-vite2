import * as W from "react";
import Ce, { useState as ue, useRef as be, cloneElement as Tk, useCallback as se, forwardRef as Vt, createElement as hd, useSyncExternalStore as Ek, useEffect as ce, createContext as At, createRef as u1, useMemo as ee, useContext as me, useImperativeHandle as Zr, useLayoutEffect as Kn, Suspense as rl, useReducer as kk } from "react";
import { createPortal as dd } from "react-dom";
var jo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ok(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var fd = { exports: {} }, Ro = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uv;
function Ik() {
  if (uv) return Ro;
  uv = 1;
  var r = Symbol.for("react.transitional.element"), e = Symbol.for("react.fragment");
  function t(n, i, s) {
    var a = null;
    if (s !== void 0 && (a = "" + s), i.key !== void 0 && (a = "" + i.key), "key" in i) {
      s = {};
      for (var c in i)
        c !== "key" && (s[c] = i[c]);
    } else s = i;
    return i = s.ref, {
      $$typeof: r,
      type: n,
      key: a,
      ref: i !== void 0 ? i : null,
      props: s
    };
  }
  return Ro.Fragment = e, Ro.jsx = t, Ro.jsxs = t, Ro;
}
var Fo = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hv;
function Ak() {
  return hv || (hv = 1, process.env.NODE_ENV !== "production" && function() {
    function r(A) {
      if (A == null) return null;
      if (typeof A == "function")
        return A.$$typeof === oe ? null : A.displayName || A.name || null;
      if (typeof A == "string") return A;
      switch (A) {
        case R:
          return "Fragment";
        case P:
          return "Portal";
        case F:
          return "Profiler";
        case V:
          return "StrictMode";
        case H:
          return "Suspense";
        case Y:
          return "SuspenseList";
      }
      if (typeof A == "object")
        switch (typeof A.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), A.$$typeof) {
          case z:
            return (A.displayName || "Context") + ".Provider";
          case $:
            return (A._context.displayName || "Context") + ".Consumer";
          case G:
            var he = A.render;
            return A = A.displayName, A || (A = he.displayName || he.name || "", A = A !== "" ? "ForwardRef(" + A + ")" : "ForwardRef"), A;
          case te:
            return he = A.displayName || null, he !== null ? he : r(A.type) || "Memo";
          case ge:
            he = A._payload, A = A._init;
            try {
              return r(A(he));
            } catch {
            }
        }
      return null;
    }
    function e(A) {
      return "" + A;
    }
    function t(A) {
      try {
        e(A);
        var he = !1;
      } catch {
        he = !0;
      }
      if (he) {
        he = console;
        var le = he.error, Re = typeof Symbol == "function" && Symbol.toStringTag && A[Symbol.toStringTag] || A.constructor.name || "Object";
        return le.call(
          he,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          Re
        ), e(A);
      }
    }
    function n() {
    }
    function i() {
      if (We === 0) {
        Ee = console.log, Ie = console.info, dt = console.warn, hr = console.error, Ht = console.group, Pt = console.groupCollapsed, dr = console.groupEnd;
        var A = {
          configurable: !0,
          enumerable: !0,
          value: n,
          writable: !0
        };
        Object.defineProperties(console, {
          info: A,
          log: A,
          warn: A,
          error: A,
          group: A,
          groupCollapsed: A,
          groupEnd: A
        });
      }
      We++;
    }
    function s() {
      if (We--, We === 0) {
        var A = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: re({}, A, { value: Ee }),
          info: re({}, A, { value: Ie }),
          warn: re({}, A, { value: dt }),
          error: re({}, A, { value: hr }),
          group: re({}, A, { value: Ht }),
          groupCollapsed: re({}, A, { value: Pt }),
          groupEnd: re({}, A, { value: dr })
        });
      }
      0 > We && console.error(
        "disabledDepth fell below zero. This is a bug in React. Please file an issue."
      );
    }
    function a(A) {
      if (ye === void 0)
        try {
          throw Error();
        } catch (le) {
          var he = le.stack.trim().match(/\n( *(at )?)/);
          ye = he && he[1] || "", _r = -1 < le.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < le.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + ye + A + _r;
    }
    function c(A, he) {
      if (!A || st) return "";
      var le = zt.get(A);
      if (le !== void 0) return le;
      st = !0, le = Error.prepareStackTrace, Error.prepareStackTrace = void 0;
      var Re = null;
      Re = ie.H, ie.H = null, i();
      try {
        var et = {
          DetermineComponentFrameRoot: function() {
            try {
              if (he) {
                var pr = function() {
                  throw Error();
                };
                if (Object.defineProperty(pr.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(pr, []);
                  } catch (Qt) {
                    var pn = Qt;
                  }
                  Reflect.construct(A, [], pr);
                } else {
                  try {
                    pr.call();
                  } catch (Qt) {
                    pn = Qt;
                  }
                  A.call(pr.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (Qt) {
                  pn = Qt;
                }
                (pr = A()) && typeof pr.catch == "function" && pr.catch(function() {
                });
              }
            } catch (Qt) {
              if (Qt && pn && typeof Qt.stack == "string")
                return [Qt.stack, pn.stack];
            }
            return [null, null];
          }
        };
        et.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var Ge = Object.getOwnPropertyDescriptor(
          et.DetermineComponentFrameRoot,
          "name"
        );
        Ge && Ge.configurable && Object.defineProperty(
          et.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var Se = et.DetermineComponentFrameRoot(), ot = Se[0], fr = Se[1];
        if (ot && fr) {
          var _t = ot.split(`
`), Cr = fr.split(`
`);
          for (Se = Ge = 0; Ge < _t.length && !_t[Ge].includes(
            "DetermineComponentFrameRoot"
          ); )
            Ge++;
          for (; Se < Cr.length && !Cr[Se].includes(
            "DetermineComponentFrameRoot"
          ); )
            Se++;
          if (Ge === _t.length || Se === Cr.length)
            for (Ge = _t.length - 1, Se = Cr.length - 1; 1 <= Ge && 0 <= Se && _t[Ge] !== Cr[Se]; )
              Se--;
          for (; 1 <= Ge && 0 <= Se; Ge--, Se--)
            if (_t[Ge] !== Cr[Se]) {
              if (Ge !== 1 || Se !== 1)
                do
                  if (Ge--, Se--, 0 > Se || _t[Ge] !== Cr[Se]) {
                    var Qr = `
` + _t[Ge].replace(
                      " at new ",
                      " at "
                    );
                    return A.displayName && Qr.includes("<anonymous>") && (Qr = Qr.replace("<anonymous>", A.displayName)), typeof A == "function" && zt.set(A, Qr), Qr;
                  }
                while (1 <= Ge && 0 <= Se);
              break;
            }
        }
      } finally {
        st = !1, ie.H = Re, s(), Error.prepareStackTrace = le;
      }
      return _t = (_t = A ? A.displayName || A.name : "") ? a(_t) : "", typeof A == "function" && zt.set(A, _t), _t;
    }
    function u(A) {
      if (A == null) return "";
      if (typeof A == "function") {
        var he = A.prototype;
        return c(
          A,
          !(!he || !he.isReactComponent)
        );
      }
      if (typeof A == "string") return a(A);
      switch (A) {
        case H:
          return a("Suspense");
        case Y:
          return a("SuspenseList");
      }
      if (typeof A == "object")
        switch (A.$$typeof) {
          case G:
            return A = c(A.render, !1), A;
          case te:
            return u(A.type);
          case ge:
            he = A._payload, A = A._init;
            try {
              return u(A(he));
            } catch {
            }
        }
      return "";
    }
    function h() {
      var A = ie.A;
      return A === null ? null : A.getOwner();
    }
    function d(A) {
      if (pe.call(A, "key")) {
        var he = Object.getOwnPropertyDescriptor(A, "key").get;
        if (he && he.isReactWarning) return !1;
      }
      return A.key !== void 0;
    }
    function p(A, he) {
      function le() {
        nt || (nt = !0, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          he
        ));
      }
      le.isReactWarning = !0, Object.defineProperty(A, "key", {
        get: le,
        configurable: !0
      });
    }
    function g() {
      var A = r(this.type);
      return Dt[A] || (Dt[A] = !0, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      )), A = this.props.ref, A !== void 0 ? A : null;
    }
    function v(A, he, le, Re, et, Ge) {
      return le = Ge.ref, A = {
        $$typeof: O,
        type: A,
        key: he,
        props: Ge,
        _owner: et
      }, (le !== void 0 ? le : null) !== null ? Object.defineProperty(A, "ref", {
        enumerable: !1,
        get: g
      }) : Object.defineProperty(A, "ref", { enumerable: !1, value: null }), A._store = {}, Object.defineProperty(A._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      }), Object.defineProperty(A, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      }), Object.freeze && (Object.freeze(A.props), Object.freeze(A)), A;
    }
    function b(A, he, le, Re, et, Ge) {
      if (typeof A == "string" || typeof A == "function" || A === R || A === F || A === V || A === H || A === Y || A === Z || typeof A == "object" && A !== null && (A.$$typeof === ge || A.$$typeof === te || A.$$typeof === z || A.$$typeof === $ || A.$$typeof === G || A.$$typeof === Ve || A.getModuleId !== void 0)) {
        var Se = he.children;
        if (Se !== void 0)
          if (Re)
            if (Ze(Se)) {
              for (Re = 0; Re < Se.length; Re++)
                x(Se[Re], A);
              Object.freeze && Object.freeze(Se);
            } else
              console.error(
                "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
              );
          else x(Se, A);
      } else
        Se = "", (A === void 0 || typeof A == "object" && A !== null && Object.keys(A).length === 0) && (Se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), A === null ? Re = "null" : Ze(A) ? Re = "array" : A !== void 0 && A.$$typeof === O ? (Re = "<" + (r(A.type) || "Unknown") + " />", Se = " Did you accidentally export a JSX literal instead of a component?") : Re = typeof A, console.error(
          "React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",
          Re,
          Se
        );
      if (pe.call(he, "key")) {
        Se = r(A);
        var ot = Object.keys(he).filter(function(_t) {
          return _t !== "key";
        });
        Re = 0 < ot.length ? "{key: someKey, " + ot.join(": ..., ") + ": ...}" : "{key: someKey}", An[Se + Re] || (ot = 0 < ot.length ? "{" + ot.join(": ..., ") + ": ...}" : "{}", console.error(
          `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
          Re,
          Se,
          ot,
          Se
        ), An[Se + Re] = !0);
      }
      if (Se = null, le !== void 0 && (t(le), Se = "" + le), d(he) && (t(he.key), Se = "" + he.key), "key" in he) {
        le = {};
        for (var fr in he)
          fr !== "key" && (le[fr] = he[fr]);
      } else le = he;
      return Se && p(
        le,
        typeof A == "function" ? A.displayName || A.name || "Unknown" : A
      ), v(A, Se, Ge, et, h(), le);
    }
    function x(A, he) {
      if (typeof A == "object" && A && A.$$typeof !== ri) {
        if (Ze(A))
          for (var le = 0; le < A.length; le++) {
            var Re = A[le];
            _(Re) && C(Re, he);
          }
        else if (_(A))
          A._store && (A._store.validated = 1);
        else if (A === null || typeof A != "object" ? le = null : (le = de && A[de] || A["@@iterator"], le = typeof le == "function" ? le : null), typeof le == "function" && le !== A.entries && (le = le.call(A), le !== A))
          for (; !(A = le.next()).done; )
            _(A.value) && C(A.value, he);
      }
    }
    function _(A) {
      return typeof A == "object" && A !== null && A.$$typeof === O;
    }
    function C(A, he) {
      if (A._store && !A._store.validated && A.key == null && (A._store.validated = 1, he = E(he), !Sr[he])) {
        Sr[he] = !0;
        var le = "";
        A && A._owner != null && A._owner !== h() && (le = null, typeof A._owner.tag == "number" ? le = r(A._owner.type) : typeof A._owner.name == "string" && (le = A._owner.name), le = " It was passed a child from " + le + ".");
        var Re = ie.getCurrentStack;
        ie.getCurrentStack = function() {
          var et = u(A.type);
          return Re && (et += Re() || ""), et;
        }, console.error(
          'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
          he,
          le
        ), ie.getCurrentStack = Re;
      }
    }
    function E(A) {
      var he = "", le = h();
      return le && (le = r(le.type)) && (he = `

Check the render method of \`` + le + "`."), he || (A = r(A)) && (he = `

Check the top-level render call using <` + A + ">."), he;
    }
    var k = Ce, O = Symbol.for("react.transitional.element"), P = Symbol.for("react.portal"), R = Symbol.for("react.fragment"), V = Symbol.for("react.strict_mode"), F = Symbol.for("react.profiler"), $ = Symbol.for("react.consumer"), z = Symbol.for("react.context"), G = Symbol.for("react.forward_ref"), H = Symbol.for("react.suspense"), Y = Symbol.for("react.suspense_list"), te = Symbol.for("react.memo"), ge = Symbol.for("react.lazy"), Z = Symbol.for("react.offscreen"), de = Symbol.iterator, oe = Symbol.for("react.client.reference"), ie = k.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, pe = Object.prototype.hasOwnProperty, re = Object.assign, Ve = Symbol.for("react.client.reference"), Ze = Array.isArray, We = 0, Ee, Ie, dt, hr, Ht, Pt, dr;
    n.__reactDisabledLog = !0;
    var ye, _r, st = !1, zt = new (typeof WeakMap == "function" ? WeakMap : Map)(), ri = Symbol.for("react.client.reference"), nt, Dt = {}, An = {}, Sr = {};
    Fo.Fragment = R, Fo.jsx = function(A, he, le, Re, et) {
      return b(A, he, le, !1, Re, et);
    }, Fo.jsxs = function(A, he, le, Re, et) {
      return b(A, he, le, !0, Re, et);
    };
  }()), Fo;
}
process.env.NODE_ENV === "production" ? fd.exports = Ik() : fd.exports = Ak();
var y = fd.exports;
function dv(r, e) {
  if (typeof r == "function")
    return r(e);
  r != null && (r.current = e);
}
function h1(...r) {
  return (e) => {
    let t = !1;
    const n = r.map((i) => {
      const s = dv(i, e);
      return !t && typeof s == "function" && (t = !0), s;
    });
    if (t)
      return () => {
        for (let i = 0; i < n.length; i++) {
          const s = n[i];
          typeof s == "function" ? s() : dv(r[i], null);
        }
      };
  };
}
function or(...r) {
  return W.useCallback(h1(...r), r);
}
var $s = W.forwardRef((r, e) => {
  const { children: t, ...n } = r, i = W.Children.toArray(t), s = i.find(Pk);
  if (s) {
    const a = s.props.children, c = i.map((u) => u === s ? W.Children.count(a) > 1 ? W.Children.only(null) : W.isValidElement(a) ? a.props.children : null : u);
    return /* @__PURE__ */ y.jsx(pd, { ...n, ref: e, children: W.isValidElement(a) ? W.cloneElement(a, void 0, c) : null });
  }
  return /* @__PURE__ */ y.jsx(pd, { ...n, ref: e, children: t });
});
$s.displayName = "Slot";
var pd = W.forwardRef((r, e) => {
  const { children: t, ...n } = r;
  if (W.isValidElement(t)) {
    const i = jk(t), s = Dk(n, t.props);
    return t.type !== W.Fragment && (s.ref = e ? h1(e, i) : i), W.cloneElement(t, s);
  }
  return W.Children.count(t) > 1 ? W.Children.only(null) : null;
});
pd.displayName = "SlotClone";
var Mk = ({ children: r }) => /* @__PURE__ */ y.jsx(y.Fragment, { children: r });
function Pk(r) {
  return W.isValidElement(r) && r.type === Mk;
}
function Dk(r, e) {
  const t = { ...e };
  for (const n in e) {
    const i = r[n], s = e[n];
    /^on[A-Z]/.test(n) ? i && s ? t[n] = (...c) => {
      s(...c), i(...c);
    } : i && (t[n] = i) : n === "style" ? t[n] = { ...i, ...s } : n === "className" && (t[n] = [i, s].filter(Boolean).join(" "));
  }
  return { ...r, ...t };
}
function jk(r) {
  let e = Object.getOwnPropertyDescriptor(r.props, "ref")?.get, t = e && "isReactWarning" in e && e.isReactWarning;
  return t ? r.ref : (e = Object.getOwnPropertyDescriptor(r, "ref")?.get, t = e && "isReactWarning" in e && e.isReactWarning, t ? r.props.ref : r.props.ref || r.ref);
}
var Rk = $s;
function d1(r) {
  var e, t, n = "";
  if (typeof r == "string" || typeof r == "number") n += r;
  else if (typeof r == "object") if (Array.isArray(r)) {
    var i = r.length;
    for (e = 0; e < i; e++) r[e] && (t = d1(r[e])) && (n && (n += " "), n += t);
  } else for (t in r) r[t] && (n && (n += " "), n += t);
  return n;
}
function f1() {
  for (var r, e, t = 0, n = "", i = arguments.length; t < i; t++) (r = arguments[t]) && (e = d1(r)) && (n && (n += " "), n += e);
  return n;
}
const fv = (r) => typeof r == "boolean" ? `${r}` : r === 0 ? "0" : r, pv = f1, Fk = (r, e) => (t) => {
  var n;
  if (e?.variants == null) return pv(r, t?.class, t?.className);
  const { variants: i, defaultVariants: s } = e, a = Object.keys(i).map((h) => {
    const d = t?.[h], p = s?.[h];
    if (d === null) return null;
    const g = fv(d) || fv(p);
    return i[h][g];
  }), c = t && Object.entries(t).reduce((h, d) => {
    let [p, g] = d;
    return g === void 0 || (h[p] = g), h;
  }, {}), u = e == null || (n = e.compoundVariants) === null || n === void 0 ? void 0 : n.reduce((h, d) => {
    let { class: p, className: g, ...v } = d;
    return Object.entries(v).every((b) => {
      let [x, _] = b;
      return Array.isArray(_) ? _.includes({
        ...s,
        ...c
      }[x]) : {
        ...s,
        ...c
      }[x] === _;
    }) ? [
      ...h,
      p,
      g
    ] : h;
  }, []);
  return pv(r, a, u, t?.class, t?.className);
}, gf = "-", Lk = (r) => {
  const e = Bk(r), {
    conflictingClassGroups: t,
    conflictingClassGroupModifiers: n
  } = r;
  return {
    getClassGroupId: (a) => {
      const c = a.split(gf);
      return c[0] === "" && c.length !== 1 && c.shift(), p1(c, e) || Nk(a);
    },
    getConflictingClassGroupIds: (a, c) => {
      const u = t[a] || [];
      return c && n[a] ? [...u, ...n[a]] : u;
    }
  };
}, p1 = (r, e) => {
  if (r.length === 0)
    return e.classGroupId;
  const t = r[0], n = e.nextPart.get(t), i = n ? p1(r.slice(1), n) : void 0;
  if (i)
    return i;
  if (e.validators.length === 0)
    return;
  const s = r.join(gf);
  return e.validators.find(({
    validator: a
  }) => a(s))?.classGroupId;
}, gv = /^\[(.+)\]$/, Nk = (r) => {
  if (gv.test(r)) {
    const e = gv.exec(r)[1], t = e?.substring(0, e.indexOf(":"));
    if (t)
      return "arbitrary.." + t;
  }
}, Bk = (r) => {
  const {
    theme: e,
    prefix: t
  } = r, n = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return zk(Object.entries(r.classGroups), t).forEach(([s, a]) => {
    gd(a, n, s, e);
  }), n;
}, gd = (r, e, t, n) => {
  r.forEach((i) => {
    if (typeof i == "string") {
      const s = i === "" ? e : mv(e, i);
      s.classGroupId = t;
      return;
    }
    if (typeof i == "function") {
      if (Vk(i)) {
        gd(i(n), e, t, n);
        return;
      }
      e.validators.push({
        validator: i,
        classGroupId: t
      });
      return;
    }
    Object.entries(i).forEach(([s, a]) => {
      gd(a, mv(e, s), t, n);
    });
  });
}, mv = (r, e) => {
  let t = r;
  return e.split(gf).forEach((n) => {
    t.nextPart.has(n) || t.nextPart.set(n, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), t = t.nextPart.get(n);
  }), t;
}, Vk = (r) => r.isThemeGetter, zk = (r, e) => e ? r.map(([t, n]) => {
  const i = n.map((s) => typeof s == "string" ? e + s : typeof s == "object" ? Object.fromEntries(Object.entries(s).map(([a, c]) => [e + a, c])) : s);
  return [t, i];
}) : r, Wk = (r) => {
  if (r < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  const i = (s, a) => {
    t.set(s, a), e++, e > r && (e = 0, n = t, t = /* @__PURE__ */ new Map());
  };
  return {
    get(s) {
      let a = t.get(s);
      if (a !== void 0)
        return a;
      if ((a = n.get(s)) !== void 0)
        return i(s, a), a;
    },
    set(s, a) {
      t.has(s) ? t.set(s, a) : i(s, a);
    }
  };
}, g1 = "!", Hk = (r) => {
  const {
    separator: e,
    experimentalParseClassName: t
  } = r, n = e.length === 1, i = e[0], s = e.length, a = (c) => {
    const u = [];
    let h = 0, d = 0, p;
    for (let _ = 0; _ < c.length; _++) {
      let C = c[_];
      if (h === 0) {
        if (C === i && (n || c.slice(_, _ + s) === e)) {
          u.push(c.slice(d, _)), d = _ + s;
          continue;
        }
        if (C === "/") {
          p = _;
          continue;
        }
      }
      C === "[" ? h++ : C === "]" && h--;
    }
    const g = u.length === 0 ? c : c.substring(d), v = g.startsWith(g1), b = v ? g.substring(1) : g, x = p && p > d ? p - d : void 0;
    return {
      modifiers: u,
      hasImportantModifier: v,
      baseClassName: b,
      maybePostfixModifierPosition: x
    };
  };
  return t ? (c) => t({
    className: c,
    parseClassName: a
  }) : a;
}, Uk = (r) => {
  if (r.length <= 1)
    return r;
  const e = [];
  let t = [];
  return r.forEach((n) => {
    n[0] === "[" ? (e.push(...t.sort(), n), t = []) : t.push(n);
  }), e.push(...t.sort()), e;
}, $k = (r) => ({
  cache: Wk(r.cacheSize),
  parseClassName: Hk(r),
  ...Lk(r)
}), Yk = /\s+/, Xk = (r, e) => {
  const {
    parseClassName: t,
    getClassGroupId: n,
    getConflictingClassGroupIds: i
  } = e, s = [], a = r.trim().split(Yk);
  let c = "";
  for (let u = a.length - 1; u >= 0; u -= 1) {
    const h = a[u], {
      modifiers: d,
      hasImportantModifier: p,
      baseClassName: g,
      maybePostfixModifierPosition: v
    } = t(h);
    let b = !!v, x = n(b ? g.substring(0, v) : g);
    if (!x) {
      if (!b) {
        c = h + (c.length > 0 ? " " + c : c);
        continue;
      }
      if (x = n(g), !x) {
        c = h + (c.length > 0 ? " " + c : c);
        continue;
      }
      b = !1;
    }
    const _ = Uk(d).join(":"), C = p ? _ + g1 : _, E = C + x;
    if (s.includes(E))
      continue;
    s.push(E);
    const k = i(x, b);
    for (let O = 0; O < k.length; ++O) {
      const P = k[O];
      s.push(C + P);
    }
    c = h + (c.length > 0 ? " " + c : c);
  }
  return c;
};
function Gk() {
  let r = 0, e, t, n = "";
  for (; r < arguments.length; )
    (e = arguments[r++]) && (t = m1(e)) && (n && (n += " "), n += t);
  return n;
}
const m1 = (r) => {
  if (typeof r == "string")
    return r;
  let e, t = "";
  for (let n = 0; n < r.length; n++)
    r[n] && (e = m1(r[n])) && (t && (t += " "), t += e);
  return t;
};
function qk(r, ...e) {
  let t, n, i, s = a;
  function a(u) {
    const h = e.reduce((d, p) => p(d), r());
    return t = $k(h), n = t.cache.get, i = t.cache.set, s = c, c(u);
  }
  function c(u) {
    const h = n(u);
    if (h)
      return h;
    const d = Xk(u, t);
    return i(u, d), d;
  }
  return function() {
    return s(Gk.apply(null, arguments));
  };
}
const ct = (r) => {
  const e = (t) => t[r] || [];
  return e.isThemeGetter = !0, e;
}, v1 = /^\[(?:([a-z-]+):)?(.+)\]$/i, Kk = /^\d+\/\d+$/, Zk = /* @__PURE__ */ new Set(["px", "full", "screen"]), Jk = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, Qk = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, eO = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, tO = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, rO = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Vn = (r) => Ws(r) || Zk.has(r) || Kk.test(r), di = (r) => Zs(r, "length", uO), Ws = (r) => !!r && !Number.isNaN(Number(r)), jh = (r) => Zs(r, "number", Ws), Lo = (r) => !!r && Number.isInteger(Number(r)), nO = (r) => r.endsWith("%") && Ws(r.slice(0, -1)), Me = (r) => v1.test(r), fi = (r) => Jk.test(r), iO = /* @__PURE__ */ new Set(["length", "size", "percentage"]), sO = (r) => Zs(r, iO, y1), oO = (r) => Zs(r, "position", y1), aO = /* @__PURE__ */ new Set(["image", "url"]), cO = (r) => Zs(r, aO, dO), lO = (r) => Zs(r, "", hO), No = () => !0, Zs = (r, e, t) => {
  const n = v1.exec(r);
  return n ? n[1] ? typeof e == "string" ? n[1] === e : e.has(n[1]) : t(n[2]) : !1;
}, uO = (r) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  Qk.test(r) && !eO.test(r)
), y1 = () => !1, hO = (r) => tO.test(r), dO = (r) => rO.test(r), fO = () => {
  const r = ct("colors"), e = ct("spacing"), t = ct("blur"), n = ct("brightness"), i = ct("borderColor"), s = ct("borderRadius"), a = ct("borderSpacing"), c = ct("borderWidth"), u = ct("contrast"), h = ct("grayscale"), d = ct("hueRotate"), p = ct("invert"), g = ct("gap"), v = ct("gradientColorStops"), b = ct("gradientColorStopPositions"), x = ct("inset"), _ = ct("margin"), C = ct("opacity"), E = ct("padding"), k = ct("saturate"), O = ct("scale"), P = ct("sepia"), R = ct("skew"), V = ct("space"), F = ct("translate"), $ = () => ["auto", "contain", "none"], z = () => ["auto", "hidden", "clip", "visible", "scroll"], G = () => ["auto", Me, e], H = () => [Me, e], Y = () => ["", Vn, di], te = () => ["auto", Ws, Me], ge = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], Z = () => ["solid", "dashed", "dotted", "double", "none"], de = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], oe = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], ie = () => ["", "0", Me], pe = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], re = () => [Ws, Me];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [No],
      spacing: [Vn, di],
      blur: ["none", "", fi, Me],
      brightness: re(),
      borderColor: [r],
      borderRadius: ["none", "", "full", fi, Me],
      borderSpacing: H(),
      borderWidth: Y(),
      contrast: re(),
      grayscale: ie(),
      hueRotate: re(),
      invert: ie(),
      gap: H(),
      gradientColorStops: [r],
      gradientColorStopPositions: [nO, di],
      inset: G(),
      margin: G(),
      opacity: re(),
      padding: H(),
      saturate: re(),
      scale: re(),
      sepia: ie(),
      skew: re(),
      space: H(),
      translate: H()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", Me]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [fi]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": pe()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": pe()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...ge(), Me]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: z()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": z()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": z()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: $()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": $()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": $()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [x]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [x]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [x]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [x]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [x]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [x]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [x]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [x]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [x]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Lo, Me]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: G()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", Me]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ie()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ie()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Lo, Me]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [No]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Lo, Me]
        }, Me]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": te()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": te()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [No]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Lo, Me]
        }, Me]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": te()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": te()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", Me]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", Me]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [g]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [g]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [g]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...oe()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...oe(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...oe(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [E]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [E]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [E]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [E]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [E]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [E]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [E]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [E]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [E]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [_]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [_]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [_]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [_]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [_]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [_]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [_]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [_]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [_]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [V]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [V]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Me, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [Me, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [Me, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [fi]
        }, fi]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [Me, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [Me, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [Me, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [Me, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", fi, di]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", jh]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [No]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Me]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", Ws, jh]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Vn, Me]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Me]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", Me]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [r]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [C]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [r]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [C]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...Z(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", Vn, di]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", Vn, Me]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [r]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: H()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Me]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Me]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [C]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...ge(), oO]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", sO]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, cO]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [r]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [b]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [b]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [b]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [v]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [v]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [v]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [s]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [s]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [s]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [s]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [s]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [s]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [s]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [s]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [s]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [s]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [s]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [s]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [s]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [s]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [s]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [c]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [c]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [c]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [c]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [c]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [c]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [c]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [c]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [c]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [C]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...Z(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [c]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [c]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [C]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: Z()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [i]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...Z()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Vn, Me]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [Vn, di]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [r]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: Y()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [r]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [C]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [Vn, di]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [r]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", fi, lO]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [No]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [C]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...de(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": de()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [t]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [n]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [u]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", fi, Me]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [h]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [d]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [p]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [k]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [P]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [t]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [n]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [u]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [h]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [d]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [p]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [C]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [k]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [P]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [a]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [a]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [a]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Me]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: re()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", Me]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: re()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", Me]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [O]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [O]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [O]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Lo, Me]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [F]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [F]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [R]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [R]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Me]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", r]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Me]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [r]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": H()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": H()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": H()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": H()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": H()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": H()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": H()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": H()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": H()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": H()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": H()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": H()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": H()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": H()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": H()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": H()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": H()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": H()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Me]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [r, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Vn, di, jh]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [r, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, pO = /* @__PURE__ */ qk(fO);
function ir(...r) {
  return pO(f1(r));
}
function f9(r, e = {}) {
  const { decimals: t = 0, sizeType: n = "normal" } = e, i = ["Bytes", "KB", "MB", "GB", "TB"], s = ["Bytes", "KiB", "MiB", "GiB", "TiB"];
  if (r === 0) return "0 Byte";
  const a = Math.floor(Math.log(r) / Math.log(1024));
  return `${(r / Math.pow(1024, a)).toFixed(t)} ${n === "accurate" ? s[a] ?? "Bytest" : i[a] ?? "Bytes"}`;
}
const gO = Fk(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), mt = W.forwardRef(
  ({ className: r, variant: e, size: t, asChild: n = !1, ...i }, s) => {
    const a = n ? $s : "button";
    return /* @__PURE__ */ y.jsx(
      a,
      {
        className: ir(gO({ variant: e, size: t, className: r })),
        ref: s,
        ...i
      }
    );
  }
);
mt.displayName = "Button";
function mf(r, [e, t]) {
  return Math.min(t, Math.max(e, r));
}
function bt(r, e, { checkForDefaultPrevented: t = !0 } = {}) {
  return function(i) {
    if (r?.(i), t === !1 || !i.defaultPrevented)
      return e?.(i);
  };
}
function ga(r, e = []) {
  let t = [];
  function n(s, a) {
    const c = W.createContext(a), u = t.length;
    t = [...t, a];
    const h = (p) => {
      const { scope: g, children: v, ...b } = p, x = g?.[r]?.[u] || c, _ = W.useMemo(() => b, Object.values(b));
      return /* @__PURE__ */ y.jsx(x.Provider, { value: _, children: v });
    };
    h.displayName = s + "Provider";
    function d(p, g) {
      const v = g?.[r]?.[u] || c, b = W.useContext(v);
      if (b) return b;
      if (a !== void 0) return a;
      throw new Error(`\`${p}\` must be used within \`${s}\``);
    }
    return [h, d];
  }
  const i = () => {
    const s = t.map((a) => W.createContext(a));
    return function(c) {
      const u = c?.[r] || s;
      return W.useMemo(
        () => ({ [`__scope${r}`]: { ...c, [r]: u } }),
        [c, u]
      );
    };
  };
  return i.scopeName = r, [n, mO(i, ...e)];
}
function mO(...r) {
  const e = r[0];
  if (r.length === 1) return e;
  const t = () => {
    const n = r.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(s) {
      const a = n.reduce((c, { useScope: u, scopeName: h }) => {
        const p = u(s)[`__scope${h}`];
        return { ...c, ...p };
      }, {});
      return W.useMemo(() => ({ [`__scope${e.scopeName}`]: a }), [a]);
    };
  };
  return t.scopeName = e.scopeName, t;
}
function bn(r) {
  const e = W.useRef(r);
  return W.useEffect(() => {
    e.current = r;
  }), W.useMemo(() => (...t) => e.current?.(...t), []);
}
function vf({
  prop: r,
  defaultProp: e,
  onChange: t = () => {
  }
}) {
  const [n, i] = vO({ defaultProp: e, onChange: t }), s = r !== void 0, a = s ? r : n, c = bn(t), u = W.useCallback(
    (h) => {
      if (s) {
        const p = typeof h == "function" ? h(r) : h;
        p !== r && c(p);
      } else
        i(h);
    },
    [s, r, i, c]
  );
  return [a, u];
}
function vO({
  defaultProp: r,
  onChange: e
}) {
  const t = W.useState(r), [n] = t, i = W.useRef(n), s = bn(e);
  return W.useEffect(() => {
    i.current !== n && (s(n), i.current = n);
  }, [n, i, s]), t;
}
var yO = W.createContext(void 0);
function Dl(r) {
  const e = W.useContext(yO);
  return r || e || "ltr";
}
function bO(r) {
  const e = W.useRef({ value: r, previous: r });
  return W.useMemo(() => (e.current.value !== r && (e.current.previous = e.current.value, e.current.value = r), e.current.previous), [r]);
}
var ra = globalThis?.document ? W.useLayoutEffect : () => {
};
function wO(r) {
  const [e, t] = W.useState(void 0);
  return ra(() => {
    if (r) {
      t({ width: r.offsetWidth, height: r.offsetHeight });
      const n = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const s = i[0];
        let a, c;
        if ("borderBoxSize" in s) {
          const u = s.borderBoxSize, h = Array.isArray(u) ? u[0] : u;
          a = h.inlineSize, c = h.blockSize;
        } else
          a = r.offsetWidth, c = r.offsetHeight;
        t({ width: a, height: c });
      });
      return n.observe(r, { box: "border-box" }), () => n.unobserve(r);
    } else
      t(void 0);
  }, [r]), e;
}
var xO = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], lr = xO.reduce((r, e) => {
  const t = W.forwardRef((n, i) => {
    const { asChild: s, ...a } = n, c = s ? $s : e;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ y.jsx(c, { ...a, ref: i });
  });
  return t.displayName = `Primitive.${e}`, { ...r, [e]: t };
}, {});
function b1(r) {
  const e = r + "CollectionProvider", [t, n] = ga(e), [i, s] = t(
    e,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), a = (v) => {
    const { scope: b, children: x } = v, _ = Ce.useRef(null), C = Ce.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ y.jsx(i, { scope: b, itemMap: C, collectionRef: _, children: x });
  };
  a.displayName = e;
  const c = r + "CollectionSlot", u = Ce.forwardRef(
    (v, b) => {
      const { scope: x, children: _ } = v, C = s(c, x), E = or(b, C.collectionRef);
      return /* @__PURE__ */ y.jsx($s, { ref: E, children: _ });
    }
  );
  u.displayName = c;
  const h = r + "CollectionItemSlot", d = "data-radix-collection-item", p = Ce.forwardRef(
    (v, b) => {
      const { scope: x, children: _, ...C } = v, E = Ce.useRef(null), k = or(b, E), O = s(h, x);
      return Ce.useEffect(() => (O.itemMap.set(E, { ref: E, ...C }), () => void O.itemMap.delete(E))), /* @__PURE__ */ y.jsx($s, { [d]: "", ref: k, children: _ });
    }
  );
  p.displayName = h;
  function g(v) {
    const b = s(r + "CollectionConsumer", v);
    return Ce.useCallback(() => {
      const _ = b.collectionRef.current;
      if (!_) return [];
      const C = Array.from(_.querySelectorAll(`[${d}]`));
      return Array.from(b.itemMap.values()).sort(
        (O, P) => C.indexOf(O.ref.current) - C.indexOf(P.ref.current)
      );
    }, [b.collectionRef, b.itemMap]);
  }
  return [
    { Provider: a, Slot: u, ItemSlot: p },
    g,
    n
  ];
}
var w1 = ["PageUp", "PageDown"], x1 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], _1 = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, Js = "Slider", [md, _O, SO] = b1(Js), [S1, p9] = ga(Js, [
  SO
]), [CO, jl] = S1(Js), C1 = W.forwardRef(
  (r, e) => {
    const {
      name: t,
      min: n = 0,
      max: i = 100,
      step: s = 1,
      orientation: a = "horizontal",
      disabled: c = !1,
      minStepsBetweenThumbs: u = 0,
      defaultValue: h = [n],
      value: d,
      onValueChange: p = () => {
      },
      onValueCommit: g = () => {
      },
      inverted: v = !1,
      form: b,
      ...x
    } = r, _ = W.useRef(/* @__PURE__ */ new Set()), C = W.useRef(0), k = a === "horizontal" ? TO : EO, [O = [], P] = vf({
      prop: d,
      defaultProp: h,
      onChange: (G) => {
        [..._.current][C.current]?.focus(), p(G);
      }
    }), R = W.useRef(O);
    function V(G) {
      const H = MO(O, G);
      z(G, H);
    }
    function F(G) {
      z(G, C.current);
    }
    function $() {
      const G = R.current[C.current];
      O[C.current] !== G && g(O);
    }
    function z(G, H, { commit: Y } = { commit: !1 }) {
      const te = RO(s), ge = FO(Math.round((G - n) / s) * s + n, te), Z = mf(ge, [n, i]);
      P((de = []) => {
        const oe = IO(de, Z, H);
        if (jO(oe, u * s)) {
          C.current = oe.indexOf(Z);
          const ie = String(oe) !== String(de);
          return ie && Y && g(oe), ie ? oe : de;
        } else
          return de;
      });
    }
    return /* @__PURE__ */ y.jsx(
      CO,
      {
        scope: r.__scopeSlider,
        name: t,
        disabled: c,
        min: n,
        max: i,
        valueIndexToChangeRef: C,
        thumbs: _.current,
        values: O,
        orientation: a,
        form: b,
        children: /* @__PURE__ */ y.jsx(md.Provider, { scope: r.__scopeSlider, children: /* @__PURE__ */ y.jsx(md.Slot, { scope: r.__scopeSlider, children: /* @__PURE__ */ y.jsx(
          k,
          {
            "aria-disabled": c,
            "data-disabled": c ? "" : void 0,
            ...x,
            ref: e,
            onPointerDown: bt(x.onPointerDown, () => {
              c || (R.current = O);
            }),
            min: n,
            max: i,
            inverted: v,
            onSlideStart: c ? void 0 : V,
            onSlideMove: c ? void 0 : F,
            onSlideEnd: c ? void 0 : $,
            onHomeKeyDown: () => !c && z(n, 0, { commit: !0 }),
            onEndKeyDown: () => !c && z(i, O.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: G, direction: H }) => {
              if (!c) {
                const ge = w1.includes(G.key) || G.shiftKey && x1.includes(G.key) ? 10 : 1, Z = C.current, de = O[Z], oe = s * ge * H;
                z(de + oe, Z, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
C1.displayName = Js;
var [T1, E1] = S1(Js, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), TO = W.forwardRef(
  (r, e) => {
    const {
      min: t,
      max: n,
      dir: i,
      inverted: s,
      onSlideStart: a,
      onSlideMove: c,
      onSlideEnd: u,
      onStepKeyDown: h,
      ...d
    } = r, [p, g] = W.useState(null), v = or(e, (k) => g(k)), b = W.useRef(void 0), x = Dl(i), _ = x === "ltr", C = _ && !s || !_ && s;
    function E(k) {
      const O = b.current || p.getBoundingClientRect(), P = [0, O.width], V = yf(P, C ? [t, n] : [n, t]);
      return b.current = O, V(k - O.left);
    }
    return /* @__PURE__ */ y.jsx(
      T1,
      {
        scope: r.__scopeSlider,
        startEdge: C ? "left" : "right",
        endEdge: C ? "right" : "left",
        direction: C ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ y.jsx(
          k1,
          {
            dir: x,
            "data-orientation": "horizontal",
            ...d,
            ref: v,
            style: {
              ...d.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (k) => {
              const O = E(k.clientX);
              a?.(O);
            },
            onSlideMove: (k) => {
              const O = E(k.clientX);
              c?.(O);
            },
            onSlideEnd: () => {
              b.current = void 0, u?.();
            },
            onStepKeyDown: (k) => {
              const P = _1[C ? "from-left" : "from-right"].includes(k.key);
              h?.({ event: k, direction: P ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), EO = W.forwardRef(
  (r, e) => {
    const {
      min: t,
      max: n,
      inverted: i,
      onSlideStart: s,
      onSlideMove: a,
      onSlideEnd: c,
      onStepKeyDown: u,
      ...h
    } = r, d = W.useRef(null), p = or(e, d), g = W.useRef(void 0), v = !i;
    function b(x) {
      const _ = g.current || d.current.getBoundingClientRect(), C = [0, _.height], k = yf(C, v ? [n, t] : [t, n]);
      return g.current = _, k(x - _.top);
    }
    return /* @__PURE__ */ y.jsx(
      T1,
      {
        scope: r.__scopeSlider,
        startEdge: v ? "bottom" : "top",
        endEdge: v ? "top" : "bottom",
        size: "height",
        direction: v ? 1 : -1,
        children: /* @__PURE__ */ y.jsx(
          k1,
          {
            "data-orientation": "vertical",
            ...h,
            ref: p,
            style: {
              ...h.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (x) => {
              const _ = b(x.clientY);
              s?.(_);
            },
            onSlideMove: (x) => {
              const _ = b(x.clientY);
              a?.(_);
            },
            onSlideEnd: () => {
              g.current = void 0, c?.();
            },
            onStepKeyDown: (x) => {
              const C = _1[v ? "from-bottom" : "from-top"].includes(x.key);
              u?.({ event: x, direction: C ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), k1 = W.forwardRef(
  (r, e) => {
    const {
      __scopeSlider: t,
      onSlideStart: n,
      onSlideMove: i,
      onSlideEnd: s,
      onHomeKeyDown: a,
      onEndKeyDown: c,
      onStepKeyDown: u,
      ...h
    } = r, d = jl(Js, t);
    return /* @__PURE__ */ y.jsx(
      lr.span,
      {
        ...h,
        ref: e,
        onKeyDown: bt(r.onKeyDown, (p) => {
          p.key === "Home" ? (a(p), p.preventDefault()) : p.key === "End" ? (c(p), p.preventDefault()) : w1.concat(x1).includes(p.key) && (u(p), p.preventDefault());
        }),
        onPointerDown: bt(r.onPointerDown, (p) => {
          const g = p.target;
          g.setPointerCapture(p.pointerId), p.preventDefault(), d.thumbs.has(g) ? g.focus() : n(p);
        }),
        onPointerMove: bt(r.onPointerMove, (p) => {
          p.target.hasPointerCapture(p.pointerId) && i(p);
        }),
        onPointerUp: bt(r.onPointerUp, (p) => {
          const g = p.target;
          g.hasPointerCapture(p.pointerId) && (g.releasePointerCapture(p.pointerId), s(p));
        })
      }
    );
  }
), O1 = "SliderTrack", I1 = W.forwardRef(
  (r, e) => {
    const { __scopeSlider: t, ...n } = r, i = jl(O1, t);
    return /* @__PURE__ */ y.jsx(
      lr.span,
      {
        "data-disabled": i.disabled ? "" : void 0,
        "data-orientation": i.orientation,
        ...n,
        ref: e
      }
    );
  }
);
I1.displayName = O1;
var vd = "SliderRange", A1 = W.forwardRef(
  (r, e) => {
    const { __scopeSlider: t, ...n } = r, i = jl(vd, t), s = E1(vd, t), a = W.useRef(null), c = or(e, a), u = i.values.length, h = i.values.map(
      (g) => P1(g, i.min, i.max)
    ), d = u > 1 ? Math.min(...h) : 0, p = 100 - Math.max(...h);
    return /* @__PURE__ */ y.jsx(
      lr.span,
      {
        "data-orientation": i.orientation,
        "data-disabled": i.disabled ? "" : void 0,
        ...n,
        ref: c,
        style: {
          ...r.style,
          [s.startEdge]: d + "%",
          [s.endEdge]: p + "%"
        }
      }
    );
  }
);
A1.displayName = vd;
var yd = "SliderThumb", M1 = W.forwardRef(
  (r, e) => {
    const t = _O(r.__scopeSlider), [n, i] = W.useState(null), s = or(e, (c) => i(c)), a = W.useMemo(
      () => n ? t().findIndex((c) => c.ref.current === n) : -1,
      [t, n]
    );
    return /* @__PURE__ */ y.jsx(kO, { ...r, ref: s, index: a });
  }
), kO = W.forwardRef(
  (r, e) => {
    const { __scopeSlider: t, index: n, name: i, ...s } = r, a = jl(yd, t), c = E1(yd, t), [u, h] = W.useState(null), d = or(e, (E) => h(E)), p = u ? a.form || !!u.closest("form") : !0, g = wO(u), v = a.values[n], b = v === void 0 ? 0 : P1(v, a.min, a.max), x = AO(n, a.values.length), _ = g?.[c.size], C = _ ? PO(_, b, c.direction) : 0;
    return W.useEffect(() => {
      if (u)
        return a.thumbs.add(u), () => {
          a.thumbs.delete(u);
        };
    }, [u, a.thumbs]), /* @__PURE__ */ y.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [c.startEdge]: `calc(${b}% + ${C}px)`
        },
        children: [
          /* @__PURE__ */ y.jsx(md.ItemSlot, { scope: r.__scopeSlider, children: /* @__PURE__ */ y.jsx(
            lr.span,
            {
              role: "slider",
              "aria-label": r["aria-label"] || x,
              "aria-valuemin": a.min,
              "aria-valuenow": v,
              "aria-valuemax": a.max,
              "aria-orientation": a.orientation,
              "data-orientation": a.orientation,
              "data-disabled": a.disabled ? "" : void 0,
              tabIndex: a.disabled ? void 0 : 0,
              ...s,
              ref: d,
              style: v === void 0 ? { display: "none" } : r.style,
              onFocus: bt(r.onFocus, () => {
                a.valueIndexToChangeRef.current = n;
              })
            }
          ) }),
          p && /* @__PURE__ */ y.jsx(
            OO,
            {
              name: i ?? (a.name ? a.name + (a.values.length > 1 ? "[]" : "") : void 0),
              form: a.form,
              value: v
            },
            n
          )
        ]
      }
    );
  }
);
M1.displayName = yd;
var OO = (r) => {
  const { value: e, ...t } = r, n = W.useRef(null), i = bO(e);
  return W.useEffect(() => {
    const s = n.current, a = window.HTMLInputElement.prototype, u = Object.getOwnPropertyDescriptor(a, "value").set;
    if (i !== e && u) {
      const h = new Event("input", { bubbles: !0 });
      u.call(s, e), s.dispatchEvent(h);
    }
  }, [i, e]), /* @__PURE__ */ y.jsx("input", { style: { display: "none" }, ...t, ref: n, defaultValue: e });
};
function IO(r = [], e, t) {
  const n = [...r];
  return n[t] = e, n.sort((i, s) => i - s);
}
function P1(r, e, t) {
  const s = 100 / (t - e) * (r - e);
  return mf(s, [0, 100]);
}
function AO(r, e) {
  return e > 2 ? `Value ${r + 1} of ${e}` : e === 2 ? ["Minimum", "Maximum"][r] : void 0;
}
function MO(r, e) {
  if (r.length === 1) return 0;
  const t = r.map((i) => Math.abs(i - e)), n = Math.min(...t);
  return t.indexOf(n);
}
function PO(r, e, t) {
  const n = r / 2, s = yf([0, 50], [0, n]);
  return (n - s(e) * t) * t;
}
function DO(r) {
  return r.slice(0, -1).map((e, t) => r[t + 1] - e);
}
function jO(r, e) {
  if (e > 0) {
    const t = DO(r);
    return Math.min(...t) >= e;
  }
  return !0;
}
function yf(r, e) {
  return (t) => {
    if (r[0] === r[1] || e[0] === e[1]) return e[0];
    const n = (e[1] - e[0]) / (r[1] - r[0]);
    return e[0] + n * (t - r[0]);
  };
}
function RO(r) {
  return (String(r).split(".")[1] || "").length;
}
function FO(r, e) {
  const t = Math.pow(10, e);
  return Math.round(r * t) / t;
}
var D1 = C1, LO = I1, NO = A1, BO = M1;
const VO = W.forwardRef(({ className: r, ...e }, t) => /* @__PURE__ */ y.jsxs(
  D1,
  {
    ref: t,
    className: ir(
      "relative flex w-full touch-none select-none items-center",
      r
    ),
    ...e,
    children: [
      /* @__PURE__ */ y.jsx(LO, { className: "relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20", children: /* @__PURE__ */ y.jsx(NO, { className: "absolute h-full bg-primary" }) }),
      /* @__PURE__ */ y.jsx(BO, { className: "block h-4 w-4 cursor-pointer rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-0 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50" })
    ]
  }
));
VO.displayName = D1.displayName;
function zO(r, e) {
  return W.useReducer((t, n) => e[t][n] ?? t, r);
}
var Qs = (r) => {
  const { present: e, children: t } = r, n = WO(e), i = typeof t == "function" ? t({ present: n.isPresent }) : W.Children.only(t), s = or(n.ref, HO(i));
  return typeof t == "function" || n.isPresent ? W.cloneElement(i, { ref: s }) : null;
};
Qs.displayName = "Presence";
function WO(r) {
  const [e, t] = W.useState(), n = W.useRef({}), i = W.useRef(r), s = W.useRef("none"), a = r ? "mounted" : "unmounted", [c, u] = zO(a, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return W.useEffect(() => {
    const h = xc(n.current);
    s.current = c === "mounted" ? h : "none";
  }, [c]), ra(() => {
    const h = n.current, d = i.current;
    if (d !== r) {
      const g = s.current, v = xc(h);
      r ? u("MOUNT") : v === "none" || h?.display === "none" ? u("UNMOUNT") : u(d && g !== v ? "ANIMATION_OUT" : "UNMOUNT"), i.current = r;
    }
  }, [r, u]), ra(() => {
    if (e) {
      let h;
      const d = e.ownerDocument.defaultView ?? window, p = (v) => {
        const x = xc(n.current).includes(v.animationName);
        if (v.target === e && x && (u("ANIMATION_END"), !i.current)) {
          const _ = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", h = d.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = _);
          });
        }
      }, g = (v) => {
        v.target === e && (s.current = xc(n.current));
      };
      return e.addEventListener("animationstart", g), e.addEventListener("animationcancel", p), e.addEventListener("animationend", p), () => {
        d.clearTimeout(h), e.removeEventListener("animationstart", g), e.removeEventListener("animationcancel", p), e.removeEventListener("animationend", p);
      };
    } else
      u("ANIMATION_END");
  }, [e, u]), {
    isPresent: ["mounted", "unmountSuspended"].includes(c),
    ref: W.useCallback((h) => {
      h && (n.current = getComputedStyle(h)), t(h);
    }, [])
  };
}
function xc(r) {
  return r?.animationName || "none";
}
function HO(r) {
  let e = Object.getOwnPropertyDescriptor(r.props, "ref")?.get, t = e && "isReactWarning" in e && e.isReactWarning;
  return t ? r.ref : (e = Object.getOwnPropertyDescriptor(r, "ref")?.get, t = e && "isReactWarning" in e && e.isReactWarning, t ? r.props.ref : r.props.ref || r.ref);
}
function UO(r, e) {
  return W.useReducer((t, n) => e[t][n] ?? t, r);
}
var bf = "ScrollArea", [j1, g9] = ga(bf), [$O, Jr] = j1(bf), R1 = W.forwardRef(
  (r, e) => {
    const {
      __scopeScrollArea: t,
      type: n = "hover",
      dir: i,
      scrollHideDelay: s = 600,
      ...a
    } = r, [c, u] = W.useState(null), [h, d] = W.useState(null), [p, g] = W.useState(null), [v, b] = W.useState(null), [x, _] = W.useState(null), [C, E] = W.useState(0), [k, O] = W.useState(0), [P, R] = W.useState(!1), [V, F] = W.useState(!1), $ = or(e, (G) => u(G)), z = Dl(i);
    return /* @__PURE__ */ y.jsx(
      $O,
      {
        scope: t,
        type: n,
        dir: z,
        scrollHideDelay: s,
        scrollArea: c,
        viewport: h,
        onViewportChange: d,
        content: p,
        onContentChange: g,
        scrollbarX: v,
        onScrollbarXChange: b,
        scrollbarXEnabled: P,
        onScrollbarXEnabledChange: R,
        scrollbarY: x,
        onScrollbarYChange: _,
        scrollbarYEnabled: V,
        onScrollbarYEnabledChange: F,
        onCornerWidthChange: E,
        onCornerHeightChange: O,
        children: /* @__PURE__ */ y.jsx(
          lr.div,
          {
            dir: z,
            ...a,
            ref: $,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": C + "px",
              "--radix-scroll-area-corner-height": k + "px",
              ...r.style
            }
          }
        )
      }
    );
  }
);
R1.displayName = bf;
var F1 = "ScrollAreaViewport", L1 = W.forwardRef(
  (r, e) => {
    const { __scopeScrollArea: t, children: n, nonce: i, ...s } = r, a = Jr(F1, t), c = W.useRef(null), u = or(e, c, a.onViewportChange);
    return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: i
        }
      ),
      /* @__PURE__ */ y.jsx(
        lr.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...s,
          ref: u,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: a.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: a.scrollbarYEnabled ? "scroll" : "hidden",
            ...r.style
          },
          children: /* @__PURE__ */ y.jsx("div", { ref: a.onContentChange, style: { minWidth: "100%", display: "table" }, children: n })
        }
      )
    ] });
  }
);
L1.displayName = F1;
var In = "ScrollAreaScrollbar", Rl = W.forwardRef(
  (r, e) => {
    const { forceMount: t, ...n } = r, i = Jr(In, r.__scopeScrollArea), { onScrollbarXEnabledChange: s, onScrollbarYEnabledChange: a } = i, c = r.orientation === "horizontal";
    return W.useEffect(() => (c ? s(!0) : a(!0), () => {
      c ? s(!1) : a(!1);
    }), [c, s, a]), i.type === "hover" ? /* @__PURE__ */ y.jsx(YO, { ...n, ref: e, forceMount: t }) : i.type === "scroll" ? /* @__PURE__ */ y.jsx(XO, { ...n, ref: e, forceMount: t }) : i.type === "auto" ? /* @__PURE__ */ y.jsx(N1, { ...n, ref: e, forceMount: t }) : i.type === "always" ? /* @__PURE__ */ y.jsx(wf, { ...n, ref: e }) : null;
  }
);
Rl.displayName = In;
var YO = W.forwardRef((r, e) => {
  const { forceMount: t, ...n } = r, i = Jr(In, r.__scopeScrollArea), [s, a] = W.useState(!1);
  return W.useEffect(() => {
    const c = i.scrollArea;
    let u = 0;
    if (c) {
      const h = () => {
        window.clearTimeout(u), a(!0);
      }, d = () => {
        u = window.setTimeout(() => a(!1), i.scrollHideDelay);
      };
      return c.addEventListener("pointerenter", h), c.addEventListener("pointerleave", d), () => {
        window.clearTimeout(u), c.removeEventListener("pointerenter", h), c.removeEventListener("pointerleave", d);
      };
    }
  }, [i.scrollArea, i.scrollHideDelay]), /* @__PURE__ */ y.jsx(Qs, { present: t || s, children: /* @__PURE__ */ y.jsx(
    N1,
    {
      "data-state": s ? "visible" : "hidden",
      ...n,
      ref: e
    }
  ) });
}), XO = W.forwardRef((r, e) => {
  const { forceMount: t, ...n } = r, i = Jr(In, r.__scopeScrollArea), s = r.orientation === "horizontal", a = Ll(() => u("SCROLL_END"), 100), [c, u] = UO("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return W.useEffect(() => {
    if (c === "idle") {
      const h = window.setTimeout(() => u("HIDE"), i.scrollHideDelay);
      return () => window.clearTimeout(h);
    }
  }, [c, i.scrollHideDelay, u]), W.useEffect(() => {
    const h = i.viewport, d = s ? "scrollLeft" : "scrollTop";
    if (h) {
      let p = h[d];
      const g = () => {
        const v = h[d];
        p !== v && (u("SCROLL"), a()), p = v;
      };
      return h.addEventListener("scroll", g), () => h.removeEventListener("scroll", g);
    }
  }, [i.viewport, s, u, a]), /* @__PURE__ */ y.jsx(Qs, { present: t || c !== "hidden", children: /* @__PURE__ */ y.jsx(
    wf,
    {
      "data-state": c === "hidden" ? "hidden" : "visible",
      ...n,
      ref: e,
      onPointerEnter: bt(r.onPointerEnter, () => u("POINTER_ENTER")),
      onPointerLeave: bt(r.onPointerLeave, () => u("POINTER_LEAVE"))
    }
  ) });
}), N1 = W.forwardRef((r, e) => {
  const t = Jr(In, r.__scopeScrollArea), { forceMount: n, ...i } = r, [s, a] = W.useState(!1), c = r.orientation === "horizontal", u = Ll(() => {
    if (t.viewport) {
      const h = t.viewport.offsetWidth < t.viewport.scrollWidth, d = t.viewport.offsetHeight < t.viewport.scrollHeight;
      a(c ? h : d);
    }
  }, 10);
  return Ys(t.viewport, u), Ys(t.content, u), /* @__PURE__ */ y.jsx(Qs, { present: n || s, children: /* @__PURE__ */ y.jsx(
    wf,
    {
      "data-state": s ? "visible" : "hidden",
      ...i,
      ref: e
    }
  ) });
}), wf = W.forwardRef((r, e) => {
  const { orientation: t = "vertical", ...n } = r, i = Jr(In, r.__scopeScrollArea), s = W.useRef(null), a = W.useRef(0), [c, u] = W.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), h = W1(c.viewport, c.content), d = {
    ...n,
    sizes: c,
    onSizesChange: u,
    hasThumb: h > 0 && h < 1,
    onThumbChange: (g) => s.current = g,
    onThumbPointerUp: () => a.current = 0,
    onThumbPointerDown: (g) => a.current = g
  };
  function p(g, v) {
    return QO(g, a.current, c, v);
  }
  return t === "horizontal" ? /* @__PURE__ */ y.jsx(
    GO,
    {
      ...d,
      ref: e,
      onThumbPositionChange: () => {
        if (i.viewport && s.current) {
          const g = i.viewport.scrollLeft, v = vv(g, c, i.dir);
          s.current.style.transform = `translate3d(${v}px, 0, 0)`;
        }
      },
      onWheelScroll: (g) => {
        i.viewport && (i.viewport.scrollLeft = g);
      },
      onDragScroll: (g) => {
        i.viewport && (i.viewport.scrollLeft = p(g, i.dir));
      }
    }
  ) : t === "vertical" ? /* @__PURE__ */ y.jsx(
    qO,
    {
      ...d,
      ref: e,
      onThumbPositionChange: () => {
        if (i.viewport && s.current) {
          const g = i.viewport.scrollTop, v = vv(g, c);
          s.current.style.transform = `translate3d(0, ${v}px, 0)`;
        }
      },
      onWheelScroll: (g) => {
        i.viewport && (i.viewport.scrollTop = g);
      },
      onDragScroll: (g) => {
        i.viewport && (i.viewport.scrollTop = p(g));
      }
    }
  ) : null;
}), GO = W.forwardRef((r, e) => {
  const { sizes: t, onSizesChange: n, ...i } = r, s = Jr(In, r.__scopeScrollArea), [a, c] = W.useState(), u = W.useRef(null), h = or(e, u, s.onScrollbarXChange);
  return W.useEffect(() => {
    u.current && c(getComputedStyle(u.current));
  }, [u]), /* @__PURE__ */ y.jsx(
    V1,
    {
      "data-orientation": "horizontal",
      ...i,
      ref: h,
      sizes: t,
      style: {
        bottom: 0,
        left: s.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: s.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": Fl(t) + "px",
        ...r.style
      },
      onThumbPointerDown: (d) => r.onThumbPointerDown(d.x),
      onDragScroll: (d) => r.onDragScroll(d.x),
      onWheelScroll: (d, p) => {
        if (s.viewport) {
          const g = s.viewport.scrollLeft + d.deltaX;
          r.onWheelScroll(g), U1(g, p) && d.preventDefault();
        }
      },
      onResize: () => {
        u.current && s.viewport && a && n({
          content: s.viewport.scrollWidth,
          viewport: s.viewport.offsetWidth,
          scrollbar: {
            size: u.current.clientWidth,
            paddingStart: il(a.paddingLeft),
            paddingEnd: il(a.paddingRight)
          }
        });
      }
    }
  );
}), qO = W.forwardRef((r, e) => {
  const { sizes: t, onSizesChange: n, ...i } = r, s = Jr(In, r.__scopeScrollArea), [a, c] = W.useState(), u = W.useRef(null), h = or(e, u, s.onScrollbarYChange);
  return W.useEffect(() => {
    u.current && c(getComputedStyle(u.current));
  }, [u]), /* @__PURE__ */ y.jsx(
    V1,
    {
      "data-orientation": "vertical",
      ...i,
      ref: h,
      sizes: t,
      style: {
        top: 0,
        right: s.dir === "ltr" ? 0 : void 0,
        left: s.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": Fl(t) + "px",
        ...r.style
      },
      onThumbPointerDown: (d) => r.onThumbPointerDown(d.y),
      onDragScroll: (d) => r.onDragScroll(d.y),
      onWheelScroll: (d, p) => {
        if (s.viewport) {
          const g = s.viewport.scrollTop + d.deltaY;
          r.onWheelScroll(g), U1(g, p) && d.preventDefault();
        }
      },
      onResize: () => {
        u.current && s.viewport && a && n({
          content: s.viewport.scrollHeight,
          viewport: s.viewport.offsetHeight,
          scrollbar: {
            size: u.current.clientHeight,
            paddingStart: il(a.paddingTop),
            paddingEnd: il(a.paddingBottom)
          }
        });
      }
    }
  );
}), [KO, B1] = j1(In), V1 = W.forwardRef((r, e) => {
  const {
    __scopeScrollArea: t,
    sizes: n,
    hasThumb: i,
    onThumbChange: s,
    onThumbPointerUp: a,
    onThumbPointerDown: c,
    onThumbPositionChange: u,
    onDragScroll: h,
    onWheelScroll: d,
    onResize: p,
    ...g
  } = r, v = Jr(In, t), [b, x] = W.useState(null), _ = or(e, ($) => x($)), C = W.useRef(null), E = W.useRef(""), k = v.viewport, O = n.content - n.viewport, P = bn(d), R = bn(u), V = Ll(p, 10);
  function F($) {
    if (C.current) {
      const z = $.clientX - C.current.left, G = $.clientY - C.current.top;
      h({ x: z, y: G });
    }
  }
  return W.useEffect(() => {
    const $ = (z) => {
      const G = z.target;
      b?.contains(G) && P(z, O);
    };
    return document.addEventListener("wheel", $, { passive: !1 }), () => document.removeEventListener("wheel", $, { passive: !1 });
  }, [k, b, O, P]), W.useEffect(R, [n, R]), Ys(b, V), Ys(v.content, V), /* @__PURE__ */ y.jsx(
    KO,
    {
      scope: t,
      scrollbar: b,
      hasThumb: i,
      onThumbChange: bn(s),
      onThumbPointerUp: bn(a),
      onThumbPositionChange: R,
      onThumbPointerDown: bn(c),
      children: /* @__PURE__ */ y.jsx(
        lr.div,
        {
          ...g,
          ref: _,
          style: { position: "absolute", ...g.style },
          onPointerDown: bt(r.onPointerDown, ($) => {
            $.button === 0 && ($.target.setPointerCapture($.pointerId), C.current = b.getBoundingClientRect(), E.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", v.viewport && (v.viewport.style.scrollBehavior = "auto"), F($));
          }),
          onPointerMove: bt(r.onPointerMove, F),
          onPointerUp: bt(r.onPointerUp, ($) => {
            const z = $.target;
            z.hasPointerCapture($.pointerId) && z.releasePointerCapture($.pointerId), document.body.style.webkitUserSelect = E.current, v.viewport && (v.viewport.style.scrollBehavior = ""), C.current = null;
          })
        }
      )
    }
  );
}), nl = "ScrollAreaThumb", xf = W.forwardRef(
  (r, e) => {
    const { forceMount: t, ...n } = r, i = B1(nl, r.__scopeScrollArea);
    return /* @__PURE__ */ y.jsx(Qs, { present: t || i.hasThumb, children: /* @__PURE__ */ y.jsx(ZO, { ref: e, ...n }) });
  }
), ZO = W.forwardRef(
  (r, e) => {
    const { __scopeScrollArea: t, style: n, ...i } = r, s = Jr(nl, t), a = B1(nl, t), { onThumbPositionChange: c } = a, u = or(
      e,
      (p) => a.onThumbChange(p)
    ), h = W.useRef(void 0), d = Ll(() => {
      h.current && (h.current(), h.current = void 0);
    }, 100);
    return W.useEffect(() => {
      const p = s.viewport;
      if (p) {
        const g = () => {
          if (d(), !h.current) {
            const v = eI(p, c);
            h.current = v, c();
          }
        };
        return c(), p.addEventListener("scroll", g), () => p.removeEventListener("scroll", g);
      }
    }, [s.viewport, d, c]), /* @__PURE__ */ y.jsx(
      lr.div,
      {
        "data-state": a.hasThumb ? "visible" : "hidden",
        ...i,
        ref: u,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...n
        },
        onPointerDownCapture: bt(r.onPointerDownCapture, (p) => {
          const v = p.target.getBoundingClientRect(), b = p.clientX - v.left, x = p.clientY - v.top;
          a.onThumbPointerDown({ x: b, y: x });
        }),
        onPointerUp: bt(r.onPointerUp, a.onThumbPointerUp)
      }
    );
  }
);
xf.displayName = nl;
var _f = "ScrollAreaCorner", z1 = W.forwardRef(
  (r, e) => {
    const t = Jr(_f, r.__scopeScrollArea), n = !!(t.scrollbarX && t.scrollbarY);
    return t.type !== "scroll" && n ? /* @__PURE__ */ y.jsx(JO, { ...r, ref: e }) : null;
  }
);
z1.displayName = _f;
var JO = W.forwardRef((r, e) => {
  const { __scopeScrollArea: t, ...n } = r, i = Jr(_f, t), [s, a] = W.useState(0), [c, u] = W.useState(0), h = !!(s && c);
  return Ys(i.scrollbarX, () => {
    const d = i.scrollbarX?.offsetHeight || 0;
    i.onCornerHeightChange(d), u(d);
  }), Ys(i.scrollbarY, () => {
    const d = i.scrollbarY?.offsetWidth || 0;
    i.onCornerWidthChange(d), a(d);
  }), h ? /* @__PURE__ */ y.jsx(
    lr.div,
    {
      ...n,
      ref: e,
      style: {
        width: s,
        height: c,
        position: "absolute",
        right: i.dir === "ltr" ? 0 : void 0,
        left: i.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...r.style
      }
    }
  ) : null;
});
function il(r) {
  return r ? parseInt(r, 10) : 0;
}
function W1(r, e) {
  const t = r / e;
  return isNaN(t) ? 0 : t;
}
function Fl(r) {
  const e = W1(r.viewport, r.content), t = r.scrollbar.paddingStart + r.scrollbar.paddingEnd, n = (r.scrollbar.size - t) * e;
  return Math.max(n, 18);
}
function QO(r, e, t, n = "ltr") {
  const i = Fl(t), s = i / 2, a = e || s, c = i - a, u = t.scrollbar.paddingStart + a, h = t.scrollbar.size - t.scrollbar.paddingEnd - c, d = t.content - t.viewport, p = n === "ltr" ? [0, d] : [d * -1, 0];
  return H1([u, h], p)(r);
}
function vv(r, e, t = "ltr") {
  const n = Fl(e), i = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, s = e.scrollbar.size - i, a = e.content - e.viewport, c = s - n, u = t === "ltr" ? [0, a] : [a * -1, 0], h = mf(r, u);
  return H1([0, a], [0, c])(h);
}
function H1(r, e) {
  return (t) => {
    if (r[0] === r[1] || e[0] === e[1]) return e[0];
    const n = (e[1] - e[0]) / (r[1] - r[0]);
    return e[0] + n * (t - r[0]);
  };
}
function U1(r, e) {
  return r > 0 && r < e;
}
var eI = (r, e = () => {
}) => {
  let t = { left: r.scrollLeft, top: r.scrollTop }, n = 0;
  return function i() {
    const s = { left: r.scrollLeft, top: r.scrollTop }, a = t.left !== s.left, c = t.top !== s.top;
    (a || c) && e(), t = s, n = window.requestAnimationFrame(i);
  }(), () => window.cancelAnimationFrame(n);
};
function Ll(r, e) {
  const t = bn(r), n = W.useRef(0);
  return W.useEffect(() => () => window.clearTimeout(n.current), []), W.useCallback(() => {
    window.clearTimeout(n.current), n.current = window.setTimeout(t, e);
  }, [t, e]);
}
function Ys(r, e) {
  const t = bn(e);
  ra(() => {
    let n = 0;
    if (r) {
      const i = new ResizeObserver(() => {
        cancelAnimationFrame(n), n = window.requestAnimationFrame(t);
      });
      return i.observe(r), () => {
        window.cancelAnimationFrame(n), i.unobserve(r);
      };
    }
  }, [r, t]);
}
var sl = R1, bd = L1, yv = Rl, bv = xf, tI = z1;
const eo = W.forwardRef(({ className: r, children: e, ...t }, n) => /* @__PURE__ */ y.jsxs(
  sl,
  {
    ref: n,
    className: ir("relative overflow-hidden", r),
    ...t,
    children: [
      /* @__PURE__ */ y.jsx(bd, { className: "h-full w-full rounded-[inherit]", children: e }),
      /* @__PURE__ */ y.jsx($1, {}),
      /* @__PURE__ */ y.jsx(tI, {})
    ]
  }
));
eo.displayName = sl.displayName;
const $1 = W.forwardRef(({ className: r, orientation: e = "vertical", ...t }, n) => /* @__PURE__ */ y.jsx(
  Rl,
  {
    ref: n,
    orientation: e,
    className: ir(
      "flex touch-none select-none transition-colors",
      e === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      e === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      r
    ),
    ...t,
    children: /* @__PURE__ */ y.jsx(xf, { className: "relative flex-1 rounded-full bg-border" })
  }
));
$1.displayName = Rl.displayName;
const Nl = ({
  children: r,
  renderCustomPreview: e,
  data: t = {},
  shouldDisplayPreview: n = !0
}) => {
  const [i, s] = ue(!1), [a, c] = ue({ x: 0, y: 0 }), u = be(null), g = Tk(r, {
    draggable: !0,
    onDragStart: (v) => {
      s(!0), v.dataTransfer.setDragImage(new Image(), 0, 0), v.dataTransfer.setData(JSON.stringify(t), JSON.stringify(t)), c({
        x: v.clientX,
        y: v.clientY
      });
    },
    onDragEnd: () => {
      s(!1);
    },
    onDrag: (v) => {
      i && c({
        x: v.clientX,
        y: v.clientY
      });
    },
    style: {
      ...r.props.style
    }
  });
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    g,
    i && n && e ? dd(
      /* @__PURE__ */ y.jsx(
        "div",
        {
          ref: u,
          style: {
            position: "fixed",
            left: a.x,
            top: a.y,
            pointerEvents: "none",
            zIndex: 9999,
            transform: "translate(-50%, -50%)"
            // Center the preview
          },
          children: e
        }
      ),
      document.body
    ) : null
  ] });
};
var rI = W.useId || (() => {
}), nI = 0;
function Y1(r) {
  const [e, t] = W.useState(rI());
  return ra(() => {
    t((n) => n ?? String(nI++));
  }, [r]), e ? `radix-${e}` : "";
}
var Rh = "rovingFocusGroup.onEntryFocus", iI = { bubbles: !1, cancelable: !0 }, Bl = "RovingFocusGroup", [wd, X1, sI] = b1(Bl), [oI, G1] = ga(
  Bl,
  [sI]
), [aI, cI] = oI(Bl), q1 = W.forwardRef(
  (r, e) => /* @__PURE__ */ y.jsx(wd.Provider, { scope: r.__scopeRovingFocusGroup, children: /* @__PURE__ */ y.jsx(wd.Slot, { scope: r.__scopeRovingFocusGroup, children: /* @__PURE__ */ y.jsx(lI, { ...r, ref: e }) }) })
);
q1.displayName = Bl;
var lI = W.forwardRef((r, e) => {
  const {
    __scopeRovingFocusGroup: t,
    orientation: n,
    loop: i = !1,
    dir: s,
    currentTabStopId: a,
    defaultCurrentTabStopId: c,
    onCurrentTabStopIdChange: u,
    onEntryFocus: h,
    preventScrollOnEntryFocus: d = !1,
    ...p
  } = r, g = W.useRef(null), v = or(e, g), b = Dl(s), [x = null, _] = vf({
    prop: a,
    defaultProp: c,
    onChange: u
  }), [C, E] = W.useState(!1), k = bn(h), O = X1(t), P = W.useRef(!1), [R, V] = W.useState(0);
  return W.useEffect(() => {
    const F = g.current;
    if (F)
      return F.addEventListener(Rh, k), () => F.removeEventListener(Rh, k);
  }, [k]), /* @__PURE__ */ y.jsx(
    aI,
    {
      scope: t,
      orientation: n,
      dir: b,
      loop: i,
      currentTabStopId: x,
      onItemFocus: W.useCallback(
        (F) => _(F),
        [_]
      ),
      onItemShiftTab: W.useCallback(() => E(!0), []),
      onFocusableItemAdd: W.useCallback(
        () => V((F) => F + 1),
        []
      ),
      onFocusableItemRemove: W.useCallback(
        () => V((F) => F - 1),
        []
      ),
      children: /* @__PURE__ */ y.jsx(
        lr.div,
        {
          tabIndex: C || R === 0 ? -1 : 0,
          "data-orientation": n,
          ...p,
          ref: v,
          style: { outline: "none", ...r.style },
          onMouseDown: bt(r.onMouseDown, () => {
            P.current = !0;
          }),
          onFocus: bt(r.onFocus, (F) => {
            const $ = !P.current;
            if (F.target === F.currentTarget && $ && !C) {
              const z = new CustomEvent(Rh, iI);
              if (F.currentTarget.dispatchEvent(z), !z.defaultPrevented) {
                const G = O().filter((Z) => Z.focusable), H = G.find((Z) => Z.active), Y = G.find((Z) => Z.id === x), ge = [H, Y, ...G].filter(
                  Boolean
                ).map((Z) => Z.ref.current);
                J1(ge, d);
              }
            }
            P.current = !1;
          }),
          onBlur: bt(r.onBlur, () => E(!1))
        }
      )
    }
  );
}), K1 = "RovingFocusGroupItem", Z1 = W.forwardRef(
  (r, e) => {
    const {
      __scopeRovingFocusGroup: t,
      focusable: n = !0,
      active: i = !1,
      tabStopId: s,
      ...a
    } = r, c = Y1(), u = s || c, h = cI(K1, t), d = h.currentTabStopId === u, p = X1(t), { onFocusableItemAdd: g, onFocusableItemRemove: v } = h;
    return W.useEffect(() => {
      if (n)
        return g(), () => v();
    }, [n, g, v]), /* @__PURE__ */ y.jsx(
      wd.ItemSlot,
      {
        scope: t,
        id: u,
        focusable: n,
        active: i,
        children: /* @__PURE__ */ y.jsx(
          lr.span,
          {
            tabIndex: d ? 0 : -1,
            "data-orientation": h.orientation,
            ...a,
            ref: e,
            onMouseDown: bt(r.onMouseDown, (b) => {
              n ? h.onItemFocus(u) : b.preventDefault();
            }),
            onFocus: bt(r.onFocus, () => h.onItemFocus(u)),
            onKeyDown: bt(r.onKeyDown, (b) => {
              if (b.key === "Tab" && b.shiftKey) {
                h.onItemShiftTab();
                return;
              }
              if (b.target !== b.currentTarget) return;
              const x = dI(b, h.orientation, h.dir);
              if (x !== void 0) {
                if (b.metaKey || b.ctrlKey || b.altKey || b.shiftKey) return;
                b.preventDefault();
                let C = p().filter((E) => E.focusable).map((E) => E.ref.current);
                if (x === "last") C.reverse();
                else if (x === "prev" || x === "next") {
                  x === "prev" && C.reverse();
                  const E = C.indexOf(b.currentTarget);
                  C = h.loop ? fI(C, E + 1) : C.slice(E + 1);
                }
                setTimeout(() => J1(C));
              }
            })
          }
        )
      }
    );
  }
);
Z1.displayName = K1;
var uI = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function hI(r, e) {
  return e !== "rtl" ? r : r === "ArrowLeft" ? "ArrowRight" : r === "ArrowRight" ? "ArrowLeft" : r;
}
function dI(r, e, t) {
  const n = hI(r.key, t);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(n)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(n)))
    return uI[n];
}
function J1(r, e = !1) {
  const t = document.activeElement;
  for (const n of r)
    if (n === t || (n.focus({ preventScroll: e }), document.activeElement !== t)) return;
}
function fI(r, e) {
  return r.map((t, n) => r[(e + n) % r.length]);
}
var pI = q1, gI = Z1, Sf = "Tabs", [mI, m9] = ga(Sf, [
  G1
]), Q1 = G1(), [vI, Cf] = mI(Sf), ey = W.forwardRef(
  (r, e) => {
    const {
      __scopeTabs: t,
      value: n,
      onValueChange: i,
      defaultValue: s,
      orientation: a = "horizontal",
      dir: c,
      activationMode: u = "automatic",
      ...h
    } = r, d = Dl(c), [p, g] = vf({
      prop: n,
      onChange: i,
      defaultProp: s
    });
    return /* @__PURE__ */ y.jsx(
      vI,
      {
        scope: t,
        baseId: Y1(),
        value: p,
        onValueChange: g,
        orientation: a,
        dir: d,
        activationMode: u,
        children: /* @__PURE__ */ y.jsx(
          lr.div,
          {
            dir: d,
            "data-orientation": a,
            ...h,
            ref: e
          }
        )
      }
    );
  }
);
ey.displayName = Sf;
var ty = "TabsList", ry = W.forwardRef(
  (r, e) => {
    const { __scopeTabs: t, loop: n = !0, ...i } = r, s = Cf(ty, t), a = Q1(t);
    return /* @__PURE__ */ y.jsx(
      pI,
      {
        asChild: !0,
        ...a,
        orientation: s.orientation,
        dir: s.dir,
        loop: n,
        children: /* @__PURE__ */ y.jsx(
          lr.div,
          {
            role: "tablist",
            "aria-orientation": s.orientation,
            ...i,
            ref: e
          }
        )
      }
    );
  }
);
ry.displayName = ty;
var ny = "TabsTrigger", iy = W.forwardRef(
  (r, e) => {
    const { __scopeTabs: t, value: n, disabled: i = !1, ...s } = r, a = Cf(ny, t), c = Q1(t), u = ay(a.baseId, n), h = cy(a.baseId, n), d = n === a.value;
    return /* @__PURE__ */ y.jsx(
      gI,
      {
        asChild: !0,
        ...c,
        focusable: !i,
        active: d,
        children: /* @__PURE__ */ y.jsx(
          lr.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": d,
            "aria-controls": h,
            "data-state": d ? "active" : "inactive",
            "data-disabled": i ? "" : void 0,
            disabled: i,
            id: u,
            ...s,
            ref: e,
            onMouseDown: bt(r.onMouseDown, (p) => {
              !i && p.button === 0 && p.ctrlKey === !1 ? a.onValueChange(n) : p.preventDefault();
            }),
            onKeyDown: bt(r.onKeyDown, (p) => {
              [" ", "Enter"].includes(p.key) && a.onValueChange(n);
            }),
            onFocus: bt(r.onFocus, () => {
              const p = a.activationMode !== "manual";
              !d && !i && p && a.onValueChange(n);
            })
          }
        )
      }
    );
  }
);
iy.displayName = ny;
var sy = "TabsContent", oy = W.forwardRef(
  (r, e) => {
    const { __scopeTabs: t, value: n, forceMount: i, children: s, ...a } = r, c = Cf(sy, t), u = ay(c.baseId, n), h = cy(c.baseId, n), d = n === c.value, p = W.useRef(d);
    return W.useEffect(() => {
      const g = requestAnimationFrame(() => p.current = !1);
      return () => cancelAnimationFrame(g);
    }, []), /* @__PURE__ */ y.jsx(Qs, { present: i || d, children: ({ present: g }) => /* @__PURE__ */ y.jsx(
      lr.div,
      {
        "data-state": d ? "active" : "inactive",
        "data-orientation": c.orientation,
        role: "tabpanel",
        "aria-labelledby": u,
        hidden: !g,
        id: h,
        tabIndex: 0,
        ...a,
        ref: e,
        style: {
          ...r.style,
          animationDuration: p.current ? "0s" : void 0
        },
        children: g && s
      }
    ) });
  }
);
oy.displayName = sy;
function ay(r, e) {
  return `${r}-trigger-${e}`;
}
function cy(r, e) {
  return `${r}-content-${e}`;
}
var yI = ey, ly = ry, uy = iy, hy = oy;
const bI = yI, dy = W.forwardRef(({ className: r, ...e }, t) => /* @__PURE__ */ y.jsx(
  ly,
  {
    ref: t,
    className: ir(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      r
    ),
    ...e
  }
));
dy.displayName = ly.displayName;
const xd = W.forwardRef(({ className: r, ...e }, t) => /* @__PURE__ */ y.jsx(
  uy,
  {
    ref: t,
    className: ir(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      r
    ),
    ...e
  }
));
xd.displayName = uy.displayName;
const _d = W.forwardRef(({ className: r, ...e }, t) => /* @__PURE__ */ y.jsx(
  hy,
  {
    ref: t,
    className: ir(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      r
    ),
    ...e
  }
));
_d.displayName = hy.displayName;
const v9 = "add", y9 = "track", b9 = "trackItems", w9 = "track:changed", x9 = "trackItems:changed", _9 = "state", S9 = "state:changed", wI = "add", fy = "add:text", ma = "add:video", va = "add:audio", C9 = "add:placeholder", ya = "add:image", T9 = "add:mask", E9 = "add:transition", k9 = "add:animation", O9 = "edit", I9 = "edit:object", A9 = "edit:text", M9 = "edit:shape", P9 = "enterEditMode", xI = "player", py = "player:play", gy = "player:pause", _I = "player:seek", D9 = "player:seekTo", SI = "player:seekBy", CI = "player:togglePlay", TI = "active", j9 = "active:set", my = "active:delete", R9 = "active:paste", vy = "active:clone", yy = "active:split", EI = "layer", F9 = "layer:locked", L9 = "layer:hidden", N9 = "layer:move", B9 = "layer:select", by = "layer:selection", V9 = "layer:sendTo", z9 = "layer:rename", W9 = "layer:editingName", H9 = "layer:copy", U9 = "layer:paste", $9 = "layer:clone", Y9 = "layer:split", X9 = "layer:cut", G9 = "layer:delete", kI = "history", wy = "history:undo", xy = "history:redo", q9 = "history:reset", OI = "scale", _y = "scale:changed", II = "drag", Sy = "drag:start", ol = "drag:end", AI = "timeline", Cy = "timeline:boundingChanged";
var Sd = function(r, e) {
  return Sd = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
  }, Sd(r, e);
};
function to(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  Sd(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function Cd(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], n = 0;
  if (t) return t.call(r);
  if (r && typeof r.length == "number") return {
    next: function() {
      return r && n >= r.length && (r = void 0), { value: r && r[n++], done: !r };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Td(r, e) {
  var t = typeof Symbol == "function" && r[Symbol.iterator];
  if (!t) return r;
  var n = t.call(r), i, s = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) s.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (t = n.return) && t.call(n);
    } finally {
      if (a) throw a.error;
    }
  }
  return s;
}
function Ed(r, e, t) {
  if (t || arguments.length === 2) for (var n = 0, i = e.length, s; n < i; n++)
    (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return r.concat(s || Array.prototype.slice.call(e));
}
function Cn(r) {
  return typeof r == "function";
}
function Ty(r) {
  var e = function(n) {
    Error.call(n), n.stack = new Error().stack;
  }, t = r(e);
  return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t;
}
var Fh = Ty(function(r) {
  return function(t) {
    r(this), this.message = t ? t.length + ` errors occurred during unsubscription:
` + t.map(function(n, i) {
      return i + 1 + ") " + n.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = t;
  };
});
function kd(r, e) {
  if (r) {
    var t = r.indexOf(e);
    0 <= t && r.splice(t, 1);
  }
}
var Vl = function() {
  function r(e) {
    this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return r.prototype.unsubscribe = function() {
    var e, t, n, i, s;
    if (!this.closed) {
      this.closed = !0;
      var a = this._parentage;
      if (a)
        if (this._parentage = null, Array.isArray(a))
          try {
            for (var c = Cd(a), u = c.next(); !u.done; u = c.next()) {
              var h = u.value;
              h.remove(this);
            }
          } catch (x) {
            e = { error: x };
          } finally {
            try {
              u && !u.done && (t = c.return) && t.call(c);
            } finally {
              if (e) throw e.error;
            }
          }
        else
          a.remove(this);
      var d = this.initialTeardown;
      if (Cn(d))
        try {
          d();
        } catch (x) {
          s = x instanceof Fh ? x.errors : [x];
        }
      var p = this._finalizers;
      if (p) {
        this._finalizers = null;
        try {
          for (var g = Cd(p), v = g.next(); !v.done; v = g.next()) {
            var b = v.value;
            try {
              wv(b);
            } catch (x) {
              s = s ?? [], x instanceof Fh ? s = Ed(Ed([], Td(s)), Td(x.errors)) : s.push(x);
            }
          }
        } catch (x) {
          n = { error: x };
        } finally {
          try {
            v && !v.done && (i = g.return) && i.call(g);
          } finally {
            if (n) throw n.error;
          }
        }
      }
      if (s)
        throw new Fh(s);
    }
  }, r.prototype.add = function(e) {
    var t;
    if (e && e !== this)
      if (this.closed)
        wv(e);
      else {
        if (e instanceof r) {
          if (e.closed || e._hasParent(this))
            return;
          e._addParent(this);
        }
        (this._finalizers = (t = this._finalizers) !== null && t !== void 0 ? t : []).push(e);
      }
  }, r.prototype._hasParent = function(e) {
    var t = this._parentage;
    return t === e || Array.isArray(t) && t.includes(e);
  }, r.prototype._addParent = function(e) {
    var t = this._parentage;
    this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e;
  }, r.prototype._removeParent = function(e) {
    var t = this._parentage;
    t === e ? this._parentage = null : Array.isArray(t) && kd(t, e);
  }, r.prototype.remove = function(e) {
    var t = this._finalizers;
    t && kd(t, e), e instanceof r && e._removeParent(this);
  }, r.EMPTY = function() {
    var e = new r();
    return e.closed = !0, e;
  }(), r;
}(), Ey = Vl.EMPTY;
function ky(r) {
  return r instanceof Vl || r && "closed" in r && Cn(r.remove) && Cn(r.add) && Cn(r.unsubscribe);
}
function wv(r) {
  Cn(r) ? r() : r.unsubscribe();
}
var MI = {
  Promise: void 0
}, PI = {
  setTimeout: function(r, e) {
    for (var t = [], n = 2; n < arguments.length; n++)
      t[n - 2] = arguments[n];
    return setTimeout.apply(void 0, Ed([r, e], Td(t)));
  },
  clearTimeout: function(r) {
    return clearTimeout(r);
  },
  delegate: void 0
};
function DI(r) {
  PI.setTimeout(function() {
    throw r;
  });
}
function xv() {
}
function Kc(r) {
  r();
}
var Tf = function(r) {
  to(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n.isStopped = !1, t ? (n.destination = t, ky(t) && t.add(n)) : n.destination = FI, n;
  }
  return e.create = function(t, n, i) {
    return new Od(t, n, i);
  }, e.prototype.next = function(t) {
    this.isStopped || this._next(t);
  }, e.prototype.error = function(t) {
    this.isStopped || (this.isStopped = !0, this._error(t));
  }, e.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, r.prototype.unsubscribe.call(this), this.destination = null);
  }, e.prototype._next = function(t) {
    this.destination.next(t);
  }, e.prototype._error = function(t) {
    try {
      this.destination.error(t);
    } finally {
      this.unsubscribe();
    }
  }, e.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, e;
}(Vl), jI = function() {
  function r(e) {
    this.partialObserver = e;
  }
  return r.prototype.next = function(e) {
    var t = this.partialObserver;
    if (t.next)
      try {
        t.next(e);
      } catch (n) {
        _c(n);
      }
  }, r.prototype.error = function(e) {
    var t = this.partialObserver;
    if (t.error)
      try {
        t.error(e);
      } catch (n) {
        _c(n);
      }
    else
      _c(e);
  }, r.prototype.complete = function() {
    var e = this.partialObserver;
    if (e.complete)
      try {
        e.complete();
      } catch (t) {
        _c(t);
      }
  }, r;
}(), Od = function(r) {
  to(e, r);
  function e(t, n, i) {
    var s = r.call(this) || this, a;
    return Cn(t) || !t ? a = {
      next: t ?? void 0,
      error: n ?? void 0,
      complete: i ?? void 0
    } : a = t, s.destination = new jI(a), s;
  }
  return e;
}(Tf);
function _c(r) {
  DI(r);
}
function RI(r) {
  throw r;
}
var FI = {
  closed: !0,
  next: xv,
  error: RI,
  complete: xv
}, LI = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function NI(r) {
  return r;
}
function BI(r) {
  return r.length === 0 ? NI : r.length === 1 ? r[0] : function(t) {
    return r.reduce(function(n, i) {
      return i(n);
    }, t);
  };
}
var _v = function() {
  function r(e) {
    e && (this._subscribe = e);
  }
  return r.prototype.lift = function(e) {
    var t = new r();
    return t.source = this, t.operator = e, t;
  }, r.prototype.subscribe = function(e, t, n) {
    var i = this, s = zI(e) ? e : new Od(e, t, n);
    return Kc(function() {
      var a = i, c = a.operator, u = a.source;
      s.add(c ? c.call(s, u) : u ? i._subscribe(s) : i._trySubscribe(s));
    }), s;
  }, r.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (t) {
      e.error(t);
    }
  }, r.prototype.forEach = function(e, t) {
    var n = this;
    return t = Sv(t), new t(function(i, s) {
      var a = new Od({
        next: function(c) {
          try {
            e(c);
          } catch (u) {
            s(u), a.unsubscribe();
          }
        },
        error: s,
        complete: i
      });
      n.subscribe(a);
    });
  }, r.prototype._subscribe = function(e) {
    var t;
    return (t = this.source) === null || t === void 0 ? void 0 : t.subscribe(e);
  }, r.prototype[LI] = function() {
    return this;
  }, r.prototype.pipe = function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    return BI(e)(this);
  }, r.prototype.toPromise = function(e) {
    var t = this;
    return e = Sv(e), new e(function(n, i) {
      var s;
      t.subscribe(function(a) {
        return s = a;
      }, function(a) {
        return i(a);
      }, function() {
        return n(s);
      });
    });
  }, r.create = function(e) {
    return new r(e);
  }, r;
}();
function Sv(r) {
  var e;
  return (e = r ?? MI.Promise) !== null && e !== void 0 ? e : Promise;
}
function VI(r) {
  return r && Cn(r.next) && Cn(r.error) && Cn(r.complete);
}
function zI(r) {
  return r && r instanceof Tf || VI(r) && ky(r);
}
function WI(r) {
  return Cn(r?.lift);
}
function HI(r) {
  return function(e) {
    if (WI(e))
      return e.lift(function(t) {
        try {
          return r(t, this);
        } catch (n) {
          this.error(n);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function UI(r, e, t, n, i) {
  return new $I(r, e, t, n, i);
}
var $I = function(r) {
  to(e, r);
  function e(t, n, i, s, a, c) {
    var u = r.call(this, t) || this;
    return u.onFinalize = a, u.shouldUnsubscribe = c, u._next = n ? function(h) {
      try {
        n(h);
      } catch (d) {
        t.error(d);
      }
    } : r.prototype._next, u._error = s ? function(h) {
      try {
        s(h);
      } catch (d) {
        t.error(d);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._error, u._complete = i ? function() {
      try {
        i();
      } catch (h) {
        t.error(h);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._complete, u;
  }
  return e.prototype.unsubscribe = function() {
    var t;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var n = this.closed;
      r.prototype.unsubscribe.call(this), !n && ((t = this.onFinalize) === null || t === void 0 || t.call(this));
    }
  }, e;
}(Tf), YI = Ty(function(r) {
  return function() {
    r(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), Ef = function(r) {
  to(e, r);
  function e() {
    var t = r.call(this) || this;
    return t.closed = !1, t.currentObservers = null, t.observers = [], t.isStopped = !1, t.hasError = !1, t.thrownError = null, t;
  }
  return e.prototype.lift = function(t) {
    var n = new Cv(this, this);
    return n.operator = t, n;
  }, e.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new YI();
  }, e.prototype.next = function(t) {
    var n = this;
    Kc(function() {
      var i, s;
      if (n._throwIfClosed(), !n.isStopped) {
        n.currentObservers || (n.currentObservers = Array.from(n.observers));
        try {
          for (var a = Cd(n.currentObservers), c = a.next(); !c.done; c = a.next()) {
            var u = c.value;
            u.next(t);
          }
        } catch (h) {
          i = { error: h };
        } finally {
          try {
            c && !c.done && (s = a.return) && s.call(a);
          } finally {
            if (i) throw i.error;
          }
        }
      }
    });
  }, e.prototype.error = function(t) {
    var n = this;
    Kc(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.hasError = n.isStopped = !0, n.thrownError = t;
        for (var i = n.observers; i.length; )
          i.shift().error(t);
      }
    });
  }, e.prototype.complete = function() {
    var t = this;
    Kc(function() {
      if (t._throwIfClosed(), !t.isStopped) {
        t.isStopped = !0;
        for (var n = t.observers; n.length; )
          n.shift().complete();
      }
    });
  }, e.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(e.prototype, "observed", {
    get: function() {
      var t;
      return ((t = this.observers) === null || t === void 0 ? void 0 : t.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._trySubscribe = function(t) {
    return this._throwIfClosed(), r.prototype._trySubscribe.call(this, t);
  }, e.prototype._subscribe = function(t) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(t), this._innerSubscribe(t);
  }, e.prototype._innerSubscribe = function(t) {
    var n = this, i = this, s = i.hasError, a = i.isStopped, c = i.observers;
    return s || a ? Ey : (this.currentObservers = null, c.push(t), new Vl(function() {
      n.currentObservers = null, kd(c, t);
    }));
  }, e.prototype._checkFinalizedStatuses = function(t) {
    var n = this, i = n.hasError, s = n.thrownError, a = n.isStopped;
    i ? t.error(s) : a && t.complete();
  }, e.prototype.asObservable = function() {
    var t = new _v();
    return t.source = this, t;
  }, e.create = function(t, n) {
    return new Cv(t, n);
  }, e;
}(_v), Cv = function(r) {
  to(e, r);
  function e(t, n) {
    var i = r.call(this) || this;
    return i.destination = t, i.source = n, i;
  }
  return e.prototype.next = function(t) {
    var n, i;
    (i = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null || i === void 0 || i.call(n, t);
  }, e.prototype.error = function(t) {
    var n, i;
    (i = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null || i === void 0 || i.call(n, t);
  }, e.prototype.complete = function() {
    var t, n;
    (n = (t = this.destination) === null || t === void 0 ? void 0 : t.complete) === null || n === void 0 || n.call(t);
  }, e.prototype._subscribe = function(t) {
    var n, i;
    return (i = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t)) !== null && i !== void 0 ? i : Ey;
  }, e;
}(Ef), Tv = function(r) {
  to(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n._value = t, n;
  }
  return Object.defineProperty(e.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._subscribe = function(t) {
    var n = r.prototype._subscribe.call(this, t);
    return !n.closed && t.next(this._value), n;
  }, e.prototype.getValue = function() {
    var t = this, n = t.hasError, i = t.thrownError, s = t._value;
    if (n)
      throw i;
    return this._throwIfClosed(), s;
  }, e.prototype.next = function(t) {
    r.prototype.next.call(this, this._value = t);
  }, e;
}(Ef);
function $n(r, e) {
  return HI(function(t, n) {
    var i = 0;
    t.subscribe(UI(n, function(s) {
      return r.call(e, s, i++) && n.next(s);
    }));
  });
}
const Oy = new Ef(), XI = (r, e) => {
  Oy.next({ key: r, value: e });
}, Ne = {
  subject: Oy,
  dispatch: XI
}, Yt = [];
for (let r = 0; r < 256; ++r)
  Yt.push((r + 256).toString(16).slice(1));
function GI(r, e = 0) {
  return (Yt[r[e + 0]] + Yt[r[e + 1]] + Yt[r[e + 2]] + Yt[r[e + 3]] + "-" + Yt[r[e + 4]] + Yt[r[e + 5]] + "-" + Yt[r[e + 6]] + Yt[r[e + 7]] + "-" + Yt[r[e + 8]] + Yt[r[e + 9]] + "-" + Yt[r[e + 10]] + Yt[r[e + 11]] + Yt[r[e + 12]] + Yt[r[e + 13]] + Yt[r[e + 14]] + Yt[r[e + 15]]).toLowerCase();
}
let Lh;
const qI = new Uint8Array(16);
function KI() {
  if (!Lh) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Lh = crypto.getRandomValues.bind(crypto);
  }
  return Lh(qI);
}
const ZI = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Ev = { randomUUID: ZI };
function Lt(r, e, t) {
  if (Ev.randomUUID && !r)
    return Ev.randomUUID();
  r = r || {};
  const n = r.random ?? r.rng?.() ?? KI();
  if (n.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, GI(n);
}
var Iy = /* @__PURE__ */ ((r) => (r.IMAGE = "image", r.VIDEO = "video", r.AUDIO = "audio", r))(Iy || {});
const JI = (r) => {
  const [e, t] = ue(!1), [n, i] = ue(!1), s = se((d) => {
    const p = { ...d, id: Lt() };
    switch (d.type) {
      case "image":
        Ne.dispatch(ya, { payload: p });
        break;
      case "video":
        Ne.dispatch(ma, { payload: p });
        break;
      case "audio":
        Ne.dispatch(va, { payload: p });
        break;
    }
  }, []), a = se(
    (d) => {
      d.preventDefault();
      try {
        const p = d.dataTransfer?.types[0], g = JSON.parse(p);
        if (!Object.values(Iy).includes(g.type))
          return;
        i(!0), t(!0), r?.(!0);
      } catch (p) {
        console.error("Error parsing dragged data:", p);
      }
    },
    [r]
  ), c = se(
    (d) => {
      d.preventDefault(), e && (i(!0), r?.(!0));
    },
    [e, r]
  ), u = se(
    (d) => {
      if (n) {
        d.preventDefault(), i(!1), r?.(!1);
        try {
          const p = d.dataTransfer?.types[0], g = JSON.parse(
            d.dataTransfer.getData(p)
          );
          s(g);
        } catch (p) {
          console.error("Error parsing dropped data:", p);
        }
      }
    },
    [n, r, s]
  ), h = se(
    (d) => {
      d.preventDefault(), d.currentTarget.contains(d.relatedTarget) || (i(!1), t(!1), r?.(!1));
    },
    [r]
  );
  return { onDragEnter: a, onDragOver: c, onDrop: u, onDragLeave: h, isDraggingOver: n };
}, QI = ({
  children: r,
  className: e,
  style: t,
  onDragStateChange: n,
  id: i
}) => {
  const { onDragEnter: s, onDragOver: a, onDrop: c, onDragLeave: u } = JI(n);
  return /* @__PURE__ */ y.jsx(
    "div",
    {
      id: i,
      onDragEnter: s,
      onDrop: c,
      onDragOver: a,
      onDragLeave: u,
      className: e,
      style: t,
      role: "region",
      "aria-label": "Droppable area for images, videos, and audio",
      children: r
    }
  );
}, K9 = ({
  size: r,
  children: e
}) => {
  const [t, n] = ue(!1);
  return /* @__PURE__ */ y.jsxs(
    QI,
    {
      id: "artboard",
      onDragStateChange: n,
      style: {
        width: r.width,
        height: r.height
      },
      className: "designcombo_scene pointer-events-auto mt-3.5 bg-black",
      children: [
        /* @__PURE__ */ y.jsx(
          "div",
          {
            style: {
              width: r.width,
              height: r.height
            },
            className: `pointer-events-none absolute z-50 mt-3.5 transition-colors duration-200 ease-in-out ${t ? "border-4 border-dashed border-white bg-white/[0.075]" : "bg-transparent"} shadow-[0_0_0_5000px_#1D1D1F]`
          }
        ),
        e
      ]
    }
  );
}, Z9 = 100, J9 = 30, Q9 = 18, eF = 14, tF = 30, rF = 24, nF = 16, e3 = 12, iF = "Regular", t3 = "sans-serif", zl = 188, Id = 40, sF = 4e3, r3 = 1920, n3 = 1080, i3 = 60, s3 = 1e3 / i3, oF = 2e6, aF = 1e7, cF = 48e3, lF = 192e3, Ay = 2.3, uF = r3 / Ay, hF = n3 / Ay, dF = 184, fF = 348, pF = 512, gF = 300, mF = 0, vF = 5e3, yF = 1, bF = 0, wF = 0, xF = 0, _F = 359, SF = 1, CF = 0, TF = !1, EF = !1, kF = 0, OF = 2, IF = 0.01, AF = 1, MF = 0, PF = 3, DF = 0.01, jF = 1, RF = 0, FF = 1, LF = 0.01, NF = 0.5, BF = -1e3, VF = 1e3, zF = 1, WF = 1, HF = 0, UF = 1, $F = 0.01, YF = 1, XF = 0, GF = 1, qF = 0.01, KF = 0, ZF = 0.5, JF = 10, QF = 0.01, eL = 1, tL = 0, rL = 1, nL = 0.01, iL = 1, kf = 16, kv = 80;
function o3(r) {
  if (!r) return "0";
  const e = r / zl, t = Math.trunc(e) % 60, n = Math.trunc(e / 60) % 60, i = Math.trunc(e / 3600) % 60, a = [
    Math.trunc(e / 216e3).toString(),
    i.toString(),
    n.toString(),
    t.toString()
  ];
  return e < 60 ? `${a[3].padStart(2, "0")}f` : e < 3600 ? `${a[2].padStart(1, "0")}s` : e < 216e3 ? `${a[1].padStart(2, "0")}:${a[2].padStart(
    2,
    "0"
  )}` : `${a[0].padStart(2, "0")}:${a[1].padStart(
    2,
    "0"
  )}:${a[2].padStart(2, "0")}`;
}
function sL(r, e = !1) {
  if (!r) return "00:00";
  const n = 1e3 / 60;
  if (r < 1e3)
    return e ? `${Math.floor(r / n)}f` : `${(r / 1e3).toFixed(1)}s`;
  const i = Math.floor(r / 1e3);
  if (i < 60)
    return `${i}s`;
  const s = Math.floor(i / 60);
  if (s < 60) {
    const h = i % 60;
    return `${s.toString().padStart(2, "0")}:${h.toString().padStart(2, "0")}`;
  }
  const a = Math.floor(s / 60), c = s % 60, u = i % 60;
  return `${a.toString().padStart(2, "0")}:${c.toString().padStart(2, "0")}:${u.toString().padStart(2, "0")}`;
}
function al(r, e) {
  return r.map((t) => ({
    ...t,
    items: t.items.filter((n) => !e.includes(n))
  }));
}
const a3 = ({ frame: r }, { fps: e }) => {
  const t = r / e, n = Math.floor(t / 3600), i = t % 3600, s = Math.floor(i / 60), a = Math.floor(i % 60), c = Math.floor(
    (i - Math.floor(i)) * 100
  );
  return n > 0 ? `${n}:${s.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}:${c.toString().padStart(2, "0")}` : `${s.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}:${c.toString().padStart(2, "0")}`;
}, c3 = ({ time: r }) => {
  const e = r / 1e3, t = Math.floor(e / 3600), n = e % 3600, i = Math.floor(n / 60), s = Math.floor(n % 60), a = Math.floor(
    (n - Math.floor(n)) * 100
  );
  return t > 0 ? `${t}:${i.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}` : `${i.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}`;
}, l3 = () => {
  const r = document.getElementById("video-current-time");
  return (r ? parseFloat(r.getAttribute("data-current-time") ?? "") : 0) * 1e3;
}, En = [
  {
    // 1x distance (minute 0 to minute 5, 5 segments).
    index: 0,
    unit: 18e3,
    zoom: 1 / 18e3,
    segments: 5
  },
  {
    // 1x distance (minute 0 to minute 3, 3 segments).
    index: 1,
    unit: 10800,
    zoom: 1 / 10800,
    segments: 3
  },
  {
    // 1x distance (minute 0 to minute 2, 2 segments).
    index: 2,
    unit: 7200,
    zoom: 1 / 7200,
    segments: 2
  },
  {
    // 1x distance (minute 0 to minute 1, 1 segment).
    index: 3,
    unit: 3600,
    zoom: 1 / 3600,
    segments: 1
  },
  {
    // 1x distance (second 0 to second 30, 2 segments).
    index: 4,
    unit: 1800,
    zoom: 1 / 1800,
    segments: 2
  },
  {
    // 1x distance (second 0 to second 15, 3 segments).
    index: 5,
    unit: 900,
    zoom: 1 / 900,
    segments: 3
  },
  {
    // 1x distance (second 0 to second 10, 2 segments).
    index: 6,
    unit: 600,
    zoom: 1 / 600,
    segments: 2
  },
  {
    // 1x distance (second 0 to second 5, 5 segments).
    index: 7,
    unit: 300,
    zoom: 1 / 300,
    segments: 5
  },
  {
    // 1x distance (second 0 to second 3, 3 segments).
    index: 8,
    unit: 180,
    zoom: 1 / 180,
    segments: 3
  },
  {
    // 1x distance (second 0 to second 2, 2 segments).
    index: 9,
    unit: 120,
    zoom: 1 / 120,
    segments: 10
  },
  {
    // 1x distance (second 0 to second 1, 1 segment).
    index: 10,
    unit: 60,
    zoom: 1 / 60,
    segments: 5
  },
  {
    // 1x distance (second 0 to second 1, 1 segment).
    index: 11,
    unit: 60,
    zoom: 1 / 60,
    segments: 5
  },
  {
    // 1x distance (frame 0 to frame 30, 2 segments).
    index: 12,
    unit: 30,
    zoom: 1 / 30,
    segments: 2
  },
  {
    // 1x distance (frame 0 to frame 15, 3 segments).
    index: 13,
    unit: 15,
    zoom: 1 / 15,
    segments: 3
  },
  {
    // 1x distance (frame 0 to frame 10, 2 segments).
    index: 14,
    unit: 10,
    zoom: 1 / 10,
    segments: 2
  },
  {
    // 1x distance (frame 0 to frame 5, 5 segments).
    index: 15,
    unit: 5,
    zoom: 1 / 5,
    segments: 5
  },
  {
    // 1x distance (frame 0 to frame 3, 3 segments).
    index: 16,
    unit: 3,
    zoom: 1 / 3,
    segments: 3
  },
  {
    // 1x distance (frame 0 to frame 2, 2 segments).
    index: 17,
    unit: 2,
    zoom: 1 / 2,
    segments: 5
  },
  {
    // 1x distance (frame 0 to frame 1, 1 segment).
    index: 18,
    unit: 1,
    zoom: 1,
    segments: 5
  },
  {
    // 2x distance (frame 0 to frame 1, 1 segment).
    index: 19,
    unit: 1,
    zoom: 2,
    segments: 5
  },
  {
    // 4x distance (frame 0 to frame 1, 1 segment).
    index: 20,
    unit: 1,
    zoom: 4,
    segments: 10
  }
];
function My(r, e) {
  let t = -1, n = r.length - 1;
  for (; 1 + t < n; ) {
    const i = t + (n - t >> 1);
    e(r[i], i, r) ? n = i : t = i;
  }
  return n;
}
function oL(r, e = 1) {
  const t = () => {
    const u = Math.max(0, Id), d = document.getElementById(
      "designcombo-timeline-canvas"
    )?.offsetWidth ?? document.body.offsetWidth;
    return Math.max(1, d - u);
  }, n = () => typeof r == "number" ? It(r, e) : g3(r, e), i = t() / n(), s = e * i;
  return {
    segments: 5,
    index: My(En, (c) => c.zoom > s),
    zoom: s,
    unit: 1 / s
  };
}
function aL(r) {
  return En[r];
}
function u3(r) {
  return h3(r) || En[0];
}
const h3 = (r) => {
  const e = En.filter(
    (n) => n.zoom < r.zoom
  );
  return e.length === 0 ? null : e.reduce(
    (n, i) => i.zoom > n.zoom ? i : n
  );
}, d3 = (r) => {
  const e = En.filter(
    (n) => n.zoom > r.zoom
  );
  return e.length === 0 ? null : e.reduce(
    (n, i) => i.zoom < n.zoom ? i : n
  );
};
function f3(r) {
  return d3(r) || En[En.length - 1];
}
function cL(r) {
  const e = En.at(-1), t = r === e, i = p3(r) - (t ? 1 : 2);
  return Math.max(0, i);
}
function p3(r) {
  const e = My(En, (t) => t.zoom > r.zoom);
  return Math.min(En.length - 1, e);
}
function It(r, e = 1, t = 1) {
  const n = zl * e;
  return r * (60 / 1e3) * n / t;
}
function ts(r, e = 1) {
  const t = zl * e;
  return r / t * s3;
}
function g3(r, e = 1) {
  return It(r, e);
}
const lL = Math.floor(Math.random() * 1e3) + 1;
function Py(r, e = 1) {
  const t = [], n = Math.floor(e), i = (s, a) => {
    for (const c of s)
      Array.isArray(c) && a < n ? i(c, a + 1) : t.push(c);
  };
  return i(r, 0), t;
}
function Dy(r, e) {
  const t = e.sort((i, s) => i.tempIndex - s.tempIndex), n = [];
  for (const i of t)
    i.tempIndex < 0 && n.push(i);
  n.push(r);
  for (const i of t)
    i.tempIndex >= 0 && n.push(i);
  return n;
}
const Ov = {
  id: "font_UwdNKSyVq2iiMiuHSRRsUIOu",
  family: "Roboto",
  fullName: "Roboto Bold",
  postScriptName: "Roboto-Bold",
  preview: "https://ik.imagekit.io/lh/fonts/v2/5zQgS86djScKA0ri67BBCqW7.png",
  style: "Roboto-Bold",
  url: "https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmWUlvAx05IsDqlA.ttf",
  category: "sans-serif",
  createdAt: "2023-06-20T04:42:55.909Z",
  updatedAt: "2023-06-20T04:42:55.909Z",
  userId: null
}, m3 = (r) => {
  const e = r.map(
    (t) => new FontFace(t.fontFamily, `url(${t.fontUrl})`).load()
    // .catch((error: unknown) => error),
  );
  return e.length === 0 ? Promise.resolve(!0) : new Promise((t, n) => {
    Promise.all(e).then((i) => {
      i.forEach((s) => {
        s instanceof FontFace && s.family && (document.fonts.add(s), t(!0));
      });
    }).catch((i) => {
      n(i);
    });
  });
}, Iv = (r) => {
  let e;
  const t = /* @__PURE__ */ new Set(), n = (h, d) => {
    const p = typeof h == "function" ? h(e) : h;
    if (!Object.is(p, e)) {
      const g = e;
      e = d ?? (typeof p != "object" || p === null) ? p : Object.assign({}, e, p), t.forEach((v) => v(e, g));
    }
  }, i = () => e, c = { setState: n, getState: i, getInitialState: () => u, subscribe: (h) => (t.add(h), () => t.delete(h)) }, u = e = r(n, i, c);
  return c;
}, v3 = (r) => r ? Iv(r) : Iv, y3 = (r) => r;
function b3(r, e = y3) {
  const t = Ce.useSyncExternalStore(
    r.subscribe,
    () => e(r.getState()),
    () => e(r.getInitialState())
  );
  return Ce.useDebugValue(t), t;
}
const Av = (r) => {
  const e = v3(r), t = (n) => b3(e, n);
  return Object.assign(t, e), t;
}, jy = (r) => r ? Av(r) : Av, Zn = jy((r) => ({
  timeline: null,
  size: {
    width: 1080,
    height: 1920
  },
  duration: 5e3,
  fps: 30,
  scale: {
    // 1x distance (second 0 to second 5, 5 segments).
    index: 7,
    unit: 300,
    zoom: 1 / 300,
    segments: 5
  },
  scroll: {
    left: 0,
    top: 0
  },
  playerRef: null,
  activeIds: [],
  targetIds: [],
  tracks: [],
  trackItemIds: [],
  transitionIds: [],
  transitionsMap: {},
  trackItemDetailsMap: {},
  trackItemsMap: {},
  setTimeline: (e) => {
    r(() => ({
      timeline: e
    }));
  },
  setScale: (e) => {
    r(() => ({
      scale: e
    }));
  },
  setScroll: (e) => {
    r(() => ({
      scroll: e
    }));
  },
  setState: async (e) => {
    r({ ...e });
  },
  setPlayerRef: (e) => {
    r({ playerRef: e });
  }
}));
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const w3 = (r) => r.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), Ry = (...r) => r.filter((e, t, n) => !!e && e.trim() !== "" && n.indexOf(e) === t).join(" ").trim();
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var x3 = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const _3 = Vt(
  ({
    color: r = "currentColor",
    size: e = 24,
    strokeWidth: t = 2,
    absoluteStrokeWidth: n,
    className: i = "",
    children: s,
    iconNode: a,
    ...c
  }, u) => hd(
    "svg",
    {
      ref: u,
      ...x3,
      width: e,
      height: e,
      stroke: r,
      strokeWidth: n ? Number(t) * 24 / Number(e) : t,
      className: Ry("lucide", i),
      ...c
    },
    [
      ...a.map(([h, d]) => hd(h, d)),
      ...Array.isArray(s) ? s : [s]
    ]
  )
);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ur = (r, e) => {
  const t = Vt(
    ({ className: n, ...i }, s) => hd(_3, {
      ref: s,
      iconNode: e,
      className: Ry(`lucide-${w3(r)}`, n),
      ...i
    })
  );
  return t.displayName = `${r}`, t;
};
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const S3 = ur("Captions", [
  ["rect", { width: "18", height: "14", x: "3", y: "5", rx: "2", ry: "2", key: "12ruh7" }],
  ["path", { d: "M7 15h4M15 15h2M7 11h2M13 11h4", key: "1ueiar" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const C3 = ur("Image", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }],
  ["circle", { cx: "9", cy: "9", r: "2", key: "af1f0g" }],
  ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21", key: "1xmnt7" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Fy = ur("Music", [
  ["path", { d: "M9 18V5l12-2v13", key: "1jmyc2" }],
  ["circle", { cx: "6", cy: "18", r: "3", key: "fqmcym" }],
  ["circle", { cx: "18", cy: "16", r: "3", key: "1hluhg" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const T3 = ur("Pause", [
  ["rect", { x: "14", y: "4", width: "4", height: "16", rx: "1", key: "zuxfzm" }],
  ["rect", { x: "6", y: "4", width: "4", height: "16", rx: "1", key: "1okwgv" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const E3 = ur("Play", [
  ["polygon", { points: "6 3 20 12 6 21 6 3", key: "1oa8hb" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const k3 = ur("SkipBack", [
  ["polygon", { points: "19 20 9 12 19 4 19 20", key: "o2sva" }],
  ["line", { x1: "5", x2: "5", y1: "19", y2: "5", key: "1ocqjk" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const O3 = ur("SkipForward", [
  ["polygon", { points: "5 4 15 12 5 20 5 4", key: "16p6eg" }],
  ["line", { x1: "19", x2: "19", y1: "5", y2: "19", key: "futhcm" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Mv = ur("SquareSplitHorizontal", [
  ["path", { d: "M8 19H5c-1 0-2-1-2-2V7c0-1 1-2 2-2h3", key: "lubmu8" }],
  ["path", { d: "M16 5h3c1 0 2 1 2 2v10c0 1-1 2-2 2h-3", key: "1ag34g" }],
  ["line", { x1: "12", x2: "12", y1: "4", y2: "20", key: "1tx1rr" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const I3 = ur("Trash", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const A3 = ur("Type", [
  ["polyline", { points: "4 7 4 4 20 4 20 7", key: "1nosan" }],
  ["line", { x1: "9", x2: "15", y1: "20", y2: "20", key: "swin9y" }],
  ["line", { x1: "12", x2: "12", y1: "4", y2: "20", key: "1tx1rr" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Pv = ur("Upload", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "17 8 12 3 7 8", key: "t8dd8p" }],
  ["line", { x1: "12", x2: "12", y1: "3", y2: "15", key: "widbto" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const M3 = ur("Video", [
  [
    "path",
    {
      d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5",
      key: "ftymec"
    }
  ],
  ["rect", { x: "2", y: "6", width: "14", height: "12", rx: "2", key: "158x01" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const P3 = ur("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const D3 = ur("ZoomIn", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "11", x2: "11", y1: "8", y2: "14", key: "1vmskp" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const j3 = ur("ZoomOut", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]), Of = (r) => {
  const e = se(
    (n) => {
      if (!r?.current)
        return () => {
        };
      const i = () => {
        n();
      };
      return r.current.addEventListener("frameupdate", i), () => {
        r.current && r.current.removeEventListener("frameupdate", i);
      };
    },
    [r]
  );
  return Ek(
    e,
    () => r?.current?.getCurrentFrame() ?? 0,
    () => 0
  );
}, Wl = () => {
  const [r, e] = ue(!1);
  return ce(() => {
    const n = Ne.subject.pipe(
      $n(({ key: i }) => i.startsWith(II))
    ).subscribe((i) => {
      i.key === Sy ? e(!0) : i.key === ol && e(!1);
    });
    return () => n.unsubscribe();
  }, []), r;
}, R3 = () => {
  const [r, e] = ue(!1), { duration: t, fps: n, scale: i, playerRef: s, activeIds: a } = Zn(), c = Of(s), u = () => {
    Ne.dispatch(my);
  }, h = () => {
    Ne.dispatch(yy, {
      payload: {},
      options: {
        time: l3()
      }
    });
  }, d = (v) => {
    Ne.dispatch(_y, {
      payload: {
        scale: v
      }
    });
  }, p = () => {
    Ne.dispatch(py);
  }, g = () => {
    Ne.dispatch(gy);
  };
  return ce(() => (s?.current?.addEventListener("play", () => {
    e(!0);
  }), s?.current?.addEventListener("pause", () => {
    e(!1);
  }), () => {
    s?.current?.removeEventListener("play", () => {
      e(!0);
    }), s?.current?.removeEventListener("pause", () => {
      e(!1);
    });
  }), [s]), /* @__PURE__ */ y.jsx(
    "div",
    {
      style: {
        position: "relative",
        height: "50px",
        boxShadow: "inset 0 1px 0 0 #27272a",
        flex: "none"
      },
      className: "bg-background",
      children: /* @__PURE__ */ y.jsx(
        "div",
        {
          style: {
            position: "absolute",
            height: 50,
            width: "100%",
            display: "flex",
            alignItems: "center"
          },
          children: /* @__PURE__ */ y.jsxs(
            "div",
            {
              style: {
                height: 36,
                width: "100%",
                display: "grid",
                gridTemplateColumns: "1fr 260px 1fr",
                alignItems: "center"
              },
              children: [
                /* @__PURE__ */ y.jsxs("div", { className: "flex px-2", children: [
                  /* @__PURE__ */ y.jsxs(
                    mt,
                    {
                      disabled: !a.length,
                      onClick: u,
                      variant: "ghost",
                      size: "sm",
                      className: "flex items-center gap-1 px-2",
                      children: [
                        /* @__PURE__ */ y.jsx(I3, { size: 14 }),
                        " Delete"
                      ]
                    }
                  ),
                  /* @__PURE__ */ y.jsxs(
                    mt,
                    {
                      disabled: !a.length,
                      onClick: h,
                      variant: "ghost",
                      size: "sm",
                      className: "flex items-center gap-1 px-2",
                      children: [
                        /* @__PURE__ */ y.jsx(Mv, { size: 15 }),
                        " Split"
                      ]
                    }
                  ),
                  /* @__PURE__ */ y.jsxs(
                    mt,
                    {
                      disabled: !a.length,
                      onClick: () => {
                        Ne.dispatch(vy);
                      },
                      variant: "ghost",
                      size: "sm",
                      className: "flex items-center gap-1 px-2",
                      children: [
                        /* @__PURE__ */ y.jsx(Mv, { size: 15 }),
                        " Clone"
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ y.jsxs("div", { className: "flex items-center justify-center", children: [
                  /* @__PURE__ */ y.jsxs("div", { children: [
                    /* @__PURE__ */ y.jsx(
                      mt,
                      {
                        onClick: u,
                        variant: "ghost",
                        size: "icon",
                        children: /* @__PURE__ */ y.jsx(k3, { size: 14 })
                      }
                    ),
                    /* @__PURE__ */ y.jsx(
                      mt,
                      {
                        onClick: () => {
                          if (r)
                            return g();
                          p();
                        },
                        variant: "ghost",
                        size: "icon",
                        children: r ? /* @__PURE__ */ y.jsx(T3, { size: 14 }) : /* @__PURE__ */ y.jsx(E3, { size: 14 })
                      }
                    ),
                    /* @__PURE__ */ y.jsx(
                      mt,
                      {
                        onClick: h,
                        variant: "ghost",
                        size: "icon",
                        children: /* @__PURE__ */ y.jsx(O3, { size: 14 })
                      }
                    )
                  ] }),
                  /* @__PURE__ */ y.jsxs(
                    "div",
                    {
                      className: "text-xs font-light",
                      style: {
                        display: "grid",
                        alignItems: "center",
                        gridTemplateColumns: "54px 4px 54px",
                        paddingTop: "2px",
                        justifyContent: "center"
                      },
                      children: [
                        /* @__PURE__ */ y.jsx(
                          "div",
                          {
                            className: "font-medium text-zinc-200",
                            style: {
                              display: "flex",
                              justifyContent: "center"
                            },
                            "data-current-time": c / n,
                            id: "video-current-time",
                            children: a3({ frame: c }, { fps: n })
                          }
                        ),
                        /* @__PURE__ */ y.jsx("span", { children: "/" }),
                        /* @__PURE__ */ y.jsx(
                          "div",
                          {
                            className: "text-muted-foreground",
                            style: {
                              display: "flex",
                              justifyContent: "center"
                            },
                            children: c3({ time: t })
                          }
                        )
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ y.jsx(
                  F3,
                  {
                    scale: i,
                    onChangeTimelineScale: d,
                    duration: t
                  }
                )
              ]
            }
          )
        }
      )
    }
  );
}, F3 = ({
  scale: r,
  onChangeTimelineScale: e,
  duration: t
}) => {
  const n = () => {
    const s = u3(r);
    e(s);
  }, i = () => {
    const s = f3(r);
    e(s);
  };
  return /* @__PURE__ */ y.jsx("div", { className: "flex items-center justify-end", children: /* @__PURE__ */ y.jsxs("div", { className: "flex border-l border-border pl-4 pr-2", children: [
    /* @__PURE__ */ y.jsx(
      mt,
      {
        size: "icon",
        variant: "ghost",
        onClick: n,
        disabled: r.index === 0,
        children: /* @__PURE__ */ y.jsx(j3, { size: 16 })
      }
    ),
    /* @__PURE__ */ y.jsx(
      mt,
      {
        size: "icon",
        variant: "ghost",
        onClick: i,
        disabled: r.index === 20,
        children: /* @__PURE__ */ y.jsx(D3, { size: 16 })
      }
    )
  ] }) });
}, L3 = [
  {
    id: "1",
    details: {
      src: "https://cdn.designcombo.dev/audio/Dawn%20of%20change.mp3",
      text: "Voiceover"
    },
    name: "Dawn of change",
    type: "audio",
    metadata: {
      author: "Roman Senyk"
    },
    display: { from: 3e3 }
  },
  {
    id: "2",
    details: {
      src: "https://cdn.designcombo.dev/audio/Hope.mp3"
    },
    name: "Hope",
    type: "audio",
    metadata: {
      author: "Hugo Dujardin"
    }
  },
  {
    id: "3",
    details: {
      src: "https://cdn.designcombo.dev/audio/Tenderness.mp3"
    },
    name: "Tenderness",
    type: "audio",
    metadata: {
      author: "Benjamin Tissot"
    }
  },
  {
    id: "4",
    details: {
      src: "https://cdn.designcombo.dev/audio/Piano%20Moment.mp3"
    },
    name: "Piano moment",
    type: "audio",
    metadata: {
      author: "Benjamin Tissot"
    }
  }
], N3 = [
  {
    id: "1",
    details: { src: "https://ik.imagekit.io/wombo/images/img1.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img1.jpg?tr=w-190",
    type: "image"
  },
  {
    id: "2",
    details: { src: "https://ik.imagekit.io/wombo/images/img2.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img2.jpg?tr=w-190",
    type: "image"
  },
  {
    id: "3",
    details: { src: "https://ik.imagekit.io/wombo/images/img3.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img3.jpg?tr=w-190",
    type: "image"
  },
  {
    id: "4",
    details: { src: "https://ik.imagekit.io/wombo/images/img4.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img4.jpg?tr=w-190",
    type: "image"
  },
  {
    id: "5",
    details: { src: "https://ik.imagekit.io/wombo/images/img5.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img5.jpg?tr=w-190",
    type: "image"
  },
  ,
  {
    id: "6",
    details: { src: "https://ik.imagekit.io/wombo/images/img6.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img6.jpg?tr=w-190",
    type: "image"
  },
  {
    id: "7",
    details: { src: "https://ik.imagekit.io/wombo/images/img7.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img7.jpg?tr=w-190",
    type: "image"
  }
], B3 = [
  {
    id: "1",
    details: {
      src: "https://cdn.designcombo.dev/videos/demo-video-1.mp4",
      text: "Scene"
    },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-1.png",
    duration: 17e3,
    display: { from: 3e3 }
  },
  {
    id: "2",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-2.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-2.png"
  },
  {
    id: "3",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-3.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-3.png",
    duration: 2e4
  },
  {
    id: "4",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-4.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-4.png",
    duration: 2e4
  },
  {
    id: "5",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-5.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-5.png",
    duration: 23e3
  },
  {
    id: "6",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-6.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-6.png",
    duration: 1e4
  },
  {
    id: "7",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-7.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-7.png",
    duration: 12e3
  },
  {
    id: "8",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-8.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-8.png",
    duration: 15e3
  },
  {
    id: "9",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-9.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-9.png",
    duration: 15e3
  },
  {
    id: "10",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-10.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-10.png",
    duration: 5e3
  },
  {
    id: "11",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-11.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-11.png",
    duration: 5e3
  }
], V3 = [
  {
    id: "1",
    kind: "none",
    duration: 0,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/transition-none.png",
    type: "transition"
  },
  {
    id: "2",
    kind: "fade",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/fade.webp",
    type: "transition"
  },
  {
    id: "3",
    kind: "slide",
    name: "slide up",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/slide-up.webp",
    type: "transition",
    direction: "from-bottom"
  },
  {
    id: "4",
    kind: "slide",
    name: "slide down",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/slide-down.webp",
    type: "transition",
    direction: "from-top"
  },
  {
    id: "5",
    kind: "slide",
    name: "slide left",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/slide-left.webp",
    type: "transition",
    direction: "from-right"
  },
  {
    id: "6",
    kind: "slide",
    name: "slide right",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/slide-right.webp",
    type: "transition",
    direction: "from-left"
  },
  {
    id: "7",
    kind: "wipe",
    name: "wipe up",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/wipe-up.webp",
    type: "transition",
    direction: "from-bottom"
  },
  {
    id: "8",
    kind: "wipe",
    name: "wipe down",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/wipe-down.webp",
    type: "transition",
    direction: "from-top"
  },
  {
    id: "9",
    kind: "wipe",
    name: "wipe left",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/wipe-left.webp",
    type: "transition",
    direction: "from-right"
  },
  {
    id: "10",
    kind: "wipe",
    name: "wipe right",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/wipe-right.webp",
    type: "transition",
    direction: "from-left"
  },
  {
    id: "11",
    kind: "flip",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/flip.webp",
    type: "transition"
  },
  {
    id: "12",
    kind: "clockWipe",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/clock-wipe.webp",
    type: "transition"
  },
  {
    id: "13",
    kind: "star",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/star.webp",
    type: "transition"
  },
  {
    id: "14",
    kind: "circle",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/circle.webp",
    type: "transition"
  },
  {
    id: "15",
    kind: "rectangle",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/rectangle.webp",
    type: "transition"
  }
], uL = [
  {
    id: "1",
    src: "https://ik.imagekit.io/snapmotion/upload-video-1.mp4",
    type: "video"
  },
  {
    id: "2",
    src: "https://ik.imagekit.io/snapmotion/upload-video-2.mp4",
    type: "video"
  },
  {
    id: "3",
    src: "https://ik.imagekit.io/snapmotion/upload-video-3.mp4",
    type: "video"
  }
], z3 = () => {
  const r = Wl();
  return /* @__PURE__ */ y.jsxs("div", { className: "flex flex-1 flex-col overflow-auto", children: [
    /* @__PURE__ */ y.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Transitions" }),
    /* @__PURE__ */ y.jsx(eo, { children: /* @__PURE__ */ y.jsx("div", { className: "grid grid-cols-3 gap-2 px-4", children: V3.map((e, t) => /* @__PURE__ */ y.jsx(
      W3,
      {
        transition: e,
        shouldDisplayPreview: !r
      },
      t
    )) }) })
  ] });
}, W3 = ({
  transition: r,
  shouldDisplayPreview: e
}) => {
  const t = Ce.useMemo(
    () => ({
      backgroundImage: `url(${r.preview})`,
      backgroundSize: "cover",
      width: "70px",
      height: "70px"
    }),
    [r.preview]
  );
  return /* @__PURE__ */ y.jsx(
    Nl,
    {
      data: r,
      renderCustomPreview: /* @__PURE__ */ y.jsx("div", { style: t }),
      shouldDisplayPreview: e,
      children: /* @__PURE__ */ y.jsxs("div", { children: [
        /* @__PURE__ */ y.jsx("div", { children: /* @__PURE__ */ y.jsx(
          "div",
          {
            style: t,
            draggable: !1
          }
        ) }),
        /* @__PURE__ */ y.jsx("div", { className: "flex h-6 items-center overflow-ellipsis text-nowrap text-[12px] capitalize text-muted-foreground", children: r.name || r.type })
      ] })
    }
  );
}, H3 = () => {
  const r = () => {
    Ne.dispatch(fy, {
      payload: {
        id: Lt(),
        display: {
          from: 0,
          to: 5e3
        },
        details: {
          text: "Heading and some body",
          fontSize: 120,
          width: 600,
          fontUrl: Ov.url,
          fontFamily: Ov.postScriptName,
          color: "#ffffff",
          wordWrap: "break-word",
          textAlign: "center",
          borderWidth: 0,
          borderColor: "#000000",
          boxShadow: {
            color: "#ffffff",
            x: 0,
            y: 0,
            blur: 0
          }
        }
      },
      options: {}
    });
  };
  return /* @__PURE__ */ y.jsxs("div", { className: "flex flex-1 flex-col", children: [
    /* @__PURE__ */ y.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Text" }),
    /* @__PURE__ */ y.jsx("div", { className: "flex flex-col gap-2 px-4", children: /* @__PURE__ */ y.jsx(
      mt,
      {
        draggable: !1,
        onClick: r,
        variant: "secondary",
        className: "w-full",
        children: "Add text"
      }
    ) })
  ] });
}, U3 = () => {
  const r = be(null), e = (n) => {
    t(n);
  }, t = async (n) => {
    const i = n[0].type;
    i.includes("audio") && Ne.dispatch(va, {
      payload: {
        id: Lt(),
        details: {
          src: URL.createObjectURL(n[0]),
          volume: 50
        }
      }
    }), i.includes("video") && Ne.dispatch(ma, {
      payload: {
        id: Lt(),
        display: {
          from: 2e3,
          to: 7e3
        },
        details: {
          src: URL.createObjectURL(n[0]),
          name: n[0].name
        }
      }
    }), i.includes("image") && Ne.dispatch(ya, {
      payload: {
        id: Lt(),
        details: {
          src: URL.createObjectURL(n[0])
        }
      }
    });
  };
  return /* @__PURE__ */ y.jsxs("div", { className: "flex flex-1 flex-col", children: [
    /* @__PURE__ */ y.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Your media" }),
    /* @__PURE__ */ y.jsx(
      "input",
      {
        ref: r,
        id: "file-upload-handle",
        type: "file",
        accept: "audio/*,video/*,image/*",
        onChange: (n) => e(Array.from(n.target.files || [])),
        className: "hidden"
      }
    ),
    /* @__PURE__ */ y.jsx("div", { className: "px-4 py-2", children: /* @__PURE__ */ y.jsx("div", { children: /* @__PURE__ */ y.jsxs(
      bI,
      {
        defaultValue: "projects",
        className: "w-full",
        children: [
          /* @__PURE__ */ y.jsxs(dy, { className: "grid w-full grid-cols-2", children: [
            /* @__PURE__ */ y.jsx(xd, { value: "projects", children: "Project" }),
            /* @__PURE__ */ y.jsx(xd, { value: "workspace", children: "Workspace" })
          ] }),
          /* @__PURE__ */ y.jsxs(_d, { value: "projects", children: [
            /* @__PURE__ */ y.jsxs(
              mt,
              {
                onClick: () => {
                  r.current?.click();
                },
                className: "flex w-full gap-2",
                variant: "secondary",
                children: [
                  /* @__PURE__ */ y.jsx(Pv, { size: 16 }),
                  " Upload"
                ]
              }
            ),
            /* @__PURE__ */ y.jsx("div", {})
          ] }),
          /* @__PURE__ */ y.jsx(_d, { value: "workspace", children: /* @__PURE__ */ y.jsxs(
            mt,
            {
              onClick: () => {
                r.current?.click();
              },
              className: "flex w-full gap-2",
              variant: "secondary",
              children: [
                /* @__PURE__ */ y.jsx(Pv, { size: 16 }),
                " Upload"
              ]
            }
          ) })
        ]
      }
    ) }) }),
    /* @__PURE__ */ y.jsx(eo, { children: /* @__PURE__ */ y.jsx("div", { className: "masonry-sm px-4" }) })
  ] });
}, $3 = () => {
  const r = Wl(), e = (t) => {
    Ne.dispatch(va, {
      payload: t,
      options: {}
    });
  };
  return /* @__PURE__ */ y.jsxs("div", { className: "flex flex-1 flex-col", children: [
    /* @__PURE__ */ y.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Audios" }),
    /* @__PURE__ */ y.jsx(eo, { children: /* @__PURE__ */ y.jsx("div", { className: "flex flex-col px-2", children: L3.map((t, n) => /* @__PURE__ */ y.jsx(
      Y3,
      {
        shouldDisplayPreview: !r,
        handleAddAudio: e,
        audio: t
      },
      n
    )) }) })
  ] });
}, Y3 = ({
  handleAddAudio: r,
  audio: e,
  shouldDisplayPreview: t
}) => {
  const n = Ce.useMemo(
    () => ({
      backgroundImage: "url(https://cdn.designcombo.dev/thumbnails/music-preview.png)",
      backgroundSize: "cover",
      width: "70px",
      height: "70px"
    }),
    []
  );
  return /* @__PURE__ */ y.jsx(
    Nl,
    {
      data: e,
      renderCustomPreview: /* @__PURE__ */ y.jsx("div", { style: n }),
      shouldDisplayPreview: t,
      children: /* @__PURE__ */ y.jsxs(
        "div",
        {
          draggable: !1,
          onClick: () => r(e),
          style: {
            display: "grid",
            gridTemplateColumns: "48px 1fr"
          },
          className: "flex cursor-pointer gap-4 px-2 py-1 text-sm hover:bg-zinc-800/70",
          children: [
            /* @__PURE__ */ y.jsx("div", { className: "flex h-12 items-center justify-center bg-zinc-800", children: /* @__PURE__ */ y.jsx(Fy, { width: 16 }) }),
            /* @__PURE__ */ y.jsxs("div", { className: "flex flex-col justify-center", children: [
              /* @__PURE__ */ y.jsx("div", { children: e.name }),
              /* @__PURE__ */ y.jsx("div", { className: "text-zinc-400", children: e.metadata?.author })
            ] })
          ]
        }
      )
    }
  );
}, X3 = () => {
  const r = Wl(), e = (t) => {
    Ne.dispatch(ya, {
      payload: t,
      options: {
        trackId: "main"
      }
    });
  };
  return /* @__PURE__ */ y.jsxs("div", { className: "flex flex-1 flex-col", children: [
    /* @__PURE__ */ y.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Photos" }),
    /* @__PURE__ */ y.jsx(eo, { children: /* @__PURE__ */ y.jsx("div", { className: "masonry-sm px-4", children: N3.map((t, n) => /* @__PURE__ */ y.jsx(
      G3,
      {
        image: t,
        shouldDisplayPreview: !r,
        handleAddImage: e
      },
      n
    )) }) })
  ] });
}, G3 = ({
  handleAddImage: r,
  image: e,
  shouldDisplayPreview: t
}) => {
  const n = Ce.useMemo(
    () => ({
      backgroundImage: `url(${e.preview})`,
      backgroundSize: "cover",
      width: "80px",
      height: "80px"
    }),
    [e.preview]
  );
  return /* @__PURE__ */ y.jsx(
    Nl,
    {
      data: e,
      renderCustomPreview: /* @__PURE__ */ y.jsx("div", { style: n }),
      shouldDisplayPreview: t,
      children: /* @__PURE__ */ y.jsx(
        "div",
        {
          onClick: () => r({
            id: Lt(),
            details: {
              src: e.details.src
            }
          }),
          className: "flex w-full items-center justify-center overflow-hidden bg-background pb-2",
          children: /* @__PURE__ */ y.jsx(
            "img",
            {
              draggable: !1,
              src: e.preview,
              className: "h-full w-full rounded-md object-cover",
              alt: "image"
            }
          )
        }
      )
    }
  );
}, q3 = () => {
  const r = Wl(), e = (t) => {
    Ne.dispatch(ma, {
      payload: t,
      options: {
        resourceId: "main"
      }
    });
  };
  return /* @__PURE__ */ y.jsxs("div", { className: "flex flex-1 flex-col", children: [
    /* @__PURE__ */ y.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Videos" }),
    /* @__PURE__ */ y.jsx(eo, { children: /* @__PURE__ */ y.jsx("div", { className: "masonry-sm px-4", children: B3.map((t, n) => /* @__PURE__ */ y.jsx(
      K3,
      {
        video: t,
        shouldDisplayPreview: !r,
        handleAddVideo: e
      },
      n
    )) }) })
  ] });
}, K3 = ({
  handleAddVideo: r,
  video: e,
  shouldDisplayPreview: t
}) => {
  const n = Ce.useMemo(
    () => ({
      backgroundImage: `url(${e.preview})`,
      backgroundSize: "cover",
      width: "80px",
      height: "80px"
    }),
    [e.preview]
  );
  return /* @__PURE__ */ y.jsx(
    Nl,
    {
      data: e,
      renderCustomPreview: /* @__PURE__ */ y.jsx(
        "div",
        {
          style: n,
          className: "draggable"
        }
      ),
      shouldDisplayPreview: t,
      children: /* @__PURE__ */ y.jsx(
        "div",
        {
          onClick: () => r({
            ...e,
            id: Lt(),
            details: {
              src: e.details.src,
              ...e.details
            }
          }),
          className: "flex w-full items-center justify-center overflow-hidden bg-background pb-2",
          children: /* @__PURE__ */ y.jsx(
            "img",
            {
              draggable: !1,
              src: e.preview,
              className: "h-full w-full rounded-md object-cover",
              alt: "image"
            }
          )
        }
      )
    }
  );
}, If = jy((r) => ({
  activeMenuItem: null,
  showMenuItem: !1,
  cropTarget: null,
  showControlItem: !1,
  showToolboxItem: !1,
  activeToolboxItem: null,
  setCropTarget: (e) => r({ cropTarget: e }),
  setActiveMenuItem: (e) => r({ activeMenuItem: e }),
  setShowMenuItem: (e) => r({ showMenuItem: e }),
  setShowControlItem: (e) => r({ showControlItem: e }),
  setShowToolboxItem: (e) => r({ showToolboxItem: e }),
  setActiveToolboxItem: (e) => r({ activeToolboxItem: e })
})), Z3 = ({ children: r }) => {
  const { showMenuItem: e, setShowMenuItem: t } = If(), n = () => {
    t(!1);
  };
  return /* @__PURE__ */ y.jsxs(
    "div",
    {
      style: {
        left: e ? "0" : "-100%",
        transition: "left 0.25s ease-in-out",
        zIndex: 200
      },
      className: "absolute top-1/2 mt-6 flex h-[calc(100%-32px-64px)] w-[340px] -translate-y-1/2 rounded-lg shadow-lg",
      children: [
        /* @__PURE__ */ y.jsx("div", { className: "w-[74px]" }),
        /* @__PURE__ */ y.jsxs("div", { className: "relative flex flex-1 bg-background/80 backdrop-blur-lg backdrop-filter", children: [
          /* @__PURE__ */ y.jsx(
            mt,
            {
              variant: "ghost",
              className: "absolute right-2 top-2 h-8 w-8 text-muted-foreground",
              size: "icon",
              children: /* @__PURE__ */ y.jsx(
                P3,
                {
                  width: 16,
                  onClick: n
                }
              )
            }
          ),
          r
        ] })
      ]
    }
  );
}, J3 = () => {
  const { activeMenuItem: r } = If();
  return r === "transitions" ? /* @__PURE__ */ y.jsx(z3, {}) : r === "texts" ? /* @__PURE__ */ y.jsx(H3, {}) : r === "videos" ? /* @__PURE__ */ y.jsx(q3, {}) : r === "audios" ? /* @__PURE__ */ y.jsx($3, {}) : r === "images" ? /* @__PURE__ */ y.jsx(X3, {}) : r === "uploads" ? /* @__PURE__ */ y.jsx(U3, {}) : null;
}, Q3 = () => /* @__PURE__ */ y.jsx(Z3, { children: /* @__PURE__ */ y.jsx(J3, {}) }), Wn = {
  audio: Fy,
  captions: S3,
  image: C3,
  redo: ({ ...r }) => /* @__PURE__ */ y.jsx(
    "svg",
    {
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...r,
      children: /* @__PURE__ */ y.jsx(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M14.2957 4.15721C13.9052 3.76669 13.9052 3.13352 14.2957 2.743C14.6862 2.35247 15.3194 2.35247 15.7099 2.743L20.953 7.98603C21.1387 8.16758 21.2539 8.42087 21.2539 8.70108C21.2539 8.70111 21.2539 8.70114 21.2539 8.70117C21.2539 8.70431 21.2539 8.70744 21.2539 8.71057C21.2518 8.93273 21.1773 9.13757 21.0528 9.30262C21.0249 9.33973 20.9942 9.37505 20.961 9.40828L15.7099 14.6593C15.3194 15.0499 14.6862 15.0499 14.2957 14.6593C13.9052 14.2688 13.9052 13.6357 14.2957 13.2451L17.8398 9.70108H9.22665C8.59943 9.70108 7.97836 9.82462 7.39888 10.0646C6.81941 10.3047 6.29289 10.6565 5.84938 11.1C5.40587 11.5435 5.05406 12.07 4.81403 12.6495C4.57401 13.229 4.45047 13.85 4.45047 14.4773C4.45047 15.1045 4.57401 15.7256 4.81403 16.305C5.05406 16.8845 5.40587 17.411 5.84938 17.8545C6.29289 18.298 6.81941 18.6498 7.39888 18.8899C7.97836 19.1299 8.59943 19.2534 9.22665 19.2534H12.9024C13.4547 19.2534 13.9024 19.7012 13.9024 20.2534C13.9024 20.8057 13.4547 21.2534 12.9024 21.2534H9.22665C8.33679 21.2534 7.45564 21.0782 6.63352 20.7376C5.81139 20.3971 5.06439 19.898 4.43517 19.2687C3.80594 18.6395 3.30681 17.8925 2.96627 17.0704C2.62574 16.2483 2.45047 15.3671 2.45047 14.4773C2.45047 13.5874 2.62574 12.7063 2.96627 11.8841C3.30681 11.062 3.80594 10.315 4.43517 9.68578C5.06439 9.05655 5.81139 8.55742 6.63352 8.21689C7.45564 7.87635 8.33679 7.70108 9.22665 7.70108H17.8396L14.2957 4.15721Z",
          fill: "currentColor"
        }
      )
    }
  ),
  shapes: ({ ...r }) => /* @__PURE__ */ y.jsxs(
    "svg",
    {
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...r,
      children: [
        /* @__PURE__ */ y.jsx("g", { clipPath: "url(#clip0_2077_2705)", children: /* @__PURE__ */ y.jsx(
          "path",
          {
            d: "M3.75 12H2.25V20.25C2.25 20.6478 2.40804 21.0294 2.68934 21.3107C2.97064 21.592 3.35218 21.75 3.75 21.75H9.75V20.25H3.75V12ZM21 21.75H12.75C12.6197 21.75 12.4916 21.716 12.3784 21.6514C12.2652 21.5868 12.1708 21.4938 12.1045 21.3816C12.0382 21.2694 12.0022 21.1419 12.0002 21.0116C11.9982 20.8813 12.0302 20.7527 12.093 20.6385L16.218 13.1385C16.2821 13.0203 16.377 12.9218 16.4928 12.8534C16.6085 12.7849 16.7406 12.7492 16.875 12.75C17.1322 12.75 17.3895 12.879 17.532 13.1385L21.657 20.6385C21.7198 20.7527 21.7518 20.8813 21.7498 21.0116C21.7478 21.1419 21.7118 21.2694 21.6455 21.3816C21.5792 21.4938 21.4848 21.5868 21.3716 21.6514C21.2584 21.716 21.1303 21.75 21 21.75ZM14.0182 20.25H19.7318L16.875 15.0563L14.0182 20.25ZM20.25 2.25H12V3.75H20.25V14.244H21.75V3.75C21.75 3.35218 21.592 2.97064 21.3107 2.68934C21.0294 2.40804 20.6478 2.25 20.25 2.25ZM8.25 2.25H3.75C3.35218 2.25 2.97064 2.40804 2.68934 2.68934C2.40804 2.97064 2.25 3.35218 2.25 3.75V8.25C2.25 8.64782 2.40804 9.02936 2.68934 9.31066C2.97064 9.59196 3.35218 9.75 3.75 9.75H8.25C8.64782 9.75 9.02936 9.59196 9.31066 9.31066C9.59196 9.02936 9.75 8.64782 9.75 8.25V3.75C9.75 3.35218 9.59196 2.97064 9.31066 2.68934C9.02936 2.40804 8.64782 2.25 8.25 2.25ZM8.25 8.25H3.75V3.75H8.25V8.25Z",
            fill: "currentColor"
          }
        ) }),
        /* @__PURE__ */ y.jsx("defs", { children: /* @__PURE__ */ y.jsx("clipPath", { id: "clip0_2077_2705", children: /* @__PURE__ */ y.jsx(
          "rect",
          {
            width: "24",
            height: "24",
            fill: "white"
          }
        ) }) })
      ]
    }
  ),
  type: A3,
  undo: ({ ...r }) => /* @__PURE__ */ y.jsx(
    "svg",
    {
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...r,
      children: /* @__PURE__ */ y.jsx(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M9.60387 4.30711C9.99439 3.91659 9.99439 3.28342 9.60387 2.8929C9.21334 2.50238 8.58018 2.50237 8.18965 2.8929L2.8925 8.19004C2.70497 8.37758 2.59961 8.63193 2.59961 8.89715C2.59961 9.16237 2.70497 9.41672 2.8925 9.60426L8.18965 14.9014C8.58018 15.2919 9.21334 15.2919 9.60387 14.9014C9.99439 14.5109 9.99439 13.8777 9.60387 13.4872L5.86478 9.7481H15.1044C15.7383 9.7481 16.366 9.87295 16.9516 10.1155C17.5372 10.3581 18.0693 10.7136 18.5176 11.1619C18.9658 11.6101 19.3213 12.1422 19.5639 12.7278C19.8065 13.3134 19.9313 13.9411 19.9313 14.575C19.9313 15.2088 19.8065 15.8365 19.5639 16.4221C19.3213 17.0077 18.9658 17.5398 18.5176 17.9881C18.0693 18.4363 17.5372 18.7918 16.9516 19.0344C16.366 19.277 15.7383 19.4018 15.1044 19.4018H11.3964C10.8442 19.4018 10.3964 19.8495 10.3964 20.4018C10.3964 20.9541 10.8442 21.4018 11.3964 21.4018H15.1044C16.001 21.4018 16.8887 21.2252 17.717 20.8822C18.5452 20.5391 19.2978 20.0362 19.9318 19.4023C20.5657 18.7683 21.0686 18.0158 21.4116 17.1875C21.7547 16.3592 21.9313 15.4715 21.9313 14.575C21.9313 13.6784 21.7547 12.7907 21.4116 11.9624C21.0686 11.1342 20.5657 10.3816 19.9318 9.74764C19.2978 9.11371 18.5452 8.61085 17.717 8.26777C16.8887 7.92469 16.001 7.7481 15.1044 7.7481H6.16287L9.60387 4.30711Z",
          fill: "currentColor"
        }
      )
    }
  ),
  upload: ({ ...r }) => /* @__PURE__ */ y.jsxs(
    "svg",
    {
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...r,
      children: [
        /* @__PURE__ */ y.jsxs("g", { clipPath: "url(#clip0_2077_2699)", children: [
          /* @__PURE__ */ y.jsx(
            "path",
            {
              d: "M8.25 13.5L9.3075 14.5575L11.25 12.6225V21.75H12.75V12.6225L14.6925 14.5575L15.75 13.5L12 9.75L8.25 13.5Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ y.jsx(
            "path",
            {
              d: "M17.6249 16.5004H17.2499V15.0004H17.6249C18.52 15.0362 19.3927 14.715 20.0509 14.1074C20.7092 13.4997 21.0991 12.6555 21.1349 11.7604C21.1707 10.8653 20.8495 9.99264 20.2418 9.33438C19.6342 8.67613 18.79 8.28621 17.8949 8.25041H17.2499L17.1749 7.63541C17.0085 6.37275 16.3888 5.21362 15.4312 4.37395C14.4736 3.53428 13.2435 3.07132 11.9699 3.07132C10.6963 3.07132 9.46616 3.53428 8.50857 4.37395C7.55099 5.21362 6.93129 6.37275 6.76489 7.63541L6.74989 8.25041H6.10489C5.20979 8.28621 4.36557 8.67613 3.75795 9.33438C3.15033 9.99264 2.82909 10.8653 2.86489 11.7604C2.9007 12.6555 3.29062 13.4997 3.94887 14.1074C4.60712 14.715 5.47979 15.0362 6.37489 15.0004H6.74989V16.5004H6.37489C5.1722 16.4928 4.01477 16.0409 3.12513 15.2315C2.2355 14.4221 1.67646 13.3124 1.55549 12.1158C1.43453 10.9192 1.76018 9.72009 2.46983 8.74905C3.17949 7.77801 4.22305 7.10357 5.39989 6.85541C5.72367 5.3453 6.55552 3.99189 7.75663 3.02101C8.95774 2.05013 10.4555 1.52051 11.9999 1.52051C13.5443 1.52051 15.042 2.05013 16.2432 3.02101C17.4443 3.99189 18.2761 5.3453 18.5999 6.85541C19.7767 7.10357 20.8203 7.77801 21.53 8.74905C22.2396 9.72009 22.5653 10.9192 22.4443 12.1158C22.3233 13.3124 21.7643 14.4221 20.8747 15.2315C19.985 16.0409 18.8276 16.4928 17.6249 16.5004Z",
              fill: "currentColor"
            }
          )
        ] }),
        /* @__PURE__ */ y.jsx("defs", { children: /* @__PURE__ */ y.jsx("clipPath", { id: "clip0_2077_2699", children: /* @__PURE__ */ y.jsx(
          "rect",
          {
            width: "24",
            height: "24",
            fill: "white"
          }
        ) }) })
      ]
    }
  ),
  video: M3
};
function e4() {
  const { setActiveMenuItem: r, setShowMenuItem: e, activeMenuItem: t, showMenuItem: n } = If();
  return /* @__PURE__ */ y.jsxs(
    "div",
    {
      style: { zIndex: 201 },
      className: "absolute left-2.5 top-1/2 mt-6 flex w-14 -translate-y-1/2 flex-col items-center rounded-lg bg-background/80 py-2 shadow-lg backdrop-blur-lg backdrop-filter",
      children: [
        /* @__PURE__ */ y.jsx(
          mt,
          {
            onClick: () => {
              r("uploads"), e(!0);
            },
            className: ir(
              n && t === "uploads" ? "bg-secondary" : "text-muted-foreground"
            ),
            variant: "ghost",
            size: "icon",
            children: /* @__PURE__ */ y.jsx(Wn.upload, { width: 20 })
          }
        ),
        /* @__PURE__ */ y.jsx(
          mt,
          {
            onClick: () => {
              r("texts"), e(!0);
            },
            className: ir(
              n && t === "texts" ? "bg-secondary" : "text-muted-foreground"
            ),
            variant: "ghost",
            size: "icon",
            children: /* @__PURE__ */ y.jsx(Wn.type, { width: 20 })
          }
        ),
        /* @__PURE__ */ y.jsx(
          mt,
          {
            onClick: () => {
              r("videos"), e(!0);
            },
            className: ir(
              n && t === "videos" ? "bg-secondary" : "text-muted-foreground"
            ),
            variant: "ghost",
            size: "icon",
            children: /* @__PURE__ */ y.jsx(Wn.video, { width: 20 })
          }
        ),
        /* @__PURE__ */ y.jsx(
          mt,
          {
            onClick: () => {
              r("captions"), e(!0);
            },
            className: ir(
              n && t === "captions" ? "bg-secondary" : "text-muted-foreground"
            ),
            variant: "ghost",
            size: "icon",
            children: /* @__PURE__ */ y.jsx(Wn.captions, { width: 20 })
          }
        ),
        /* @__PURE__ */ y.jsx(
          mt,
          {
            onClick: () => {
              r("images"), e(!0);
            },
            className: ir(
              n && t === "images" ? "bg-secondary" : "text-muted-foreground"
            ),
            variant: "ghost",
            size: "icon",
            children: /* @__PURE__ */ y.jsx(Wn.image, { width: 20 })
          }
        ),
        /* @__PURE__ */ y.jsx(
          mt,
          {
            onClick: () => {
              r("shapes"), e(!0);
            },
            className: ir(
              n && t === "shapes" ? "bg-secondary" : "text-muted-foreground"
            ),
            variant: "ghost",
            size: "icon",
            children: /* @__PURE__ */ y.jsx(Wn.shapes, { width: 20 })
          }
        ),
        /* @__PURE__ */ y.jsx(
          mt,
          {
            onClick: () => {
              r("audios"), e(!0);
            },
            className: ir(
              n && t === "audios" ? "bg-secondary" : "text-muted-foreground"
            ),
            variant: "ghost",
            size: "icon",
            children: /* @__PURE__ */ y.jsx(Wn.audio, { width: 20 })
          }
        ),
        /* @__PURE__ */ y.jsx(
          mt,
          {
            onClick: () => {
              r("transitions"), e(!0);
            },
            className: ir(
              n && t === "transitions" ? "bg-secondary" : "text-muted-foreground"
            ),
            variant: "ghost",
            size: "icon",
            children: /* @__PURE__ */ y.jsx(
              "svg",
              {
                width: 20,
                viewBox: "0 0 24 24",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg",
                children: /* @__PURE__ */ y.jsx(
                  "path",
                  {
                    d: "M3 5.30359C3 3.93159 4.659 3.24359 5.629 4.21359L11.997 10.5826L10.583 11.9966L5 6.41359V17.5856L10.586 11.9996L10.583 11.9966L11.997 10.5826L12 10.5856L18.371 4.21459C19.341 3.24459 21 3.93159 21 5.30359V18.6956C21 20.0676 19.341 20.7556 18.371 19.7856L12 13.5L13.414 11.9996L19 17.5866V6.41359L13.414 11.9996L13.421 12.0056L12.006 13.4206L12 13.4136L5.629 19.7846C4.659 20.7546 3 20.0676 3 18.6956V5.30359Z",
                    fill: "currentColor"
                  }
                )
              }
            )
          }
        )
      ]
    }
  );
}
function t4() {
  const r = () => {
    Ne.dispatch(wy);
  }, e = () => {
    Ne.dispatch(xy);
  };
  return /* @__PURE__ */ y.jsx(
    "div",
    {
      style: {
        display: "grid",
        gridTemplateColumns: "320px 1fr 320px"
      },
      className: "pointer-events-none absolute left-0 right-0 top-0 z-[205] flex h-[72px] items-center px-2",
      children: /* @__PURE__ */ y.jsxs("div", { className: "pointer-events-auto flex h-14 items-center gap-2", children: [
        /* @__PURE__ */ y.jsx("div", { className: "flex h-12 w-12 items-center justify-center rounded-md bg-background" }),
        /* @__PURE__ */ y.jsxs("div", { className: "flex h-12 items-center bg-background px-1.5", children: [
          /* @__PURE__ */ y.jsx(
            mt,
            {
              onClick: r,
              className: "text-muted-foreground",
              variant: "ghost",
              size: "icon",
              children: /* @__PURE__ */ y.jsx(Wn.undo, { width: 20 })
            }
          ),
          /* @__PURE__ */ y.jsx(
            mt,
            {
              onClick: e,
              className: "text-muted-foreground",
              variant: "ghost",
              size: "icon",
              children: /* @__PURE__ */ y.jsx(Wn.redo, { width: 20 })
            }
          )
        ] })
      ] })
    }
  );
}
var r4 = Object.defineProperty, Ly = (r, e) => {
  for (var t in e)
    r4(r, t, {
      get: e[t],
      enumerable: !0,
      configurable: !0,
      set: (n) => e[t] = () => n
    });
};
if (typeof At != "function") {
  const r = [
    'Remotion requires React.createContext, but it is "undefined".',
    'If you are in a React Server Component, turn it into a client component by adding "use client" at the top of the file.',
    "",
    "Before:",
    '  import {useCurrentFrame} from "remotion";',
    "",
    "After:",
    '  "use client";',
    '  import {useCurrentFrame} from "remotion";'
  ];
  throw new Error(r.join(`
`));
}
function Dv() {
  return ["NOD", "E_EN", "V"].join("");
}
var jv = () => ["e", "nv"].join(""), Mt = () => {
  const r = typeof window < "u" && window.remotion_isPlayer, e = typeof window < "u" && typeof window.process < "u" && typeof window.process.env < "u" && (window.process[jv()][Dv()] === "test" || window.process[jv()][Dv()] === "production" && typeof window < "u" && typeof window.remotion_puppeteerTimeout < "u");
  return {
    isStudio: typeof window < "u" && window.remotion_isStudio,
    isRendering: e,
    isPlayer: r
  };
}, n4 = Ce.createElement, Ny = [], By = () => {
  if (!Mt().isStudio)
    return;
  const r = new Proxy(n4, {
    apply(e, t, n) {
      if (Ny.includes(n[0])) {
        const [i, s, ...a] = n, c = {
          ...s ?? {},
          stack: new Error().stack
        };
        return Reflect.apply(e, t, [i, c, ...a]);
      }
      return Reflect.apply(e, t, n);
    }
  });
  Ce.createElement = r;
}, ba = (r) => {
  Ny.push(r), By();
}, Vy = At(!1), i4 = ({
  children: r
}) => /* @__PURE__ */ y.jsx(Vy.Provider, {
  value: !0,
  children: r
}), Af = () => me(Vy);
function Hl(r) {
  return !!r;
}
var Sc = "4.0.229", s4 = () => {
  if (typeof globalThis > "u")
    return;
  const r = globalThis.remotion_imported || typeof window < "u" && window.remotion_imported;
  if (r) {
    if (r === Sc)
      return;
    throw new TypeError(`🚨 Multiple versions of Remotion detected: ${[
      Sc,
      typeof r == "string" ? r : "an older version"
    ].filter(Hl).join(" and ")}. This will cause things to break in an unexpected way.
Check that all your Remotion packages are on the same version. If your dependencies depend on Remotion, make them peer dependencies. You can also run \`npx remotion versions\` from your terminal to see which versions are mismatching.`);
  }
  globalThis.remotion_imported = Sc, typeof window < "u" && (window.remotion_imported = Sc);
}, o4 = (r, e) => {
  const { style: t, ...n } = r, i = ee(() => ({
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    width: "100%",
    height: "100%",
    display: "flex",
    flexDirection: "column",
    ...t
  }), [t]);
  return /* @__PURE__ */ y.jsx("div", {
    ref: e,
    style: i,
    ...n
  });
}, Yo = Vt(o4), Jt = At(null), ro = Ce.createContext({
  registerSequence: () => {
    throw new Error("SequenceManagerContext not initialized");
  },
  unregisterSequence: () => {
    throw new Error("SequenceManagerContext not initialized");
  },
  sequences: []
}), wa = Ce.createContext({
  hidden: {},
  setHidden: () => {
    throw new Error("SequenceVisibilityToggle not initialized");
  }
}), a4 = ({ children: r }) => {
  const [e, t] = ue([]), [n, i] = ue({}), s = se((h) => {
    t((d) => [...d, h]);
  }, []), a = se((h) => {
    t((d) => d.filter((p) => p.id !== h));
  }, []), c = ee(() => ({
    registerSequence: s,
    sequences: e,
    unregisterSequence: a
  }), [s, e, a]), u = ee(() => ({
    hidden: n,
    setHidden: i
  }), [n]);
  return /* @__PURE__ */ y.jsx(ro.Provider, {
    value: c,
    children: /* @__PURE__ */ y.jsx(wa.Provider, {
      value: u,
      children: r
    })
  });
}, no = At({
  getNonce: () => 0,
  fastRefreshes: 0
}), Mf = () => {
  const r = me(no), [e, t] = ue(() => r.getNonce()), n = be(r);
  return ce(() => {
    n.current !== r && (n.current = r, t(r.getNonce));
  }, [r]), e;
}, zy = {};
Ly(zy, {
  useTimelineSetFrame: () => eb,
  useTimelinePosition: () => us,
  usePlayingState: () => Rf,
  persistCurrentFrame: () => Zy,
  getInitialFrameState: () => Jy,
  getFrameForComposition: () => Qy,
  TimelineContext: () => ln,
  SetTimelineContext: () => io
});
var Ti = At({
  compositions: [],
  registerComposition: () => {
  },
  unregisterComposition: () => {
  },
  registerFolder: () => {
  },
  unregisterFolder: () => {
  },
  setCurrentCompositionMetadata: () => {
  },
  updateCompositionDefaultProps: () => {
  },
  folders: [],
  currentCompositionMetadata: null,
  canvasContent: null,
  setCanvasContent: () => {
  }
}), Ul = At({
  props: {},
  updateProps: () => {
    throw new Error("Not implemented");
  },
  resetUnsaved: () => {
    throw new Error("Not implemented");
  }
}), Wy = Ce.createRef(), Hy = ({ children: r }) => {
  const [e, t] = Ce.useState({}), n = se(({
    defaultProps: a,
    id: c,
    newProps: u
  }) => {
    t((h) => ({
      ...h,
      [c]: typeof u == "function" ? u(h[c] ?? a) : u
    }));
  }, []), i = se(() => {
    t({});
  }, []);
  Zr(Wy, () => ({
    getProps: () => e,
    setProps: t
  }), [e]);
  const s = ee(() => ({ props: e, updateProps: n, resetUnsaved: i }), [e, i, n]);
  return /* @__PURE__ */ y.jsx(Ul.Provider, {
    value: s,
    children: r
  });
}, c4 = {
  "%3A": ":",
  "%2F": "/",
  "%3F": "?",
  "%23": "#",
  "%5B": "[",
  "%5D": "]",
  "%40": "@",
  "%21": "!",
  "%24": "$",
  "%26": "&",
  "%27": "'",
  "%28": "(",
  "%29": ")",
  "%2A": "*",
  "%2B": "+",
  "%2C": ",",
  "%3B": ";"
}, Rv = {}, l4 = (r) => {
  Rv[r] || (console.warn(r), Rv[r] = !0);
}, u4 = (r) => {
  for (const e of Object.keys(c4))
    if (r.includes(e))
      return { containsHex: !0, hexCode: e };
  return { containsHex: !1 };
}, Ad = (r) => r.startsWith("/") ? Ad(r.substring(1)) : r, h4 = (r) => {
  if (typeof window < "u" && window.remotion_staticBase) {
    if (r.startsWith(window.remotion_staticBase))
      throw new Error(`The value "${r}" is already prefixed with the static base ${window.remotion_staticBase}. You don't need to call staticFile() on it.`);
    return `${window.remotion_staticBase}/${Ad(r)}`;
  }
  return `/${Ad(r)}`;
}, d4 = (r) => r.split("/").map((i) => encodeURIComponent(i)).join("/"), f4 = (r) => {
  if (r === null)
    throw new TypeError("null was passed to staticFile()");
  if (typeof r > "u")
    throw new TypeError("undefined was passed to staticFile()");
  if (r.startsWith("http://") || r.startsWith("https://"))
    throw new TypeError(`staticFile() does not support remote URLs - got "${r}". Instead, pass the URL without wrapping it in staticFile(). See: https://remotion.dev/docs/staticfile-remote-urls`);
  if (r.startsWith("..") || r.startsWith("./"))
    throw new TypeError(`staticFile() does not support relative paths - got "${r}". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);
  if (r.startsWith("/Users") || r.startsWith("/home") || r.startsWith("/tmp") || r.startsWith("/etc") || r.startsWith("/opt") || r.startsWith("/var") || r.startsWith("C:") || r.startsWith("D:") || r.startsWith("E:"))
    throw new TypeError(`staticFile() does not support absolute paths - got "${r}". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);
  if (r.startsWith("public/"))
    throw new TypeError(`Do not include the public/ prefix when using staticFile() - got "${r}". See: https://remotion.dev/docs/staticfile-relative-paths`);
  const e = u4(r);
  e.containsHex && l4(`WARNING: You seem to pass an already encoded path (path contains ${e.hexCode}). Since Remotion 4.0, the encoding is done by staticFile() itself. You may want to remove a encodeURIComponent() wrapping.`);
  const t = d4(r), n = h4(t);
  return n.startsWith("/") ? n : `/${n}`;
}, Md = "remotion-date:", Pd = "remotion-file:", p4 = ({
  data: r,
  indent: e,
  staticBase: t
}) => {
  let n = !1, i = !1, s = !1, a = !1;
  try {
    return { serializedString: JSON.stringify(r, function(u, h) {
      const d = this[u];
      return d instanceof Date ? (n = !0, `${Md}${d.toISOString()}`) : d instanceof Map ? (s = !0, h) : d instanceof Set ? (a = !0, h) : typeof d == "string" && t !== null && d.startsWith(t) ? (i = !0, `${Pd}${d.replace(t + "/", "")}`) : h;
    }, e), customDateUsed: n, customFileUsed: i, mapUsed: s, setUsed: a };
  } catch (c) {
    throw new Error("Could not serialize the passed input props to JSON: " + c.message);
  }
}, Uy = (r) => JSON.parse(r, (e, t) => typeof t == "string" && t.startsWith(Md) ? new Date(t.replace(Md, "")) : typeof t == "string" && t.startsWith(Pd) ? f4(t.replace(Pd, "")) : t), Hi = (r) => Mt().isStudio ? Uy(p4({
  data: r,
  indent: 2,
  staticBase: window.remotion_staticBase
}).serializedString) : r, Fv = !1, g4 = () => {
  Fv || (Fv = !0, console.warn("Called `getInputProps()` on the server. This function is not available server-side and has returned an empty object."), console.warn("To hide this warning, don't call this function on the server:"), console.warn("  typeof window === 'undefined' ? {} : getInputProps()"));
}, $y = () => {
  if (typeof window > "u")
    return g4(), {};
  if (Mt().isPlayer)
    throw new Error("You cannot call `getInputProps()` from a <Player>. Instead, the props are available as React props from component that you passed as `component` prop.");
  const r = window.remotion_inputProps;
  return r ? Uy(r) : {};
}, Lv = [
  "h264",
  "h265",
  "vp8",
  "vp9",
  "mp3",
  "aac",
  "wav",
  "prores",
  "h264-mkv",
  "h264-ts",
  "gif"
];
function m4(r, e) {
  if (!(typeof r > "u")) {
    if (typeof r != "string")
      throw new TypeError(`The "defaultCodec" prop ${e} must be a string, but you passed a value of type ${typeof r}.`);
    if (!Lv.includes(r))
      throw new Error(`The "defaultCodec" prop ${e} must be one of ${Lv.join(", ")}, but you passed ${r}.`);
  }
}
function cl(r, e, t) {
  if (typeof r != "number")
    throw new Error(`The "${e}" prop ${t} must be a number, but you passed a value of type ${typeof r}`);
  if (isNaN(r))
    throw new TypeError(`The "${e}" prop ${t} must not be NaN, but is NaN.`);
  if (!Number.isFinite(r))
    throw new TypeError(`The "${e}" prop ${t} must be finite, but is ${r}.`);
  if (r % 1 !== 0)
    throw new TypeError(`The "${e}" prop ${t} must be an integer, but is ${r}.`);
  if (r <= 0)
    throw new TypeError(`The "${e}" prop ${t} must be positive, but got ${r}.`);
}
function Pf(r, e) {
  const { allowFloats: t, component: n } = e;
  if (typeof r > "u")
    throw new Error(`The "durationInFrames" prop ${n} is missing.`);
  if (typeof r != "number")
    throw new Error(`The "durationInFrames" prop ${n} must be a number, but you passed a value of type ${typeof r}`);
  if (r <= 0)
    throw new TypeError(`The "durationInFrames" prop ${n} must be positive, but got ${r}.`);
  if (!t && r % 1 !== 0)
    throw new TypeError(`The "durationInFrames" prop ${n} must be an integer, but got ${r}.`);
  if (!Number.isFinite(r))
    throw new TypeError(`The "durationInFrames" prop ${n} must be finite, but got ${r}.`);
}
function Yy(r, e, t) {
  if (typeof r != "number")
    throw new Error(`"fps" must be a number, but you passed a value of type ${typeof r} ${e}`);
  if (!Number.isFinite(r))
    throw new Error(`"fps" must be a finite, but you passed ${r} ${e}`);
  if (isNaN(r))
    throw new Error(`"fps" must not be NaN, but got ${r} ${e}`);
  if (r <= 0)
    throw new TypeError(`"fps" must be positive, but got ${r} ${e}`);
}
var Nv = ({
  calculated: r,
  compositionId: e,
  compositionFps: t,
  compositionHeight: n,
  compositionWidth: i,
  compositionDurationInFrames: s
}) => {
  const a = `calculated by calculateMetadata() for the composition "${e}"`, c = `of the "<Composition />" component with the id "${e}"`, u = r?.width ?? i ?? void 0;
  cl(u, "width", r?.width ? a : c);
  const h = r?.height ?? n ?? void 0;
  cl(h, "height", r?.height ? a : c);
  const d = r?.fps ?? t ?? null;
  Yy(d, r?.fps ? a : c);
  const p = r?.durationInFrames ?? s ?? null;
  Pf(p, {
    allowFloats: !1,
    component: `of the "<Composition />" component with the id "${e}"`
  });
  const g = r?.defaultCodec;
  return m4(g, a), { width: u, height: h, fps: d, durationInFrames: p, defaultCodec: g };
}, Xy = ({
  calculateMetadata: r,
  signal: e,
  defaultProps: t,
  originalProps: n,
  compositionId: i,
  compositionDurationInFrames: s,
  compositionFps: a,
  compositionHeight: c,
  compositionWidth: u
}) => {
  const h = r ? r({
    defaultProps: t,
    props: n,
    abortSignal: e,
    compositionId: i
  }) : null;
  if (h !== null && typeof h == "object" && "then" in h)
    return h.then((p) => {
      const { height: g, width: v, durationInFrames: b, fps: x, defaultCodec: _ } = Nv({
        calculated: p,
        compositionDurationInFrames: s,
        compositionFps: a,
        compositionHeight: c,
        compositionWidth: u,
        compositionId: i
      });
      return {
        width: v,
        height: g,
        fps: x,
        durationInFrames: b,
        id: i,
        defaultProps: Hi(t),
        props: Hi(p.props ?? n),
        defaultCodec: _ ?? null
      };
    });
  const d = Nv({
    calculated: h,
    compositionDurationInFrames: s,
    compositionFps: a,
    compositionHeight: c,
    compositionWidth: u,
    compositionId: i
  });
  return h === null ? {
    ...d,
    id: i,
    defaultProps: Hi(t ?? {}),
    props: Hi(n),
    defaultCodec: null
  } : {
    ...d,
    id: i,
    defaultProps: Hi(t ?? {}),
    props: Hi(h.props ?? n),
    defaultCodec: h.defaultCodec ?? null
  };
}, v4 = (r) => {
  try {
    return {
      type: "success",
      result: Xy(r)
    };
  } catch (e) {
    return {
      type: "error",
      error: e
    };
  }
}, $l = At(null), Gy = u1(), qy = (r) => !!r.calculateMetadata, y4 = "remotion.propsUpdatedExternally", Ky = ({ children: r }) => {
  const [e, t] = ue(null), { compositions: n, canvasContent: i, currentCompositionMetadata: s } = me(Ti), { fastRefreshes: a } = me(no), c = ee(() => n.find((F) => i && i.type === "composition" && i.compositionId === F.id), [i, n]), u = n.find((F) => F.id === e), { props: h } = me(Ul), d = ee(() => typeof window > "u" || Mt().isPlayer ? {} : $y() ?? {}, []), [p, g] = ue({}), v = ee(() => c ? h[c.id] ?? {} : {}, [h, c]), b = ee(() => u ? h[u.id] ?? {} : {}, [h, u]), x = !!s, _ = se(({
    calculateMetadata: F,
    combinedProps: $,
    compositionDurationInFrames: z,
    compositionFps: G,
    compositionHeight: H,
    compositionId: Y,
    compositionWidth: te,
    defaultProps: ge
  }) => {
    const Z = new AbortController();
    if (x)
      return Z;
    const { signal: de } = Z, oe = v4({
      compositionId: Y,
      calculateMetadata: F,
      originalProps: $,
      signal: de,
      defaultProps: ge,
      compositionDurationInFrames: z,
      compositionFps: G,
      compositionHeight: H,
      compositionWidth: te
    });
    if (oe.type === "error")
      return g((pe) => ({
        ...pe,
        [Y]: {
          type: "error",
          error: oe.error
        }
      })), Z;
    const ie = oe.result;
    return typeof ie == "object" && "then" in ie ? (g((pe) => {
      const re = pe[Y];
      return re?.type === "success" || re?.type === "success-and-refreshing" ? {
        ...pe,
        [Y]: {
          type: "success-and-refreshing",
          result: re.result
        }
      } : {
        ...pe,
        [Y]: {
          type: "loading"
        }
      };
    }), ie.then((pe) => {
      Z.signal.aborted || g((re) => ({
        ...re,
        [Y]: {
          type: "success",
          result: pe
        }
      }));
    }).catch((pe) => {
      Z.signal.aborted || g((re) => ({
        ...re,
        [Y]: {
          type: "error",
          error: pe
        }
      }));
    })) : g((pe) => ({
      ...pe,
      [Y]: {
        type: "success",
        result: ie
      }
    })), Z;
  }, [x]), C = i?.type === "composition" ? i.compositionId : null;
  Zr(Gy, () => ({
    setCurrentRenderModalComposition: (F) => {
      t(F);
    },
    reloadCurrentlySelectedComposition: () => {
      if (!C)
        return;
      const F = n.find((H) => H.id === C);
      if (!F)
        throw new Error(`Could not find composition with id ${C}`);
      const $ = h[C] ?? {}, z = {
        ...F.defaultProps ?? {},
        ...$ ?? {}
      }, G = {
        ...z,
        ...d ?? {}
      };
      _({
        defaultProps: z,
        calculateMetadata: F.calculateMetadata,
        combinedProps: G,
        compositionDurationInFrames: F.durationInFrames ?? null,
        compositionFps: F.fps ?? null,
        compositionHeight: F.height ?? null,
        compositionWidth: F.width ?? null,
        compositionId: F.id
      });
    }
  }), [
    h,
    n,
    C,
    _,
    d
  ]);
  const E = c?.id === u?.id, k = ee(() => ({
    ...c?.defaultProps ?? {},
    ...v ?? {}
  }), [c?.defaultProps, v]), O = ee(() => ({
    ...k,
    ...d ?? {}
  }), [k, d]), P = c && qy(c), R = typeof window < "u" && window.remotion_ignoreFastRefreshUpdate && a <= window.remotion_ignoreFastRefreshUpdate;
  ce(() => {
    if (!R && P) {
      const F = _({
        calculateMetadata: c.calculateMetadata,
        combinedProps: O,
        compositionDurationInFrames: c.durationInFrames ?? null,
        compositionFps: c.fps ?? null,
        compositionHeight: c.height ?? null,
        compositionWidth: c.width ?? null,
        defaultProps: k,
        compositionId: c.id
      });
      return () => {
        F.abort();
      };
    }
  }, [
    P,
    k,
    _,
    O,
    c?.calculateMetadata,
    c?.durationInFrames,
    c?.fps,
    c?.height,
    c?.id,
    c?.width,
    R
  ]), ce(() => {
    R || window.dispatchEvent(new CustomEvent("remotion.propsUpdatedExternally"));
  }, [a]), ce(() => {
    if (u && !E) {
      const F = {
        ...u.defaultProps ?? {},
        ...b ?? {},
        ...d ?? {}
      }, $ = _({
        calculateMetadata: u.calculateMetadata,
        compositionDurationInFrames: u.durationInFrames ?? null,
        compositionFps: u.fps ?? null,
        compositionHeight: u.height ?? null,
        compositionId: u.id,
        compositionWidth: u.width ?? null,
        defaultProps: k,
        combinedProps: F
      });
      return () => {
        $.abort();
      };
    }
  }, [
    k,
    _,
    d,
    E,
    u,
    b
  ]);
  const V = ee(() => {
    const F = n.filter(($) => $.calculateMetadata === null);
    return {
      ...p,
      ...F.reduce(($, z) => ({
        ...$,
        [z.id]: {
          type: "success",
          result: { ...z, defaultProps: z.defaultProps ?? {} }
        }
      }), {})
    };
  }, [n, p]);
  return /* @__PURE__ */ y.jsx($l.Provider, {
    value: V,
    children: r
  });
}, Df = (r) => {
  const e = me($l), { props: t } = me(Ul), { compositions: n, canvasContent: i, currentCompositionMetadata: s } = me(Ti), a = i?.type === "composition" ? i.compositionId : null, c = r ?? a, u = n.find((d) => d.id === c), h = ee(() => u ? t[u.id] ?? {} : {}, [t, u]);
  return ee(() => u ? s ? {
    type: "success",
    result: {
      ...s,
      id: u.id,
      props: s.props,
      defaultProps: u.defaultProps ?? {},
      defaultCodec: s.defaultCodec
    }
  } : qy(u) ? e[u.id] ? e[u.id] : null : (Pf(u.durationInFrames, {
    allowFloats: !1,
    component: `in <Composition id="${u.id}">`
  }), Yy(u.fps, `in <Composition id="${u.id}">`), cl(u.width, "width", `in <Composition id="${u.id}">`), cl(u.height, "height", `in <Composition id="${u.id}">`), {
    type: "success",
    result: {
      width: u.width,
      height: u.height,
      fps: u.fps,
      id: u.id,
      durationInFrames: u.durationInFrames,
      defaultProps: u.defaultProps ?? {},
      props: {
        ...u.defaultProps ?? {},
        ...h ?? {},
        ...typeof window > "u" || Mt().isPlayer ? {} : $y() ?? {}
      },
      defaultCodec: null
    }
  }) : null, [u, e, s, h]);
}, Yl = () => {
  const { canvasContent: r, compositions: e, currentCompositionMetadata: t } = me(Ti), n = e.find((s) => r?.type === "composition" && s.id === r.compositionId), i = Df(n?.id ?? null);
  return ee(() => !i || i.type === "error" || i.type === "loading" || !n ? null : {
    ...i.result,
    defaultProps: n.defaultProps ?? {},
    id: n.id,
    ...t ?? {},
    component: n.component
  }, [t, i, n]);
}, ln = At({
  frame: {},
  playing: !1,
  playbackRate: 1,
  rootId: "",
  imperativePlaying: {
    current: !1
  },
  setPlaybackRate: () => {
    throw new Error("default");
  },
  audioAndVideoTags: { current: [] }
}), io = At({
  setFrame: () => {
    throw new Error("default");
  },
  setPlaying: () => {
    throw new Error("default");
  }
}), jf = () => "remotion.time-all", Zy = (r) => {
  localStorage.setItem(jf(), JSON.stringify(r));
}, Jy = () => {
  const r = localStorage.getItem(jf()) ?? "{}";
  return JSON.parse(r);
}, Qy = (r) => {
  const e = localStorage.getItem(jf()) ?? "{}", t = JSON.parse(e);
  return t[r] !== void 0 ? Number(t[r]) : typeof window > "u" ? 0 : window.remotion_initialFrame ?? 0;
}, us = () => {
  const r = Yl(), e = me(ln);
  if (!r)
    return typeof window > "u" ? 0 : window.remotion_initialFrame ?? 0;
  const t = e.frame[r.id] ?? (Mt().isPlayer ? 0 : Qy(r.id));
  return Math.min(r.durationInFrames - 1, t);
}, eb = () => {
  const { setFrame: r } = me(io);
  return r;
}, Rf = () => {
  const { playing: r, imperativePlaying: e } = me(ln), { setPlaying: t } = me(io);
  return ee(() => [r, t, e], [e, r, t]);
}, hs = At(!1), Dd = ({ children: r }) => /* @__PURE__ */ y.jsx(hs.Provider, {
  value: !0,
  children: r
}), Xl = () => {
  const r = me(Jt), e = r?.width ?? null, t = r?.height ?? null, n = r?.durationInFrames ?? null, i = Yl();
  return ee(() => {
    if (!i)
      return null;
    const {
      id: s,
      durationInFrames: a,
      fps: c,
      height: u,
      width: h,
      defaultProps: d,
      props: p,
      defaultCodec: g
    } = i;
    return {
      id: s,
      width: e ?? h,
      height: t ?? u,
      fps: c,
      durationInFrames: n ?? a,
      defaultProps: d,
      props: p,
      defaultCodec: g
    };
  }, [n, t, e, i]);
}, Ei = () => {
  const r = Xl(), e = me(hs), t = Af();
  if (!r)
    throw typeof window < "u" && window.remotion_isPlayer || t ? new Error([
      "No video config found. Likely reasons:",
      "- You are probably calling useVideoConfig() from outside the component passed to <Player />. See https://www.remotion.dev/docs/player/examples for how to set up the Player correctly.",
      "- You have multiple versions of Remotion installed which causes the React context to get lost."
    ].join("-")) : new Error("No video config found. You are probably calling useVideoConfig() from a component which has not been registered as a <Composition />. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions for more information.");
  if (!e)
    throw new Error("Called useVideoConfig() outside a Remotion composition.");
  return r;
}, ki = () => {
  if (!me(hs))
    throw Mt().isPlayer ? new Error("useCurrentFrame can only be called inside a component that was passed to <Player>. See: https://www.remotion.dev/docs/player/examples") : new Error("useCurrentFrame() can only be called inside a component that was registered as a composition. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions");
  const e = us(), t = me(Jt), n = t ? t.cumulatedFrom + t.relativeFrom : 0;
  return e - n;
}, b4 = ({
  frame: r,
  children: e,
  active: t = !0
}) => {
  const n = ki(), i = Ei();
  if (typeof r > "u")
    throw new Error("The <Freeze /> component requires a 'frame' prop, but none was passed.");
  if (typeof r != "number")
    throw new Error(`The 'frame' prop of <Freeze /> must be a number, but is of type ${typeof r}`);
  if (Number.isNaN(r))
    throw new Error("The 'frame' prop of <Freeze /> must be a real number, but it is NaN.");
  if (!Number.isFinite(r))
    throw new Error(`The 'frame' prop of <Freeze /> must be a finite number, but it is ${r}.`);
  const s = ee(() => {
    if (typeof t == "boolean")
      return t;
    if (typeof t == "function")
      return t(n);
  }, [t, n]), a = me(ln), u = me(Jt)?.relativeFrom ?? 0, h = ee(() => s ? {
    ...a,
    playing: !1,
    imperativePlaying: {
      current: !1
    },
    frame: {
      [i.id]: r + u
    }
  } : a, [s, a, i.id, r, u]);
  return /* @__PURE__ */ y.jsx(ln.Provider, {
    value: h,
    children: e
  });
}, w4 = ({
  from: r = 0,
  durationInFrames: e = 1 / 0,
  children: t,
  name: n,
  height: i,
  width: s,
  showInTimeline: a = !0,
  _remotionInternalLoopDisplay: c,
  _remotionInternalStack: u,
  _remotionInternalPremountDisplay: h,
  ...d
}, p) => {
  const { layout: g = "absolute-fill" } = d, [v] = ue(() => String(Math.random())), b = me(Jt), { rootId: x } = me(ln), _ = b ? b.cumulatedFrom + b.relativeFrom : 0, C = Mf();
  if (g !== "absolute-fill" && g !== "none")
    throw new TypeError(`The layout prop of <Sequence /> expects either "absolute-fill" or "none", but you passed: ${g}`);
  if (g === "none" && typeof d.style < "u")
    throw new TypeError('If layout="none", you may not pass a style.');
  if (typeof e != "number")
    throw new TypeError(`You passed to durationInFrames an argument of type ${typeof e}, but it must be a number.`);
  if (e <= 0)
    throw new TypeError(`durationInFrames must be positive, but got ${e}`);
  if (typeof r != "number")
    throw new TypeError(`You passed to the "from" props of your <Sequence> an argument of type ${typeof r}, but it must be a number.`);
  if (!Number.isFinite(r))
    throw new TypeError(`The "from" prop of a sequence must be finite, but got ${r}.`);
  const E = us(), k = Ei(), O = b ? Math.min(b.durationInFrames - r, e) : e, P = Math.max(0, Math.min(k.durationInFrames - r, O)), { registerSequence: R, unregisterSequence: V } = me(ro), { hidden: F } = me(wa), $ = ee(() => b?.premounting ?? !!d._remotionInternalIsPremounting, [d._remotionInternalIsPremounting, b?.premounting]), z = ee(() => ({
    cumulatedFrom: _,
    relativeFrom: r,
    durationInFrames: P,
    parentFrom: b?.relativeFrom ?? 0,
    id: v,
    height: i ?? b?.height ?? null,
    width: s ?? b?.width ?? null,
    premounting: $
  }), [
    _,
    r,
    P,
    b,
    v,
    i,
    s,
    $
  ]), G = ee(() => n ?? "", [n]);
  ce(() => {
    if (Mt().isStudio)
      return R({
        from: r,
        duration: P,
        id: v,
        displayName: G,
        parent: b?.id ?? null,
        type: "sequence",
        rootId: x,
        showInTimeline: a,
        nonce: C,
        loopDisplay: c,
        stack: u ?? null,
        premountDisplay: h ?? null
      }), () => {
        V(v);
      };
  }, [
    e,
    v,
    n,
    R,
    G,
    V,
    b?.id,
    P,
    x,
    r,
    a,
    C,
    c,
    u,
    h
  ]);
  const H = Math.ceil(_ + r + e - 1), Y = E < _ + r || E > H ? null : t, te = d.layout === "none" ? void 0 : d.style, ge = ee(() => ({
    flexDirection: void 0,
    ...s ? { width: s } : {},
    ...i ? { height: i } : {},
    ...te ?? {}
  }), [i, te, s]);
  if (p !== null && g === "none")
    throw new TypeError('It is not supported to pass both a `ref` and `layout="none"` to <Sequence />.');
  return F[v] ?? !1 ? null : /* @__PURE__ */ y.jsx(Jt.Provider, {
    value: z,
    children: Y === null ? null : d.layout === "none" ? Y : /* @__PURE__ */ y.jsx(Yo, {
      ref: p,
      style: ge,
      className: d.className,
      children: Y
    })
  });
}, x4 = Vt(w4), _4 = (r, e) => {
  const t = ki();
  if (r.layout === "none")
    throw new Error('`<Sequence>` with `premountFor` prop does not support layout="none"');
  const { style: n, from: i = 0, premountFor: s = 0, ...a } = r, c = t < i && t >= i - s, u = ee(() => ({
    ...n,
    opacity: c ? 0 : 1,
    pointerEvents: c ? "none" : n?.pointerEvents ?? void 0
  }), [c, n]);
  return /* @__PURE__ */ y.jsx(b4, {
    frame: i,
    active: c,
    children: /* @__PURE__ */ y.jsx(xn, {
      ref: e,
      from: i,
      style: u,
      _remotionInternalPremountDisplay: s,
      _remotionInternalIsPremounting: c,
      ...a
    })
  });
}, S4 = Vt(_4), C4 = (r, e) => r.layout !== "none" && r.premountFor && !Mt().isRendering ? /* @__PURE__ */ y.jsx(S4, {
  ...r,
  ref: e
}) : /* @__PURE__ */ y.jsx(x4, {
  ...r,
  ref: e
}), xn = Vt(C4), T4 = (r) => {
  if (typeof r != "string")
    throw new TypeError(`The "filename" must be a string, but you passed a value of type ${typeof r}`);
  if (r.trim() === "")
    throw new Error("The `filename` must not be empty");
  if (!r.match(/^([0-9a-zA-Z-!_.*'()/:&$@=;+,?]+)/g))
    throw new Error('The `filename` must match "/^([0-9a-zA-Z-!_.*\'()/:&$@=;+,?]+)/g". Use forward slashes only, even on Windows.');
}, E4 = (r) => {
  if (typeof r != "string" && !(r instanceof Uint8Array))
    throw new TypeError(`The "content" must be a string or Uint8Array, but you passed a value of type ${typeof r}`);
  if (typeof r == "string" && r.trim() === "")
    throw new Error("The `content` must not be empty");
}, tb = (r) => {
  r.type === "artifact" && (T4(r.filename), E4(r.content));
}, ds = At({
  registerRenderAsset: () => {
  },
  unregisterRenderAsset: () => {
  },
  renderAssets: []
}), k4 = ({ children: r }) => {
  const [e, t] = ue([]), n = se((a) => {
    tb(a), t((c) => [...c, a]);
  }, []), i = se((a) => {
    t((c) => c.filter((u) => u.id !== a));
  }, []);
  Kn(() => {
    typeof window < "u" && (window.remotion_collectAssets = () => (t([]), e));
  }, [e]);
  const s = ee(() => ({
    registerRenderAsset: n,
    unregisterRenderAsset: i,
    renderAssets: e
  }), [e, n, i]);
  return /* @__PURE__ */ y.jsx(ds.Provider, {
    value: s,
    children: r
  });
}, Jn = (r) => typeof window > "u" ? r : new URL(r, window.origin).href, rb = ({
  endAt: r,
  mediaDuration: e,
  playbackRate: t,
  startFrom: n
}) => {
  let i = e;
  typeof r < "u" && (i = r), typeof n < "u" && (i -= n);
  const s = i / t;
  return Math.floor(s);
};
function na(r) {
  let e;
  throw O4(r) ? (e = r, e.stack || (e.stack = new Error(e.message).stack)) : typeof r == "string" ? e = Error(r) : e = Error("Rendering was cancelled"), window.remotion_cancelledError = e.stack, e;
}
var O4 = (r) => r instanceof Error ? !0 : !(r === null || typeof r != "object" || !("stack" in r) || typeof r.stack != "string" || !("message" in r) || typeof r.message != "string"), nb = At(null), I4 = () => Ce.useContext(nb), Gl = ({ durationInFrames: r, times: e = 1 / 0, children: t, name: n, ...i }) => {
  const s = ki(), { durationInFrames: a } = Ei();
  if (Pf(r, {
    component: "of the <Loop /> component",
    allowFloats: !0
  }), typeof e != "number")
    throw new TypeError(`You passed to "times" an argument of type ${typeof e}, but it must be a number.`);
  if (e !== 1 / 0 && e % 1 !== 0)
    throw new TypeError(`The "times" prop of a loop must be an integer, but got ${e}.`);
  if (e < 0)
    throw new TypeError(`The "times" prop of a loop must be at least 0, but got ${e}`);
  const c = Math.ceil(a / r), u = Math.min(c, e), h = i.layout === "none" ? void 0 : i.style, d = r * (u - 1), g = Math.floor(s / r) * r, v = Math.min(g, d), b = ee(() => ({
    numberOfTimes: u,
    startOffset: -v,
    durationInFrames: r
  }), [u, r, v]), x = ee(() => ({
    iteration: Math.floor(s / r),
    durationInFrames: r
  }), [s, r]);
  return /* @__PURE__ */ y.jsx(nb.Provider, {
    value: x,
    children: /* @__PURE__ */ y.jsx(xn, {
      durationInFrames: r,
      from: v,
      name: n ?? "<Loop>",
      _remotionInternalLoopDisplay: b,
      layout: i.layout,
      style: h,
      children: t
    })
  });
};
Gl.useLoop = I4;
var ql = At({}), Bv = {}, Nh = [], ib = ({ children: r }) => {
  const [e, t] = ue(() => Bv);
  return ce(() => {
    const n = () => {
      t(Bv);
    };
    return Nh.push(n), () => {
      Nh = Nh.filter((i) => i !== n);
    };
  }, []), /* @__PURE__ */ y.jsx(ql.Provider, {
    value: e,
    children: r
  });
}, so = (r) => me(ql)[r] ?? r, Ff = (r, e) => {
  if (typeof r.volume != "number" && typeof r.volume != "function" && typeof r.volume < "u")
    throw new TypeError(`You have passed a volume of type ${typeof r.volume} to your <${e} /> component. Volume must be a number or a function with the signature '(frame: number) => number' undefined.`);
  if (typeof r.volume == "number" && r.volume < 0)
    throw new TypeError(`You have passed a volume below 0 to your <${e} /> component. Volume must be between 0 and 1`);
  if (typeof r.playbackRate != "number" && typeof r.playbackRate < "u")
    throw new TypeError(`You have passed a playbackRate of type ${typeof r.playbackRate} to your <${e} /> component. Playback rate must a real number or undefined.`);
  if (typeof r.playbackRate == "number" && (isNaN(r.playbackRate) || !Number.isFinite(r.playbackRate) || r.playbackRate <= 0))
    throw new TypeError(`You have passed a playbackRate of ${r.playbackRate} to your <${e} /> component. Playback rate must be a real number above 0.`);
}, Lf = (r, e) => {
  if (typeof r < "u") {
    if (typeof r != "number")
      throw new TypeError(`type of startFrom prop must be a number, instead got type ${typeof r}.`);
    if (isNaN(r) || r === 1 / 0)
      throw new TypeError("startFrom prop can not be NaN or Infinity.");
    if (r < 0)
      throw new TypeError(`startFrom must be greater than equal to 0 instead got ${r}.`);
  }
  if (typeof e < "u") {
    if (typeof e != "number")
      throw new TypeError(`type of endAt prop must be a number, instead got type ${typeof e}.`);
    if (isNaN(e))
      throw new TypeError("endAt prop can not be NaN.");
    if (e <= 0)
      throw new TypeError(`endAt must be a positive number, instead got ${e}.`);
  }
  if (e < r)
    throw new TypeError("endAt prop must be greater than startFrom prop.");
}, A4 = (r, e) => {
  switch (e.type) {
    case "got-duration": {
      const t = Jn(e.src);
      return r[t] === e.durationInSeconds ? r : {
        ...r,
        [t]: e.durationInSeconds
      };
    }
    default:
      return r;
  }
}, Nf = At({
  durations: {},
  setDurations: () => {
    throw new Error("context missing");
  }
}), sb = ({ children: r }) => {
  const [e, t] = kk(A4, {}), n = ee(() => ({
    durations: e,
    setDurations: t
  }), [e]);
  return /* @__PURE__ */ y.jsx(Nf.Provider, {
    value: n,
    children: r
  });
};
function Vv(r) {
  let e = r + 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function M4(r) {
  let e = 0, t = 0, n = 0;
  for (e = 0; e < r.length; e++)
    t = r.charCodeAt(e), n = (n << 5) - n + t, n |= 0;
  return n;
}
var fs = (r, e) => {
  if (r === null)
    return Math.random();
  if (typeof r == "string")
    return Vv(M4(r));
  if (typeof r == "number")
    return Vv(r * 1e10);
  throw new Error("random() argument must be a number or a string");
}, oo = () => {
  const r = me(Jt);
  return Math.min(0, r?.relativeFrom ?? 0);
}, xa = (r) => {
  const e = Gl.useLoop(), t = ki(), n = oo();
  return r === "repeat" || e === null ? t + n : t + n + e.durationInFrames * e.iteration;
}, P4 = (r) => {
  if (/data:|blob:/.test(r.substring(0, 5)))
    return "Data URL";
  const e = r.split("/").map((t) => t.split("\\")).flat(1);
  return e[e.length - 1];
}, ll = (r, e, t) => {
  const { current: n } = r;
  if (!n)
    return;
  const i = n.play();
  i.catch && i.catch((s) => {
    if (n && !s.message.includes("request was interrupted by a call to pause") && !s.message.includes("The operation was aborted.") && !s.message.includes("The fetching process for the media resource was aborted by the user agent") && !s.message.includes("request was interrupted by a new load request") && !s.message.includes("because the media was removed from the document") && !(s.message.includes("user didn't interact with the document") && n.muted) && (console.log(`Could not play ${e} due to following error: `, s), !n.muted)) {
      if (t) {
        t();
        return;
      }
      console.log("The video will be muted and we'll retry playing it."), e === "video" && Mt().isPlayer && console.log("Use onAutoPlayError() to handle this error yourself."), n.muted = !0, n.play();
    }
  });
}, ao = ({
  frame: r,
  volume: e,
  mediaVolume: t = 1,
  allowAmplificationDuringRender: n
}) => {
  const i = n ? 1 / 0 : 1;
  if (typeof e == "number")
    return Math.min(i, e * t);
  if (typeof e > "u")
    return Number(t);
  const s = e(r) * t;
  if (typeof s != "number")
    throw new TypeError(`You passed in a a function to the volume prop but it did not return a number but a value of type ${typeof s} for frame ${r}`);
  if (Number.isNaN(s))
    throw new TypeError(`You passed in a function to the volume prop but it returned NaN for frame ${r}.`);
  if (!Number.isFinite(s))
    throw new TypeError(`You passed in a function to the volume prop but it returned a non-finite number for frame ${r}.`);
  return Math.max(0, Math.min(i, s));
}, zv = {}, D4 = (r) => {
  zv[r] || (console.warn(r), zv[r] = !0);
}, ob = ({
  volume: r,
  mediaVolume: e,
  mediaRef: t,
  src: n,
  mediaType: i,
  playbackRate: s,
  displayName: a,
  id: c,
  stack: u,
  showInTimeline: h,
  premountDisplay: d,
  onAutoPlayError: p
}) => {
  const g = Ei(), { rootId: v, audioAndVideoTags: b } = me(ln), x = me(Jt), _ = x ? x.relativeFrom + x.cumulatedFrom : 0, [C] = Rf(), E = oo(), { registerSequence: k, unregisterSequence: O } = me(ro), [P] = ue(() => r), R = Mf(), V = x ? Math.min(x.durationInFrames, g.durationInFrames) : g.durationInFrames, F = typeof r == "function", $ = ee(() => typeof r == "number" ? r : new Array(Math.floor(Math.max(0, V + E))).fill(!0).map((z, G) => ao({
    frame: G + E,
    volume: r,
    mediaVolume: e,
    allowAmplificationDuringRender: !1
  })).join(","), [V, E, r, e]);
  ce(() => {
    typeof r == "number" && r !== P && D4(`Remotion: The ${i} with src ${n} has changed it's volume. Prefer the callback syntax for setting volume to get better timeline display: https://www.remotion.dev/docs/using-audio/#controlling-volume`);
  }, [P, i, n, r]), ce(() => {
    if (t.current) {
      if (!n)
        throw new Error("No src passed");
      if (!(!Mt().isStudio && window.process?.env?.NODE_ENV !== "test") && h)
        return k({
          type: i,
          src: n,
          id: c,
          duration: V,
          from: 0,
          parent: x?.id ?? null,
          displayName: a ?? P4(n),
          rootId: v,
          volume: $,
          showInTimeline: !0,
          nonce: R,
          startMediaFrom: 0 - E,
          doesVolumeChange: F,
          loopDisplay: void 0,
          playbackRate: s,
          stack: u,
          premountDisplay: d
        }), () => {
          O(c);
        };
    }
  }, [
    _,
    V,
    c,
    x,
    n,
    k,
    v,
    O,
    g,
    $,
    F,
    R,
    t,
    i,
    E,
    s,
    a,
    u,
    h,
    d
  ]), ce(() => {
    const z = {
      id: c,
      play: () => {
        if (C)
          return ll(t, i, p);
      }
    };
    return b.current.push(z), () => {
      b.current = b.current.filter((G) => G.id !== c);
    };
  }, [b, c, t, i, p, C]);
}, j4 = () => {
  const [r, e] = ue([]), [t, n] = ue([]), [i, s] = ue([]), a = be(!1), c = se((d) => (e((p) => [...p, d]), {
    unblock: () => {
      e((p) => {
        const g = p.filter((v) => v !== d);
        return g.length === p.length ? p : g;
      });
    }
  }), []), u = se((d) => (n((p) => [...p, d]), {
    remove: () => {
      n((p) => p.filter((g) => g !== d));
    }
  }), []), h = se((d) => (s((p) => [...p, d]), {
    remove: () => {
      s((p) => p.filter((g) => g !== d));
    }
  }), []);
  return ce(() => {
    r.length > 0 && t.forEach((d) => d());
  }, [r]), ce(() => {
    r.length === 0 && i.forEach((d) => d());
  }, [r]), ee(() => ({ addBlock: c, listenForBuffering: u, listenForResume: h, buffering: a }), [c, a, u, h]);
}, co = Ce.createContext(null), ab = ({ children: r }) => {
  const e = j4();
  return /* @__PURE__ */ y.jsx(co.Provider, {
    value: e,
    children: r
  });
}, R4 = (r) => {
  const [e, t] = ue(r.buffering.current);
  return ce(() => {
    const n = () => {
      t(!0);
    }, i = () => {
      t(!1);
    };
    return r.listenForBuffering(n), r.listenForResume(i), () => {
      r.listenForBuffering(() => {
      }), r.listenForResume(() => {
      });
    };
  }, [r]), e;
}, Bf = () => {
  const r = me(co), e = r ? r.addBlock : null;
  return ee(() => ({
    delayPlayback: () => {
      if (!e)
        throw new Error("Tried to enable the buffering state, but a Remotion context was not found. This API can only be called in a component that was passed to the Remotion Player or a <Composition>. Or you might have experienced a version mismatch - run `npx remotion versions` and ensure all packages have the same version. This error is thrown by the buffer state https://remotion.dev/docs/player/buffer-state");
      const { unblock: t } = e({
        id: String(Math.random())
      });
      return { unblock: t };
    }
  }), [e]);
}, F4 = ({
  mediaRef: r,
  mediaType: e,
  onVariableFpsVideoDetected: t,
  pauseWhenBuffering: n
}) => {
  const i = be(!1), { delayPlayback: s } = Bf(), a = se((c) => {
    if (e !== "video" || !n)
      return;
    const u = r.current;
    if (!u || !u.requestVideoFrameCallback)
      return;
    i.current = !0;
    const h = s(), d = () => {
      h.unblock(), u.removeEventListener("ended", d, {
        once: !0
      }), u.removeEventListener("pause", d, {
        once: !0
      }), i.current = !1;
    }, p = () => {
      d();
    };
    u.requestVideoFrameCallback((g, v) => {
      Math.abs(v.mediaTime - c) > 0.5 && t(), d();
    }), u.addEventListener("ended", p, { once: !0 }), u.addEventListener("pause", p, { once: !0 }), u.addEventListener("canplay", p, {
      once: !0
    });
  }, [
    s,
    r,
    e,
    t,
    n
  ]);
  return ee(() => ({
    isBuffering: () => i.current,
    bufferUntilFirstFrame: a
  }), [a]);
}, L4 = ({
  element: r,
  shouldBuffer: e,
  isPremounting: t
}) => {
  const n = Bf(), [i, s] = ue(!1);
  return ce(() => {
    let a = [];
    const { current: c } = r;
    if (!c || !e || t)
      return;
    const u = () => {
      a.forEach((p) => p()), a = [], s(!1);
    }, h = () => {
      s(!0);
      const { unblock: p } = n.delayPlayback(), g = () => {
        u(), d();
      }, v = () => {
        u(), d();
      };
      c.addEventListener("canplay", g, {
        once: !0
      }), a.push(() => {
        c.removeEventListener("canplay", g);
      }), c.addEventListener("error", v, {
        once: !0
      }), a.push(() => {
        c.removeEventListener("error", v);
      }), a.push(() => {
        p();
      });
    }, d = () => {
      c.readyState < c.HAVE_FUTURE_DATA ? (h(), navigator.userAgent.includes("Firefox/") || c.load()) : (c.addEventListener("waiting", h), a.push(() => {
        c.removeEventListener("waiting", h);
      }));
    };
    return d(), () => {
      u();
    };
  }, [n, r, t, e]), i;
}, N4 = ({
  mediaRef: r,
  mediaType: e,
  lastSeek: t,
  onVariableFpsVideoDetected: n
}) => {
  const i = be(null);
  return ce(() => {
    const { current: s } = r;
    if (s)
      i.current = s.currentTime;
    else {
      i.current = null;
      return;
    }
    if (e !== "video") {
      i.current = null;
      return;
    }
    const a = s;
    if (!a.requestVideoFrameCallback)
      return;
    let c = () => {
    };
    const u = () => {
      if (!a)
        return;
      const h = a.requestVideoFrameCallback((d, p) => {
        if (i.current !== null) {
          const g = Math.abs(i.current - p.mediaTime), v = Math.abs(t.current === null ? 1 / 0 : p.mediaTime - t.current);
          g > 0.5 && v > 0.5 && p.mediaTime > i.current && n();
        }
        i.current = p.mediaTime, u();
      });
      c = () => {
        a.cancelVideoFrameCallback(h), c = () => {
        };
      };
    };
    return u(), () => {
      c();
    };
  }, [t, r, e, n]), i;
};
function B4(r, e, t, n) {
  const { extrapolateLeft: i, extrapolateRight: s, easing: a } = n;
  let c = r;
  const [u, h] = e, [d, p] = t;
  if (c < u) {
    if (i === "identity")
      return c;
    if (i === "clamp")
      c = u;
    else if (i === "wrap") {
      const g = h - u;
      c = ((c - u) % g + g) % g + u;
    }
  }
  if (c > h) {
    if (s === "identity")
      return c;
    if (s === "clamp")
      c = h;
    else if (s === "wrap") {
      const g = h - u;
      c = ((c - u) % g + g) % g + u;
    }
  }
  return d === p ? d : (c = (c - u) / (h - u), c = a(c), c = c * (p - d) + d, c);
}
function V4(r, e) {
  let t;
  for (t = 1; t < e.length - 1 && !(e[t] >= r); ++t)
    ;
  return t - 1;
}
function z4(r) {
  for (let e = 1; e < r.length; ++e)
    if (!(r[e] > r[e - 1]))
      throw new Error(`inputRange must be strictly monotonically increasing but got [${r.join(",")}]`);
}
function Wv(r, e) {
  if (e.length < 2)
    throw new Error(r + " must have at least 2 elements");
  for (const t of e) {
    if (typeof t != "number")
      throw new Error(`${r} must contain only numbers`);
    if (!Number.isFinite(t))
      throw new Error(`${r} must contain only finite numbers, but got [${e.join(",")}]`);
  }
}
function cb(r, e, t, n) {
  if (typeof r > "u")
    throw new Error("input can not be undefined");
  if (typeof e > "u")
    throw new Error("inputRange can not be undefined");
  if (typeof t > "u")
    throw new Error("outputRange can not be undefined");
  if (e.length !== t.length)
    throw new Error("inputRange (" + e.length + ") and outputRange (" + t.length + ") must have the same length");
  Wv("inputRange", e), Wv("outputRange", t), z4(e);
  const i = n?.easing ?? ((u) => u);
  let s = "extend";
  n?.extrapolateLeft !== void 0 && (s = n.extrapolateLeft);
  let a = "extend";
  if (n?.extrapolateRight !== void 0 && (a = n.extrapolateRight), typeof r != "number")
    throw new TypeError("Cannot interpolate an input which is not a number");
  const c = V4(r, e);
  return B4(r, [e[c], e[c + 1]], [t[c], t[c + 1]], {
    easing: i,
    extrapolateLeft: s,
    extrapolateRight: a
  });
}
var lb = ({
  frame: r,
  playbackRate: e,
  startFrom: t
}) => cb(r, [-1, t, t + 1], [-1, t, t + e]), ub = ({
  fps: r,
  frame: e,
  playbackRate: t,
  startFrom: n
}) => {
  const i = lb({
    frame: e,
    playbackRate: t,
    startFrom: n
  }), s = 1e3 / r;
  return i * s / 1e3;
}, hb = (r, e) => Math.round(r / e * 100) / 100, Kl = () => {
  if (typeof window > "u")
    return !1;
  const r = /iP(ad|od|hone)/i.test(window.navigator.userAgent), e = /AppleWebKit/.test(window.navigator.userAgent);
  return r && e;
}, W4 = (r) => Kl() && r.startsWith("blob:"), jd = ({
  actualFrom: r,
  fps: e
}) => hb(Math.max(0, -r), e), Rd = ({
  duration: r,
  fps: e
}) => hb(r, e), H4 = ({
  actualSrc: r,
  actualFrom: e,
  duration: t,
  fps: n
}) => {
  if (W4(r) || r.startsWith("data:") || !!new URL(r, (typeof window > "u" ? null : window.location.href) ?? "http://localhost:3000").hash || !Number.isFinite(e))
    return r;
  const s = `${r}#t=${jd({ actualFrom: e, fps: n })}`;
  return Number.isFinite(t) ? `${s},${Rd({ duration: t, fps: n })}` : s;
}, U4 = ({
  prevStartFrom: r,
  newStartFrom: e,
  prevDuration: t,
  newDuration: n,
  fps: i
}) => {
  const s = jd({ actualFrom: r, fps: i }), a = jd({ actualFrom: e, fps: i }), c = Rd({ duration: t, fps: i }), u = Rd({ duration: n, fps: i });
  return !(a < s || u > c);
}, $4 = ({
  actualSrc: r,
  actualFrom: e,
  duration: t,
  fps: n
}) => {
  const i = be(e), s = be(t), a = be(r);
  return (!U4({
    prevStartFrom: i.current,
    newStartFrom: e,
    prevDuration: s.current,
    newDuration: t,
    fps: n
  }) || r !== a.current) && (i.current = e, s.current = t, a.current = r), H4({
    actualSrc: a.current,
    actualFrom: i.current,
    duration: s.current,
    fps: n
  });
}, Hv = {}, Y4 = (r, e) => {
  if (r === null || r.seekable.length === 0 || r.seekable.length > 1 || Hv[r.src])
    return;
  const t = { start: r.seekable.start(0), end: r.seekable.end(0) };
  if (t.start === 0 && t.end === 0) {
    const n = [
      `The media ${r.src} cannot be seeked. This could be one of few reasons:`,
      "1) The media resource was replaced while the video is playing but it was not loaded yet.",
      "2) The media does not support seeking.",
      "3) The media was loaded with security headers prventing it from being included.",
      "Please see https://remotion.dev/docs/non-seekable-media for assistance."
    ].join(`
`);
    if (e === "console-error")
      console.error(n);
    else if (e === "console-warning")
      console.warn(`The media ${r.src} does not support seeking. The video will render fine, but may not play correctly in the Remotion Studio and in the <Player>. See https://remotion.dev/docs/non-seekable-media for an explanation.`);
    else
      throw new Error(n);
    Hv[r.src] = !0;
  }
}, Vf = 0.45, Bh = (r, e) => {
  if (!r.current)
    return;
  const t = Kl() ? Number(e.toFixed(1)) : e;
  r.current.currentTime = t;
}, db = ({
  mediaRef: r,
  src: e,
  mediaType: t,
  playbackRate: n,
  onlyWarnForMediaSeekingError: i,
  acceptableTimeshift: s,
  pauseWhenBuffering: a,
  isPremounting: c,
  debugSeeking: u,
  onAutoPlayError: h
}) => {
  const { playbackRate: d } = me(ln), p = ki(), g = us(), [v] = Rf(), b = me(co), { fps: x } = Ei(), _ = oo(), C = be(null), E = be(null);
  if (!b)
    throw new Error("useMediaPlayback must be used inside a <BufferingContext>");
  const k = be({}), O = se(() => {
    e && (u && console.log(`Detected ${e} as a variable FPS video. Disabling buffering while seeking.`), k.current[e] = !0);
  }, [u, e]), P = N4({
    mediaRef: r,
    mediaType: t,
    lastSeek: E,
    onVariableFpsVideoDetected: O
  }), R = ub({
    frame: p,
    playbackRate: n,
    startFrom: -_,
    fps: x
  }), V = L4({
    element: r,
    shouldBuffer: a,
    isPremounting: c
  }), { bufferUntilFirstFrame: F, isBuffering: $ } = F4({
    mediaRef: r,
    mediaType: t,
    onVariableFpsVideoDetected: O,
    pauseWhenBuffering: a
  }), z = n * d, G = r.current?.duration ? Math.min(r.current.duration, s ?? Vf) : s, H = R4(b);
  ce(() => {
    if (!v) {
      r.current?.pause();
      return;
    }
    const Y = V || $();
    H && !Y && r.current?.pause();
  }, [$, V, H, r, v]), ce(() => {
    const Y = t === "audio" ? "<Audio>" : "<Video>";
    if (!r.current)
      throw new Error(`No ${t} ref found`);
    if (!e)
      throw new Error(`No 'src' attribute was passed to the ${Y} element.`);
    const te = Math.max(0, z);
    r.current.playbackRate !== te && (r.current.playbackRate = te);
    const { duration: ge } = r.current, Z = !Number.isNaN(ge) && Number.isFinite(ge) ? Math.min(ge, R) : R, de = r.current.currentTime, oe = P.current ?? null, ie = k.current[e], pe = Math.abs(Z - de), re = oe ? Math.abs(Z - oe) : null, Ve = re && !ie ? re : pe;
    if (u && console.log({
      mediaTagTime: de,
      rvcTime: oe,
      shouldBeTime: Z,
      state: r.current.readyState,
      playing: !r.current.paused,
      isVariableFpsVideo: ie
    }), Ve > G && C.current !== Z) {
      u && console.log("Seeking", {
        shouldBeTime: Z,
        isTime: de,
        rvcTime: oe,
        timeShift: Ve,
        isVariableFpsVideo: ie
      }), Bh(r, Z), E.current = Z, C.current = Z, v && !ie && (z > 0 && F(Z), r.current.paused && ll(r, t, h)), i || Y4(r.current, i ? "console-warning" : "console-error");
      return;
    }
    const Ze = v ? 0.15 : 1e-5, We = Math.abs(r.current.currentTime - Z) > Ze, Ee = V || $(), Ie = b.buffering.current && !Ee;
    if (!v || Ie) {
      We && (Bh(r, Z), E.current = Z);
      return;
    }
    (r.current.paused && !r.current.ended || g === 0) && (We && (Bh(r, Z), E.current = Z), ll(r, t, h), ie || z > 0 && F(Z));
  }, [
    g,
    G,
    F,
    b.buffering,
    P,
    u,
    R,
    $,
    V,
    r,
    t,
    i,
    z,
    v,
    e,
    h
  ]);
}, fb = (r) => {
  const [e, t] = ue(1);
  return ce(() => {
    const n = r.current;
    if (!n)
      return;
    const i = () => {
      t(n.volume);
    };
    return n.addEventListener("volumechange", i), () => n.removeEventListener("volumechange", i);
  }, [r]), ce(() => {
    const n = r.current;
    n && n.volume !== e && t(n.volume);
  }, [e, r]), e;
}, X4 = 1e-5, zf = (r, e) => Math.abs(r - e) < X4, pb = ({
  volumePropFrame: r,
  actualVolume: e,
  volume: t,
  mediaVolume: n,
  mediaRef: i
}) => {
  ce(() => {
    const s = ao({
      frame: r,
      volume: t,
      mediaVolume: n,
      allowAmplificationDuringRender: !1
    });
    !zf(s, e) && i.current && (i.current.volume = s);
  }, [e, r, i, t, n]);
}, Wf = At({
  mediaMuted: !1,
  mediaVolume: 1
}), Hf = At({
  setMediaMuted: () => {
    throw new Error("default");
  },
  setMediaVolume: () => {
    throw new Error("default");
  }
}), Uf = () => {
  const { mediaVolume: r } = me(Wf), { setMediaVolume: e } = me(Hf);
  return ee(() => [r, e], [r, e]);
}, $f = () => {
  const { mediaMuted: r } = me(Wf), { setMediaMuted: e } = me(Hf);
  return ee(() => [r, e], [r, e]);
}, Uv = "data:audio/mp3;base64,/+MYxAAJcAV8AAgAABn//////+/gQ5BAMA+D4Pg+BAQBAEAwD4Pg+D4EBAEAQDAPg++hYBH///hUFQVBUFREDQNHmf///////+MYxBUGkAGIMAAAAP/29Xt6lUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxDUAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV", G4 = (r, e) => {
  const t = Object.keys(r).sort(), n = Object.keys(e).sort();
  if (t.length !== n.length)
    return !1;
  for (let i = 0; i < t.length; i++)
    if (t[i] !== n[i] || r[t[i]] !== e[n[i]])
      return !1;
  return !0;
}, q4 = (r, e, t) => r === "src" && !t.startsWith("data:") && !e.startsWith("data:") ? new URL(t, window.origin).toString() !== new URL(e, window.origin).toString() : t !== e, Zl = At(null), gb = ({ children: r, numberOfAudioTags: e, component: t }) => {
  const n = be([]), [i] = ue(e);
  if (e !== i)
    throw new Error("The number of shared audio tags has changed dynamically. Once you have set this property, you cannot change it afterwards.");
  const s = ee(() => new Array(e).fill(!0).map(() => ({ id: Math.random(), ref: u1() })), [e]), a = be(new Array(e).fill(!1)), c = se(() => {
    s.forEach(({ ref: b, id: x }) => {
      const _ = n.current?.find((E) => E.id === x), { current: C } = b;
      if (C) {
        if (_ === void 0) {
          C.src = Uv;
          return;
        }
        if (!_)
          throw new TypeError("Expected audio data to be there");
        Object.keys(_.props).forEach((E) => {
          q4(E, _.props[E], C[E]) && (C[E] = _.props[E]);
        });
      }
    });
  }, [s]), u = se((b, x) => {
    const _ = n.current?.find((R) => R.audioId === x);
    if (_)
      return _;
    const C = a.current.findIndex((R) => R === !1);
    if (C === -1)
      throw new Error(`Tried to simultaneously mount ${e + 1} <Audio /> tags at the same time. With the current settings, the maximum amount of <Audio /> tags is limited to ${e} at the same time. Remotion pre-mounts silent audio tags to help avoid browser autoplay restrictions. See https://remotion.dev/docs/player/autoplay#use-the-numberofsharedaudiotags-property for more information on how to increase this limit.`);
    const { id: E, ref: k } = s[C], O = [...a.current];
    O[C] = E, a.current = O;
    const P = {
      props: b,
      id: E,
      el: k,
      audioId: x
    };
    return n.current?.push(P), c(), P;
  }, [e, s, c]), h = se((b) => {
    const x = [...a.current], _ = s.findIndex((C) => C.id === b);
    if (_ === -1)
      throw new TypeError("Error occured in ");
    x[_] = !1, a.current = x, n.current = n.current?.filter((C) => C.id !== b), c();
  }, [s, c]), d = se(({
    aud: b,
    audioId: x,
    id: _
  }) => {
    let C = !1;
    n.current = n.current?.map((E) => E.id === _ ? G4(b, E.props) ? E : (C = !0, {
      ...E,
      props: b,
      audioId: x
    }) : E), C && c();
  }, [c]), p = se(() => {
    s.forEach((b) => {
      ll(b.ref, "audio", null);
    });
  }, [s]), g = ee(() => ({
    registerAudio: u,
    unregisterAudio: h,
    updateAudio: d,
    playAllAudios: p,
    numberOfAudioTags: e
  }), [
    e,
    p,
    u,
    h,
    d
  ]), v = se(() => {
    a.current = new Array(e).fill(!1), n.current = [], c();
  }, [e, c]);
  return ce(() => () => {
    v();
  }, [t, v]), /* @__PURE__ */ y.jsxs(Zl.Provider, {
    value: g,
    children: [
      s.map(({ id: b, ref: x }) => /* @__PURE__ */ y.jsx("audio", {
        ref: x,
        preload: "metadata",
        src: Uv
      }, b)),
      r
    ]
  });
}, K4 = (r, e) => {
  const t = me(Zl), [n] = ue(() => t && t.numberOfAudioTags > 0 ? t.registerAudio(r, e) : {
    el: Ce.createRef(),
    id: Math.random(),
    props: r,
    audioId: e
  }), i = Ce.useInsertionEffect ?? Ce.useLayoutEffect;
  return typeof document < "u" && (i(() => {
    t && t.numberOfAudioTags > 0 && t.updateAudio({ id: n.id, aud: r, audioId: e });
  }, [r, t, n.id, e]), i(() => () => {
    t && t.numberOfAudioTags > 0 && t.unregisterAudio(n.id);
  }, [t, n.id])), n;
}, Z4 = (r, e) => {
  const [t] = ue(r.shouldPreMountAudioTags);
  if (r.shouldPreMountAudioTags !== t)
    throw new Error("Cannot change the behavior for pre-mounting audio tags dynamically.");
  const {
    volume: n,
    muted: i,
    playbackRate: s,
    shouldPreMountAudioTags: a,
    src: c,
    onDuration: u,
    acceptableTimeShiftInSeconds: h,
    _remotionInternalNeedsDurationCalculation: d,
    _remotionInternalNativeLoopPassed: p,
    _remotionInternalStack: g,
    _remotionDebugSeeking: v,
    allowAmplificationDuringRender: b,
    name: x,
    pauseWhenBuffering: _,
    showInTimeline: C,
    loopVolumeCurveBehavior: E,
    stack: k,
    ...O
  } = r, [P] = Uf(), [R] = $f(), V = xa(E ?? "repeat"), { hidden: F } = me(wa);
  if (!c)
    throw new TypeError("No 'src' was passed to <Audio>.");
  const $ = so(c), z = me(Jt), [G] = ue(() => String(Math.random())), H = F[G] ?? !1, Y = ao({
    frame: V,
    volume: n,
    mediaVolume: P,
    allowAmplificationDuringRender: !1
  }), te = ee(() => ({
    muted: i || R || H || Y <= 0,
    src: $,
    loop: p,
    ...O
  }), [
    p,
    H,
    R,
    i,
    O,
    $,
    Y
  ]), ge = ee(() => `audio-${fs(c ?? "")}-${z?.relativeFrom}-${z?.cumulatedFrom}-${z?.durationInFrames}-muted:${r.muted}-loop:${r.loop}`, [
    c,
    z?.relativeFrom,
    z?.cumulatedFrom,
    z?.durationInFrames,
    r.muted,
    r.loop
  ]), Z = K4(te, ge).el, de = fb(Z);
  pb({
    volumePropFrame: V,
    actualVolume: de,
    volume: n,
    mediaVolume: P,
    mediaRef: Z
  }), ob({
    volume: n,
    mediaVolume: P,
    mediaRef: Z,
    src: c,
    mediaType: "audio",
    playbackRate: s ?? 1,
    displayName: x ?? null,
    id: G,
    stack: g,
    showInTimeline: C,
    premountDisplay: null,
    onAutoPlayError: null
  }), db({
    mediaRef: Z,
    src: c,
    mediaType: "audio",
    playbackRate: s ?? 1,
    onlyWarnForMediaSeekingError: !1,
    acceptableTimeshift: h ?? Vf,
    isPremounting: !!z?.premounting,
    pauseWhenBuffering: _,
    debugSeeking: v,
    onAutoPlayError: null
  }), Zr(e, () => Z.current, [Z]);
  const oe = be();
  return oe.current = u, ce(() => {
    const { current: ie } = Z;
    if (!ie)
      return;
    if (ie.duration) {
      oe.current?.(ie.src, ie.duration);
      return;
    }
    const pe = () => {
      oe.current?.(ie.src, ie.duration);
    };
    return ie.addEventListener("loadedmetadata", pe), () => {
      ie.removeEventListener("loadedmetadata", pe);
    };
  }, [Z, c]), t ? null : /* @__PURE__ */ y.jsx("audio", {
    ref: Z,
    preload: "metadata",
    ...te
  });
}, J4 = Vt(Z4);
typeof window < "u" && (window.remotion_renderReady = !1);
var Zc = [];
typeof window < "u" && (window.remotion_delayRenderTimeouts = {});
var Q4 = "The delayRender was called:", eA = "Retries left: ", tA = "- Rendering the frame will be retried.", $v = 3e4, vi = (r, e) => {
  if (typeof r != "string" && typeof r < "u")
    throw new Error("The label parameter of delayRender() must be a string or undefined, got: " + JSON.stringify(r));
  const t = Math.random();
  Zc.push(t);
  const n = Error().stack?.replace(/^Error/g, "") ?? "";
  if (Mt().isRendering) {
    const i = (e?.timeoutInMilliseconds ?? (typeof window > "u" ? $v : window.remotion_puppeteerTimeout ?? $v)) - 2e3;
    if (typeof window < "u") {
      const s = (e?.retries ?? 0) - (window.remotion_attempt - 1);
      window.remotion_delayRenderTimeouts[t] = {
        label: r ?? null,
        timeout: setTimeout(() => {
          const a = [
            "A delayRender()",
            r ? `"${r}"` : null,
            `was called but not cleared after ${i}ms. See https://remotion.dev/docs/timeout for help.`,
            s > 0 ? eA + s : null,
            s > 0 ? tA : null,
            Q4,
            n
          ].filter(Hl).join(" ");
          na(Error(a));
        }, i)
      };
    }
  }
  return typeof window < "u" && (window.remotion_renderReady = !1), t;
}, yt = (r) => {
  if (typeof r > "u")
    throw new TypeError("The continueRender() method must be called with a parameter that is the return value of delayRender(). No value was passed.");
  if (typeof r != "number")
    throw new TypeError("The parameter passed into continueRender() must be the return value of delayRender() which is a number. Got: " + JSON.stringify(r));
  Zc = Zc.filter((e) => e === r ? (Mt().isRendering && (clearTimeout(window.remotion_delayRenderTimeouts[r].timeout), delete window.remotion_delayRenderTimeouts[r]), !1) : !0), Zc.length === 0 && typeof window < "u" && (window.remotion_renderReady = !0);
}, rA = (r, e) => {
  const t = be(null), {
    volume: n,
    playbackRate: i,
    allowAmplificationDuringRender: s,
    onDuration: a,
    toneFrequency: c,
    _remotionInternalNeedsDurationCalculation: u,
    _remotionInternalNativeLoopPassed: h,
    acceptableTimeShiftInSeconds: d,
    name: p,
    onError: g,
    delayRenderRetries: v,
    delayRenderTimeoutInMilliseconds: b,
    loopVolumeCurveBehavior: x,
    pauseWhenBuffering: _,
    ...C
  } = r, E = us(), k = xa(x ?? "repeat"), O = ki(), P = me(Jt), { registerRenderAsset: R, unregisterRenderAsset: V } = me(ds), F = ee(() => `audio-${fs(r.src ?? "")}-${P?.relativeFrom}-${P?.cumulatedFrom}-${P?.durationInFrames}`, [
    r.src,
    P?.relativeFrom,
    P?.cumulatedFrom,
    P?.durationInFrames
  ]), $ = ao({
    volume: n,
    frame: k,
    mediaVolume: 1,
    allowAmplificationDuringRender: s ?? !1
  });
  Zr(e, () => t.current, []), ce(() => {
    if (!r.src)
      throw new Error("No src passed");
    if (window.remotion_audioEnabled && !r.muted && !($ <= 0))
      return R({
        type: "audio",
        src: Jn(r.src),
        id: F,
        frame: E,
        volume: $,
        mediaFrame: O,
        playbackRate: r.playbackRate ?? 1,
        allowAmplificationDuringRender: s ?? !1,
        toneFrequency: c ?? null,
        audioStartFrame: Math.max(0, -(P?.relativeFrom ?? 0))
      }), () => V(F);
  }, [
    r.muted,
    r.src,
    R,
    E,
    F,
    V,
    $,
    k,
    O,
    i,
    r.playbackRate,
    s,
    c,
    P?.relativeFrom
  ]);
  const { src: z } = r, G = e || u;
  return Kn(() => {
    if (window.process?.env?.NODE_ENV === "test" || !G)
      return;
    const H = vi("Loading <Audio> duration with src=" + z, {
      retries: v ?? void 0,
      timeoutInMilliseconds: b ?? void 0
    }), { current: Y } = t, te = () => {
      Y?.duration && a(Y.src, Y.duration), yt(H);
    };
    return Y?.duration ? (a(Y.src, Y.duration), yt(H)) : Y?.addEventListener("loadedmetadata", te, { once: !0 }), () => {
      Y?.removeEventListener("loadedmetadata", te), yt(H);
    };
  }, [
    z,
    a,
    G,
    v,
    b
  ]), G ? /* @__PURE__ */ y.jsx("audio", {
    ref: t,
    ...C
  }) : null;
}, nA = Vt(rA), iA = (r, e) => {
  const t = me(Zl), {
    startFrom: n,
    endAt: i,
    name: s,
    stack: a,
    pauseWhenBuffering: c,
    showInTimeline: u,
    _remotionDebugSeeking: h,
    ...d
  } = r, { loop: p, ...g } = r, { fps: v } = Ei(), b = Mt(), { durations: x, setDurations: _ } = me(Nf);
  if (typeof r.src != "string")
    throw new TypeError(`The \`<Audio>\` tag requires a string for \`src\`, but got ${JSON.stringify(r.src)} instead.`);
  const C = so(r.src), E = se((P) => {
    console.log(P.currentTarget.error);
    const R = `Could not play audio with src ${C}: ${P.currentTarget.error}. See https://remotion.dev/docs/media-playback-error for help.`;
    p ? na(new Error(R)) : console.warn(R);
  }, [p, C]), k = se((P, R) => {
    _({ type: "got-duration", durationInSeconds: R, src: P });
  }, [_]), O = x[Jn(C)] ?? x[Jn(r.src)];
  if (p && O !== void 0) {
    if (!Number.isFinite(O))
      return /* @__PURE__ */ y.jsx(Xo, {
        ...g,
        ref: e,
        _remotionInternalNativeLoopPassed: !0
      });
    const P = O * v;
    return /* @__PURE__ */ y.jsx(Gl, {
      layout: "none",
      durationInFrames: rb({
        endAt: i,
        mediaDuration: P,
        playbackRate: r.playbackRate ?? 1,
        startFrom: n
      }),
      children: /* @__PURE__ */ y.jsx(Xo, {
        ...g,
        ref: e,
        _remotionInternalNativeLoopPassed: !0
      })
    });
  }
  if (typeof n < "u" || typeof i < "u") {
    Lf(n, i);
    const P = n ?? 0, R = i ?? 1 / 0;
    return /* @__PURE__ */ y.jsx(xn, {
      layout: "none",
      from: 0 - P,
      showInTimeline: !1,
      durationInFrames: R,
      name: s,
      children: /* @__PURE__ */ y.jsx(Xo, {
        _remotionInternalNeedsDurationCalculation: !!p,
        pauseWhenBuffering: c ?? !1,
        ...d,
        ref: e
      })
    });
  }
  return Ff(r, "Audio"), b.isRendering ? /* @__PURE__ */ y.jsx(nA, {
    onDuration: k,
    ...r,
    ref: e,
    onError: E,
    _remotionInternalNeedsDurationCalculation: !!p
  }) : /* @__PURE__ */ y.jsx(J4, {
    _remotionInternalNativeLoopPassed: r._remotionInternalNativeLoopPassed ?? !1,
    _remotionDebugSeeking: h ?? !1,
    _remotionInternalStack: a ?? null,
    shouldPreMountAudioTags: t !== null && t.numberOfAudioTags > 0,
    ...r,
    ref: e,
    onError: E,
    onDuration: k,
    pauseWhenBuffering: c ?? !1,
    _remotionInternalNeedsDurationCalculation: !!p,
    showInTimeline: u ?? !0
  });
}, Xo = Vt(iA);
ba(Xo);
var sA = At({
  folderName: null,
  parentName: null
}), oA = {
  transform: "rotate(90deg)"
}, Yv = 40, aA = {
  color: "white",
  fontSize: 14,
  fontFamily: "sans-serif"
}, cA = {
  justifyContent: "center",
  alignItems: "center"
}, lA = () => /* @__PURE__ */ y.jsxs(Yo, {
  style: cA,
  id: "remotion-comp-loading",
  children: [
    /* @__PURE__ */ y.jsx("style", {
      type: "text/css",
      children: `
				@keyframes anim {
					from {
						opacity: 0
					}
					to {
						opacity: 1
					}
				}
				#remotion-comp-loading {
					animation: anim 2s;
					animation-fill-mode: forwards;
				}
			`
    }),
    /* @__PURE__ */ y.jsx("svg", {
      width: Yv,
      height: Yv,
      viewBox: "-100 -100 400 400",
      style: oA,
      children: /* @__PURE__ */ y.jsx("path", {
        fill: "#555",
        stroke: "#555",
        strokeWidth: "100",
        strokeLinejoin: "round",
        d: "M 2 172 a 196 100 0 0 0 195 5 A 196 240 0 0 0 100 2.259 A 196 240 0 0 0 2 172 z"
      })
    }),
    /* @__PURE__ */ y.jsxs("p", {
      style: aA,
      children: [
        "Resolving ",
        "<Suspense>",
        "..."
      ]
    })
  ]
}), Pr = null, Fd = () => {
  if (!Pr) {
    if (typeof document > "u")
      throw new Error("Tried to call an API that only works in the browser from outside the browser");
    Pr = document.createElement("div"), Pr.style.position = "absolute", Pr.style.top = "0px", Pr.style.left = "0px", Pr.style.right = "0px", Pr.style.bottom = "0px", Pr.style.width = "100%", Pr.style.height = "100%", Pr.style.display = "flex", Pr.style.flexDirection = "column";
    const r = document.createElement("div");
    r.style.position = "fixed", r.style.top = "-999999px", r.appendChild(Pr), document.body.appendChild(r);
  }
  return Pr;
}, mb = (r) => ee(() => {
  if ("lazyComponent" in r && typeof r.lazyComponent < "u")
    return Ce.lazy(r.lazyComponent);
  if ("component" in r)
    return typeof document > "u" ? r.component : Ce.lazy(() => Promise.resolve({ default: r.component }));
  throw new Error("You must pass either 'component' or 'lazyComponent'");
}, [r.component, r.lazyComponent]), vb = () => /^([a-zA-Z0-9-\u4E00-\u9FFF])+$/g, yb = (r) => r.match(vb()), uA = (r) => {
  if (!yb(r))
    throw new Error(`Composition id can only contain a-z, A-Z, 0-9, CJK characters and -. You passed ${r}`);
}, hA = `Composition ID must match ${String(vb())}`, dA = (r, e, t) => {
  if (r) {
    if (typeof r != "object")
      throw new Error(`"${e}" must be an object, but you passed a value of type ${typeof r}`);
    if (Array.isArray(r))
      throw new Error(`"${e}" must be an object, an array was passed ${t ? `for composition "${t}"` : ""}`);
  }
}, fA = () => (ce(() => {
  const r = vi("Waiting for Root component to unsuspend");
  return () => yt(r);
}, []), null), Xv = ({
  width: r,
  height: e,
  fps: t,
  durationInFrames: n,
  id: i,
  defaultProps: s,
  schema: a,
  ...c
}) => {
  const { registerComposition: u, unregisterComposition: h } = me(Ti), d = Yl(), p = mb(c), g = Mf(), v = Af(), b = Mt();
  if (me(hs))
    throw v ? new Error("<Composition> was mounted inside the `component` that was passed to the <Player>. See https://remotion.dev/docs/wrong-composition-mount for help.") : new Error("<Composition> mounted inside another composition. See https://remotion.dev/docs/wrong-composition-mount for help.");
  const { folderName: _, parentName: C } = me(sA);
  ce(() => {
    if (!i)
      throw new Error("No id for composition passed.");
    return uA(i), dA(s, "defaultProps", i), u({
      durationInFrames: n ?? void 0,
      fps: t ?? void 0,
      height: e ?? void 0,
      width: r ?? void 0,
      id: i,
      folderName: _,
      component: p,
      defaultProps: Hi(s ?? {}),
      nonce: g,
      parentFolderName: C,
      schema: a ?? null,
      calculateMetadata: c.calculateMetadata ?? null
    }), () => {
      h(i);
    };
  }, [
    n,
    t,
    e,
    p,
    i,
    _,
    s,
    u,
    h,
    r,
    g,
    C,
    a,
    c.calculateMetadata
  ]);
  const E = Df(i);
  if (b.isStudio && d && d.component === p) {
    const k = p;
    return E === null || E.type !== "success" ? null : dd(/* @__PURE__ */ y.jsx(Dd, {
      children: /* @__PURE__ */ y.jsx(rl, {
        fallback: /* @__PURE__ */ y.jsx(lA, {}),
        children: /* @__PURE__ */ y.jsx(k, {
          ...E.result.props ?? {}
        })
      })
    }), Fd());
  }
  if (b.isRendering && d && d.component === p) {
    const k = p;
    return E === null || E.type !== "success" ? null : dd(/* @__PURE__ */ y.jsx(Dd, {
      children: /* @__PURE__ */ y.jsx(rl, {
        fallback: /* @__PURE__ */ y.jsx(fA, {}),
        children: /* @__PURE__ */ y.jsx(k, {
          ...E.result.props ?? {}
        })
      })
    }), Fd());
  }
  return null;
}, bb = Ce.createRef(), pA = ({ children: r, numberOfAudioTags: e }) => {
  const [t, n] = ue([]), i = be(t), [s, a] = ue([]), [c, u] = ue(null), [h, d] = ue(null), p = se((k) => {
    n((O) => {
      const P = k(O);
      return i.current = P, P;
    });
  }, []), g = se((k) => {
    p((O) => {
      if (O.find((R) => R.id === k.id))
        throw new Error(`Multiple composition with id ${k.id} are registered.`);
      return [...O, k].slice().sort((R, V) => R.nonce - V.nonce);
    });
  }, [p]), v = se((k) => {
    n((O) => O.filter((P) => P.id !== k));
  }, []), b = se((k, O) => {
    a((P) => [
      ...P,
      {
        name: k,
        parent: O
      }
    ]);
  }, []), x = se((k, O) => {
    a((P) => P.filter((R) => !(R.name === k && R.parent === O)));
  }, []);
  Zr(bb, () => ({
    getCompositions: () => i.current
  }), []);
  const _ = t.find((k) => c?.type === "composition" ? k.id === c.compositionId : null), C = se((k, O) => {
    n((P) => P.map((V) => V.id === k ? {
      ...V,
      defaultProps: O
    } : V));
  }, []), E = ee(() => ({
    compositions: t,
    registerComposition: g,
    unregisterComposition: v,
    folders: s,
    registerFolder: b,
    unregisterFolder: x,
    currentCompositionMetadata: h,
    setCurrentCompositionMetadata: d,
    canvasContent: c,
    setCanvasContent: u,
    updateCompositionDefaultProps: C
  }), [
    t,
    g,
    v,
    s,
    b,
    x,
    h,
    c,
    C
  ]);
  return /* @__PURE__ */ y.jsx(Ti.Provider, {
    value: E,
    children: /* @__PURE__ */ y.jsx(a4, {
      children: /* @__PURE__ */ y.jsx(k4, {
        children: /* @__PURE__ */ y.jsx(Ky, {
          children: /* @__PURE__ */ y.jsx(gb, {
            numberOfAudioTags: e,
            component: _?.component ?? null,
            children: r
          })
        })
      })
    })
  });
}, gA = ({
  onLoad: r,
  onError: e,
  delayRenderRetries: t,
  delayRenderTimeoutInMilliseconds: n,
  ...i
}, s) => {
  const [a] = ue(() => vi(`Loading <IFrame> with source ${i.src}`, {
    retries: t ?? void 0,
    timeoutInMilliseconds: n ?? void 0
  })), c = se((h) => {
    yt(a), r?.(h);
  }, [a, r]), u = se((h) => {
    yt(a), e ? e(h) : console.error("Error loading iframe:", h, "Handle the event using the onError() prop to make this message disappear.");
  }, [a, e]);
  return /* @__PURE__ */ y.jsx("iframe", {
    ...i,
    ref: s,
    onError: u,
    onLoad: c
  });
};
Vt(gA);
function mA(r) {
  return 1e3 * 2 ** (r - 1);
}
var vA = ({
  onError: r,
  maxRetries: e = 2,
  src: t,
  pauseWhenLoading: n,
  delayRenderRetries: i,
  delayRenderTimeoutInMilliseconds: s,
  onImageFrame: a,
  ...c
}, u) => {
  const h = be(null), d = be({}), { delayPlayback: p } = Bf(), g = me(Jt);
  if (!t)
    throw new Error('No "src" prop was passed to <Img>.');
  Zr(u, () => h.current, []);
  const v = so(t), b = se((_) => {
    if (!h.current)
      return;
    const C = h.current.src;
    setTimeout(() => {
      if (!h.current)
        return;
      const E = h.current?.src;
      E === C && (h.current.removeAttribute("src"), h.current.setAttribute("src", E));
    }, _);
  }, []), x = se((_) => {
    if (d.current) {
      if (d.current[h.current?.src] = (d.current[h.current?.src] ?? 0) + 1, r && (d.current[h.current?.src] ?? 0) > e) {
        r(_);
        return;
      }
      if ((d.current[h.current?.src] ?? 0) <= e) {
        const C = mA(d.current[h.current?.src] ?? 0);
        console.warn(`Could not load image with source ${h.current?.src}, retrying again in ${C}ms`), b(C);
        return;
      }
      na("Error loading image with src: " + h.current?.src);
    }
  }, [e, r, b]);
  if (typeof window < "u") {
    const _ = !!g?.premounting;
    Kn(() => {
      if (window.process?.env?.NODE_ENV === "test") {
        h.current && (h.current.src = v);
        return;
      }
      const C = vi("Loading <Img> with src=" + v, {
        retries: i ?? void 0,
        timeoutInMilliseconds: s ?? void 0
      }), E = n && !_ ? p().unblock : () => {
      }, { current: k } = h;
      let O = !1;
      const P = () => {
        O || ((d.current[h.current?.src] ?? 0) > 0 && (delete d.current[h.current?.src], console.info(`Retry successful - ${h.current?.src} is now loaded`)), k && (k.src = v, a?.(k)), E(), yt(C));
      }, R = new Image();
      return R.src = v, R.decode().then(P).catch((V) => {
        console.warn(V), R.complete ? P() : R.addEventListener("load", P);
      }), () => {
        O = !0, R.removeEventListener("load", P), E(), yt(C);
      };
    }, [
      v,
      p,
      i,
      s,
      n,
      _,
      a
    ]);
  }
  return /* @__PURE__ */ y.jsx("img", {
    ...c,
    ref: h,
    onError: x
  });
}, wb = Vt(vA), xb = {};
Ly(xb, {
  makeDefaultPreviewCSS: () => bA,
  injectCSS: () => yA,
  OFFTHREAD_VIDEO_CLASS_NAME: () => ul
});
var Gv = {}, yA = (r) => {
  if (typeof document > "u" || Gv[r])
    return;
  const e = document.head || document.getElementsByTagName("head")[0], t = document.createElement("style");
  t.appendChild(document.createTextNode(r)), e.prepend(t), Gv[r] = !0;
}, ul = "__remotion_offthreadvideo", bA = (r, e) => r ? `
    ${r} * {
      box-sizing: border-box;
    }
    ${r} *:-webkit-full-screen {
      width: 100%;
      height: 100%;
    }
    ${r} .${ul} {
      object-fit: contain;
    }
  ` : `
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
	    background-color: ${e};
    }
    .${ul} {
      object-fit: contain;
    }
    `, _b = "__remotion-studio-container", wA = () => document.getElementById(_b), xA = null, Vh = [], _A = () => xA, SA = (r) => (Vh.push(r), () => {
  Vh = Vh.filter((e) => e !== r);
}), CA = ({ children: r, numberOfAudioTags: e }) => {
  const [t] = ue(() => String(fs(null))), [n, i] = ue(() => Jy()), [s, a] = ue(!1), c = be(!1), [u, h] = ue(0), [d, p] = ue(1), g = be([]);
  typeof window < "u" && Kn(() => {
    window.remotion_setFrame = (_, C, E) => {
      window.remotion_attempt = E;
      const k = vi(`Setting the current frame to ${_}`);
      let O = !0;
      i((P) => (P[C] ?? window.remotion_initialFrame) === _ ? (O = !1, P) : {
        ...P,
        [C]: _
      }), O ? requestAnimationFrame(() => yt(k)) : yt(k);
    }, window.remotion_isPlayer = !1;
  }, []);
  const v = ee(() => ({
    frame: n,
    playing: s,
    imperativePlaying: c,
    rootId: t,
    playbackRate: d,
    setPlaybackRate: p,
    audioAndVideoTags: g
  }), [n, d, s, t]), b = ee(() => ({
    setFrame: i,
    setPlaying: a
  }), []), x = ee(() => {
    let _ = 0;
    return {
      getNonce: () => _++,
      fastRefreshes: u
    };
  }, [u]);
  return ce(() => {
    typeof __webpack_module__ < "u" && __webpack_module__.hot && __webpack_module__.hot.addStatusHandler((_) => {
      _ === "idle" && h((C) => C + 1);
    });
  }, []), /* @__PURE__ */ y.jsx(no.Provider, {
    value: x,
    children: /* @__PURE__ */ y.jsx(ln.Provider, {
      value: v,
      children: /* @__PURE__ */ y.jsx(io.Provider, {
        value: b,
        children: /* @__PURE__ */ y.jsx(Hy, {
          children: /* @__PURE__ */ y.jsx(ib, {
            children: /* @__PURE__ */ y.jsx(pA, {
              numberOfAudioTags: e,
              children: /* @__PURE__ */ y.jsx(sb, {
                children: /* @__PURE__ */ y.jsx(ab, {
                  children: r
                })
              })
            })
          })
        })
      })
    })
  });
}, TA = () => {
  if (Mt().isRendering) {
    const r = window.remotion_envVariables;
    return r ? { ...JSON.parse(r), NODE_ENV: "production" } : {};
  }
  return {
    NODE_ENV: "production"
  };
}, EA = () => {
  const r = TA();
  window.process || (window.process = {}), window.process.env || (window.process.env = {}), Object.keys(r).forEach((e) => {
    window.process.env[e] = r[e];
  });
}, kA = Ce.createContext(null), OA = At({
  setSize: () => {
  },
  size: { size: "auto", translation: { x: 0, y: 0 } }
}), IA = ({
  canvasSize: r,
  compositionHeight: e,
  compositionWidth: t,
  previewSize: n
}) => {
  const i = r.height / e, s = r.width / t, a = Math.min(i, s);
  return n === "auto" ? a : Number(n);
}, AA = "remotion_staticFilesChanged";
function MA() {
  const r = Ce.useContext(Ti), e = Ce.useContext(ln), t = Ce.useContext(io), n = Ce.useContext(Jt), i = Ce.useContext(no), s = Ce.useContext(hs), a = Ce.useContext(ql), c = Ce.useContext($l), u = Ce.useContext(ds), h = Ce.useContext(ro), d = Ce.useContext(co);
  return ee(() => ({
    compositionManagerCtx: r,
    timelineContext: e,
    setTimelineContext: t,
    sequenceContext: n,
    nonceContext: i,
    canUseRemotionHooksContext: s,
    preloadContext: a,
    resolveCompositionContext: c,
    renderAssetManagerContext: u,
    sequenceManagerContext: h,
    bufferManagerContext: d
  }), [
    r,
    i,
    n,
    t,
    e,
    s,
    a,
    c,
    u,
    h,
    d
  ]);
}
var PA = (r) => {
  const { children: e, contexts: t } = r;
  return /* @__PURE__ */ y.jsx(hs.Provider, {
    value: t.canUseRemotionHooksContext,
    children: /* @__PURE__ */ y.jsx(no.Provider, {
      value: t.nonceContext,
      children: /* @__PURE__ */ y.jsx(ql.Provider, {
        value: t.preloadContext,
        children: /* @__PURE__ */ y.jsx(Ti.Provider, {
          value: t.compositionManagerCtx,
          children: /* @__PURE__ */ y.jsx(ro.Provider, {
            value: t.sequenceManagerContext,
            children: /* @__PURE__ */ y.jsx(ds.Provider, {
              value: t.renderAssetManagerContext,
              children: /* @__PURE__ */ y.jsx($l.Provider, {
                value: t.resolveCompositionContext,
                children: /* @__PURE__ */ y.jsx(ln.Provider, {
                  value: t.timelineContext,
                  children: /* @__PURE__ */ y.jsx(io.Provider, {
                    value: t.setTimelineContext,
                    children: /* @__PURE__ */ y.jsx(Jt.Provider, {
                      value: t.sequenceContext,
                      children: /* @__PURE__ */ y.jsx(co.Provider, {
                        value: t.bufferManagerContext,
                        children: e
                      })
                    })
                  })
                })
              })
            })
          })
        })
      })
    })
  });
}, Te = {
  useUnsafeVideoConfig: Xl,
  Timeline: zy,
  CompositionManager: Ti,
  SequenceManager: ro,
  SequenceVisibilityToggleContext: wa,
  RemotionRoot: CA,
  useVideo: Yl,
  getRoot: _A,
  useMediaVolumeState: Uf,
  useMediaMutedState: $f,
  useLazyComponent: mb,
  truthy: Hl,
  SequenceContext: Jt,
  useRemotionContexts: MA,
  RemotionContextProvider: PA,
  CSSUtils: xb,
  setupEnvVariables: EA,
  MediaVolumeContext: Wf,
  SetMediaVolumeContext: Hf,
  getRemotionEnvironment: Mt,
  SharedAudioContext: Zl,
  SharedAudioContextProvider: gb,
  invalidCompositionErrorMessage: hA,
  isCompositionIdValid: yb,
  getPreviewDomElement: wA,
  compositionsRef: bb,
  portalNode: Fd,
  waitForRoot: SA,
  CanUseRemotionHooksProvider: Dd,
  CanUseRemotionHooks: hs,
  PrefetchProvider: ib,
  DurationsContextProvider: sb,
  IsPlayerContextProvider: i4,
  useIsPlayer: Af,
  EditorPropsProvider: Hy,
  EditorPropsContext: Ul,
  usePreload: so,
  NonceContext: no,
  resolveVideoConfig: Xy,
  useResolvedVideoConfig: Df,
  resolveCompositionsRef: Gy,
  ResolveCompositionConfig: Ky,
  REMOTION_STUDIO_CONTAINER_ELEMENT: _b,
  RenderAssetManager: ds,
  persistCurrentFrame: Zy,
  useTimelineSetFrame: eb,
  isIosSafari: Kl,
  WATCH_REMOTION_STATIC_FILES: AA,
  addSequenceStackTraces: ba,
  useMediaStartsAt: oo,
  BufferingProvider: ab,
  BufferingContextReact: co,
  enableSequenceStackTraces: By,
  CurrentScaleContext: kA,
  PreviewSizeContext: OA,
  calculateScale: IA,
  editorPropsProviderRef: Wy,
  PROPS_UPDATED_EXTERNALLY: y4,
  validateRenderAsset: tb
}, DA = ({
  src: r,
  transparent: e,
  currentTime: t,
  toneMapped: n
}) => `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(Jn(r))}&time=${encodeURIComponent(t)}&transparent=${String(e)}&toneMapped=${String(n)}`, Sb = At(!1), jA = ({ children: r }) => /* @__PURE__ */ y.jsx(Sb.Provider, {
  value: !1,
  children: r
}), RA = () => {
  if (!Ce.useContext(Sb))
    throw new Error("This component must be inside a <Series /> component.");
}, FA = ({ children: r }, e) => (RA(), /* @__PURE__ */ y.jsx(jA, {
  children: r
})), LA = Vt(FA);
ba(LA);
var NA = ({
  onError: r,
  volume: e,
  playbackRate: t,
  src: n,
  muted: i,
  allowAmplificationDuringRender: s,
  transparent: a = !1,
  toneMapped: c = !0,
  toneFrequency: u,
  name: h,
  loopVolumeCurveBehavior: d,
  delayRenderRetries: p,
  delayRenderTimeoutInMilliseconds: g,
  onVideoFrame: v,
  ...b
}) => {
  const x = us(), _ = ki(), C = xa(d ?? "repeat"), E = Xl(), k = me(Jt), O = oo(), { registerRenderAsset: P, unregisterRenderAsset: R } = me(ds);
  if (!n)
    throw new TypeError("No `src` was passed to <OffthreadVideo>.");
  const V = ee(() => `offthreadvideo-${fs(n ?? "")}-${k?.cumulatedFrom}-${k?.relativeFrom}-${k?.durationInFrames}`, [
    n,
    k?.cumulatedFrom,
    k?.relativeFrom,
    k?.durationInFrames
  ]);
  if (!E)
    throw new Error("No video config found");
  const F = ao({
    volume: e,
    frame: C,
    mediaVolume: 1,
    allowAmplificationDuringRender: s ?? !1
  });
  ce(() => {
    if (!n)
      throw new Error("No src passed");
    if (window.remotion_audioEnabled && !i && !(F <= 0))
      return P({
        type: "video",
        src: Jn(n),
        id: V,
        frame: x,
        volume: F,
        mediaFrame: _,
        playbackRate: t ?? 1,
        allowAmplificationDuringRender: s ?? !1,
        toneFrequency: u ?? null,
        audioStartFrame: Math.max(0, -(k?.relativeFrom ?? 0))
      }), () => R(V);
  }, [
    i,
    n,
    P,
    V,
    R,
    F,
    _,
    x,
    t,
    s,
    u,
    k?.relativeFrom
  ]);
  const $ = ee(() => lb({
    frame: _,
    playbackRate: t || 1,
    startFrom: -O
  }) / E.fps, [_, O, t, E.fps]), z = ee(() => DA({
    src: n,
    currentTime: $,
    transparent: a,
    toneMapped: c
  }), [c, $, n, a]), [G, H] = ue(null);
  Kn(() => {
    if (!window.remotion_videoEnabled)
      return;
    const Z = [];
    H(null);
    const de = new AbortController(), oe = vi(`Fetching ${z} from server`, {
      retries: p ?? void 0,
      timeoutInMilliseconds: g ?? void 0
    });
    return (async () => {
      try {
        const pe = await fetch(z, {
          signal: de.signal
        });
        if (pe.status !== 200) {
          if (pe.status === 500) {
            const Ze = await pe.json();
            if (Ze.error) {
              const We = Ze.error.replace(/^Error: /, "");
              throw new Error(We);
            }
          }
          throw new Error(`Server returned status ${pe.status} while fetching ${z}`);
        }
        const re = await pe.blob(), Ve = URL.createObjectURL(re);
        Z.push(() => URL.revokeObjectURL(Ve)), H({
          src: Ve,
          handle: oe
        });
      } catch (pe) {
        if (pe.message.includes("aborted")) {
          yt(oe);
          return;
        }
        if (de.signal.aborted) {
          yt(oe);
          return;
        }
        pe.message.includes("Failed to fetch") && (pe = new Error(`Failed to fetch ${z}. This could be caused by Chrome rejecting the request because the disk space is low. Consider increasing the disk size of your environment.`, { cause: pe })), r ? r(pe) : na(pe);
      }
    })(), Z.push(() => {
      de.signal.aborted || de.abort();
    }), () => {
      Z.forEach((pe) => pe());
    };
  }, [
    z,
    p,
    g,
    r
  ]);
  const Y = se(() => {
    r ? r?.(new Error("Failed to load image with src " + G)) : na("Failed to load image with src " + G);
  }, [G, r]), te = ee(() => [ul, b.className].filter(Hl).join(" "), [b.className]), ge = se((Z) => {
    v && v(Z);
  }, [v]);
  return !G || !window.remotion_videoEnabled ? null : (yt(G.handle), /* @__PURE__ */ y.jsx(wb, {
    src: G.src,
    className: te,
    delayRenderRetries: p,
    delayRenderTimeoutInMilliseconds: g,
    onImageFrame: ge,
    ...b,
    onError: Y
  }));
}, BA = ({
  ref: r,
  onVideoFrame: e
}) => {
  ce(() => {
    const { current: t } = r;
    if (!t || !e)
      return;
    let n = 0;
    const i = () => {
      r.current && (e(r.current), n = r.current.requestVideoFrameCallback(i));
    };
    return i(), () => {
      t.cancelVideoFrameCallback(n);
    };
  }, [e, r]);
}, VA = (r, e) => {
  const t = be(null), {
    volume: n,
    muted: i,
    playbackRate: s,
    onlyWarnForMediaSeekingError: a,
    src: c,
    onDuration: u,
    acceptableTimeShift: h,
    acceptableTimeShiftInSeconds: d,
    toneFrequency: p,
    name: g,
    _remotionInternalNativeLoopPassed: v,
    _remotionInternalStack: b,
    _remotionDebugSeeking: x,
    style: _,
    pauseWhenBuffering: C,
    showInTimeline: E,
    loopVolumeCurveBehavior: k,
    onError: O,
    onAutoPlayError: P,
    onVideoFrame: R,
    crossOrigin: V,
    ...F
  } = r, $ = xa(k ?? "repeat"), { fps: z, durationInFrames: G } = Ei(), H = me(Jt), { hidden: Y } = me(wa), [te] = ue(() => String(Math.random())), ge = Y[te] ?? !1;
  if (typeof h < "u")
    throw new Error("acceptableTimeShift has been removed. Use acceptableTimeShiftInSeconds instead.");
  const Z = fb(t), [de] = Uf(), [oe] = $f();
  ob({
    mediaRef: t,
    volume: n,
    mediaVolume: de,
    mediaType: "video",
    src: c,
    playbackRate: r.playbackRate ?? 1,
    displayName: g ?? null,
    id: te,
    stack: b,
    showInTimeline: E,
    premountDisplay: null,
    onAutoPlayError: P ?? null
  }), pb({
    volumePropFrame: $,
    actualVolume: Z,
    volume: n,
    mediaVolume: de,
    mediaRef: t
  }), db({
    mediaRef: t,
    src: c,
    mediaType: "video",
    playbackRate: r.playbackRate ?? 1,
    onlyWarnForMediaSeekingError: a,
    acceptableTimeshift: d ?? Vf,
    isPremounting: !!H?.premounting,
    pauseWhenBuffering: C,
    debugSeeking: x,
    onAutoPlayError: P ?? null
  });
  const ie = H ? H.relativeFrom : 0, pe = H ? Math.min(H.durationInFrames, G) : G, re = $4({
    actualSrc: so(c),
    actualFrom: ie,
    duration: pe,
    fps: z
  });
  Zr(e, () => t.current, []), ce(() => {
    const { current: Ee } = t;
    if (!Ee)
      return;
    const Ie = () => {
      if (Ee.error) {
        if (console.error("Error occurred in video", Ee?.error), O) {
          const dt = new Error(`Code ${Ee.error.code}: ${Ee.error.message}`);
          O(dt);
          return;
        }
        throw new Error(`The browser threw an error while playing the video ${c}: Code ${Ee.error.code} - ${Ee?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);
      } else {
        if (O) {
          const dt = new Error(`The browser threw an error while playing the video ${c}`);
          O(dt);
          return;
        }
        throw new Error("The browser threw an error while playing the video");
      }
    };
    return Ee.addEventListener("error", Ie, { once: !0 }), () => {
      Ee.removeEventListener("error", Ie);
    };
  }, [O, c]);
  const Ve = be();
  Ve.current = u, BA({ ref: t, onVideoFrame: R }), ce(() => {
    const { current: Ee } = t;
    if (!Ee)
      return;
    if (Ee.duration) {
      Ve.current?.(c, Ee.duration);
      return;
    }
    const Ie = () => {
      Ve.current?.(c, Ee.duration);
    };
    return Ee.addEventListener("loadedmetadata", Ie), () => {
      Ee.removeEventListener("loadedmetadata", Ie);
    };
  }, [c]), ce(() => {
    const { current: Ee } = t;
    Ee && (Kl() ? Ee.preload = "metadata" : Ee.preload = "auto");
  }, []);
  const Ze = ee(() => ({
    ..._,
    opacity: ge ? 0 : _?.opacity ?? 1
  }), [ge, _]), We = V ?? (R ? "anonymous" : void 0);
  return /* @__PURE__ */ y.jsx("video", {
    ref: t,
    muted: i || oe,
    playsInline: !0,
    src: re,
    loop: v,
    style: Ze,
    disableRemotePlayback: !0,
    crossOrigin: We,
    ...F
  });
}, Cb = Vt(VA), Tb = (r) => {
  const {
    startFrom: e,
    endAt: t,
    name: n,
    pauseWhenBuffering: i,
    stack: s,
    showInTimeline: a,
    ...c
  } = r, u = Mt(), h = se(() => {
  }, []);
  if (typeof r.src != "string")
    throw new TypeError(`The \`<OffthreadVideo>\` tag requires a string for \`src\`, but got ${JSON.stringify(r.src)} instead.`);
  if (r.imageFormat)
    throw new TypeError("The `<OffthreadVideo>` tag does no longer accept `imageFormat`. Use the `transparent` prop if you want to render a transparent video.");
  if (typeof e < "u" || typeof t < "u") {
    Lf(e, t);
    const C = e ?? 0, E = t ?? 1 / 0;
    return /* @__PURE__ */ y.jsx(xn, {
      layout: "none",
      from: 0 - C,
      showInTimeline: !1,
      durationInFrames: E,
      name: n,
      children: /* @__PURE__ */ y.jsx(Tb, {
        pauseWhenBuffering: i ?? !1,
        ...c
      })
    });
  }
  if (Ff(r, "Video"), u.isRendering)
    return /* @__PURE__ */ y.jsx(NA, {
      ...c
    });
  const {
    transparent: d,
    toneMapped: p,
    _remotionDebugSeeking: g,
    onAutoPlayError: v,
    onVideoFrame: b,
    crossOrigin: x,
    ..._
  } = c;
  return /* @__PURE__ */ y.jsx(Cb, {
    _remotionInternalStack: s ?? null,
    _remotionInternalNativeLoopPassed: !1,
    _remotionDebugSeeking: g ?? !1,
    onDuration: h,
    onlyWarnForMediaSeekingError: !0,
    pauseWhenBuffering: i ?? !1,
    showInTimeline: a ?? !0,
    onAutoPlayError: v ?? void 0,
    onVideoFrame: b ?? null,
    crossOrigin: x,
    ..._
  });
}, qv = (r) => Math.round(r * 1e5) / 1e5, zh = (r, e) => {
  if (zf(r.currentTime, e))
    return {
      wait: Promise.resolve(e),
      cancel: () => {
      }
    };
  r.currentTime = e;
  let t, n = null;
  const i = new Promise((a) => {
    t = r.requestVideoFrameCallback((c, u) => {
      const h = u.expectedDisplayTime - c;
      if (h <= 0) {
        a(u.mediaTime);
        return;
      }
      setTimeout(() => {
        a(u.mediaTime);
      }, h + 150);
    });
  }), s = new Promise((a) => {
    const c = () => {
      a();
    };
    r.addEventListener("seeked", c, {
      once: !0
    }), n = () => {
      r.removeEventListener("seeked", c);
    };
  });
  return {
    wait: Promise.all([i, s]).then(([a]) => a),
    cancel: () => {
      n?.(), r.cancelVideoFrameCallback(t);
    }
  };
}, zA = (r, e, t) => {
  const n = 1 / t / 2;
  let i = () => {
  };
  return Number.isFinite(r.duration) && r.currentTime >= r.duration && e >= r.duration ? {
    prom: Promise.resolve(),
    cancel: () => {
    }
  } : {
    prom: new Promise((a, c) => {
      const u = zh(r, e + n);
      u.wait.then((h) => {
        if (Math.abs(e - h) <= n)
          return a();
        const p = e > h ? 1 : -1, g = zh(r, h + n * p);
        i = g.cancel, g.wait.then((v) => {
          const b = Math.abs(e - v);
          if (qv(b) <= qv(n))
            return a();
          const x = zh(r, e + n);
          return i = x.cancel, x.wait.then(() => {
            a();
          }).catch((_) => {
            c(_);
          });
        }).catch((v) => {
          c(v);
        });
      }), i = u.cancel;
    }),
    cancel: () => {
      i();
    }
  };
}, WA = ({
  onError: r,
  volume: e,
  allowAmplificationDuringRender: t,
  playbackRate: n,
  onDuration: i,
  toneFrequency: s,
  name: a,
  acceptableTimeShiftInSeconds: c,
  delayRenderRetries: u,
  delayRenderTimeoutInMilliseconds: h,
  loopVolumeCurveBehavior: d,
  ...p
}, g) => {
  const v = us(), b = ki(), x = xa(d ?? "repeat"), _ = Xl(), C = be(null), E = me(Jt), k = oo(), O = Mt(), { registerRenderAsset: P, unregisterRenderAsset: R } = me(ds), V = ee(() => `video-${fs(p.src ?? "")}-${E?.cumulatedFrom}-${E?.relativeFrom}-${E?.durationInFrames}`, [
    p.src,
    E?.cumulatedFrom,
    E?.relativeFrom,
    E?.durationInFrames
  ]);
  if (!_)
    throw new Error("No video config found");
  const F = ao({
    volume: e,
    frame: x,
    mediaVolume: 1,
    allowAmplificationDuringRender: t ?? !1
  });
  ce(() => {
    if (!p.src)
      throw new Error("No src passed");
    if (!p.muted && !(F <= 0) && window.remotion_audioEnabled)
      return P({
        type: "video",
        src: Jn(p.src),
        id: V,
        frame: v,
        volume: F,
        mediaFrame: b,
        playbackRate: n ?? 1,
        allowAmplificationDuringRender: t ?? !1,
        toneFrequency: s ?? null,
        audioStartFrame: Math.max(0, -(E?.relativeFrom ?? 0))
      }), () => R(V);
  }, [
    p.muted,
    p.src,
    P,
    V,
    R,
    F,
    b,
    v,
    n,
    t,
    s,
    E?.relativeFrom
  ]), Zr(g, () => C.current, []), ce(() => {
    if (!window.remotion_videoEnabled)
      return;
    const { current: z } = C;
    if (!z)
      return;
    const G = ub({
      frame: b,
      playbackRate: n || 1,
      startFrom: -k,
      fps: _.fps
    }), H = vi(`Rendering <Video /> with src="${p.src}" at time ${G}`, {
      retries: u ?? void 0,
      timeoutInMilliseconds: h ?? void 0
    });
    if (window.process?.env?.NODE_ENV === "test") {
      yt(H);
      return;
    }
    if (zf(z.currentTime, G)) {
      if (z.readyState >= 2) {
        yt(H);
        return;
      }
      const Z = () => {
        yt(H);
      };
      return z.addEventListener("loadeddata", Z, { once: !0 }), () => {
        z.removeEventListener("loadeddata", Z);
      };
    }
    const Y = () => {
      yt(H);
    }, te = zA(z, G, _.fps);
    te.prom.then(() => {
      yt(H);
    }), z.addEventListener("ended", Y, { once: !0 });
    const ge = () => {
      if (z?.error) {
        if (console.error("Error occurred in video", z?.error), r)
          return;
        throw new Error(`The browser threw an error while playing the video ${p.src}: Code ${z.error.code} - ${z?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);
      } else
        throw new Error("The browser threw an error");
    };
    return z.addEventListener("error", ge, { once: !0 }), () => {
      te.cancel(), z.removeEventListener("ended", Y), z.removeEventListener("error", ge), yt(H);
    };
  }, [
    x,
    p.src,
    n,
    _.fps,
    b,
    k,
    r,
    u,
    h
  ]);
  const { src: $ } = p;
  return O.isRendering && Kn(() => {
    if (window.process?.env?.NODE_ENV === "test")
      return;
    const z = vi("Loading <Video> duration with src=" + $, {
      retries: u ?? void 0,
      timeoutInMilliseconds: h ?? void 0
    }), { current: G } = C, H = () => {
      G?.duration && i($, G.duration), yt(z);
    };
    return G?.duration ? (i($, G.duration), yt(z)) : G?.addEventListener("loadedmetadata", H, { once: !0 }), () => {
      G?.removeEventListener("loadedmetadata", H), yt(z);
    };
  }, [$, i, u, h]), /* @__PURE__ */ y.jsx("video", {
    ref: C,
    disableRemotePlayback: !0,
    ...p
  });
}, HA = Vt(WA), UA = (r, e) => {
  const {
    startFrom: t,
    endAt: n,
    name: i,
    pauseWhenBuffering: s,
    stack: a,
    _remotionInternalNativeLoopPassed: c,
    showInTimeline: u,
    onAutoPlayError: h,
    ...d
  } = r, { loop: p, _remotionDebugSeeking: g, ...v } = r, { fps: b } = Ei(), x = Mt(), { durations: _, setDurations: C } = me(Nf);
  if (typeof e == "string")
    throw new Error("string refs are not supported");
  if (typeof r.src != "string")
    throw new TypeError(`The \`<Video>\` tag requires a string for \`src\`, but got ${JSON.stringify(r.src)} instead.`);
  const E = so(r.src), k = se((R, V) => {
    C({ type: "got-duration", durationInSeconds: V, src: R });
  }, [C]), O = se(() => {
  }, []), P = _[Jn(E)] ?? _[Jn(r.src)];
  if (p && P !== void 0) {
    if (!Number.isFinite(P))
      return /* @__PURE__ */ y.jsx(Jc, {
        ...v,
        ref: e,
        _remotionInternalNativeLoopPassed: !0
      });
    const R = P * b;
    return /* @__PURE__ */ y.jsx(Gl, {
      durationInFrames: rb({
        endAt: n,
        mediaDuration: R,
        playbackRate: r.playbackRate ?? 1,
        startFrom: t
      }),
      layout: "none",
      name: i,
      children: /* @__PURE__ */ y.jsx(Jc, {
        ...v,
        ref: e,
        _remotionInternalNativeLoopPassed: !0
      })
    });
  }
  if (typeof t < "u" || typeof n < "u") {
    Lf(t, n);
    const R = t ?? 0, V = n ?? 1 / 0;
    return /* @__PURE__ */ y.jsx(xn, {
      layout: "none",
      from: 0 - R,
      showInTimeline: !1,
      durationInFrames: V,
      name: i,
      children: /* @__PURE__ */ y.jsx(Jc, {
        pauseWhenBuffering: s ?? !1,
        ...d,
        ref: e
      })
    });
  }
  return Ff(r, "Video"), x.isRendering ? /* @__PURE__ */ y.jsx(HA, {
    onDuration: k,
    onVideoFrame: O ?? null,
    ...d,
    ref: e
  }) : /* @__PURE__ */ y.jsx(Cb, {
    onlyWarnForMediaSeekingError: !1,
    ...d,
    ref: e,
    onVideoFrame: null,
    pauseWhenBuffering: s ?? !1,
    onDuration: k,
    _remotionInternalStack: a ?? null,
    _remotionInternalNativeLoopPassed: c ?? !1,
    _remotionDebugSeeking: g ?? !1,
    showInTimeline: u ?? !0,
    onAutoPlayError: h ?? void 0
  });
}, Jc = Vt(UA);
ba(Jc);
s4();
var $A = {}, YA = new Proxy($A, {
  get(r, e) {
    return e === "Bundling" || e === "Rendering" || e === "Log" || e === "Puppeteer" || e === "Output" ? YA : () => {
      console.warn("⚠️  The CLI configuration has been extracted from Remotion Core."), console.warn("Update the import from the config file:"), console.warn(), console.warn("- Delete:"), console.warn('import {Config} from "remotion";'), console.warn("+ Replace:"), console.warn('import {Config} from "@remotion/cli/config";'), console.warn(), console.warn("For more information, see https://www.remotion.dev/docs/4-0-migration."), process.exit(1);
    };
  }
});
ba(xn);
typeof window < "u" && (window.remotion_renderReady = !1);
typeof window < "u" && (window.remotion_delayRenderTimeouts = {});
var XA = (r, e, t) => {
  if (r) {
    if (typeof r != "object")
      throw new Error(`"${e}" must be an object, but you passed a value of type ${typeof r}`);
    if (Array.isArray(r))
      throw new Error(`"${e}" must be an object, an array was passed ${t ? `for composition "${t}"` : ""}`);
  }
};
function GA(r, e, t) {
  if (typeof r != "number")
    throw new Error(`The "${e}" prop ${t} must be a number, but you passed a value of type ${typeof r}`);
  if (isNaN(r))
    throw new TypeError(`The "${e}" prop ${t} must not be NaN, but is NaN.`);
  if (!Number.isFinite(r))
    throw new TypeError(`The "${e}" prop ${t} must be finite, but is ${r}.`);
  if (r % 1 !== 0)
    throw new TypeError(`The "${e}" prop ${t} must be an integer, but is ${r}.`);
  if (r <= 0)
    throw new TypeError(`The "${e}" prop ${t} must be positive, but got ${r}.`);
}
function qA(r, e) {
  const { allowFloats: t, component: n } = e;
  if (typeof r > "u")
    throw new Error(`The "durationInFrames" prop ${n} is missing.`);
  if (typeof r != "number")
    throw new Error(`The "durationInFrames" prop ${n} must be a number, but you passed a value of type ${typeof r}`);
  if (r <= 0)
    throw new TypeError(`The "durationInFrames" prop ${n} must be positive, but got ${r}.`);
  if (!t && r % 1 !== 0)
    throw new TypeError(`The "durationInFrames" prop ${n} must be an integer, but got ${r}.`);
  if (!Number.isFinite(r))
    throw new TypeError(`The "durationInFrames" prop ${n} must be finite, but got ${r}.`);
}
function KA(r, e, t) {
  if (typeof r != "number")
    throw new Error(`"fps" must be a number, but you passed a value of type ${typeof r} ${e}`);
  if (!Number.isFinite(r))
    throw new Error(`"fps" must be a finite, but you passed ${r} ${e}`);
  if (isNaN(r))
    throw new Error(`"fps" must not be NaN, but got ${r} ${e}`);
  if (r <= 0)
    throw new TypeError(`"fps" must be positive, but got ${r} ${e}`);
  if (t && r > 50)
    throw new TypeError("The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif");
}
var Jl = {
  validateFps: KA,
  validateDimension: GA,
  validateDurationInFrames: qA,
  validateDefaultAndInputProps: XA
}, Xt = 25, Ld = 16, ZA = () => /* @__PURE__ */ y.jsx("svg", {
  width: Xt,
  height: Xt,
  viewBox: "0 0 25 25",
  fill: "none",
  children: /* @__PURE__ */ y.jsx("path", {
    d: "M8 6.375C7.40904 8.17576 7.06921 10.2486 7.01438 12.3871C6.95955 14.5255 7.19163 16.6547 7.6875 18.5625C9.95364 18.2995 12.116 17.6164 14.009 16.5655C15.902 15.5147 17.4755 14.124 18.6088 12.5C17.5158 10.8949 15.9949 9.51103 14.1585 8.45082C12.3222 7.3906 10.2174 6.68116 8 6.375Z",
    fill: "white",
    stroke: "white",
    strokeWidth: "6.25",
    strokeLinejoin: "round"
  })
}), JA = () => /* @__PURE__ */ y.jsxs("svg", {
  viewBox: "0 0 100 100",
  width: Xt,
  height: Xt,
  children: [
    /* @__PURE__ */ y.jsx("rect", {
      x: "25",
      y: "20",
      width: "20",
      height: "60",
      fill: "#fff",
      ry: "5",
      rx: "5"
    }),
    /* @__PURE__ */ y.jsx("rect", {
      x: "55",
      y: "20",
      width: "20",
      height: "60",
      fill: "#fff",
      ry: "5",
      rx: "5"
    })
  ]
}), QA = ({
  isFullscreen: r
}) => {
  const n = r ? 0 : 3, i = r ? 6 * 1.6 : 6 / 2, s = r ? 6 * 1.6 : 6 * 2;
  return /* @__PURE__ */ y.jsxs("svg", {
    viewBox: "0 0 32 32",
    height: Ld,
    width: Ld,
    children: [
      /* @__PURE__ */ y.jsx("path", {
        d: `
				M ${n} ${s}
				L ${i} ${i}
				L ${s} ${n}
				`,
        stroke: "#fff",
        strokeWidth: 6,
        fill: "none"
      }),
      /* @__PURE__ */ y.jsx("path", {
        d: `
				M ${32 - n} ${s}
				L ${32 - i} ${i}
				L ${32 - s} ${n}
				`,
        stroke: "#fff",
        strokeWidth: 6,
        fill: "none"
      }),
      /* @__PURE__ */ y.jsx("path", {
        d: `
				M ${n} ${32 - s}
				L ${i} ${32 - i}
				L ${s} ${32 - n}
				`,
        stroke: "#fff",
        strokeWidth: 6,
        fill: "none"
      }),
      /* @__PURE__ */ y.jsx("path", {
        d: `
				M ${32 - n} ${32 - s}
				L ${32 - i} ${32 - i}
				L ${32 - s} ${32 - n}
				`,
        stroke: "#fff",
        strokeWidth: 6,
        fill: "none"
      })
    ]
  });
}, eM = () => /* @__PURE__ */ y.jsx("svg", {
  width: Xt,
  height: Xt,
  viewBox: "0 0 24 24",
  children: /* @__PURE__ */ y.jsx("path", {
    d: "M3.63 3.63a.996.996 0 000 1.41L7.29 8.7 7 9H4c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h3l3.29 3.29c.63.63 1.71.18 1.71-.71v-4.17l4.18 4.18c-.49.37-1.02.68-1.6.91-.36.15-.58.53-.58.92 0 .72.73 1.18 1.39.91.8-.33 1.55-.77 2.22-1.31l1.34 1.34a.996.996 0 101.41-1.41L5.05 3.63c-.39-.39-1.02-.39-1.42 0zM19 12c0 .82-.15 1.61-.41 2.34l1.53 1.53c.56-1.17.88-2.48.88-3.87 0-3.83-2.4-7.11-5.78-8.4-.59-.23-1.22.23-1.22.86v.19c0 .38.25.71.61.85C17.18 6.54 19 9.06 19 12zm-8.71-6.29l-.17.17L12 7.76V6.41c0-.89-1.08-1.33-1.71-.7zM16.5 12A4.5 4.5 0 0014 7.97v1.79l2.48 2.48c.01-.08.02-.16.02-.24z",
    fill: "#fff"
  })
}), tM = () => /* @__PURE__ */ y.jsx("svg", {
  width: Xt,
  height: Xt,
  viewBox: "0 0 24 24",
  children: /* @__PURE__ */ y.jsx("path", {
    d: "M3 10v4c0 .55.45 1 1 1h3l3.29 3.29c.63.63 1.71.18 1.71-.71V6.41c0-.89-1.08-1.34-1.71-.71L7 9H4c-.55 0-1 .45-1 1zm13.5 2A4.5 4.5 0 0014 7.97v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 4.45v.2c0 .38.25.71.6.85C17.18 6.53 19 9.06 19 12s-1.82 5.47-4.4 6.5c-.36.14-.6.47-.6.85v.2c0 .63.63 1.07 1.21.85C18.6 19.11 21 15.84 21 12s-2.4-7.11-5.79-8.4c-.58-.23-1.21.22-1.21.85z",
    fill: "#fff"
  })
}), Kv = "__remotion_buffering_indicator", Zv = "__remotion_buffering_animation", rM = {
  width: Xt,
  height: Xt,
  overflow: "hidden",
  lineHeight: "normal",
  fontSize: "inherit"
}, nM = {
  width: 14,
  height: 14,
  overflow: "hidden",
  lineHeight: "normal",
  fontSize: "inherit"
}, iM = ({ type: r }) => {
  const e = r === "player" ? rM : nM;
  return /* @__PURE__ */ y.jsxs(y.Fragment, {
    children: [
      /* @__PURE__ */ y.jsx("style", {
        type: "text/css",
        children: `
				@keyframes ${Zv} {
          0% {
            rotate: 0deg;
          }
          100% {
            rotate: 360deg;
          }
        }
        
        .${Kv} {
            animation: ${Zv} 1s linear infinite;
        }        
			`
      }),
      /* @__PURE__ */ y.jsx("div", {
        style: e,
        children: /* @__PURE__ */ y.jsx("svg", {
          viewBox: r === "player" ? "0 0 22 22" : "0 0 18 18",
          style: e,
          className: Kv,
          children: /* @__PURE__ */ y.jsx("path", {
            d: r === "player" ? "M 11 4 A 7 7 0 0 1 15.1145 16.66312" : "M 9 2 A 7 7 0 0 1 13.1145 14.66312",
            stroke: "white",
            strokeLinecap: "round",
            fill: "none",
            strokeWidth: 3
          })
        })
      })
    ]
  });
}, sM = ({
  currentSize: r,
  width: e,
  height: t,
  compositionWidth: n,
  compositionHeight: i
}) => e !== void 0 && t === void 0 ? {
  aspectRatio: [n, i].join("/")
} : t !== void 0 && e === void 0 ? {
  aspectRatio: [n, i].join("/")
} : r ? {
  width: n,
  height: i
} : {
  width: n,
  height: i
}, Eb = ({
  previewSize: r,
  compositionWidth: e,
  compositionHeight: t,
  canvasSize: n
}) => {
  const i = Te.calculateScale({
    canvasSize: n,
    compositionHeight: t,
    compositionWidth: e,
    previewSize: r
  }), s = 0 - (1 - i) / 2, a = s * e, c = s * t, u = e * i, h = t * i, d = n.width / 2 - u / 2, p = n.height / 2 - h / 2;
  return {
    centerX: d,
    centerY: p,
    xCorrection: a,
    yCorrection: c,
    scale: i
  };
}, kb = ({
  config: r,
  style: e,
  canvasSize: t,
  overflowVisible: n,
  layout: i
}) => r ? {
  position: "relative",
  overflow: n ? "visible" : "hidden",
  ...sM({
    compositionHeight: r.height,
    compositionWidth: r.width,
    currentSize: t,
    height: e?.height,
    width: e?.width
  }),
  opacity: i ? 1 : 0,
  ...e
} : {}, Ob = ({
  config: r,
  canvasSize: e,
  layout: t,
  scale: n,
  overflowVisible: i
}) => !r || !e || !t ? {} : {
  position: "absolute",
  width: r.width,
  height: r.height,
  display: "flex",
  transform: `scale(${n})`,
  marginLeft: t.xCorrection,
  marginTop: t.yCorrection,
  overflow: i ? "visible" : "hidden"
}, Ib = ({
  layout: r,
  scale: e,
  config: t,
  overflowVisible: n
}) => {
  if (!r || !t)
    return {};
  const { centerX: i, centerY: s } = r;
  return {
    width: t.width * e,
    height: t.height * e,
    display: "flex",
    flexDirection: "column",
    position: "absolute",
    left: i,
    top: s,
    overflow: n ? "visible" : "hidden"
  };
}, Ab = Ce.createContext(void 0), Mb = Ce.createContext(void 0);
class oM {
  listeners = {
    ended: [],
    error: [],
    pause: [],
    play: [],
    ratechange: [],
    scalechange: [],
    seeked: [],
    timeupdate: [],
    frameupdate: [],
    fullscreenchange: [],
    volumechange: [],
    mutechange: [],
    waiting: [],
    resume: []
  };
  addEventListener(e, t) {
    this.listeners[e].push(t);
  }
  removeEventListener(e, t) {
    this.listeners[e] = this.listeners[e].filter((n) => n !== t);
  }
  dispatchEvent(e, t) {
    this.listeners[e].forEach((n) => {
      n({ detail: t });
    });
  }
  dispatchSeek(e) {
    this.dispatchEvent("seeked", {
      frame: e
    });
  }
  dispatchVolumeChange(e) {
    this.dispatchEvent("volumechange", {
      volume: e
    });
  }
  dispatchPause() {
    this.dispatchEvent("pause", void 0);
  }
  dispatchPlay() {
    this.dispatchEvent("play", void 0);
  }
  dispatchEnded() {
    this.dispatchEvent("ended", void 0);
  }
  dispatchRateChange(e) {
    this.dispatchEvent("ratechange", {
      playbackRate: e
    });
  }
  dispatchScaleChange(e) {
    this.dispatchEvent("scalechange", {
      scale: e
    });
  }
  dispatchError(e) {
    this.dispatchEvent("error", {
      error: e
    });
  }
  dispatchTimeUpdate(e) {
    this.dispatchEvent("timeupdate", e);
  }
  dispatchFrameUpdate(e) {
    this.dispatchEvent("frameupdate", e);
  }
  dispatchFullscreenChange(e) {
    this.dispatchEvent("fullscreenchange", e);
  }
  dispatchMuteChange(e) {
    this.dispatchEvent("mutechange", e);
  }
  dispatchWaiting(e) {
    this.dispatchEvent("waiting", e);
  }
  dispatchResume(e) {
    this.dispatchEvent("resume", e);
  }
}
class aM {
  listeners = {
    error: [],
    waiting: [],
    resume: []
  };
  addEventListener(e, t) {
    this.listeners[e].push(t);
  }
  removeEventListener(e, t) {
    this.listeners[e] = this.listeners[e].filter((n) => n !== t);
  }
  dispatchEvent(e, t) {
    this.listeners[e].forEach((n) => {
      n({ detail: t });
    });
  }
  dispatchError(e) {
    this.dispatchEvent("error", {
      error: e
    });
  }
  dispatchWaiting(e) {
    this.dispatchEvent("waiting", e);
  }
  dispatchResume(e) {
    this.dispatchEvent("resume", e);
  }
}
var Pb = (r) => {
  const e = me(Te.BufferingContextReact);
  if (!e)
    throw new Error("BufferingContextReact not found");
  ce(() => {
    const t = e.listenForBuffering(() => {
      e.buffering.current = !0, r.dispatchWaiting({});
    }), n = e.listenForResume(() => {
      e.buffering.current = !1, r.dispatchResume({});
    });
    return () => {
      t.remove(), n.remove();
    };
  }, [e, r]);
}, cM = ({ children: r, currentPlaybackRate: e }) => {
  const [t] = ue(() => new oM());
  if (!me(Te.BufferingContextReact))
    throw new Error("BufferingContextReact not found");
  return ce(() => {
    e && t.dispatchRateChange(e);
  }, [t, e]), Pb(t), /* @__PURE__ */ y.jsx(Ab.Provider, {
    value: t,
    children: r
  });
}, Yf = (r, e) => {
  const [t, n] = ue(!1);
  return ce(() => {
    const { current: i } = r;
    if (!i)
      return;
    let s;
    const a = () => {
      e && (clearTimeout(s), s = setTimeout(() => {
        n(!1);
      }, e === !0 ? 3e3 : e));
    }, c = () => {
      n(!0), a();
    }, u = () => {
      n(!1), clearTimeout(s);
    }, h = () => {
      n(!0), a();
    };
    return i.addEventListener("mouseenter", c), i.addEventListener("mouseleave", u), i.addEventListener("mousemove", h), () => {
      i.removeEventListener("mouseenter", c), i.removeEventListener("mouseleave", u), i.removeEventListener("mousemove", h), clearTimeout(s);
    };
  }, [e, r]), t;
}, Ql = () => {
  const [r, e, t] = Te.Timeline.usePlayingState(), [n, i] = ue(!1), s = Te.Timeline.useTimelinePosition(), a = be(s), c = Te.Timeline.useTimelineSetFrame(), u = Te.Timeline.useTimelineSetFrame(), h = me(Te.SharedAudioContext), { audioAndVideoTags: d } = me(Te.Timeline.TimelineContext), p = be(s);
  p.current = s;
  const g = Te.useVideo(), v = Te.useUnsafeVideoConfig(), b = me(Ab), x = (v?.durationInFrames ?? 1) - 1, _ = s === x, C = s === 0;
  if (!b)
    throw new TypeError("Expected Player event emitter context");
  const E = me(Te.BufferingContextReact);
  if (!E)
    throw new Error("Missing the buffering context. Most likely you have a Remotion version mismatch.");
  const { buffering: k } = E, O = se((H) => {
    g?.id && u((Y) => ({ ...Y, [g.id]: H })), p.current = H, b.dispatchSeek(H);
  }, [b, u, g?.id]), P = se((H) => {
    t.current || (i(!0), _ && O(0), h && h.numberOfAudioTags > 0 && H && h.playAllAudios(), d.current.forEach((Y) => Y.play()), t.current = !0, e(!0), a.current = p.current, b.dispatchPlay());
  }, [
    t,
    _,
    h,
    e,
    b,
    O,
    d
  ]), R = se(() => {
    t.current && (t.current = !1, e(!1), b.dispatchPause());
  }, [b, t, e]), V = se(() => {
    t.current && (t.current = !1, p.current = a.current, v && (u((H) => ({
      ...H,
      [v.id]: a.current
    })), e(!1), b.dispatchPause()));
  }, [v, b, t, e, u]), F = g?.id, $ = se((H) => {
    if (!F)
      return null;
    t.current || c((Y) => {
      const te = Y[F] ?? window.remotion_initialFrame ?? 0;
      return {
        ...Y,
        [F]: Math.max(0, te - H)
      };
    });
  }, [t, c, F]), z = se((H) => {
    if (!F)
      return null;
    t.current || c((Y) => {
      const te = Y[F] ?? window.remotion_initialFrame ?? 0;
      return {
        ...Y,
        [F]: Math.min(x, te + H)
      };
    });
  }, [F, t, x, c]);
  return ee(() => ({
    frameBack: $,
    frameForward: z,
    isLastFrame: _,
    emitter: b,
    playing: r,
    play: P,
    pause: R,
    seek: O,
    isFirstFrame: C,
    getCurrentFrame: () => p.current,
    isPlaying: () => t.current,
    isBuffering: () => k.current,
    pauseAndReturnToPlayStart: V,
    hasPlayed: n,
    remotionInternal_currentFrameRef: p
  }), [
    $,
    z,
    _,
    b,
    r,
    P,
    R,
    O,
    C,
    V,
    n,
    t,
    k
  ]);
}, lM = ({
  browserMediaControlsBehavior: r,
  videoConfig: e,
  playbackRate: t
}) => {
  const { playing: n, pause: i, play: s, emitter: a, getCurrentFrame: c, seek: u } = Ql();
  ce(() => {
    navigator.mediaSession && r.mode !== "do-nothing" && (n ? navigator.mediaSession.playbackState = "playing" : navigator.mediaSession.playbackState = "paused");
  }, [r.mode, n]), ce(() => {
    if (!navigator.mediaSession || r.mode === "do-nothing")
      return;
    const h = () => {
      e && navigator.mediaSession && navigator.mediaSession.setPositionState({
        duration: e.durationInFrames / e.fps,
        playbackRate: t,
        position: c() / e.fps
      });
    };
    return a.addEventListener("timeupdate", h), () => {
      a.removeEventListener("timeupdate", h);
    };
  }, [
    r.mode,
    a,
    c,
    t,
    e
  ]), ce(() => {
    if (navigator.mediaSession && r.mode !== "do-nothing")
      return navigator.mediaSession.setActionHandler("play", () => {
        r.mode === "register-media-session" && s();
      }), navigator.mediaSession.setActionHandler("pause", () => {
        r.mode === "register-media-session" && i();
      }), navigator.mediaSession.setActionHandler("seekto", (h) => {
        r.mode === "register-media-session" && h.seekTime !== void 0 && e && u(Math.round(h.seekTime * e.fps));
      }), navigator.mediaSession.setActionHandler("seekbackward", () => {
        r.mode === "register-media-session" && e && u(Math.max(0, Math.round((c() - 10) * e.fps)));
      }), navigator.mediaSession.setActionHandler("seekforward", () => {
        r.mode === "register-media-session" && e && u(Math.max(e.durationInFrames - 1, Math.round((c() + 10) * e.fps)));
      }), navigator.mediaSession.setActionHandler("previoustrack", () => {
        r.mode === "register-media-session" && u(0);
      }), () => {
        navigator.mediaSession.metadata = null, navigator.mediaSession.setActionHandler("play", null), navigator.mediaSession.setActionHandler("pause", null), navigator.mediaSession.setActionHandler("seekto", null), navigator.mediaSession.setActionHandler("seekbackward", null), navigator.mediaSession.setActionHandler("seekforward", null), navigator.mediaSession.setActionHandler("previoustrack", null);
      };
  }, [
    r.mode,
    c,
    i,
    s,
    u,
    e
  ]);
}, uM = ({
  time: r,
  currentFrame: e,
  playbackSpeed: t,
  fps: n,
  actualLastFrame: i,
  actualFirstFrame: s,
  framesAdvanced: a,
  shouldLoop: c
}) => {
  const h = (t < 0 ? Math.ceil : Math.floor)(r * t / (1e3 / n)) - a, d = h + e, p = e > i || e < s, g = d > i || d < s, v = !c && g && !p;
  return t > 0 ? g ? {
    nextFrame: s,
    framesToAdvance: h,
    hasEnded: v
  } : { nextFrame: d, framesToAdvance: h, hasEnded: v } : g ? { nextFrame: i, framesToAdvance: h, hasEnded: v } : { nextFrame: d, framesToAdvance: h, hasEnded: v };
}, Jv = () => typeof document > "u" ? !1 : document.visibilityState === "hidden", hM = () => {
  const r = be(Jv());
  return ce(() => {
    const e = () => {
      r.current = Jv();
    };
    return document.addEventListener("visibilitychange", e), () => {
      document.removeEventListener("visibilitychange", e);
    };
  }, []), r;
}, dM = ({
  loop: r,
  playbackRate: e,
  moveToBeginningWhenEnded: t,
  inFrame: n,
  outFrame: i,
  frameRef: s,
  browserMediaControlsBehavior: a
}) => {
  const c = Te.useUnsafeVideoConfig(), u = Te.Timeline.useTimelinePosition(), { playing: h, pause: d, emitter: p } = Ql(), g = Te.Timeline.useTimelineSetFrame(), v = be(null), b = hM(), x = be(null), _ = me(Te.BufferingContextReact);
  if (!_)
    throw new Error("Missing the buffering context. Most likely you have a Remotion version mismatch.");
  lM({
    browserMediaControlsBehavior: a,
    playbackRate: e,
    videoConfig: c
  }), ce(() => {
    const C = _.listenForBuffering(() => {
      v.current = performance.now();
    }), E = _.listenForResume(() => {
      v.current = null;
    });
    return () => {
      C.remove(), E.remove();
    };
  }, [_]), ce(() => {
    if (!c || !h)
      return;
    let C = !1, E = null, k = performance.now(), O = 0;
    const P = () => {
      E !== null && (E.type === "raf" ? cancelAnimationFrame(E.id) : clearTimeout(E.id));
    }, R = () => {
      C = !0, P();
    }, V = () => {
      const z = performance.now() - k, G = i ?? c.durationInFrames - 1, H = n ?? 0, Y = s.current, { nextFrame: te, framesToAdvance: ge, hasEnded: Z } = uM({
        time: z,
        currentFrame: Y,
        playbackSpeed: e,
        fps: c.fps,
        actualFirstFrame: H,
        actualLastFrame: G,
        framesAdvanced: O,
        shouldLoop: r
      });
      if (O += ge, te !== s.current && (!Z || t) && g((de) => ({ ...de, [c.id]: te })), Z) {
        R(), d(), p.dispatchEnded();
        return;
      }
      C || F();
    }, F = () => {
      if (v.current) {
        const z = _.listenForResume(() => {
          z.remove(), !C && (k = performance.now(), O = 0, V());
        });
        return;
      }
      b.current ? E = {
        type: "timeout",
        id: setTimeout(V, 1e3 / c.fps)
      } : E = { type: "raf", id: requestAnimationFrame(V) };
    };
    F();
    const $ = () => {
      document.visibilityState !== "visible" && (P(), V());
    };
    return window.addEventListener("visibilitychange", $), () => {
      window.removeEventListener("visibilitychange", $), R();
    };
  }, [
    c,
    r,
    d,
    h,
    g,
    p,
    e,
    n,
    i,
    t,
    b,
    s,
    v,
    _
  ]), ce(() => {
    const C = setInterval(() => {
      x.current !== s.current && (p.dispatchTimeUpdate({ frame: s.current }), x.current = s.current);
    }, 250);
    return () => clearInterval(C);
  }, [p, s]), ce(() => {
    p.dispatchFrameUpdate({ frame: u });
  }, [p, u]);
}, Wh = [], Xf = (r, e) => {
  const [t, n] = ue(() => {
    if (!r.current)
      return null;
    const a = r.current.getClientRects();
    return a[0] ? {
      width: a[0].width,
      height: a[0].height,
      left: a[0].x,
      top: a[0].y,
      windowSize: {
        height: window.innerHeight,
        width: window.innerWidth
      }
    } : null;
  }), i = ee(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((a) => {
    const { contentRect: c, target: u } = a[0], h = u.getClientRects();
    if (!h?.[0]) {
      n(null);
      return;
    }
    const d = c.width === 0 ? 1 : h[0].width / c.width, p = e.shouldApplyCssTransforms ? h[0].width : h[0].width * (1 / d), g = e.shouldApplyCssTransforms ? h[0].height : h[0].height * (1 / d);
    n({
      width: p,
      height: g,
      left: h[0].x,
      top: h[0].y,
      windowSize: {
        height: window.innerHeight,
        width: window.innerWidth
      }
    });
  }), [e.shouldApplyCssTransforms]), s = se(() => {
    if (!r.current)
      return;
    const a = r.current.getClientRects();
    if (!a[0]) {
      n(null);
      return;
    }
    n((c) => c && c.width === a[0].width && c.height === a[0].height && c.left === a[0].x && c.top === a[0].y && c.windowSize.height === window.innerHeight && c.windowSize.width === window.innerWidth ? c : {
      width: a[0].width,
      height: a[0].height,
      left: a[0].x,
      top: a[0].y,
      windowSize: {
        height: window.innerHeight,
        width: window.innerWidth
      }
    });
  }, [r]);
  return ce(() => {
    if (!i)
      return;
    const { current: a } = r;
    return a && i.observe(a), () => {
      a && i.unobserve(a);
    };
  }, [i, r, s]), ce(() => {
    if (e.triggerOnWindowResize)
      return window.addEventListener("resize", s), () => {
        window.removeEventListener("resize", s);
      };
  }, [e.triggerOnWindowResize, s]), ce(() => (Wh.push(s), () => {
    Wh = Wh.filter((a) => a !== s);
  }), [s]), ee(() => t ? { ...t, refresh: s } : null, [t, s]);
}, Qv = ({ playing: r, buffering: e }) => r && e ? /* @__PURE__ */ y.jsx(iM, {
  type: "player"
}) : r ? /* @__PURE__ */ y.jsx(JA, {}) : /* @__PURE__ */ y.jsx(ZA, {}), js = 12, e0 = 5, fM = ({
  volume: r,
  isVertical: e,
  onBlur: t,
  inputRef: n,
  setVolume: i
}) => {
  const s = ee(() => {
    const g = {
      paddingLeft: 5,
      height: Xt,
      width: qi,
      display: "inline-flex",
      alignItems: "center"
    };
    return e ? {
      ...g,
      position: "absolute",
      transform: `rotate(-90deg) translateX(${qi / 2 + Xt / 2}px)`
    } : {
      ...g
    };
  }, [e]), a = typeof Ce.useId > "u" ? "volume-slider" : Ce.useId(), [c] = ue(() => `__remotion-volume-slider-${fs(a)}`.replace(".", "")), u = se((p) => {
    i(parseFloat(p.target.value));
  }, [i]), h = ee(() => {
    const p = {
      WebkitAppearance: "none",
      backgroundColor: "rgba(255, 255, 255, 0.5)",
      borderRadius: e0 / 2,
      cursor: "pointer",
      height: e0,
      width: qi,
      backgroundImage: `linear-gradient(
				to right,
				white ${r * 100}%, rgba(255, 255, 255, 0) ${r * 100}%
			)`
    };
    return e ? {
      ...p,
      bottom: Xt + qi / 2
    } : p;
  }, [e, r]), d = `
	.${c}::-webkit-slider-thumb {
		-webkit-appearance: none;
		background-color: white;
		border-radius: ${js / 2}px;
		box-shadow: 0 0 2px black;
		height: ${js}px;
		width: ${js}px;
	}

	.${c}::-moz-range-thumb {
		-webkit-appearance: none;
		background-color: white;
		border-radius: ${js / 2}px;
		box-shadow: 0 0 2px black;
		height: ${js}px;
		width: ${js}px;
	}
`;
  return /* @__PURE__ */ y.jsxs("div", {
    style: s,
    children: [
      /* @__PURE__ */ y.jsx("style", {
        dangerouslySetInnerHTML: {
          __html: d
        }
      }),
      /* @__PURE__ */ y.jsx("input", {
        ref: n,
        "aria-label": "Change volume",
        className: c,
        max: 1,
        min: 0,
        onBlur: t,
        onChange: u,
        step: 0.01,
        type: "range",
        value: r,
        style: h
      })
    ]
  });
}, pM = (r) => /* @__PURE__ */ y.jsx(fM, {
  ...r
}), qi = 100, gM = ({ displayVerticalVolumeSlider: r, renderMuteButton: e, renderVolumeSlider: t }) => {
  const [n, i] = Te.useMediaMutedState(), [s, a] = Te.useMediaVolumeState(), [c, u] = ue(!1), h = be(null), d = be(null), p = Yf(h, !1), g = se(() => {
    setTimeout(() => {
      d.current && document.activeElement !== d.current && u(!1);
    }, 10);
  }, []), v = s === 0, b = se(() => {
    if (v) {
      a(1), i(!1);
      return;
    }
    i((O) => !O);
  }, [v, i, a]), x = ee(() => ({
    display: "inline-flex",
    background: "none",
    border: "none",
    justifyContent: "center",
    alignItems: "center",
    touchAction: "none",
    ...r && { position: "relative" }
  }), [r]), _ = ee(() => ({
    display: "inline",
    width: Xt,
    height: Xt,
    cursor: "pointer",
    appearance: "none",
    background: "none",
    border: "none",
    padding: 0
  }), []), C = se(({ muted: O, volume: P }) => {
    const R = O || P === 0;
    return /* @__PURE__ */ y.jsx("button", {
      "aria-label": R ? "Unmute sound" : "Mute sound",
      title: R ? "Unmute sound" : "Mute sound",
      onClick: b,
      onBlur: g,
      onFocus: () => u(!0),
      style: _,
      type: "button",
      children: R ? /* @__PURE__ */ y.jsx(eM, {}) : /* @__PURE__ */ y.jsx(tM, {})
    });
  }, [g, b, _]), E = ee(() => e ? e({ muted: n, volume: s }) : C({ muted: n, volume: s }), [n, s, C, e]), k = ee(() => (c || p) && !n && !Te.isIosSafari() ? (t ?? pM)({
    isVertical: r,
    volume: s,
    onBlur: () => u(!1),
    inputRef: d,
    setVolume: a
  }) : null, [
    r,
    c,
    p,
    n,
    s,
    t,
    a
  ]);
  return /* @__PURE__ */ y.jsxs("div", {
    ref: h,
    style: x,
    children: [
      E,
      k
    ]
  });
};
function mM(r) {
  const [e, t] = ue(r), n = be(null);
  return ce(() => {
    const i = (s) => {
      n.current && !n.current.contains(s.target) && t(!1);
    };
    return document.addEventListener("pointerup", i, !0), () => {
      document.removeEventListener("pointerup", i, !0);
    };
  }, []), { ref: n, isComponentVisible: e, setIsComponentVisible: t };
}
var vM = 35, yM = 70, bM = {
  height: 30,
  paddingRight: 15,
  paddingLeft: 12,
  display: "flex",
  flexDirection: "row",
  alignItems: "center"
}, wM = {
  width: 22,
  display: "flex",
  alignItems: "center"
}, xM = {
  width: 14,
  height: 14,
  color: "black"
}, _M = () => /* @__PURE__ */ y.jsx("svg", {
  viewBox: "0 0 512 512",
  style: xM,
  children: /* @__PURE__ */ y.jsx("path", {
    fill: "currentColor",
    d: "M435.848 83.466L172.804 346.51l-96.652-96.652c-4.686-4.686-12.284-4.686-16.971 0l-28.284 28.284c-4.686 4.686-4.686 12.284 0 16.971l133.421 133.421c4.686 4.686 12.284 4.686 16.971 0l299.813-299.813c4.686-4.686 4.686-12.284 0-16.971l-28.284-28.284c-4.686-4.686-12.284-4.686-16.97 0z"
  })
}), SM = ({ rate: r, onSelect: e, selectedRate: t, keyboardSelectedRate: n }) => {
  const i = se((p) => {
    p.stopPropagation(), p.preventDefault(), e(r);
  }, [e, r]), [s, a] = ue(!1), c = se(() => {
    a(!0);
  }, []), u = se(() => {
    a(!1);
  }, []), h = n === r, d = ee(() => ({
    ...bM,
    backgroundColor: s || h ? "#eee" : "transparent"
  }), [s, h]);
  return /* @__PURE__ */ y.jsxs("div", {
    onMouseEnter: c,
    onMouseLeave: u,
    tabIndex: 0,
    style: d,
    onClick: i,
    children: [
      /* @__PURE__ */ y.jsx("div", {
        style: wM,
        children: r === t ? /* @__PURE__ */ y.jsx(_M, {}) : null
      }),
      r.toFixed(1),
      "x"
    ]
  }, r);
}, CM = ({ setIsComponentVisible: r, playbackRates: e, canvasSize: t }) => {
  const { setPlaybackRate: n, playbackRate: i } = me(Te.Timeline.TimelineContext), [s, a] = ue(i);
  ce(() => {
    const h = (d) => {
      if (d.preventDefault(), d.key === "ArrowUp") {
        const p = e.findIndex((g) => g === s);
        if (p === 0)
          return;
        a(p === -1 ? e[0] : e[p - 1]);
      } else if (d.key === "ArrowDown") {
        const p = e.findIndex((g) => g === s);
        if (p === e.length - 1)
          return;
        a(p === -1 ? e[e.length - 1] : e[p + 1]);
      } else d.key === "Enter" && (n(s), r(!1));
    };
    return window.addEventListener("keydown", h), () => {
      window.removeEventListener("keydown", h);
    };
  }, [
    e,
    s,
    n,
    r
  ]);
  const c = se((h) => {
    n(h), r(!1);
  }, [r, n]), u = ee(() => ({
    position: "absolute",
    right: 0,
    width: 125,
    maxHeight: t.height - yM - vM,
    bottom: 35,
    background: "#fff",
    borderRadius: 4,
    overflow: "auto",
    color: "black",
    textAlign: "left"
  }), [t.height]);
  return /* @__PURE__ */ y.jsx("div", {
    style: u,
    children: e.map((h) => /* @__PURE__ */ y.jsx(SM, {
      selectedRate: i,
      onSelect: c,
      rate: h,
      keyboardSelectedRate: s
    }, h))
  });
}, TM = {
  fontSize: 13,
  fontWeight: "bold",
  color: "white",
  border: "2px solid white",
  borderRadius: 20,
  paddingLeft: 8,
  paddingRight: 8,
  paddingTop: 2,
  paddingBottom: 2
}, Nd = {
  appearance: "none",
  backgroundColor: "transparent",
  border: "none",
  cursor: "pointer",
  paddingLeft: 0,
  paddingRight: 0,
  paddingTop: 6,
  paddingBottom: 6,
  height: 37,
  display: "inline-flex",
  marginBottom: 0,
  marginTop: 0,
  alignItems: "center"
}, EM = {
  ...Nd,
  position: "relative"
}, kM = ({ playbackRates: r, canvasSize: e }) => {
  const { ref: t, isComponentVisible: n, setIsComponentVisible: i } = mM(!1), { playbackRate: s } = me(Te.Timeline.TimelineContext), a = se((c) => {
    c.stopPropagation(), c.preventDefault(), i((u) => !u);
  }, [i]);
  return /* @__PURE__ */ y.jsx("div", {
    ref: t,
    children: /* @__PURE__ */ y.jsxs("button", {
      type: "button",
      "aria-label": "Change playback rate",
      style: EM,
      onClick: a,
      children: [
        /* @__PURE__ */ y.jsxs("div", {
          style: TM,
          children: [
            s,
            "x"
          ]
        }),
        n && /* @__PURE__ */ y.jsx(CM, {
          canvasSize: e,
          playbackRates: r,
          setIsComponentVisible: i
        })
      ]
    })
  });
}, t0 = (r, e, t) => Math.round(cb(r, [0, t], [0, e - 1], {
  extrapolateLeft: "clamp",
  extrapolateRight: "clamp"
})), Ns = 5, Bo = 12, Bd = 4, OM = {
  userSelect: "none",
  WebkitUserSelect: "none",
  paddingTop: Bd,
  paddingBottom: Bd,
  boxSizing: "border-box",
  cursor: "pointer",
  position: "relative",
  touchAction: "none"
}, IM = {
  height: Ns,
  backgroundColor: "rgba(255, 255, 255, 0.25)",
  width: "100%",
  borderRadius: Ns / 2
}, AM = (r) => {
  let e = r;
  for (; e.parentElement; )
    e = e.parentElement;
  return e;
}, MM = ({ durationInFrames: r, onSeekEnd: e, onSeekStart: t, inFrame: n, outFrame: i }) => {
  const s = be(null), a = Yf(s, !1), c = Xf(s, {
    triggerOnWindowResize: !0,
    shouldApplyCssTransforms: !0
  }), { seek: u, play: h, pause: d, playing: p } = Ql(), g = Te.Timeline.useTimelinePosition(), [v, b] = ue({
    dragging: !1
  }), x = c?.width ?? 0, _ = se((R) => {
    if (R.button !== 0)
      return;
    const V = s.current?.getBoundingClientRect().left, F = t0(R.clientX - V, r, x);
    d(), u(F), b({
      dragging: !0,
      wasPlaying: p
    }), t();
  }, [r, x, d, u, p, t]), C = se((R) => {
    if (!c)
      throw new Error("Player has no size");
    if (!v.dragging)
      return;
    const V = s.current?.getBoundingClientRect().left, F = t0(R.clientX - V, r, c.width);
    u(F);
  }, [v.dragging, r, u, c]), E = se(() => {
    b({
      dragging: !1
    }), v.dragging && (v.wasPlaying ? h() : d(), e());
  }, [v, e, d, h]);
  ce(() => {
    if (!v.dragging)
      return;
    const R = AM(s.current);
    return R.addEventListener("pointermove", C), R.addEventListener("pointerup", E), () => {
      R.removeEventListener("pointermove", C), R.removeEventListener("pointerup", E);
    };
  }, [v.dragging, C, E]);
  const k = ee(() => ({
    height: Bo,
    width: Bo,
    borderRadius: Bo / 2,
    position: "absolute",
    top: Bd - Bo / 2 + 5 / 2,
    backgroundColor: "white",
    left: Math.max(0, g / Math.max(1, r - 1) * x - Bo / 2),
    boxShadow: "0 0 2px black",
    opacity: Number(a)
  }), [a, r, g, x]), O = ee(() => ({
    height: Ns,
    backgroundColor: "rgba(255, 255, 255, 1)",
    width: (g - (n ?? 0)) / (r - 1) * 100 + "%",
    marginLeft: (n ?? 0) / (r - 1) * 100 + "%",
    borderRadius: Ns / 2
  }), [r, g, n]), P = ee(() => ({
    height: Ns,
    backgroundColor: "rgba(255, 255, 255, 0.25)",
    width: ((i ?? r - 1) - (n ?? 0)) / (r - 1) * 100 + "%",
    marginLeft: (n ?? 0) / (r - 1) * 100 + "%",
    borderRadius: Ns / 2,
    position: "absolute"
  }), [r, n, i]);
  return /* @__PURE__ */ y.jsxs("div", {
    ref: s,
    onPointerDown: _,
    style: OM,
    children: [
      /* @__PURE__ */ y.jsxs("div", {
        style: IM,
        children: [
          /* @__PURE__ */ y.jsx("div", {
            style: P
          }),
          /* @__PURE__ */ y.jsx("div", {
            style: O
          })
        ]
      }),
      /* @__PURE__ */ y.jsx("div", {
        style: k
      })
    ]
  });
}, r0 = (r) => {
  const e = Math.floor(r / 60), t = Math.floor(r - e * 60);
  return `${String(e)}:${String(t).padStart(2, "0")}`;
}, PM = 10, Vd = 12, DM = ({
  allowFullscreen: r,
  playerWidth: e
}) => ee(() => {
  const n = Xt, i = Xt, s = r ? Ld : 0, a = i + n + s + Vd * 2 + PM * 2, c = e - a, u = Math.max(c, 0), h = u - qi, p = (h < qi ? u : h) + a + qi, g = e < p;
  return {
    maxTimeLabelWidth: u === 0 ? null : u,
    displayVerticalVolumeSlider: g
  };
}, [r, e]), jM = [
  0,
  0.013,
  0.049,
  0.104,
  0.175,
  0.259,
  0.352,
  0.45,
  0.55,
  0.648,
  0.741,
  0.825,
  0.896,
  0.951,
  0.987
], RM = [
  0,
  8.1,
  15.5,
  22.5,
  29,
  35.3,
  41.2,
  47.1,
  52.9,
  58.8,
  64.7,
  71,
  77.5,
  84.5,
  91.9
], FM = 1 / 0.7, LM = {
  boxSizing: "border-box",
  position: "absolute",
  bottom: 0,
  width: "100%",
  paddingTop: 40,
  paddingBottom: 10,
  backgroundImage: `linear-gradient(to bottom,${jM.map((r, e) => `hsla(0, 0%, 0%, ${r}) ${RM[e] * FM}%`).join(", ")}, hsl(0, 0%, 0%) 100%)`,
  backgroundSize: "auto 145px",
  display: "flex",
  paddingRight: Vd,
  paddingLeft: Vd,
  flexDirection: "column",
  transition: "opacity 0.3s"
}, NM = {
  display: "flex",
  flexDirection: "row",
  width: "100%",
  alignItems: "center",
  justifyContent: "center",
  userSelect: "none",
  WebkitUserSelect: "none"
}, BM = {
  display: "flex",
  flexDirection: "row",
  userSelect: "none",
  WebkitUserSelect: "none",
  alignItems: "center"
}, Cc = {
  width: 12
}, VM = {
  height: 8
}, zM = {
  flex: 1
}, WM = {}, HM = ({
  durationInFrames: r,
  isFullscreen: e,
  fps: t,
  player: n,
  showVolumeControls: i,
  onFullscreenButtonClick: s,
  allowFullscreen: a,
  onExitFullscreenButtonClick: c,
  spaceKeyToPlayOrPause: u,
  onSeekEnd: h,
  onSeekStart: d,
  inFrame: p,
  outFrame: g,
  initiallyShowControls: v,
  canvasSize: b,
  renderPlayPauseButton: x,
  renderFullscreenButton: _,
  alwaysShowControls: C,
  showPlaybackRateControl: E,
  containerRef: k,
  buffering: O,
  hideControlsWhenPointerDoesntMove: P,
  onPointerDown: R,
  onDoubleClick: V,
  renderMuteButton: F,
  renderVolumeSlider: $
}) => {
  const z = be(null), G = Te.Timeline.useTimelinePosition(), [H, Y] = ue(!1), te = Yf(k, P), { maxTimeLabelWidth: ge, displayVerticalVolumeSlider: Z } = DM({
    allowFullscreen: a,
    playerWidth: b?.width ?? 0
  }), [de, oe] = ue(() => {
    if (typeof v == "boolean")
      return v;
    if (typeof v == "number") {
      if (v % 1 !== 0)
        throw new Error("initiallyShowControls must be an integer or a boolean");
      if (Number.isNaN(v))
        throw new Error("initiallyShowControls must not be NaN");
      if (!Number.isFinite(v))
        throw new Error("initiallyShowControls must be finite");
      if (v <= 0)
        throw new Error("initiallyShowControls must be a positive integer");
      return v;
    }
    throw new TypeError("initiallyShowControls must be a number or a boolean");
  }), ie = ee(() => {
    const Ie = te || !n.playing || de || C;
    return {
      ...LM,
      opacity: Number(Ie)
    };
  }, [te, de, n.playing, C]);
  ce(() => {
    z.current && u && z.current.focus({
      preventScroll: !0
    });
  }, [n.playing, u]), ce(() => {
    Y((typeof document < "u" && (document.fullscreenEnabled || document.webkitFullscreenEnabled)) ?? !1);
  }, []), ce(() => {
    if (de === !1)
      return;
    const dt = setTimeout(() => {
      oe(!1);
    }, de === !0 ? 2e3 : de);
    return () => {
      clearInterval(dt);
    };
  }, [de]);
  const pe = ee(() => ({
    color: "white",
    fontFamily: "sans-serif",
    fontSize: 14,
    maxWidth: ge === null ? void 0 : ge,
    overflow: "hidden",
    textOverflow: "ellipsis"
  }), [ge]), re = ee(() => {
    if (E === !0)
      return [0.5, 0.8, 1, 1.2, 1.5, 1.8, 2, 2.5, 3];
    if (Array.isArray(E)) {
      for (const Ie of E) {
        if (typeof Ie != "number")
          throw new Error("Every item in showPlaybackRateControl must be a number");
        if (Ie <= 0)
          throw new Error("Every item in showPlaybackRateControl must be positive");
      }
      return E;
    }
    return null;
  }, [E]), Ve = be(null), Ze = be(null), We = se((Ie) => {
    (Ie.target === Ve.current || Ie.target === Ze.current) && R?.(Ie);
  }, [R]), Ee = se((Ie) => {
    (Ie.target === Ve.current || Ie.target === Ze.current) && V?.(Ie);
  }, [V]);
  return /* @__PURE__ */ y.jsxs("div", {
    ref: Ve,
    style: ie,
    onPointerDown: We,
    onDoubleClick: Ee,
    children: [
      /* @__PURE__ */ y.jsxs("div", {
        ref: Ze,
        style: NM,
        children: [
          /* @__PURE__ */ y.jsxs("div", {
            style: BM,
            children: [
              /* @__PURE__ */ y.jsx("button", {
                ref: z,
                type: "button",
                style: Nd,
                onClick: n.playing ? n.pause : n.play,
                "aria-label": n.playing ? "Pause video" : "Play video",
                title: n.playing ? "Pause video" : "Play video",
                children: x === null ? /* @__PURE__ */ y.jsx(Qv, {
                  buffering: O,
                  playing: n.playing
                }) : x({
                  playing: n.playing,
                  isBuffering: O
                }) ?? /* @__PURE__ */ y.jsx(Qv, {
                  buffering: O,
                  playing: n.playing
                })
              }),
              i ? /* @__PURE__ */ y.jsxs(y.Fragment, {
                children: [
                  /* @__PURE__ */ y.jsx("div", {
                    style: Cc
                  }),
                  /* @__PURE__ */ y.jsx(gM, {
                    renderMuteButton: F,
                    renderVolumeSlider: $,
                    displayVerticalVolumeSlider: Z
                  })
                ]
              }) : null,
              /* @__PURE__ */ y.jsx("div", {
                style: Cc
              }),
              /* @__PURE__ */ y.jsxs("div", {
                style: pe,
                children: [
                  r0(G / t),
                  " / ",
                  r0(r / t)
                ]
              }),
              /* @__PURE__ */ y.jsx("div", {
                style: Cc
              })
            ]
          }),
          /* @__PURE__ */ y.jsx("div", {
            style: zM
          }),
          re && b && /* @__PURE__ */ y.jsx(kM, {
            canvasSize: b,
            playbackRates: re
          }),
          re && H && a ? /* @__PURE__ */ y.jsx("div", {
            style: Cc
          }) : null,
          /* @__PURE__ */ y.jsx("div", {
            style: WM,
            children: H && a ? /* @__PURE__ */ y.jsx("button", {
              type: "button",
              "aria-label": e ? "Exit fullscreen" : "Enter Fullscreen",
              title: e ? "Exit fullscreen" : "Enter Fullscreen",
              style: Nd,
              onClick: e ? c : s,
              children: _ === null ? /* @__PURE__ */ y.jsx(QA, {
                isFullscreen: e
              }) : _({ isFullscreen: e })
            }) : null
          })
        ]
      }),
      /* @__PURE__ */ y.jsx("div", {
        style: VM
      }),
      /* @__PURE__ */ y.jsx(MM, {
        onSeekEnd: h,
        onSeekStart: d,
        durationInFrames: r,
        inFrame: p,
        outFrame: g
      })
    ]
  });
}, UM = {
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  flex: 1,
  height: "100%",
  width: "100%"
};
class Db extends Ce.Component {
  state = { hasError: null };
  static getDerivedStateFromError(e) {
    return { hasError: e };
  }
  componentDidCatch(e) {
    this.props.onError(e);
  }
  render() {
    return this.state.hasError ? /* @__PURE__ */ y.jsx("div", {
      style: UM,
      children: this.props.errorFallback({
        error: this.state.hasError
      })
    }) : this.props.children;
  }
}
var Gf = "__remotion-player", jb = typeof document > "u", $M = (r) => {
  let e = !1;
  return {
    promise: new Promise((n, i) => {
      r.then((s) => {
        if (e) {
          i({ isCanceled: e, value: s });
          return;
        }
        n(s);
      }).catch((s) => {
        i({ isCanceled: e, error: s });
      });
    }),
    cancel: () => {
      e = !0;
    }
  };
}, YM = (r) => new Promise((e) => setTimeout(e, r)), XM = () => {
  const r = be([]), e = se((s) => {
    r.current = [...r.current, s];
  }, []), t = se((s) => {
    r.current = r.current.filter((a) => a !== s);
  }, []), n = se(() => r.current.map((s) => s.cancel()), []);
  return ee(() => ({
    appendPendingPromise: e,
    removePendingPromise: t,
    clearPendingPromises: n
  }), [e, n, t]);
}, GM = (r, e, t) => {
  const n = XM(), i = se(async (u) => {
    if (u instanceof PointerEvent ? u.pointerType === "touch" : u.nativeEvent.pointerType === "touch") {
      r(u);
      return;
    }
    n.clearPendingPromises();
    const h = $M(YM(200));
    n.appendPendingPromise(h);
    try {
      await h.promise, n.removePendingPromise(h), r(u);
    } catch (d) {
      const p = d;
      if (n.removePendingPromise(h), !p.isCanceled)
        throw p.error;
    }
  }, [n, r]), s = se(() => {
    document.addEventListener("pointerup", (u) => {
      i(u);
    }, {
      once: !0
    });
  }, [i]), a = se(() => {
    n.clearPendingPromises(), e();
  }, [n, e]);
  return ee(() => t ? { handlePointerDown: s, handleDoubleClick: a } : { handlePointerDown: r, handleDoubleClick: () => {
  } }, [t, a, s, r]);
}, zd = Ce.version.split(".")[0];
if (zd === "0")
  throw new Error(`Version ${zd} of "react" is not supported by Remotion`);
var qM = parseInt(zd, 10) >= 18, KM = ({
  controls: r,
  style: e,
  loop: t,
  autoPlay: n,
  allowFullscreen: i,
  inputProps: s,
  clickToPlay: a,
  showVolumeControls: c,
  doubleClickToFullscreen: u,
  spaceKeyToPlayOrPause: h,
  errorFallback: d,
  playbackRate: p,
  renderLoading: g,
  renderPoster: v,
  className: b,
  moveToBeginningWhenEnded: x,
  showPosterWhenUnplayed: _,
  showPosterWhenEnded: C,
  showPosterWhenPaused: E,
  showPosterWhenBuffering: k,
  inFrame: O,
  outFrame: P,
  initiallyShowControls: R,
  renderFullscreen: V,
  renderPlayPauseButton: F,
  renderMuteButton: $,
  renderVolumeSlider: z,
  alwaysShowControls: G,
  showPlaybackRateControl: H,
  posterFillMode: Y,
  bufferStateDelayInMilliseconds: te,
  hideControlsWhenPointerDoesntMove: ge,
  overflowVisible: Z,
  browserMediaControlsBehavior: de
}, oe) => {
  const ie = Te.useUnsafeVideoConfig(), pe = Te.useVideo(), re = be(null), Ve = Xf(re, {
    triggerOnWindowResize: !1,
    shouldApplyCssTransforms: !1
  }), [Ze, We] = ue(!1), [Ee, Ie] = ue(n), [dt, hr] = ue(() => !1), [Ht, Pt] = ue(!1), dr = ee(() => typeof document > "u" ? !1 : !!(document.fullscreenEnabled || document.webkitFullscreenEnabled), []), ye = Ql();
  dM({
    loop: t,
    playbackRate: p,
    moveToBeginningWhenEnded: x,
    inFrame: O,
    outFrame: P,
    frameRef: ye.remotionInternal_currentFrameRef,
    browserMediaControlsBehavior: de
  }), ce(() => {
    Ze && !ye.playing && (We(!1), ye.play());
  }, [Ze, ye]), ce(() => {
    const { current: $e } = re;
    if (!$e)
      return;
    const He = () => {
      const Tr = document.fullscreenElement === $e || document.webkitFullscreenElement === $e;
      hr(Tr);
    };
    return document.addEventListener("fullscreenchange", He), document.addEventListener("webkitfullscreenchange", He), () => {
      document.removeEventListener("fullscreenchange", He), document.removeEventListener("webkitfullscreenchange", He);
    };
  }, []);
  const _r = se(($e) => {
    ye.isPlaying() ? ye.pause() : ye.play($e);
  }, [ye]), st = se(() => {
    if (!i)
      throw new Error("allowFullscreen is false");
    if (!dr)
      throw new Error("Browser doesnt support fullscreen");
    if (!re.current)
      throw new Error("No player ref found");
    re.current.webkitRequestFullScreen ? re.current.webkitRequestFullScreen() : re.current.requestFullscreen();
  }, [i, dr]), zt = se(() => {
    document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.exitFullscreen();
  }, []);
  ce(() => {
    const { current: $e } = re;
    if (!$e)
      return;
    const He = () => {
      const Tr = document.webkitFullscreenElement ?? document.fullscreenElement;
      Tr && Tr === re.current ? ye.emitter.dispatchFullscreenChange({
        isFullscreen: !0
      }) : ye.emitter.dispatchFullscreenChange({
        isFullscreen: !1
      });
    };
    return $e.addEventListener("webkitfullscreenchange", He), $e.addEventListener("fullscreenchange", He), () => {
      $e.removeEventListener("webkitfullscreenchange", He), $e.removeEventListener("fullscreenchange", He);
    };
  }, [ye.emitter]);
  const ri = ie?.durationInFrames ?? 1, nt = ee(() => !ie || !Ve ? null : Eb({
    canvasSize: Ve,
    compositionHeight: ie.height,
    compositionWidth: ie.width,
    previewSize: "auto"
  }), [Ve, ie]), Dt = nt?.scale ?? 1, An = be(!1);
  ce(() => {
    if (!An.current) {
      An.current = !0;
      return;
    }
    ye.emitter.dispatchScaleChange(Dt);
  }, [ye.emitter, Dt]);
  const { setMediaVolume: Sr, setMediaMuted: A } = me(Te.SetMediaVolumeContext), { mediaMuted: he, mediaVolume: le } = me(Te.MediaVolumeContext);
  ce(() => {
    ye.emitter.dispatchVolumeChange(le);
  }, [ye.emitter, le]);
  const Re = he || le === 0;
  ce(() => {
    ye.emitter.dispatchMuteChange({
      isMuted: Re
    });
  }, [ye.emitter, Re]);
  const [et, Ge] = ue(!1);
  ce(() => {
    let $e = null, He = !1;
    const Tr = () => {
      He = !1, requestAnimationFrame(() => {
        te === 0 ? Ge(!0) : $e = setTimeout(() => {
          He || Ge(!0);
        }, te);
      });
    }, gn = () => {
      requestAnimationFrame(() => {
        He = !0, Ge(!1), $e && clearTimeout($e);
      });
    };
    return ye.emitter.addEventListener("waiting", Tr), ye.emitter.addEventListener("resume", gn), () => {
      ye.emitter.removeEventListener("waiting", Tr), ye.emitter.removeEventListener("resume", gn), Ge(!1), $e && clearTimeout($e), He = !0;
    };
  }, [te, ye.emitter]), Zr(oe, () => {
    const $e = {
      play: ye.play,
      pause: () => {
        We(!1), ye.pause();
      },
      toggle: _r,
      getContainerNode: () => re.current,
      getCurrentFrame: ye.getCurrentFrame,
      isPlaying: ye.isPlaying,
      seekTo: (He) => {
        const Tr = ri - 1, gn = Math.max(0, Math.min(Tr, He));
        ye.isPlaying() && (We(gn !== Tr || t), ye.pause()), gn === Tr && !t && ye.emitter.dispatchEnded(), ye.seek(gn);
      },
      isFullscreen: () => {
        const { current: He } = re;
        return He ? document.fullscreenElement === He || document.webkitFullscreenElement === He : !1;
      },
      requestFullscreen: st,
      exitFullscreen: zt,
      getVolume: () => he ? 0 : le,
      setVolume: (He) => {
        if (typeof He != "number")
          throw new TypeError(`setVolume() takes a number, got value of type ${typeof He}`);
        if (isNaN(He))
          throw new TypeError("setVolume() got a number that is NaN. Volume must be between 0 and 1.");
        if (He < 0 || He > 1)
          throw new TypeError(`setVolume() got a number that is out of range. Must be between 0 and 1, got ${typeof He}`);
        Sr(He);
      },
      isMuted: () => Re,
      mute: () => {
        A(!0);
      },
      unmute: () => {
        A(!1);
      },
      getScale: () => Dt,
      pauseAndReturnToPlayStart: () => {
        ye.pauseAndReturnToPlayStart();
      }
    };
    return Object.assign(ye.emitter, $e);
  }, [
    ri,
    zt,
    t,
    he,
    Re,
    le,
    ye,
    st,
    A,
    Sr,
    _r,
    Dt
  ]);
  const Se = pe ? pe.component : null, ot = ee(() => kb({
    canvasSize: Ve,
    config: ie,
    style: e,
    overflowVisible: Z,
    layout: nt
  }), [Ve, ie, nt, Z, e]), fr = ee(() => Ib({ config: ie, layout: nt, scale: Dt, overflowVisible: Z }), [ie, nt, Z, Dt]), _t = ee(() => Ob({
    canvasSize: Ve,
    config: ie,
    layout: nt,
    scale: Dt,
    overflowVisible: Z
  }), [Ve, ie, nt, Z, Dt]), Cr = se(($e) => {
    ye.pause(), ye.emitter.dispatchError($e);
  }, [ye]), Qr = se(($e) => {
    $e.stopPropagation(), st();
  }, [st]), pr = se(($e) => {
    $e.stopPropagation(), zt();
  }, [zt]), pn = se(($e) => {
    ($e instanceof MouseEvent ? $e.button === 2 : $e.nativeEvent.button) || _r($e);
  }, [_r]), Qt = se(() => {
    Pt(!0);
  }, []), vo = se(() => {
    Pt(!1);
  }, []), yo = se(() => {
    dt ? zt() : st();
  }, [zt, dt, st]), { handlePointerDown: ys, handleDoubleClick: bs } = GM(pn, yo, u && i && dr);
  ce(() => {
    Ee && (ye.play(), Ie(!1));
  }, [Ee, ye]);
  const xu = ee(() => g ? g({
    height: ot.height,
    width: ot.width,
    isBuffering: et
  }) : null, [ot.height, ot.width, g, et]), Aa = ee(() => ({
    type: "scale",
    scale: Dt
  }), [Dt]);
  if (!ie)
    return null;
  const Mi = v ? v({
    height: Y === "player-size" ? ot.height : ie.height,
    width: Y === "player-size" ? ot.width : ie.width,
    isBuffering: et
  }) : null;
  if (Mi === void 0)
    throw new TypeError("renderPoster() must return a React element, but undefined was returned");
  const Ma = Mi && [
    E && !ye.isPlaying() && !Ht,
    C && ye.isLastFrame && !ye.isPlaying(),
    _ && !ye.hasPlayed && !ye.isPlaying(),
    k && et && ye.isPlaying()
  ].some(Boolean), { left: jp, top: Rp, width: Fp, height: _u, ...Su } = fr, Pa = /* @__PURE__ */ y.jsxs(y.Fragment, {
    children: [
      /* @__PURE__ */ y.jsx("div", {
        style: fr,
        onPointerDown: a ? ys : void 0,
        onDoubleClick: u ? bs : void 0,
        children: /* @__PURE__ */ y.jsxs("div", {
          style: _t,
          className: Gf,
          children: [
            Se ? /* @__PURE__ */ y.jsx(Db, {
              onError: Cr,
              errorFallback: d,
              children: /* @__PURE__ */ y.jsx(Te.CurrentScaleContext.Provider, {
                value: Aa,
                children: /* @__PURE__ */ y.jsx(Se, {
                  ...pe?.props ?? {},
                  ...s ?? {}
                })
              })
            }) : null,
            Ma && Y === "composition-size" ? /* @__PURE__ */ y.jsx("div", {
              style: {
                ...Su,
                width: ie.width,
                height: ie.height
              },
              onPointerDown: a ? ys : void 0,
              onDoubleClick: u ? bs : void 0,
              children: Mi
            }) : null
          ]
        })
      }),
      Ma && Y === "player-size" ? /* @__PURE__ */ y.jsx("div", {
        style: fr,
        onPointerDown: a ? ys : void 0,
        onDoubleClick: u ? bs : void 0,
        children: Mi
      }) : null,
      r ? /* @__PURE__ */ y.jsx(HM, {
        fps: ie.fps,
        durationInFrames: ie.durationInFrames,
        player: ye,
        containerRef: re,
        onFullscreenButtonClick: Qr,
        isFullscreen: dt,
        allowFullscreen: i,
        showVolumeControls: c,
        onExitFullscreenButtonClick: pr,
        spaceKeyToPlayOrPause: h,
        onSeekEnd: vo,
        onSeekStart: Qt,
        inFrame: O,
        outFrame: P,
        initiallyShowControls: R,
        canvasSize: Ve,
        renderFullscreenButton: V,
        renderPlayPauseButton: F,
        alwaysShowControls: G,
        showPlaybackRateControl: H,
        buffering: et,
        hideControlsWhenPointerDoesntMove: ge,
        onDoubleClick: u ? bs : void 0,
        onPointerDown: a ? ys : void 0,
        renderMuteButton: $,
        renderVolumeSlider: z
      }) : null
    ]
  });
  return jb && !qM ? /* @__PURE__ */ y.jsx("div", {
    ref: re,
    style: ot,
    className: b,
    children: Pa
  }) : /* @__PURE__ */ y.jsx("div", {
    ref: re,
    style: ot,
    className: b,
    children: /* @__PURE__ */ y.jsx(rl, {
      fallback: xu,
      children: Pa
    })
  });
}, ZM = Vt(KM), Rb = "remotion.volumePreference", JM = (r) => {
  if (!(typeof window > "u"))
    try {
      window.localStorage.setItem(Rb, String(r));
    } catch (e) {
      console.log("Could not persist volume", e);
    }
}, QM = () => {
  if (typeof window > "u")
    return 1;
  try {
    const r = window.localStorage.getItem(Rb);
    return r ? Number(r) : 1;
  } catch {
    return 1;
  }
}, qf = "player-comp", Fb = ({
  children: r,
  timelineContext: e,
  fps: t,
  compositionHeight: n,
  compositionWidth: i,
  durationInFrames: s,
  component: a,
  numberOfSharedAudioTags: c,
  initiallyMuted: u
}) => {
  const h = ee(() => ({
    compositions: [
      {
        component: a,
        durationInFrames: s,
        height: n,
        width: i,
        fps: t,
        id: qf,
        nonce: 777,
        folderName: null,
        parentFolderName: null,
        schema: null,
        calculateMetadata: null
      }
    ],
    folders: [],
    registerFolder: () => {
    },
    unregisterFolder: () => {
    },
    registerComposition: () => {
    },
    unregisterComposition: () => {
    },
    currentCompositionMetadata: null,
    setCurrentCompositionMetadata: () => {
    },
    canvasContent: { type: "composition", compositionId: "player-comp" },
    setCanvasContent: () => {
    },
    updateCompositionDefaultProps: () => {
    }
  }), [a, s, n, i, t]), [d, p] = ue(() => u), [g, v] = ue(() => QM()), b = ee(() => ({
    mediaMuted: d,
    mediaVolume: g
  }), [d, g]), x = se((C) => {
    v(C), JM(C);
  }, []), _ = ee(() => ({
    setMediaMuted: p,
    setMediaVolume: x
  }), [x]);
  return /* @__PURE__ */ y.jsx(Te.CanUseRemotionHooksProvider, {
    children: /* @__PURE__ */ y.jsx(Te.Timeline.TimelineContext.Provider, {
      value: e,
      children: /* @__PURE__ */ y.jsx(Te.CompositionManager.Provider, {
        value: h,
        children: /* @__PURE__ */ y.jsx(Te.ResolveCompositionConfig, {
          children: /* @__PURE__ */ y.jsx(Te.PrefetchProvider, {
            children: /* @__PURE__ */ y.jsx(Te.DurationsContextProvider, {
              children: /* @__PURE__ */ y.jsx(Te.MediaVolumeContext.Provider, {
                value: b,
                children: /* @__PURE__ */ y.jsx(Te.SetMediaVolumeContext.Provider, {
                  value: _,
                  children: /* @__PURE__ */ y.jsx(Te.SharedAudioContextProvider, {
                    numberOfAudioTags: c,
                    component: a,
                    children: /* @__PURE__ */ y.jsx(Te.BufferingProvider, {
                      children: r
                    })
                  })
                })
              })
            })
          })
        })
      })
    })
  });
}, n0 = (r, e) => {
  if (typeof r > "u" || r === null)
    return r ?? null;
  if (typeof r != "number")
    throw new TypeError(`"${e}" must be a number, but is ${JSON.stringify(r)}`);
  if (Number.isNaN(r))
    throw new TypeError(`"${e}" must not be NaN, but is ${JSON.stringify(r)}`);
  if (!Number.isFinite(r))
    throw new TypeError(`"${e}" must be finite, but is ${JSON.stringify(r)}`);
  if (r % 1 !== 0)
    throw new TypeError(`"${e}" must be an integer, but is ${JSON.stringify(r)}`);
  return r;
}, eP = ({
  inFrame: r,
  durationInFrames: e,
  outFrame: t
}) => {
  const n = n0(r, "inFrame"), i = n0(t, "outFrame");
  if (!(n === null && i === null)) {
    if (n !== null && n > e - 1)
      throw new Error("inFrame must be less than (durationInFrames - 1), but is " + n);
    if (i !== null && i > e - 1)
      throw new Error("outFrame must be less than (durationInFrames - 1), but is " + i);
    if (n !== null && n < 0)
      throw new Error("inFrame must be greater than 0, but is " + n);
    if (i !== null && i <= 0)
      throw new Error(`outFrame must be greater than 0, but is ${i}. If you want to render a single frame, use <Thumbnail /> instead.`);
    if (i !== null && n !== null && i <= n)
      throw new Error("outFrame must be greater than inFrame, but is " + i + " <= " + n);
  }
}, tP = ({
  initialFrame: r,
  durationInFrames: e
}) => {
  if (typeof e != "number")
    throw new Error(`\`durationInFrames\` must be a number, but is ${JSON.stringify(e)}`);
  if (!(typeof r > "u")) {
    if (typeof r != "number")
      throw new Error(`\`initialFrame\` must be a number, but is ${JSON.stringify(r)}`);
    if (Number.isNaN(r))
      throw new Error("`initialFrame` must be a number, but is NaN");
    if (!Number.isFinite(r))
      throw new Error("`initialFrame` must be a number, but is Infinity");
    if (r % 1 !== 0)
      throw new Error(`\`initialFrame\` must be an integer, but is ${JSON.stringify(r)}`);
    if (r > e - 1)
      throw new Error(`\`initialFrame\` must be less or equal than \`durationInFrames - 1\`, but is ${JSON.stringify(r)}`);
  }
}, rP = (r) => {
  if (r !== void 0) {
    if (r > 4)
      throw new Error(`The highest possible playback rate is 4. You passed: ${r}`);
    if (r < -4)
      throw new Error(`The lowest possible playback rate is -4. You passed: ${r}`);
    if (r === 0)
      throw new Error("A playback rate of 0 is not supported.");
  }
}, nP = Jl.validateFps, i0 = Jl.validateDimension, iP = Jl.validateDurationInFrames, sP = Jl.validateDefaultAndInputProps, oP = (r) => "component" in r ? r.component : null, aP = ({
  durationInFrames: r,
  compositionHeight: e,
  compositionWidth: t,
  fps: n,
  inputProps: i,
  style: s,
  controls: a = !1,
  loop: c = !1,
  autoPlay: u = !1,
  showVolumeControls: h = !0,
  allowFullscreen: d = !0,
  clickToPlay: p,
  doubleClickToFullscreen: g = !1,
  spaceKeyToPlayOrPause: v = !0,
  moveToBeginningWhenEnded: b = !0,
  numberOfSharedAudioTags: x = 5,
  errorFallback: _ = () => "⚠️",
  playbackRate: C = 1,
  renderLoading: E,
  className: k,
  showPosterWhenUnplayed: O,
  showPosterWhenEnded: P,
  showPosterWhenPaused: R,
  showPosterWhenBuffering: V,
  initialFrame: F,
  renderPoster: $,
  inFrame: z,
  outFrame: G,
  initiallyShowControls: H,
  renderFullscreenButton: Y,
  renderPlayPauseButton: te,
  renderVolumeSlider: ge,
  alwaysShowControls: Z = !1,
  initiallyMuted: de = !1,
  showPlaybackRateControl: oe = !1,
  posterFillMode: ie = "player-size",
  bufferStateDelayInMilliseconds: pe,
  hideControlsWhenPointerDoesntMove: re = !0,
  overflowVisible: Ve = !1,
  renderMuteButton: Ze,
  browserMediaControlsBehavior: We,
  ...Ee
}, Ie) => {
  if (typeof window < "u" && Kn(() => {
    window.remotion_isPlayer = !0;
  }, []), Ee.defaultProps !== void 0)
    throw new Error("The <Player /> component does not accept `defaultProps`, but some were passed. Use `inputProps` instead.");
  const dt = oP(Ee);
  if (dt?.type === Xv)
    throw new TypeError("'component' should not be an instance of <Composition/>. Pass the React component directly, and set the duration, fps and dimensions as separate props. See https://www.remotion.dev/docs/player/examples for an example.");
  if (dt === Xv)
    throw new TypeError("'component' must not be the 'Composition' component. Pass your own React component directly, and set the duration, fps and dimensions as separate props. See https://www.remotion.dev/docs/player/examples for an example.");
  const hr = Te.useLazyComponent(Ee);
  tP({ initialFrame: F, durationInFrames: r });
  const [Ht, Pt] = ue(() => ({
    [qf]: F ?? 0
  })), [dr, ye] = ue(!1), [_r] = ue("player-comp"), st = be(null), zt = be([]), ri = be(!1), [nt, Dt] = ue(C);
  if (typeof e != "number")
    throw new TypeError(`'compositionHeight' must be a number but got '${typeof e}' instead`);
  if (typeof t != "number")
    throw new TypeError(`'compositionWidth' must be a number but got '${typeof t}' instead`);
  if (i0(e, "compositionHeight", "of the <Player /> component"), i0(t, "compositionWidth", "of the <Player /> component"), iP(r, {
    component: "of the <Player/> component",
    allowFloats: !1
  }), nP(n, "as a prop of the <Player/> component", !1), sP(i, "inputProps", null), eP({
    durationInFrames: r,
    inFrame: z,
    outFrame: G
  }), typeof a != "boolean" && typeof a < "u")
    throw new TypeError(`'controls' must be a boolean or undefined but got '${typeof a}' instead`);
  if (typeof u != "boolean" && typeof u < "u")
    throw new TypeError(`'autoPlay' must be a boolean or undefined but got '${typeof u}' instead`);
  if (typeof c != "boolean" && typeof c < "u")
    throw new TypeError(`'loop' must be a boolean or undefined but got '${typeof c}' instead`);
  if (typeof g != "boolean" && typeof g < "u")
    throw new TypeError(`'doubleClickToFullscreen' must be a boolean or undefined but got '${typeof g}' instead`);
  if (typeof h != "boolean" && typeof h < "u")
    throw new TypeError(`'showVolumeControls' must be a boolean or undefined but got '${typeof h}' instead`);
  if (typeof d != "boolean" && typeof d < "u")
    throw new TypeError(`'allowFullscreen' must be a boolean or undefined but got '${typeof d}' instead`);
  if (typeof p != "boolean" && typeof p < "u")
    throw new TypeError(`'clickToPlay' must be a boolean or undefined but got '${typeof p}' instead`);
  if (typeof v != "boolean" && typeof v < "u")
    throw new TypeError(`'spaceKeyToPlayOrPause' must be a boolean or undefined but got '${typeof v}' instead`);
  if (typeof x != "number" || x % 1 !== 0 || !Number.isFinite(x) || Number.isNaN(x) || x < 0)
    throw new TypeError(`'numberOfSharedAudioTags' must be an integer but got '${x}' instead`);
  rP(nt), ce(() => {
    Dt(C);
  }, [C]), Zr(Ie, () => st.current, []);
  const An = ee(() => ({
    frame: Ht,
    playing: dr,
    rootId: _r,
    playbackRate: nt,
    imperativePlaying: ri,
    setPlaybackRate: (le) => {
      Dt(le);
    },
    audioAndVideoTags: zt
  }), [Ht, nt, dr, _r]), Sr = ee(() => ({
    setFrame: Pt,
    setPlaying: ye
  }), [Pt]);
  typeof window < "u" && Kn(() => {
    Te.CSSUtils.injectCSS(Te.CSSUtils.makeDefaultPreviewCSS(`.${Gf}`, "#fff"));
  }, []);
  const A = ee(() => i ?? {}, [i]), he = ee(() => We ?? {
    mode: "prevent-media-session"
  }, [We]);
  return /* @__PURE__ */ y.jsx(Te.IsPlayerContextProvider, {
    children: /* @__PURE__ */ y.jsx(Fb, {
      timelineContext: An,
      component: hr,
      compositionHeight: e,
      compositionWidth: t,
      durationInFrames: r,
      fps: n,
      numberOfSharedAudioTags: x,
      initiallyMuted: de,
      children: /* @__PURE__ */ y.jsx(Te.Timeline.SetTimelineContext.Provider, {
        value: Sr,
        children: /* @__PURE__ */ y.jsx(cM, {
          currentPlaybackRate: nt,
          children: /* @__PURE__ */ y.jsx(ZM, {
            ref: st,
            posterFillMode: ie,
            renderLoading: E,
            autoPlay: !!u,
            loop: !!c,
            controls: !!a,
            errorFallback: _,
            style: s,
            inputProps: A,
            allowFullscreen: !!d,
            moveToBeginningWhenEnded: !!b,
            clickToPlay: typeof p == "boolean" ? p : !!a,
            showVolumeControls: !!h,
            doubleClickToFullscreen: !!g,
            spaceKeyToPlayOrPause: !!v,
            playbackRate: nt,
            className: k ?? void 0,
            showPosterWhenUnplayed: !!O,
            showPosterWhenEnded: !!P,
            showPosterWhenPaused: !!R,
            showPosterWhenBuffering: !!V,
            renderPoster: $,
            inFrame: z ?? null,
            outFrame: G ?? null,
            initiallyShowControls: H ?? !0,
            renderFullscreen: Y ?? null,
            renderPlayPauseButton: te ?? null,
            renderMuteButton: Ze ?? null,
            renderVolumeSlider: ge ?? null,
            alwaysShowControls: Z,
            showPlaybackRateControl: oe,
            bufferStateDelayInMilliseconds: pe ?? 300,
            hideControlsWhenPointerDoesntMove: re,
            overflowVisible: Ve,
            browserMediaControlsBehavior: he
          })
        })
      })
    })
  });
}, cP = Vt, lP = cP(aP), uP = () => {
  const r = me(Mb);
  if (!r)
    throw new TypeError("Expected Player event emitter context");
  return ee(() => ({
    emitter: r
  }), [r]);
}, Wd = Ce.version.split(".")[0];
if (Wd === "0")
  throw new Error(`Version ${Wd} of "react" is not supported by Remotion`);
var hP = parseInt(Wd, 10) >= 18, dP = ({ style: r, inputProps: e, errorFallback: t, renderLoading: n, className: i, overflowVisible: s }, a) => {
  const c = Te.useUnsafeVideoConfig(), u = Te.useVideo(), h = be(null), d = Xf(h, {
    triggerOnWindowResize: !1,
    shouldApplyCssTransforms: !1
  }), p = ee(() => !c || !d ? null : Eb({
    canvasSize: d,
    compositionHeight: c.height,
    compositionWidth: c.width,
    previewSize: "auto"
  }), [d, c]), g = p?.scale ?? 1, v = uP();
  Pb(v.emitter), Zr(a, () => {
    const R = {
      getContainerNode: () => h.current,
      getScale: () => g
    };
    return Object.assign(v.emitter, R);
  }, [g, v.emitter]);
  const b = u ? u.component : null, x = ee(() => kb({
    config: c,
    style: r,
    canvasSize: d,
    overflowVisible: s,
    layout: p
  }), [d, c, p, s, r]), _ = ee(() => Ib({ config: c, layout: p, scale: g, overflowVisible: s }), [c, p, s, g]), C = ee(() => Ob({
    canvasSize: d,
    config: c,
    layout: p,
    scale: g,
    overflowVisible: s
  }), [d, c, p, s, g]), E = se((R) => {
    v.emitter.dispatchError(R);
  }, [v.emitter]), k = ee(() => n ? n({
    height: x.height,
    width: x.width,
    isBuffering: !1
  }) : null, [x.height, x.width, n]), O = ee(() => ({
    type: "scale",
    scale: g
  }), [g]);
  if (!c)
    return null;
  const P = /* @__PURE__ */ y.jsx("div", {
    style: _,
    children: /* @__PURE__ */ y.jsx("div", {
      style: C,
      className: Gf,
      children: b ? /* @__PURE__ */ y.jsx(Db, {
        onError: E,
        errorFallback: t,
        children: /* @__PURE__ */ y.jsx(Te.CurrentScaleContext.Provider, {
          value: O,
          children: /* @__PURE__ */ y.jsx(b, {
            ...u?.props ?? {},
            ...e ?? {}
          })
        })
      }) : null
    })
  });
  return jb && !hP ? /* @__PURE__ */ y.jsx("div", {
    ref: h,
    style: x,
    className: i,
    children: P
  }) : /* @__PURE__ */ y.jsx("div", {
    ref: h,
    style: x,
    className: i,
    children: /* @__PURE__ */ y.jsx(rl, {
      fallback: k,
      children: P
    })
  });
}, fP = Vt(dP), pP = ({
  frameToDisplay: r,
  style: e,
  inputProps: t,
  compositionHeight: n,
  compositionWidth: i,
  durationInFrames: s,
  fps: a,
  className: c,
  errorFallback: u = () => "⚠️",
  renderLoading: h,
  overflowVisible: d = !1,
  ...p
}, g) => {
  typeof window < "u" && Kn(() => {
    window.remotion_isPlayer = !0;
  }, []);
  const [v] = ue(() => String(fs(null))), b = be(null), x = ee(() => ({
    playing: !1,
    frame: {
      [qf]: r
    },
    rootId: v,
    imperativePlaying: {
      current: !1
    },
    playbackRate: 1,
    setPlaybackRate: () => {
      throw new Error("thumbnail");
    },
    audioAndVideoTags: { current: [] }
  }), [r, v]);
  Zr(g, () => b.current, []);
  const _ = Te.useLazyComponent(p), [C] = ue(() => new aM()), E = ee(() => t ?? {}, [t]);
  return /* @__PURE__ */ y.jsx(Te.IsPlayerContextProvider, {
    children: /* @__PURE__ */ y.jsx(Fb, {
      timelineContext: x,
      component: _,
      compositionHeight: n,
      compositionWidth: i,
      durationInFrames: s,
      fps: a,
      numberOfSharedAudioTags: 0,
      initiallyMuted: !0,
      children: /* @__PURE__ */ y.jsx(Mb.Provider, {
        value: C,
        children: /* @__PURE__ */ y.jsx(fP, {
          ref: b,
          className: c,
          errorFallback: u,
          inputProps: E,
          renderLoading: h,
          style: e,
          overflowVisible: d
        })
      })
    })
  });
}, gP = Vt;
gP(pP);
const Tc = (r, e) => {
  const t = r.from / 1e3 * e, n = r.to / 1e3 * e - t;
  return { from: t, durationInFrames: n };
}, mP = {
  text: (r, e) => {
    const { fps: t, height: n, width: i } = e, { from: s, durationInFrames: a } = Tc(r.display, t);
    return /* @__PURE__ */ y.jsx(
      xn,
      {
        from: s,
        durationInFrames: a,
        "data-track-item": "transition-element",
        style: {
          position: "absolute",
          width: r.details.width ?? 300,
          height: r.details.height ?? 400,
          transform: r.details.transform ?? "none",
          fontSize: r.details.fontSize || "16px",
          // Updated default font size
          textAlign: r.details.textAlign || "left",
          // Updated default text alignment
          top: r.details.top ?? 300,
          left: r.details.left ?? 600,
          color: r.details.color || "#000000",
          // Updated text color (fill)
          backgroundColor: r.details.backgroundColor || "transparent",
          // Updated background color
          border: r.details.border ?? "none",
          // Updated border
          opacity: r.details.opacity ?? 100 / 100,
          fontFamily: r.details.fontFamily || "Arial",
          // Updated default font family
          textDecoration: r.details.textDecoration || "none",
          fontWeight: r.details.fontWeight || "normal",
          lineHeight: r.details.lineHeight || "normal",
          // Added line height
          letterSpacing: r.details.letterSpacing || "normal",
          // Added letter spacing
          wordSpacing: r.details.wordSpacing || "normal",
          // Added word spacing
          wordWrap: r.details.wordWrap || "normal",
          //'break-word'
          wordBreak: r.details.wordBreak || "normal",
          //'break-all',
          pointerEvents: "auto"
        },
        children: /* @__PURE__ */ y.jsx("div", { children: r.details.text })
      },
      r.id
    );
  },
  image: (r, e) => {
    const { fps: t } = e, { from: n, durationInFrames: i } = Tc(r.display, t);
    return /* @__PURE__ */ y.jsx(
      xn,
      {
        from: n,
        durationInFrames: i,
        style: {
          width: r.details.width ?? "100%",
          // Default width
          height: r.details.height ?? "auto",
          // Default height
          transform: r.details.transform ?? "none",
          opacity: (r.details.opacity ?? 100) / 100 || 1,
          border: r.details.border ?? "none",
          // Default border
          borderRadius: r.details.borderRadius ?? "0",
          // Default border radius
          boxShadow: r.details.boxShadow ?? "none",
          // Default box shadow
          filter: r.details.filter || "none",
          top: r.details.top ?? 0,
          left: r.details.left ?? 0
        },
        children: /* @__PURE__ */ y.jsx(Yo, { style: { pointerEvents: "none" }, children: /* @__PURE__ */ y.jsx(
          wb,
          {
            style: { pointerEvents: "none" },
            "data-id": r.id,
            src: r.details.src
          }
        ) })
      },
      r.id
    );
  },
  video: (r, e) => {
    const { fps: t } = e, { from: n, durationInFrames: i } = Tc(r.display, t), s = r.trim, a = r.details.crop || {
      x: 0,
      y: 0,
      width: r.details.width,
      height: r.details.height
    };
    return s ? /* @__PURE__ */ y.jsx(
      xn,
      {
        premountFor: 30 * 5,
        from: n,
        durationInFrames: i,
        style: {
          width: a.width || "100%",
          // Default width
          height: a.height || "auto",
          // Default height
          transform: r.details.transform ?? "none",
          opacity: (r.details.opacity ?? 100) / 100 || 1,
          border: r.details.border ?? "none",
          // Default border
          borderRadius: r.details.borderRadius ?? "0",
          // Default border radius
          boxShadow: r.details.boxShadow ?? "none",
          // Default box shadow
          top: r.details.top ?? 0,
          left: r.details.left ?? 0,
          overflow: "hidden"
        },
        children: /* @__PURE__ */ y.jsx(
          Yo,
          {
            style: {
              pointerEvents: "none",
              width: r.details.width,
              height: r.details.height,
              top: -a.y,
              left: -a.x
            },
            children: /* @__PURE__ */ y.jsx(
              Tb,
              {
                startFrom: s.from / 1e3 * t,
                endAt: s.to / 1e3 * t,
                src: r.details.src,
                volume: (r.details.volume ?? 100) / 100,
                style: {
                  pointerEvents: "none",
                  width: r.details.width,
                  height: r.details.height
                }
              }
            )
          }
        )
      },
      r.id
    ) : /* @__PURE__ */ y.jsx(y.Fragment, {});
  },
  audio: (r, e) => {
    const { fps: t } = e, { from: n, durationInFrames: i } = Tc(r.display, t), s = r.trim;
    return s ? /* @__PURE__ */ y.jsx(
      xn,
      {
        className: `moonshine-scene-item id-${r.id} moonshine-scene-item-type-${r.type}`,
        from: n,
        durationInFrames: i,
        style: {
          userSelect: "none",
          pointerEvents: "none"
        },
        children: /* @__PURE__ */ y.jsx(Yo, { children: /* @__PURE__ */ y.jsx(
          Xo,
          {
            startFrom: s.from / 1e3 * t,
            endAt: s.to / 1e3 * t,
            src: r.details.src,
            volume: (r.details.volume ?? 100) / 100
          }
        ) })
      },
      r.id
    ) : /* @__PURE__ */ y.jsx(y.Fragment, {});
  }
};
var hl = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
hl.exports;
(function(r, e) {
  (function() {
    var t, n = "4.17.21", i = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", a = "Expected a function", c = "Invalid `variable` option passed into `_.template`", u = "__lodash_hash_undefined__", h = 500, d = "__lodash_placeholder__", p = 1, g = 2, v = 4, b = 1, x = 2, _ = 1, C = 2, E = 4, k = 8, O = 16, P = 32, R = 64, V = 128, F = 256, $ = 512, z = 30, G = "...", H = 800, Y = 16, te = 1, ge = 2, Z = 3, de = 1 / 0, oe = 9007199254740991, ie = 17976931348623157e292, pe = NaN, re = 4294967295, Ve = re - 1, Ze = re >>> 1, We = [
      ["ary", V],
      ["bind", _],
      ["bindKey", C],
      ["curry", k],
      ["curryRight", O],
      ["flip", $],
      ["partial", P],
      ["partialRight", R],
      ["rearg", F]
    ], Ee = "[object Arguments]", Ie = "[object Array]", dt = "[object AsyncFunction]", hr = "[object Boolean]", Ht = "[object Date]", Pt = "[object DOMException]", dr = "[object Error]", ye = "[object Function]", _r = "[object GeneratorFunction]", st = "[object Map]", zt = "[object Number]", ri = "[object Null]", nt = "[object Object]", Dt = "[object Promise]", An = "[object Proxy]", Sr = "[object RegExp]", A = "[object Set]", he = "[object String]", le = "[object Symbol]", Re = "[object Undefined]", et = "[object WeakMap]", Ge = "[object WeakSet]", Se = "[object ArrayBuffer]", ot = "[object DataView]", fr = "[object Float32Array]", _t = "[object Float64Array]", Cr = "[object Int8Array]", Qr = "[object Int16Array]", pr = "[object Int32Array]", pn = "[object Uint8Array]", Qt = "[object Uint8ClampedArray]", vo = "[object Uint16Array]", yo = "[object Uint32Array]", ys = /\b__p \+= '';/g, bs = /\b(__p \+=) '' \+/g, xu = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Aa = /&(?:amp|lt|gt|quot|#39);/g, Mi = /[&<>"']/g, Ma = RegExp(Aa.source), jp = RegExp(Mi.source), Rp = /<%-([\s\S]+?)%>/g, Fp = /<%([\s\S]+?)%>/g, _u = /<%=([\s\S]+?)%>/g, Su = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Pa = /^\w*$/, $e = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, He = /[\\^$.*+?()[\]{}|]/g, Tr = RegExp(He.source), gn = /^\s+/, Lp = /\s/, i_ = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, s_ = /\{\n\/\* \[wrapped with (.+)\] \*/, o_ = /,? & /, a_ = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, c_ = /[()=,{}\[\]\/\s]/, l_ = /\\(\\)?/g, u_ = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Np = /\w*$/, h_ = /^[-+]0x[0-9a-f]+$/i, d_ = /^0b[01]+$/i, f_ = /^\[object .+?Constructor\]$/, p_ = /^0o[0-7]+$/i, g_ = /^(?:0|[1-9]\d*)$/, m_ = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Da = /($^)/, v_ = /['\n\r\u2028\u2029\\]/g, ja = "\\ud800-\\udfff", y_ = "\\u0300-\\u036f", b_ = "\\ufe20-\\ufe2f", w_ = "\\u20d0-\\u20ff", Bp = y_ + b_ + w_, Vp = "\\u2700-\\u27bf", zp = "a-z\\xdf-\\xf6\\xf8-\\xff", x_ = "\\xac\\xb1\\xd7\\xf7", __ = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", S_ = "\\u2000-\\u206f", C_ = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Wp = "A-Z\\xc0-\\xd6\\xd8-\\xde", Hp = "\\ufe0e\\ufe0f", Up = x_ + __ + S_ + C_, Cu = "['’]", T_ = "[" + ja + "]", $p = "[" + Up + "]", Ra = "[" + Bp + "]", Yp = "\\d+", E_ = "[" + Vp + "]", Xp = "[" + zp + "]", Gp = "[^" + ja + Up + Yp + Vp + zp + Wp + "]", Tu = "\\ud83c[\\udffb-\\udfff]", k_ = "(?:" + Ra + "|" + Tu + ")", qp = "[^" + ja + "]", Eu = "(?:\\ud83c[\\udde6-\\uddff]){2}", ku = "[\\ud800-\\udbff][\\udc00-\\udfff]", ws = "[" + Wp + "]", Kp = "\\u200d", Zp = "(?:" + Xp + "|" + Gp + ")", O_ = "(?:" + ws + "|" + Gp + ")", Jp = "(?:" + Cu + "(?:d|ll|m|re|s|t|ve))?", Qp = "(?:" + Cu + "(?:D|LL|M|RE|S|T|VE))?", eg = k_ + "?", tg = "[" + Hp + "]?", I_ = "(?:" + Kp + "(?:" + [qp, Eu, ku].join("|") + ")" + tg + eg + ")*", A_ = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", M_ = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rg = tg + eg + I_, P_ = "(?:" + [E_, Eu, ku].join("|") + ")" + rg, D_ = "(?:" + [qp + Ra + "?", Ra, Eu, ku, T_].join("|") + ")", j_ = RegExp(Cu, "g"), R_ = RegExp(Ra, "g"), Ou = RegExp(Tu + "(?=" + Tu + ")|" + D_ + rg, "g"), F_ = RegExp([
      ws + "?" + Xp + "+" + Jp + "(?=" + [$p, ws, "$"].join("|") + ")",
      O_ + "+" + Qp + "(?=" + [$p, ws + Zp, "$"].join("|") + ")",
      ws + "?" + Zp + "+" + Jp,
      ws + "+" + Qp,
      M_,
      A_,
      Yp,
      P_
    ].join("|"), "g"), L_ = RegExp("[" + Kp + ja + Bp + Hp + "]"), N_ = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, B_ = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], V_ = -1, at = {};
    at[fr] = at[_t] = at[Cr] = at[Qr] = at[pr] = at[pn] = at[Qt] = at[vo] = at[yo] = !0, at[Ee] = at[Ie] = at[Se] = at[hr] = at[ot] = at[Ht] = at[dr] = at[ye] = at[st] = at[zt] = at[nt] = at[Sr] = at[A] = at[he] = at[et] = !1;
    var it = {};
    it[Ee] = it[Ie] = it[Se] = it[ot] = it[hr] = it[Ht] = it[fr] = it[_t] = it[Cr] = it[Qr] = it[pr] = it[st] = it[zt] = it[nt] = it[Sr] = it[A] = it[he] = it[le] = it[pn] = it[Qt] = it[vo] = it[yo] = !0, it[dr] = it[ye] = it[et] = !1;
    var z_ = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, W_ = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, H_ = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, U_ = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, $_ = parseFloat, Y_ = parseInt, ng = typeof jo == "object" && jo && jo.Object === Object && jo, X_ = typeof self == "object" && self && self.Object === Object && self, Ut = ng || X_ || Function("return this")(), Iu = e && !e.nodeType && e, Pi = Iu && !0 && r && !r.nodeType && r, ig = Pi && Pi.exports === Iu, Au = ig && ng.process, Nr = function() {
      try {
        var L = Pi && Pi.require && Pi.require("util").types;
        return L || Au && Au.binding && Au.binding("util");
      } catch {
      }
    }(), sg = Nr && Nr.isArrayBuffer, og = Nr && Nr.isDate, ag = Nr && Nr.isMap, cg = Nr && Nr.isRegExp, lg = Nr && Nr.isSet, ug = Nr && Nr.isTypedArray;
    function Er(L, X, U) {
      switch (U.length) {
        case 0:
          return L.call(X);
        case 1:
          return L.call(X, U[0]);
        case 2:
          return L.call(X, U[0], U[1]);
        case 3:
          return L.call(X, U[0], U[1], U[2]);
      }
      return L.apply(X, U);
    }
    function G_(L, X, U, fe) {
      for (var ke = -1, Ye = L == null ? 0 : L.length; ++ke < Ye; ) {
        var jt = L[ke];
        X(fe, jt, U(jt), L);
      }
      return fe;
    }
    function Br(L, X) {
      for (var U = -1, fe = L == null ? 0 : L.length; ++U < fe && X(L[U], U, L) !== !1; )
        ;
      return L;
    }
    function q_(L, X) {
      for (var U = L == null ? 0 : L.length; U-- && X(L[U], U, L) !== !1; )
        ;
      return L;
    }
    function hg(L, X) {
      for (var U = -1, fe = L == null ? 0 : L.length; ++U < fe; )
        if (!X(L[U], U, L))
          return !1;
      return !0;
    }
    function ni(L, X) {
      for (var U = -1, fe = L == null ? 0 : L.length, ke = 0, Ye = []; ++U < fe; ) {
        var jt = L[U];
        X(jt, U, L) && (Ye[ke++] = jt);
      }
      return Ye;
    }
    function Fa(L, X) {
      var U = L == null ? 0 : L.length;
      return !!U && xs(L, X, 0) > -1;
    }
    function Mu(L, X, U) {
      for (var fe = -1, ke = L == null ? 0 : L.length; ++fe < ke; )
        if (U(X, L[fe]))
          return !0;
      return !1;
    }
    function lt(L, X) {
      for (var U = -1, fe = L == null ? 0 : L.length, ke = Array(fe); ++U < fe; )
        ke[U] = X(L[U], U, L);
      return ke;
    }
    function ii(L, X) {
      for (var U = -1, fe = X.length, ke = L.length; ++U < fe; )
        L[ke + U] = X[U];
      return L;
    }
    function Pu(L, X, U, fe) {
      var ke = -1, Ye = L == null ? 0 : L.length;
      for (fe && Ye && (U = L[++ke]); ++ke < Ye; )
        U = X(U, L[ke], ke, L);
      return U;
    }
    function K_(L, X, U, fe) {
      var ke = L == null ? 0 : L.length;
      for (fe && ke && (U = L[--ke]); ke--; )
        U = X(U, L[ke], ke, L);
      return U;
    }
    function Du(L, X) {
      for (var U = -1, fe = L == null ? 0 : L.length; ++U < fe; )
        if (X(L[U], U, L))
          return !0;
      return !1;
    }
    var Z_ = ju("length");
    function J_(L) {
      return L.split("");
    }
    function Q_(L) {
      return L.match(a_) || [];
    }
    function dg(L, X, U) {
      var fe;
      return U(L, function(ke, Ye, jt) {
        if (X(ke, Ye, jt))
          return fe = Ye, !1;
      }), fe;
    }
    function La(L, X, U, fe) {
      for (var ke = L.length, Ye = U + (fe ? 1 : -1); fe ? Ye-- : ++Ye < ke; )
        if (X(L[Ye], Ye, L))
          return Ye;
      return -1;
    }
    function xs(L, X, U) {
      return X === X ? hS(L, X, U) : La(L, fg, U);
    }
    function eS(L, X, U, fe) {
      for (var ke = U - 1, Ye = L.length; ++ke < Ye; )
        if (fe(L[ke], X))
          return ke;
      return -1;
    }
    function fg(L) {
      return L !== L;
    }
    function pg(L, X) {
      var U = L == null ? 0 : L.length;
      return U ? Fu(L, X) / U : pe;
    }
    function ju(L) {
      return function(X) {
        return X == null ? t : X[L];
      };
    }
    function Ru(L) {
      return function(X) {
        return L == null ? t : L[X];
      };
    }
    function gg(L, X, U, fe, ke) {
      return ke(L, function(Ye, jt, tt) {
        U = fe ? (fe = !1, Ye) : X(U, Ye, jt, tt);
      }), U;
    }
    function tS(L, X) {
      var U = L.length;
      for (L.sort(X); U--; )
        L[U] = L[U].value;
      return L;
    }
    function Fu(L, X) {
      for (var U, fe = -1, ke = L.length; ++fe < ke; ) {
        var Ye = X(L[fe]);
        Ye !== t && (U = U === t ? Ye : U + Ye);
      }
      return U;
    }
    function Lu(L, X) {
      for (var U = -1, fe = Array(L); ++U < L; )
        fe[U] = X(U);
      return fe;
    }
    function rS(L, X) {
      return lt(X, function(U) {
        return [U, L[U]];
      });
    }
    function mg(L) {
      return L && L.slice(0, wg(L) + 1).replace(gn, "");
    }
    function kr(L) {
      return function(X) {
        return L(X);
      };
    }
    function Nu(L, X) {
      return lt(X, function(U) {
        return L[U];
      });
    }
    function bo(L, X) {
      return L.has(X);
    }
    function vg(L, X) {
      for (var U = -1, fe = L.length; ++U < fe && xs(X, L[U], 0) > -1; )
        ;
      return U;
    }
    function yg(L, X) {
      for (var U = L.length; U-- && xs(X, L[U], 0) > -1; )
        ;
      return U;
    }
    function nS(L, X) {
      for (var U = L.length, fe = 0; U--; )
        L[U] === X && ++fe;
      return fe;
    }
    var iS = Ru(z_), sS = Ru(W_);
    function oS(L) {
      return "\\" + U_[L];
    }
    function aS(L, X) {
      return L == null ? t : L[X];
    }
    function _s(L) {
      return L_.test(L);
    }
    function cS(L) {
      return N_.test(L);
    }
    function lS(L) {
      for (var X, U = []; !(X = L.next()).done; )
        U.push(X.value);
      return U;
    }
    function Bu(L) {
      var X = -1, U = Array(L.size);
      return L.forEach(function(fe, ke) {
        U[++X] = [ke, fe];
      }), U;
    }
    function bg(L, X) {
      return function(U) {
        return L(X(U));
      };
    }
    function si(L, X) {
      for (var U = -1, fe = L.length, ke = 0, Ye = []; ++U < fe; ) {
        var jt = L[U];
        (jt === X || jt === d) && (L[U] = d, Ye[ke++] = U);
      }
      return Ye;
    }
    function Na(L) {
      var X = -1, U = Array(L.size);
      return L.forEach(function(fe) {
        U[++X] = fe;
      }), U;
    }
    function uS(L) {
      var X = -1, U = Array(L.size);
      return L.forEach(function(fe) {
        U[++X] = [fe, fe];
      }), U;
    }
    function hS(L, X, U) {
      for (var fe = U - 1, ke = L.length; ++fe < ke; )
        if (L[fe] === X)
          return fe;
      return -1;
    }
    function dS(L, X, U) {
      for (var fe = U + 1; fe--; )
        if (L[fe] === X)
          return fe;
      return fe;
    }
    function Ss(L) {
      return _s(L) ? pS(L) : Z_(L);
    }
    function en(L) {
      return _s(L) ? gS(L) : J_(L);
    }
    function wg(L) {
      for (var X = L.length; X-- && Lp.test(L.charAt(X)); )
        ;
      return X;
    }
    var fS = Ru(H_);
    function pS(L) {
      for (var X = Ou.lastIndex = 0; Ou.test(L); )
        ++X;
      return X;
    }
    function gS(L) {
      return L.match(Ou) || [];
    }
    function mS(L) {
      return L.match(F_) || [];
    }
    var vS = function L(X) {
      X = X == null ? Ut : Cs.defaults(Ut.Object(), X, Cs.pick(Ut, B_));
      var U = X.Array, fe = X.Date, ke = X.Error, Ye = X.Function, jt = X.Math, tt = X.Object, Vu = X.RegExp, yS = X.String, Vr = X.TypeError, Ba = U.prototype, bS = Ye.prototype, Ts = tt.prototype, Va = X["__core-js_shared__"], za = bS.toString, Je = Ts.hasOwnProperty, wS = 0, xg = function() {
        var o = /[^.]+$/.exec(Va && Va.keys && Va.keys.IE_PROTO || "");
        return o ? "Symbol(src)_1." + o : "";
      }(), Wa = Ts.toString, xS = za.call(tt), _S = Ut._, SS = Vu(
        "^" + za.call(Je).replace(He, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Ha = ig ? X.Buffer : t, oi = X.Symbol, Ua = X.Uint8Array, _g = Ha ? Ha.allocUnsafe : t, $a = bg(tt.getPrototypeOf, tt), Sg = tt.create, Cg = Ts.propertyIsEnumerable, Ya = Ba.splice, Tg = oi ? oi.isConcatSpreadable : t, wo = oi ? oi.iterator : t, Di = oi ? oi.toStringTag : t, Xa = function() {
        try {
          var o = Ni(tt, "defineProperty");
          return o({}, "", {}), o;
        } catch {
        }
      }(), CS = X.clearTimeout !== Ut.clearTimeout && X.clearTimeout, TS = fe && fe.now !== Ut.Date.now && fe.now, ES = X.setTimeout !== Ut.setTimeout && X.setTimeout, Ga = jt.ceil, qa = jt.floor, zu = tt.getOwnPropertySymbols, kS = Ha ? Ha.isBuffer : t, Eg = X.isFinite, OS = Ba.join, IS = bg(tt.keys, tt), Rt = jt.max, Gt = jt.min, AS = fe.now, MS = X.parseInt, kg = jt.random, PS = Ba.reverse, Wu = Ni(X, "DataView"), xo = Ni(X, "Map"), Hu = Ni(X, "Promise"), Es = Ni(X, "Set"), _o = Ni(X, "WeakMap"), So = Ni(tt, "create"), Ka = _o && new _o(), ks = {}, DS = Bi(Wu), jS = Bi(xo), RS = Bi(Hu), FS = Bi(Es), LS = Bi(_o), Za = oi ? oi.prototype : t, Co = Za ? Za.valueOf : t, Og = Za ? Za.toString : t;
      function S(o) {
        if (vt(o) && !Oe(o) && !(o instanceof Le)) {
          if (o instanceof zr)
            return o;
          if (Je.call(o, "__wrapped__"))
            return Im(o);
        }
        return new zr(o);
      }
      var Os = /* @__PURE__ */ function() {
        function o() {
        }
        return function(l) {
          if (!ft(l))
            return {};
          if (Sg)
            return Sg(l);
          o.prototype = l;
          var f = new o();
          return o.prototype = t, f;
        };
      }();
      function Ja() {
      }
      function zr(o, l) {
        this.__wrapped__ = o, this.__actions__ = [], this.__chain__ = !!l, this.__index__ = 0, this.__values__ = t;
      }
      S.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Rp,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: Fp,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: _u,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: S
        }
      }, S.prototype = Ja.prototype, S.prototype.constructor = S, zr.prototype = Os(Ja.prototype), zr.prototype.constructor = zr;
      function Le(o) {
        this.__wrapped__ = o, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = re, this.__views__ = [];
      }
      function NS() {
        var o = new Le(this.__wrapped__);
        return o.__actions__ = gr(this.__actions__), o.__dir__ = this.__dir__, o.__filtered__ = this.__filtered__, o.__iteratees__ = gr(this.__iteratees__), o.__takeCount__ = this.__takeCount__, o.__views__ = gr(this.__views__), o;
      }
      function BS() {
        if (this.__filtered__) {
          var o = new Le(this);
          o.__dir__ = -1, o.__filtered__ = !0;
        } else
          o = this.clone(), o.__dir__ *= -1;
        return o;
      }
      function VS() {
        var o = this.__wrapped__.value(), l = this.__dir__, f = Oe(o), m = l < 0, w = f ? o.length : 0, T = J2(0, w, this.__views__), I = T.start, M = T.end, N = M - I, q = m ? M : I - 1, K = this.__iteratees__, J = K.length, ae = 0, ve = Gt(N, this.__takeCount__);
        if (!f || !m && w == N && ve == N)
          return Jg(o, this.__actions__);
        var xe = [];
        e:
          for (; N-- && ae < ve; ) {
            q += l;
            for (var De = -1, _e = o[q]; ++De < J; ) {
              var Fe = K[De], ze = Fe.iteratee, Ar = Fe.type, rr = ze(_e);
              if (Ar == ge)
                _e = rr;
              else if (!rr) {
                if (Ar == te)
                  continue e;
                break e;
              }
            }
            xe[ae++] = _e;
          }
        return xe;
      }
      Le.prototype = Os(Ja.prototype), Le.prototype.constructor = Le;
      function ji(o) {
        var l = -1, f = o == null ? 0 : o.length;
        for (this.clear(); ++l < f; ) {
          var m = o[l];
          this.set(m[0], m[1]);
        }
      }
      function zS() {
        this.__data__ = So ? So(null) : {}, this.size = 0;
      }
      function WS(o) {
        var l = this.has(o) && delete this.__data__[o];
        return this.size -= l ? 1 : 0, l;
      }
      function HS(o) {
        var l = this.__data__;
        if (So) {
          var f = l[o];
          return f === u ? t : f;
        }
        return Je.call(l, o) ? l[o] : t;
      }
      function US(o) {
        var l = this.__data__;
        return So ? l[o] !== t : Je.call(l, o);
      }
      function $S(o, l) {
        var f = this.__data__;
        return this.size += this.has(o) ? 0 : 1, f[o] = So && l === t ? u : l, this;
      }
      ji.prototype.clear = zS, ji.prototype.delete = WS, ji.prototype.get = HS, ji.prototype.has = US, ji.prototype.set = $S;
      function Mn(o) {
        var l = -1, f = o == null ? 0 : o.length;
        for (this.clear(); ++l < f; ) {
          var m = o[l];
          this.set(m[0], m[1]);
        }
      }
      function YS() {
        this.__data__ = [], this.size = 0;
      }
      function XS(o) {
        var l = this.__data__, f = Qa(l, o);
        if (f < 0)
          return !1;
        var m = l.length - 1;
        return f == m ? l.pop() : Ya.call(l, f, 1), --this.size, !0;
      }
      function GS(o) {
        var l = this.__data__, f = Qa(l, o);
        return f < 0 ? t : l[f][1];
      }
      function qS(o) {
        return Qa(this.__data__, o) > -1;
      }
      function KS(o, l) {
        var f = this.__data__, m = Qa(f, o);
        return m < 0 ? (++this.size, f.push([o, l])) : f[m][1] = l, this;
      }
      Mn.prototype.clear = YS, Mn.prototype.delete = XS, Mn.prototype.get = GS, Mn.prototype.has = qS, Mn.prototype.set = KS;
      function Pn(o) {
        var l = -1, f = o == null ? 0 : o.length;
        for (this.clear(); ++l < f; ) {
          var m = o[l];
          this.set(m[0], m[1]);
        }
      }
      function ZS() {
        this.size = 0, this.__data__ = {
          hash: new ji(),
          map: new (xo || Mn)(),
          string: new ji()
        };
      }
      function JS(o) {
        var l = hc(this, o).delete(o);
        return this.size -= l ? 1 : 0, l;
      }
      function QS(o) {
        return hc(this, o).get(o);
      }
      function e2(o) {
        return hc(this, o).has(o);
      }
      function t2(o, l) {
        var f = hc(this, o), m = f.size;
        return f.set(o, l), this.size += f.size == m ? 0 : 1, this;
      }
      Pn.prototype.clear = ZS, Pn.prototype.delete = JS, Pn.prototype.get = QS, Pn.prototype.has = e2, Pn.prototype.set = t2;
      function Ri(o) {
        var l = -1, f = o == null ? 0 : o.length;
        for (this.__data__ = new Pn(); ++l < f; )
          this.add(o[l]);
      }
      function r2(o) {
        return this.__data__.set(o, u), this;
      }
      function n2(o) {
        return this.__data__.has(o);
      }
      Ri.prototype.add = Ri.prototype.push = r2, Ri.prototype.has = n2;
      function tn(o) {
        var l = this.__data__ = new Mn(o);
        this.size = l.size;
      }
      function i2() {
        this.__data__ = new Mn(), this.size = 0;
      }
      function s2(o) {
        var l = this.__data__, f = l.delete(o);
        return this.size = l.size, f;
      }
      function o2(o) {
        return this.__data__.get(o);
      }
      function a2(o) {
        return this.__data__.has(o);
      }
      function c2(o, l) {
        var f = this.__data__;
        if (f instanceof Mn) {
          var m = f.__data__;
          if (!xo || m.length < i - 1)
            return m.push([o, l]), this.size = ++f.size, this;
          f = this.__data__ = new Pn(m);
        }
        return f.set(o, l), this.size = f.size, this;
      }
      tn.prototype.clear = i2, tn.prototype.delete = s2, tn.prototype.get = o2, tn.prototype.has = a2, tn.prototype.set = c2;
      function Ig(o, l) {
        var f = Oe(o), m = !f && Vi(o), w = !f && !m && hi(o), T = !f && !m && !w && Ps(o), I = f || m || w || T, M = I ? Lu(o.length, yS) : [], N = M.length;
        for (var q in o)
          (l || Je.call(o, q)) && !(I && // Safari 9 has enumerable `arguments.length` in strict mode.
          (q == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          w && (q == "offset" || q == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          T && (q == "buffer" || q == "byteLength" || q == "byteOffset") || // Skip index properties.
          Fn(q, N))) && M.push(q);
        return M;
      }
      function Ag(o) {
        var l = o.length;
        return l ? o[eh(0, l - 1)] : t;
      }
      function l2(o, l) {
        return dc(gr(o), Fi(l, 0, o.length));
      }
      function u2(o) {
        return dc(gr(o));
      }
      function Uu(o, l, f) {
        (f !== t && !rn(o[l], f) || f === t && !(l in o)) && Dn(o, l, f);
      }
      function To(o, l, f) {
        var m = o[l];
        (!(Je.call(o, l) && rn(m, f)) || f === t && !(l in o)) && Dn(o, l, f);
      }
      function Qa(o, l) {
        for (var f = o.length; f--; )
          if (rn(o[f][0], l))
            return f;
        return -1;
      }
      function h2(o, l, f, m) {
        return ai(o, function(w, T, I) {
          l(m, w, f(w), I);
        }), m;
      }
      function Mg(o, l) {
        return o && vn(l, Wt(l), o);
      }
      function d2(o, l) {
        return o && vn(l, vr(l), o);
      }
      function Dn(o, l, f) {
        l == "__proto__" && Xa ? Xa(o, l, {
          configurable: !0,
          enumerable: !0,
          value: f,
          writable: !0
        }) : o[l] = f;
      }
      function $u(o, l) {
        for (var f = -1, m = l.length, w = U(m), T = o == null; ++f < m; )
          w[f] = T ? t : Th(o, l[f]);
        return w;
      }
      function Fi(o, l, f) {
        return o === o && (f !== t && (o = o <= f ? o : f), l !== t && (o = o >= l ? o : l)), o;
      }
      function Wr(o, l, f, m, w, T) {
        var I, M = l & p, N = l & g, q = l & v;
        if (f && (I = w ? f(o, m, w, T) : f(o)), I !== t)
          return I;
        if (!ft(o))
          return o;
        var K = Oe(o);
        if (K) {
          if (I = eC(o), !M)
            return gr(o, I);
        } else {
          var J = qt(o), ae = J == ye || J == _r;
          if (hi(o))
            return tm(o, M);
          if (J == nt || J == Ee || ae && !w) {
            if (I = N || ae ? {} : wm(o), !M)
              return N ? H2(o, d2(I, o)) : W2(o, Mg(I, o));
          } else {
            if (!it[J])
              return w ? o : {};
            I = tC(o, J, M);
          }
        }
        T || (T = new tn());
        var ve = T.get(o);
        if (ve)
          return ve;
        T.set(o, I), qm(o) ? o.forEach(function(_e) {
          I.add(Wr(_e, l, f, _e, o, T));
        }) : Xm(o) && o.forEach(function(_e, Fe) {
          I.set(Fe, Wr(_e, l, f, Fe, o, T));
        });
        var xe = q ? N ? hh : uh : N ? vr : Wt, De = K ? t : xe(o);
        return Br(De || o, function(_e, Fe) {
          De && (Fe = _e, _e = o[Fe]), To(I, Fe, Wr(_e, l, f, Fe, o, T));
        }), I;
      }
      function f2(o) {
        var l = Wt(o);
        return function(f) {
          return Pg(f, o, l);
        };
      }
      function Pg(o, l, f) {
        var m = f.length;
        if (o == null)
          return !m;
        for (o = tt(o); m--; ) {
          var w = f[m], T = l[w], I = o[w];
          if (I === t && !(w in o) || !T(I))
            return !1;
        }
        return !0;
      }
      function Dg(o, l, f) {
        if (typeof o != "function")
          throw new Vr(a);
        return Po(function() {
          o.apply(t, f);
        }, l);
      }
      function Eo(o, l, f, m) {
        var w = -1, T = Fa, I = !0, M = o.length, N = [], q = l.length;
        if (!M)
          return N;
        f && (l = lt(l, kr(f))), m ? (T = Mu, I = !1) : l.length >= i && (T = bo, I = !1, l = new Ri(l));
        e:
          for (; ++w < M; ) {
            var K = o[w], J = f == null ? K : f(K);
            if (K = m || K !== 0 ? K : 0, I && J === J) {
              for (var ae = q; ae--; )
                if (l[ae] === J)
                  continue e;
              N.push(K);
            } else T(l, J, m) || N.push(K);
          }
        return N;
      }
      var ai = om(mn), jg = om(Xu, !0);
      function p2(o, l) {
        var f = !0;
        return ai(o, function(m, w, T) {
          return f = !!l(m, w, T), f;
        }), f;
      }
      function ec(o, l, f) {
        for (var m = -1, w = o.length; ++m < w; ) {
          var T = o[m], I = l(T);
          if (I != null && (M === t ? I === I && !Ir(I) : f(I, M)))
            var M = I, N = T;
        }
        return N;
      }
      function g2(o, l, f, m) {
        var w = o.length;
        for (f = Ae(f), f < 0 && (f = -f > w ? 0 : w + f), m = m === t || m > w ? w : Ae(m), m < 0 && (m += w), m = f > m ? 0 : Zm(m); f < m; )
          o[f++] = l;
        return o;
      }
      function Rg(o, l) {
        var f = [];
        return ai(o, function(m, w, T) {
          l(m, w, T) && f.push(m);
        }), f;
      }
      function $t(o, l, f, m, w) {
        var T = -1, I = o.length;
        for (f || (f = nC), w || (w = []); ++T < I; ) {
          var M = o[T];
          l > 0 && f(M) ? l > 1 ? $t(M, l - 1, f, m, w) : ii(w, M) : m || (w[w.length] = M);
        }
        return w;
      }
      var Yu = am(), Fg = am(!0);
      function mn(o, l) {
        return o && Yu(o, l, Wt);
      }
      function Xu(o, l) {
        return o && Fg(o, l, Wt);
      }
      function tc(o, l) {
        return ni(l, function(f) {
          return Ln(o[f]);
        });
      }
      function Li(o, l) {
        l = li(l, o);
        for (var f = 0, m = l.length; o != null && f < m; )
          o = o[yn(l[f++])];
        return f && f == m ? o : t;
      }
      function Lg(o, l, f) {
        var m = l(o);
        return Oe(o) ? m : ii(m, f(o));
      }
      function er(o) {
        return o == null ? o === t ? Re : ri : Di && Di in tt(o) ? Z2(o) : uC(o);
      }
      function Gu(o, l) {
        return o > l;
      }
      function m2(o, l) {
        return o != null && Je.call(o, l);
      }
      function v2(o, l) {
        return o != null && l in tt(o);
      }
      function y2(o, l, f) {
        return o >= Gt(l, f) && o < Rt(l, f);
      }
      function qu(o, l, f) {
        for (var m = f ? Mu : Fa, w = o[0].length, T = o.length, I = T, M = U(T), N = 1 / 0, q = []; I--; ) {
          var K = o[I];
          I && l && (K = lt(K, kr(l))), N = Gt(K.length, N), M[I] = !f && (l || w >= 120 && K.length >= 120) ? new Ri(I && K) : t;
        }
        K = o[0];
        var J = -1, ae = M[0];
        e:
          for (; ++J < w && q.length < N; ) {
            var ve = K[J], xe = l ? l(ve) : ve;
            if (ve = f || ve !== 0 ? ve : 0, !(ae ? bo(ae, xe) : m(q, xe, f))) {
              for (I = T; --I; ) {
                var De = M[I];
                if (!(De ? bo(De, xe) : m(o[I], xe, f)))
                  continue e;
              }
              ae && ae.push(xe), q.push(ve);
            }
          }
        return q;
      }
      function b2(o, l, f, m) {
        return mn(o, function(w, T, I) {
          l(m, f(w), T, I);
        }), m;
      }
      function ko(o, l, f) {
        l = li(l, o), o = Cm(o, l);
        var m = o == null ? o : o[yn(Ur(l))];
        return m == null ? t : Er(m, o, f);
      }
      function Ng(o) {
        return vt(o) && er(o) == Ee;
      }
      function w2(o) {
        return vt(o) && er(o) == Se;
      }
      function x2(o) {
        return vt(o) && er(o) == Ht;
      }
      function Oo(o, l, f, m, w) {
        return o === l ? !0 : o == null || l == null || !vt(o) && !vt(l) ? o !== o && l !== l : _2(o, l, f, m, Oo, w);
      }
      function _2(o, l, f, m, w, T) {
        var I = Oe(o), M = Oe(l), N = I ? Ie : qt(o), q = M ? Ie : qt(l);
        N = N == Ee ? nt : N, q = q == Ee ? nt : q;
        var K = N == nt, J = q == nt, ae = N == q;
        if (ae && hi(o)) {
          if (!hi(l))
            return !1;
          I = !0, K = !1;
        }
        if (ae && !K)
          return T || (T = new tn()), I || Ps(o) ? vm(o, l, f, m, w, T) : q2(o, l, N, f, m, w, T);
        if (!(f & b)) {
          var ve = K && Je.call(o, "__wrapped__"), xe = J && Je.call(l, "__wrapped__");
          if (ve || xe) {
            var De = ve ? o.value() : o, _e = xe ? l.value() : l;
            return T || (T = new tn()), w(De, _e, f, m, T);
          }
        }
        return ae ? (T || (T = new tn()), K2(o, l, f, m, w, T)) : !1;
      }
      function S2(o) {
        return vt(o) && qt(o) == st;
      }
      function Ku(o, l, f, m) {
        var w = f.length, T = w, I = !m;
        if (o == null)
          return !T;
        for (o = tt(o); w--; ) {
          var M = f[w];
          if (I && M[2] ? M[1] !== o[M[0]] : !(M[0] in o))
            return !1;
        }
        for (; ++w < T; ) {
          M = f[w];
          var N = M[0], q = o[N], K = M[1];
          if (I && M[2]) {
            if (q === t && !(N in o))
              return !1;
          } else {
            var J = new tn();
            if (m)
              var ae = m(q, K, N, o, l, J);
            if (!(ae === t ? Oo(K, q, b | x, m, J) : ae))
              return !1;
          }
        }
        return !0;
      }
      function Bg(o) {
        if (!ft(o) || sC(o))
          return !1;
        var l = Ln(o) ? SS : f_;
        return l.test(Bi(o));
      }
      function C2(o) {
        return vt(o) && er(o) == Sr;
      }
      function T2(o) {
        return vt(o) && qt(o) == A;
      }
      function E2(o) {
        return vt(o) && yc(o.length) && !!at[er(o)];
      }
      function Vg(o) {
        return typeof o == "function" ? o : o == null ? yr : typeof o == "object" ? Oe(o) ? Hg(o[0], o[1]) : Wg(o) : cv(o);
      }
      function Zu(o) {
        if (!Mo(o))
          return IS(o);
        var l = [];
        for (var f in tt(o))
          Je.call(o, f) && f != "constructor" && l.push(f);
        return l;
      }
      function k2(o) {
        if (!ft(o))
          return lC(o);
        var l = Mo(o), f = [];
        for (var m in o)
          m == "constructor" && (l || !Je.call(o, m)) || f.push(m);
        return f;
      }
      function Ju(o, l) {
        return o < l;
      }
      function zg(o, l) {
        var f = -1, m = mr(o) ? U(o.length) : [];
        return ai(o, function(w, T, I) {
          m[++f] = l(w, T, I);
        }), m;
      }
      function Wg(o) {
        var l = fh(o);
        return l.length == 1 && l[0][2] ? _m(l[0][0], l[0][1]) : function(f) {
          return f === o || Ku(f, o, l);
        };
      }
      function Hg(o, l) {
        return gh(o) && xm(l) ? _m(yn(o), l) : function(f) {
          var m = Th(f, o);
          return m === t && m === l ? Eh(f, o) : Oo(l, m, b | x);
        };
      }
      function rc(o, l, f, m, w) {
        o !== l && Yu(l, function(T, I) {
          if (w || (w = new tn()), ft(T))
            O2(o, l, I, f, rc, m, w);
          else {
            var M = m ? m(vh(o, I), T, I + "", o, l, w) : t;
            M === t && (M = T), Uu(o, I, M);
          }
        }, vr);
      }
      function O2(o, l, f, m, w, T, I) {
        var M = vh(o, f), N = vh(l, f), q = I.get(N);
        if (q) {
          Uu(o, f, q);
          return;
        }
        var K = T ? T(M, N, f + "", o, l, I) : t, J = K === t;
        if (J) {
          var ae = Oe(N), ve = !ae && hi(N), xe = !ae && !ve && Ps(N);
          K = N, ae || ve || xe ? Oe(M) ? K = M : St(M) ? K = gr(M) : ve ? (J = !1, K = tm(N, !0)) : xe ? (J = !1, K = rm(N, !0)) : K = [] : Do(N) || Vi(N) ? (K = M, Vi(M) ? K = Jm(M) : (!ft(M) || Ln(M)) && (K = wm(N))) : J = !1;
        }
        J && (I.set(N, K), w(K, N, m, T, I), I.delete(N)), Uu(o, f, K);
      }
      function Ug(o, l) {
        var f = o.length;
        if (f)
          return l += l < 0 ? f : 0, Fn(l, f) ? o[l] : t;
      }
      function $g(o, l, f) {
        l.length ? l = lt(l, function(T) {
          return Oe(T) ? function(I) {
            return Li(I, T.length === 1 ? T[0] : T);
          } : T;
        }) : l = [yr];
        var m = -1;
        l = lt(l, kr(we()));
        var w = zg(o, function(T, I, M) {
          var N = lt(l, function(q) {
            return q(T);
          });
          return { criteria: N, index: ++m, value: T };
        });
        return tS(w, function(T, I) {
          return z2(T, I, f);
        });
      }
      function I2(o, l) {
        return Yg(o, l, function(f, m) {
          return Eh(o, m);
        });
      }
      function Yg(o, l, f) {
        for (var m = -1, w = l.length, T = {}; ++m < w; ) {
          var I = l[m], M = Li(o, I);
          f(M, I) && Io(T, li(I, o), M);
        }
        return T;
      }
      function A2(o) {
        return function(l) {
          return Li(l, o);
        };
      }
      function Qu(o, l, f, m) {
        var w = m ? eS : xs, T = -1, I = l.length, M = o;
        for (o === l && (l = gr(l)), f && (M = lt(o, kr(f))); ++T < I; )
          for (var N = 0, q = l[T], K = f ? f(q) : q; (N = w(M, K, N, m)) > -1; )
            M !== o && Ya.call(M, N, 1), Ya.call(o, N, 1);
        return o;
      }
      function Xg(o, l) {
        for (var f = o ? l.length : 0, m = f - 1; f--; ) {
          var w = l[f];
          if (f == m || w !== T) {
            var T = w;
            Fn(w) ? Ya.call(o, w, 1) : nh(o, w);
          }
        }
        return o;
      }
      function eh(o, l) {
        return o + qa(kg() * (l - o + 1));
      }
      function M2(o, l, f, m) {
        for (var w = -1, T = Rt(Ga((l - o) / (f || 1)), 0), I = U(T); T--; )
          I[m ? T : ++w] = o, o += f;
        return I;
      }
      function th(o, l) {
        var f = "";
        if (!o || l < 1 || l > oe)
          return f;
        do
          l % 2 && (f += o), l = qa(l / 2), l && (o += o);
        while (l);
        return f;
      }
      function je(o, l) {
        return yh(Sm(o, l, yr), o + "");
      }
      function P2(o) {
        return Ag(Ds(o));
      }
      function D2(o, l) {
        var f = Ds(o);
        return dc(f, Fi(l, 0, f.length));
      }
      function Io(o, l, f, m) {
        if (!ft(o))
          return o;
        l = li(l, o);
        for (var w = -1, T = l.length, I = T - 1, M = o; M != null && ++w < T; ) {
          var N = yn(l[w]), q = f;
          if (N === "__proto__" || N === "constructor" || N === "prototype")
            return o;
          if (w != I) {
            var K = M[N];
            q = m ? m(K, N, M) : t, q === t && (q = ft(K) ? K : Fn(l[w + 1]) ? [] : {});
          }
          To(M, N, q), M = M[N];
        }
        return o;
      }
      var Gg = Ka ? function(o, l) {
        return Ka.set(o, l), o;
      } : yr, j2 = Xa ? function(o, l) {
        return Xa(o, "toString", {
          configurable: !0,
          enumerable: !1,
          value: Oh(l),
          writable: !0
        });
      } : yr;
      function R2(o) {
        return dc(Ds(o));
      }
      function Hr(o, l, f) {
        var m = -1, w = o.length;
        l < 0 && (l = -l > w ? 0 : w + l), f = f > w ? w : f, f < 0 && (f += w), w = l > f ? 0 : f - l >>> 0, l >>>= 0;
        for (var T = U(w); ++m < w; )
          T[m] = o[m + l];
        return T;
      }
      function F2(o, l) {
        var f;
        return ai(o, function(m, w, T) {
          return f = l(m, w, T), !f;
        }), !!f;
      }
      function nc(o, l, f) {
        var m = 0, w = o == null ? m : o.length;
        if (typeof l == "number" && l === l && w <= Ze) {
          for (; m < w; ) {
            var T = m + w >>> 1, I = o[T];
            I !== null && !Ir(I) && (f ? I <= l : I < l) ? m = T + 1 : w = T;
          }
          return w;
        }
        return rh(o, l, yr, f);
      }
      function rh(o, l, f, m) {
        var w = 0, T = o == null ? 0 : o.length;
        if (T === 0)
          return 0;
        l = f(l);
        for (var I = l !== l, M = l === null, N = Ir(l), q = l === t; w < T; ) {
          var K = qa((w + T) / 2), J = f(o[K]), ae = J !== t, ve = J === null, xe = J === J, De = Ir(J);
          if (I)
            var _e = m || xe;
          else q ? _e = xe && (m || ae) : M ? _e = xe && ae && (m || !ve) : N ? _e = xe && ae && !ve && (m || !De) : ve || De ? _e = !1 : _e = m ? J <= l : J < l;
          _e ? w = K + 1 : T = K;
        }
        return Gt(T, Ve);
      }
      function qg(o, l) {
        for (var f = -1, m = o.length, w = 0, T = []; ++f < m; ) {
          var I = o[f], M = l ? l(I) : I;
          if (!f || !rn(M, N)) {
            var N = M;
            T[w++] = I === 0 ? 0 : I;
          }
        }
        return T;
      }
      function Kg(o) {
        return typeof o == "number" ? o : Ir(o) ? pe : +o;
      }
      function Or(o) {
        if (typeof o == "string")
          return o;
        if (Oe(o))
          return lt(o, Or) + "";
        if (Ir(o))
          return Og ? Og.call(o) : "";
        var l = o + "";
        return l == "0" && 1 / o == -1 / 0 ? "-0" : l;
      }
      function ci(o, l, f) {
        var m = -1, w = Fa, T = o.length, I = !0, M = [], N = M;
        if (f)
          I = !1, w = Mu;
        else if (T >= i) {
          var q = l ? null : X2(o);
          if (q)
            return Na(q);
          I = !1, w = bo, N = new Ri();
        } else
          N = l ? [] : M;
        e:
          for (; ++m < T; ) {
            var K = o[m], J = l ? l(K) : K;
            if (K = f || K !== 0 ? K : 0, I && J === J) {
              for (var ae = N.length; ae--; )
                if (N[ae] === J)
                  continue e;
              l && N.push(J), M.push(K);
            } else w(N, J, f) || (N !== M && N.push(J), M.push(K));
          }
        return M;
      }
      function nh(o, l) {
        return l = li(l, o), o = Cm(o, l), o == null || delete o[yn(Ur(l))];
      }
      function Zg(o, l, f, m) {
        return Io(o, l, f(Li(o, l)), m);
      }
      function ic(o, l, f, m) {
        for (var w = o.length, T = m ? w : -1; (m ? T-- : ++T < w) && l(o[T], T, o); )
          ;
        return f ? Hr(o, m ? 0 : T, m ? T + 1 : w) : Hr(o, m ? T + 1 : 0, m ? w : T);
      }
      function Jg(o, l) {
        var f = o;
        return f instanceof Le && (f = f.value()), Pu(l, function(m, w) {
          return w.func.apply(w.thisArg, ii([m], w.args));
        }, f);
      }
      function ih(o, l, f) {
        var m = o.length;
        if (m < 2)
          return m ? ci(o[0]) : [];
        for (var w = -1, T = U(m); ++w < m; )
          for (var I = o[w], M = -1; ++M < m; )
            M != w && (T[w] = Eo(T[w] || I, o[M], l, f));
        return ci($t(T, 1), l, f);
      }
      function Qg(o, l, f) {
        for (var m = -1, w = o.length, T = l.length, I = {}; ++m < w; ) {
          var M = m < T ? l[m] : t;
          f(I, o[m], M);
        }
        return I;
      }
      function sh(o) {
        return St(o) ? o : [];
      }
      function oh(o) {
        return typeof o == "function" ? o : yr;
      }
      function li(o, l) {
        return Oe(o) ? o : gh(o, l) ? [o] : Om(qe(o));
      }
      var L2 = je;
      function ui(o, l, f) {
        var m = o.length;
        return f = f === t ? m : f, !l && f >= m ? o : Hr(o, l, f);
      }
      var em = CS || function(o) {
        return Ut.clearTimeout(o);
      };
      function tm(o, l) {
        if (l)
          return o.slice();
        var f = o.length, m = _g ? _g(f) : new o.constructor(f);
        return o.copy(m), m;
      }
      function ah(o) {
        var l = new o.constructor(o.byteLength);
        return new Ua(l).set(new Ua(o)), l;
      }
      function N2(o, l) {
        var f = l ? ah(o.buffer) : o.buffer;
        return new o.constructor(f, o.byteOffset, o.byteLength);
      }
      function B2(o) {
        var l = new o.constructor(o.source, Np.exec(o));
        return l.lastIndex = o.lastIndex, l;
      }
      function V2(o) {
        return Co ? tt(Co.call(o)) : {};
      }
      function rm(o, l) {
        var f = l ? ah(o.buffer) : o.buffer;
        return new o.constructor(f, o.byteOffset, o.length);
      }
      function nm(o, l) {
        if (o !== l) {
          var f = o !== t, m = o === null, w = o === o, T = Ir(o), I = l !== t, M = l === null, N = l === l, q = Ir(l);
          if (!M && !q && !T && o > l || T && I && N && !M && !q || m && I && N || !f && N || !w)
            return 1;
          if (!m && !T && !q && o < l || q && f && w && !m && !T || M && f && w || !I && w || !N)
            return -1;
        }
        return 0;
      }
      function z2(o, l, f) {
        for (var m = -1, w = o.criteria, T = l.criteria, I = w.length, M = f.length; ++m < I; ) {
          var N = nm(w[m], T[m]);
          if (N) {
            if (m >= M)
              return N;
            var q = f[m];
            return N * (q == "desc" ? -1 : 1);
          }
        }
        return o.index - l.index;
      }
      function im(o, l, f, m) {
        for (var w = -1, T = o.length, I = f.length, M = -1, N = l.length, q = Rt(T - I, 0), K = U(N + q), J = !m; ++M < N; )
          K[M] = l[M];
        for (; ++w < I; )
          (J || w < T) && (K[f[w]] = o[w]);
        for (; q--; )
          K[M++] = o[w++];
        return K;
      }
      function sm(o, l, f, m) {
        for (var w = -1, T = o.length, I = -1, M = f.length, N = -1, q = l.length, K = Rt(T - M, 0), J = U(K + q), ae = !m; ++w < K; )
          J[w] = o[w];
        for (var ve = w; ++N < q; )
          J[ve + N] = l[N];
        for (; ++I < M; )
          (ae || w < T) && (J[ve + f[I]] = o[w++]);
        return J;
      }
      function gr(o, l) {
        var f = -1, m = o.length;
        for (l || (l = U(m)); ++f < m; )
          l[f] = o[f];
        return l;
      }
      function vn(o, l, f, m) {
        var w = !f;
        f || (f = {});
        for (var T = -1, I = l.length; ++T < I; ) {
          var M = l[T], N = m ? m(f[M], o[M], M, f, o) : t;
          N === t && (N = o[M]), w ? Dn(f, M, N) : To(f, M, N);
        }
        return f;
      }
      function W2(o, l) {
        return vn(o, ph(o), l);
      }
      function H2(o, l) {
        return vn(o, ym(o), l);
      }
      function sc(o, l) {
        return function(f, m) {
          var w = Oe(f) ? G_ : h2, T = l ? l() : {};
          return w(f, o, we(m, 2), T);
        };
      }
      function Is(o) {
        return je(function(l, f) {
          var m = -1, w = f.length, T = w > 1 ? f[w - 1] : t, I = w > 2 ? f[2] : t;
          for (T = o.length > 3 && typeof T == "function" ? (w--, T) : t, I && tr(f[0], f[1], I) && (T = w < 3 ? t : T, w = 1), l = tt(l); ++m < w; ) {
            var M = f[m];
            M && o(l, M, m, T);
          }
          return l;
        });
      }
      function om(o, l) {
        return function(f, m) {
          if (f == null)
            return f;
          if (!mr(f))
            return o(f, m);
          for (var w = f.length, T = l ? w : -1, I = tt(f); (l ? T-- : ++T < w) && m(I[T], T, I) !== !1; )
            ;
          return f;
        };
      }
      function am(o) {
        return function(l, f, m) {
          for (var w = -1, T = tt(l), I = m(l), M = I.length; M--; ) {
            var N = I[o ? M : ++w];
            if (f(T[N], N, T) === !1)
              break;
          }
          return l;
        };
      }
      function U2(o, l, f) {
        var m = l & _, w = Ao(o);
        function T() {
          var I = this && this !== Ut && this instanceof T ? w : o;
          return I.apply(m ? f : this, arguments);
        }
        return T;
      }
      function cm(o) {
        return function(l) {
          l = qe(l);
          var f = _s(l) ? en(l) : t, m = f ? f[0] : l.charAt(0), w = f ? ui(f, 1).join("") : l.slice(1);
          return m[o]() + w;
        };
      }
      function As(o) {
        return function(l) {
          return Pu(ov(sv(l).replace(j_, "")), o, "");
        };
      }
      function Ao(o) {
        return function() {
          var l = arguments;
          switch (l.length) {
            case 0:
              return new o();
            case 1:
              return new o(l[0]);
            case 2:
              return new o(l[0], l[1]);
            case 3:
              return new o(l[0], l[1], l[2]);
            case 4:
              return new o(l[0], l[1], l[2], l[3]);
            case 5:
              return new o(l[0], l[1], l[2], l[3], l[4]);
            case 6:
              return new o(l[0], l[1], l[2], l[3], l[4], l[5]);
            case 7:
              return new o(l[0], l[1], l[2], l[3], l[4], l[5], l[6]);
          }
          var f = Os(o.prototype), m = o.apply(f, l);
          return ft(m) ? m : f;
        };
      }
      function $2(o, l, f) {
        var m = Ao(o);
        function w() {
          for (var T = arguments.length, I = U(T), M = T, N = Ms(w); M--; )
            I[M] = arguments[M];
          var q = T < 3 && I[0] !== N && I[T - 1] !== N ? [] : si(I, N);
          if (T -= q.length, T < f)
            return fm(
              o,
              l,
              oc,
              w.placeholder,
              t,
              I,
              q,
              t,
              t,
              f - T
            );
          var K = this && this !== Ut && this instanceof w ? m : o;
          return Er(K, this, I);
        }
        return w;
      }
      function lm(o) {
        return function(l, f, m) {
          var w = tt(l);
          if (!mr(l)) {
            var T = we(f, 3);
            l = Wt(l), f = function(M) {
              return T(w[M], M, w);
            };
          }
          var I = o(l, f, m);
          return I > -1 ? w[T ? l[I] : I] : t;
        };
      }
      function um(o) {
        return Rn(function(l) {
          var f = l.length, m = f, w = zr.prototype.thru;
          for (o && l.reverse(); m--; ) {
            var T = l[m];
            if (typeof T != "function")
              throw new Vr(a);
            if (w && !I && uc(T) == "wrapper")
              var I = new zr([], !0);
          }
          for (m = I ? m : f; ++m < f; ) {
            T = l[m];
            var M = uc(T), N = M == "wrapper" ? dh(T) : t;
            N && mh(N[0]) && N[1] == (V | k | P | F) && !N[4].length && N[9] == 1 ? I = I[uc(N[0])].apply(I, N[3]) : I = T.length == 1 && mh(T) ? I[M]() : I.thru(T);
          }
          return function() {
            var q = arguments, K = q[0];
            if (I && q.length == 1 && Oe(K))
              return I.plant(K).value();
            for (var J = 0, ae = f ? l[J].apply(this, q) : K; ++J < f; )
              ae = l[J].call(this, ae);
            return ae;
          };
        });
      }
      function oc(o, l, f, m, w, T, I, M, N, q) {
        var K = l & V, J = l & _, ae = l & C, ve = l & (k | O), xe = l & $, De = ae ? t : Ao(o);
        function _e() {
          for (var Fe = arguments.length, ze = U(Fe), Ar = Fe; Ar--; )
            ze[Ar] = arguments[Ar];
          if (ve)
            var rr = Ms(_e), Mr = nS(ze, rr);
          if (m && (ze = im(ze, m, w, ve)), T && (ze = sm(ze, T, I, ve)), Fe -= Mr, ve && Fe < q) {
            var Ct = si(ze, rr);
            return fm(
              o,
              l,
              oc,
              _e.placeholder,
              f,
              ze,
              Ct,
              M,
              N,
              q - Fe
            );
          }
          var nn = J ? f : this, Bn = ae ? nn[o] : o;
          return Fe = ze.length, M ? ze = hC(ze, M) : xe && Fe > 1 && ze.reverse(), K && N < Fe && (ze.length = N), this && this !== Ut && this instanceof _e && (Bn = De || Ao(Bn)), Bn.apply(nn, ze);
        }
        return _e;
      }
      function hm(o, l) {
        return function(f, m) {
          return b2(f, o, l(m), {});
        };
      }
      function ac(o, l) {
        return function(f, m) {
          var w;
          if (f === t && m === t)
            return l;
          if (f !== t && (w = f), m !== t) {
            if (w === t)
              return m;
            typeof f == "string" || typeof m == "string" ? (f = Or(f), m = Or(m)) : (f = Kg(f), m = Kg(m)), w = o(f, m);
          }
          return w;
        };
      }
      function ch(o) {
        return Rn(function(l) {
          return l = lt(l, kr(we())), je(function(f) {
            var m = this;
            return o(l, function(w) {
              return Er(w, m, f);
            });
          });
        });
      }
      function cc(o, l) {
        l = l === t ? " " : Or(l);
        var f = l.length;
        if (f < 2)
          return f ? th(l, o) : l;
        var m = th(l, Ga(o / Ss(l)));
        return _s(l) ? ui(en(m), 0, o).join("") : m.slice(0, o);
      }
      function Y2(o, l, f, m) {
        var w = l & _, T = Ao(o);
        function I() {
          for (var M = -1, N = arguments.length, q = -1, K = m.length, J = U(K + N), ae = this && this !== Ut && this instanceof I ? T : o; ++q < K; )
            J[q] = m[q];
          for (; N--; )
            J[q++] = arguments[++M];
          return Er(ae, w ? f : this, J);
        }
        return I;
      }
      function dm(o) {
        return function(l, f, m) {
          return m && typeof m != "number" && tr(l, f, m) && (f = m = t), l = Nn(l), f === t ? (f = l, l = 0) : f = Nn(f), m = m === t ? l < f ? 1 : -1 : Nn(m), M2(l, f, m, o);
        };
      }
      function lc(o) {
        return function(l, f) {
          return typeof l == "string" && typeof f == "string" || (l = $r(l), f = $r(f)), o(l, f);
        };
      }
      function fm(o, l, f, m, w, T, I, M, N, q) {
        var K = l & k, J = K ? I : t, ae = K ? t : I, ve = K ? T : t, xe = K ? t : T;
        l |= K ? P : R, l &= ~(K ? R : P), l & E || (l &= -4);
        var De = [
          o,
          l,
          w,
          ve,
          J,
          xe,
          ae,
          M,
          N,
          q
        ], _e = f.apply(t, De);
        return mh(o) && Tm(_e, De), _e.placeholder = m, Em(_e, o, l);
      }
      function lh(o) {
        var l = jt[o];
        return function(f, m) {
          if (f = $r(f), m = m == null ? 0 : Gt(Ae(m), 292), m && Eg(f)) {
            var w = (qe(f) + "e").split("e"), T = l(w[0] + "e" + (+w[1] + m));
            return w = (qe(T) + "e").split("e"), +(w[0] + "e" + (+w[1] - m));
          }
          return l(f);
        };
      }
      var X2 = Es && 1 / Na(new Es([, -0]))[1] == de ? function(o) {
        return new Es(o);
      } : Mh;
      function pm(o) {
        return function(l) {
          var f = qt(l);
          return f == st ? Bu(l) : f == A ? uS(l) : rS(l, o(l));
        };
      }
      function jn(o, l, f, m, w, T, I, M) {
        var N = l & C;
        if (!N && typeof o != "function")
          throw new Vr(a);
        var q = m ? m.length : 0;
        if (q || (l &= -97, m = w = t), I = I === t ? I : Rt(Ae(I), 0), M = M === t ? M : Ae(M), q -= w ? w.length : 0, l & R) {
          var K = m, J = w;
          m = w = t;
        }
        var ae = N ? t : dh(o), ve = [
          o,
          l,
          f,
          m,
          w,
          K,
          J,
          T,
          I,
          M
        ];
        if (ae && cC(ve, ae), o = ve[0], l = ve[1], f = ve[2], m = ve[3], w = ve[4], M = ve[9] = ve[9] === t ? N ? 0 : o.length : Rt(ve[9] - q, 0), !M && l & (k | O) && (l &= -25), !l || l == _)
          var xe = U2(o, l, f);
        else l == k || l == O ? xe = $2(o, l, M) : (l == P || l == (_ | P)) && !w.length ? xe = Y2(o, l, f, m) : xe = oc.apply(t, ve);
        var De = ae ? Gg : Tm;
        return Em(De(xe, ve), o, l);
      }
      function gm(o, l, f, m) {
        return o === t || rn(o, Ts[f]) && !Je.call(m, f) ? l : o;
      }
      function mm(o, l, f, m, w, T) {
        return ft(o) && ft(l) && (T.set(l, o), rc(o, l, t, mm, T), T.delete(l)), o;
      }
      function G2(o) {
        return Do(o) ? t : o;
      }
      function vm(o, l, f, m, w, T) {
        var I = f & b, M = o.length, N = l.length;
        if (M != N && !(I && N > M))
          return !1;
        var q = T.get(o), K = T.get(l);
        if (q && K)
          return q == l && K == o;
        var J = -1, ae = !0, ve = f & x ? new Ri() : t;
        for (T.set(o, l), T.set(l, o); ++J < M; ) {
          var xe = o[J], De = l[J];
          if (m)
            var _e = I ? m(De, xe, J, l, o, T) : m(xe, De, J, o, l, T);
          if (_e !== t) {
            if (_e)
              continue;
            ae = !1;
            break;
          }
          if (ve) {
            if (!Du(l, function(Fe, ze) {
              if (!bo(ve, ze) && (xe === Fe || w(xe, Fe, f, m, T)))
                return ve.push(ze);
            })) {
              ae = !1;
              break;
            }
          } else if (!(xe === De || w(xe, De, f, m, T))) {
            ae = !1;
            break;
          }
        }
        return T.delete(o), T.delete(l), ae;
      }
      function q2(o, l, f, m, w, T, I) {
        switch (f) {
          case ot:
            if (o.byteLength != l.byteLength || o.byteOffset != l.byteOffset)
              return !1;
            o = o.buffer, l = l.buffer;
          case Se:
            return !(o.byteLength != l.byteLength || !T(new Ua(o), new Ua(l)));
          case hr:
          case Ht:
          case zt:
            return rn(+o, +l);
          case dr:
            return o.name == l.name && o.message == l.message;
          case Sr:
          case he:
            return o == l + "";
          case st:
            var M = Bu;
          case A:
            var N = m & b;
            if (M || (M = Na), o.size != l.size && !N)
              return !1;
            var q = I.get(o);
            if (q)
              return q == l;
            m |= x, I.set(o, l);
            var K = vm(M(o), M(l), m, w, T, I);
            return I.delete(o), K;
          case le:
            if (Co)
              return Co.call(o) == Co.call(l);
        }
        return !1;
      }
      function K2(o, l, f, m, w, T) {
        var I = f & b, M = uh(o), N = M.length, q = uh(l), K = q.length;
        if (N != K && !I)
          return !1;
        for (var J = N; J--; ) {
          var ae = M[J];
          if (!(I ? ae in l : Je.call(l, ae)))
            return !1;
        }
        var ve = T.get(o), xe = T.get(l);
        if (ve && xe)
          return ve == l && xe == o;
        var De = !0;
        T.set(o, l), T.set(l, o);
        for (var _e = I; ++J < N; ) {
          ae = M[J];
          var Fe = o[ae], ze = l[ae];
          if (m)
            var Ar = I ? m(ze, Fe, ae, l, o, T) : m(Fe, ze, ae, o, l, T);
          if (!(Ar === t ? Fe === ze || w(Fe, ze, f, m, T) : Ar)) {
            De = !1;
            break;
          }
          _e || (_e = ae == "constructor");
        }
        if (De && !_e) {
          var rr = o.constructor, Mr = l.constructor;
          rr != Mr && "constructor" in o && "constructor" in l && !(typeof rr == "function" && rr instanceof rr && typeof Mr == "function" && Mr instanceof Mr) && (De = !1);
        }
        return T.delete(o), T.delete(l), De;
      }
      function Rn(o) {
        return yh(Sm(o, t, Pm), o + "");
      }
      function uh(o) {
        return Lg(o, Wt, ph);
      }
      function hh(o) {
        return Lg(o, vr, ym);
      }
      var dh = Ka ? function(o) {
        return Ka.get(o);
      } : Mh;
      function uc(o) {
        for (var l = o.name + "", f = ks[l], m = Je.call(ks, l) ? f.length : 0; m--; ) {
          var w = f[m], T = w.func;
          if (T == null || T == o)
            return w.name;
        }
        return l;
      }
      function Ms(o) {
        var l = Je.call(S, "placeholder") ? S : o;
        return l.placeholder;
      }
      function we() {
        var o = S.iteratee || Ih;
        return o = o === Ih ? Vg : o, arguments.length ? o(arguments[0], arguments[1]) : o;
      }
      function hc(o, l) {
        var f = o.__data__;
        return iC(l) ? f[typeof l == "string" ? "string" : "hash"] : f.map;
      }
      function fh(o) {
        for (var l = Wt(o), f = l.length; f--; ) {
          var m = l[f], w = o[m];
          l[f] = [m, w, xm(w)];
        }
        return l;
      }
      function Ni(o, l) {
        var f = aS(o, l);
        return Bg(f) ? f : t;
      }
      function Z2(o) {
        var l = Je.call(o, Di), f = o[Di];
        try {
          o[Di] = t;
          var m = !0;
        } catch {
        }
        var w = Wa.call(o);
        return m && (l ? o[Di] = f : delete o[Di]), w;
      }
      var ph = zu ? function(o) {
        return o == null ? [] : (o = tt(o), ni(zu(o), function(l) {
          return Cg.call(o, l);
        }));
      } : Ph, ym = zu ? function(o) {
        for (var l = []; o; )
          ii(l, ph(o)), o = $a(o);
        return l;
      } : Ph, qt = er;
      (Wu && qt(new Wu(new ArrayBuffer(1))) != ot || xo && qt(new xo()) != st || Hu && qt(Hu.resolve()) != Dt || Es && qt(new Es()) != A || _o && qt(new _o()) != et) && (qt = function(o) {
        var l = er(o), f = l == nt ? o.constructor : t, m = f ? Bi(f) : "";
        if (m)
          switch (m) {
            case DS:
              return ot;
            case jS:
              return st;
            case RS:
              return Dt;
            case FS:
              return A;
            case LS:
              return et;
          }
        return l;
      });
      function J2(o, l, f) {
        for (var m = -1, w = f.length; ++m < w; ) {
          var T = f[m], I = T.size;
          switch (T.type) {
            case "drop":
              o += I;
              break;
            case "dropRight":
              l -= I;
              break;
            case "take":
              l = Gt(l, o + I);
              break;
            case "takeRight":
              o = Rt(o, l - I);
              break;
          }
        }
        return { start: o, end: l };
      }
      function Q2(o) {
        var l = o.match(s_);
        return l ? l[1].split(o_) : [];
      }
      function bm(o, l, f) {
        l = li(l, o);
        for (var m = -1, w = l.length, T = !1; ++m < w; ) {
          var I = yn(l[m]);
          if (!(T = o != null && f(o, I)))
            break;
          o = o[I];
        }
        return T || ++m != w ? T : (w = o == null ? 0 : o.length, !!w && yc(w) && Fn(I, w) && (Oe(o) || Vi(o)));
      }
      function eC(o) {
        var l = o.length, f = new o.constructor(l);
        return l && typeof o[0] == "string" && Je.call(o, "index") && (f.index = o.index, f.input = o.input), f;
      }
      function wm(o) {
        return typeof o.constructor == "function" && !Mo(o) ? Os($a(o)) : {};
      }
      function tC(o, l, f) {
        var m = o.constructor;
        switch (l) {
          case Se:
            return ah(o);
          case hr:
          case Ht:
            return new m(+o);
          case ot:
            return N2(o, f);
          case fr:
          case _t:
          case Cr:
          case Qr:
          case pr:
          case pn:
          case Qt:
          case vo:
          case yo:
            return rm(o, f);
          case st:
            return new m();
          case zt:
          case he:
            return new m(o);
          case Sr:
            return B2(o);
          case A:
            return new m();
          case le:
            return V2(o);
        }
      }
      function rC(o, l) {
        var f = l.length;
        if (!f)
          return o;
        var m = f - 1;
        return l[m] = (f > 1 ? "& " : "") + l[m], l = l.join(f > 2 ? ", " : " "), o.replace(i_, `{
/* [wrapped with ` + l + `] */
`);
      }
      function nC(o) {
        return Oe(o) || Vi(o) || !!(Tg && o && o[Tg]);
      }
      function Fn(o, l) {
        var f = typeof o;
        return l = l ?? oe, !!l && (f == "number" || f != "symbol" && g_.test(o)) && o > -1 && o % 1 == 0 && o < l;
      }
      function tr(o, l, f) {
        if (!ft(f))
          return !1;
        var m = typeof l;
        return (m == "number" ? mr(f) && Fn(l, f.length) : m == "string" && l in f) ? rn(f[l], o) : !1;
      }
      function gh(o, l) {
        if (Oe(o))
          return !1;
        var f = typeof o;
        return f == "number" || f == "symbol" || f == "boolean" || o == null || Ir(o) ? !0 : Pa.test(o) || !Su.test(o) || l != null && o in tt(l);
      }
      function iC(o) {
        var l = typeof o;
        return l == "string" || l == "number" || l == "symbol" || l == "boolean" ? o !== "__proto__" : o === null;
      }
      function mh(o) {
        var l = uc(o), f = S[l];
        if (typeof f != "function" || !(l in Le.prototype))
          return !1;
        if (o === f)
          return !0;
        var m = dh(f);
        return !!m && o === m[0];
      }
      function sC(o) {
        return !!xg && xg in o;
      }
      var oC = Va ? Ln : Dh;
      function Mo(o) {
        var l = o && o.constructor, f = typeof l == "function" && l.prototype || Ts;
        return o === f;
      }
      function xm(o) {
        return o === o && !ft(o);
      }
      function _m(o, l) {
        return function(f) {
          return f == null ? !1 : f[o] === l && (l !== t || o in tt(f));
        };
      }
      function aC(o) {
        var l = mc(o, function(m) {
          return f.size === h && f.clear(), m;
        }), f = l.cache;
        return l;
      }
      function cC(o, l) {
        var f = o[1], m = l[1], w = f | m, T = w < (_ | C | V), I = m == V && f == k || m == V && f == F && o[7].length <= l[8] || m == (V | F) && l[7].length <= l[8] && f == k;
        if (!(T || I))
          return o;
        m & _ && (o[2] = l[2], w |= f & _ ? 0 : E);
        var M = l[3];
        if (M) {
          var N = o[3];
          o[3] = N ? im(N, M, l[4]) : M, o[4] = N ? si(o[3], d) : l[4];
        }
        return M = l[5], M && (N = o[5], o[5] = N ? sm(N, M, l[6]) : M, o[6] = N ? si(o[5], d) : l[6]), M = l[7], M && (o[7] = M), m & V && (o[8] = o[8] == null ? l[8] : Gt(o[8], l[8])), o[9] == null && (o[9] = l[9]), o[0] = l[0], o[1] = w, o;
      }
      function lC(o) {
        var l = [];
        if (o != null)
          for (var f in tt(o))
            l.push(f);
        return l;
      }
      function uC(o) {
        return Wa.call(o);
      }
      function Sm(o, l, f) {
        return l = Rt(l === t ? o.length - 1 : l, 0), function() {
          for (var m = arguments, w = -1, T = Rt(m.length - l, 0), I = U(T); ++w < T; )
            I[w] = m[l + w];
          w = -1;
          for (var M = U(l + 1); ++w < l; )
            M[w] = m[w];
          return M[l] = f(I), Er(o, this, M);
        };
      }
      function Cm(o, l) {
        return l.length < 2 ? o : Li(o, Hr(l, 0, -1));
      }
      function hC(o, l) {
        for (var f = o.length, m = Gt(l.length, f), w = gr(o); m--; ) {
          var T = l[m];
          o[m] = Fn(T, f) ? w[T] : t;
        }
        return o;
      }
      function vh(o, l) {
        if (!(l === "constructor" && typeof o[l] == "function") && l != "__proto__")
          return o[l];
      }
      var Tm = km(Gg), Po = ES || function(o, l) {
        return Ut.setTimeout(o, l);
      }, yh = km(j2);
      function Em(o, l, f) {
        var m = l + "";
        return yh(o, rC(m, dC(Q2(m), f)));
      }
      function km(o) {
        var l = 0, f = 0;
        return function() {
          var m = AS(), w = Y - (m - f);
          if (f = m, w > 0) {
            if (++l >= H)
              return arguments[0];
          } else
            l = 0;
          return o.apply(t, arguments);
        };
      }
      function dc(o, l) {
        var f = -1, m = o.length, w = m - 1;
        for (l = l === t ? m : l; ++f < l; ) {
          var T = eh(f, w), I = o[T];
          o[T] = o[f], o[f] = I;
        }
        return o.length = l, o;
      }
      var Om = aC(function(o) {
        var l = [];
        return o.charCodeAt(0) === 46 && l.push(""), o.replace($e, function(f, m, w, T) {
          l.push(w ? T.replace(l_, "$1") : m || f);
        }), l;
      });
      function yn(o) {
        if (typeof o == "string" || Ir(o))
          return o;
        var l = o + "";
        return l == "0" && 1 / o == -1 / 0 ? "-0" : l;
      }
      function Bi(o) {
        if (o != null) {
          try {
            return za.call(o);
          } catch {
          }
          try {
            return o + "";
          } catch {
          }
        }
        return "";
      }
      function dC(o, l) {
        return Br(We, function(f) {
          var m = "_." + f[0];
          l & f[1] && !Fa(o, m) && o.push(m);
        }), o.sort();
      }
      function Im(o) {
        if (o instanceof Le)
          return o.clone();
        var l = new zr(o.__wrapped__, o.__chain__);
        return l.__actions__ = gr(o.__actions__), l.__index__ = o.__index__, l.__values__ = o.__values__, l;
      }
      function fC(o, l, f) {
        (f ? tr(o, l, f) : l === t) ? l = 1 : l = Rt(Ae(l), 0);
        var m = o == null ? 0 : o.length;
        if (!m || l < 1)
          return [];
        for (var w = 0, T = 0, I = U(Ga(m / l)); w < m; )
          I[T++] = Hr(o, w, w += l);
        return I;
      }
      function pC(o) {
        for (var l = -1, f = o == null ? 0 : o.length, m = 0, w = []; ++l < f; ) {
          var T = o[l];
          T && (w[m++] = T);
        }
        return w;
      }
      function gC() {
        var o = arguments.length;
        if (!o)
          return [];
        for (var l = U(o - 1), f = arguments[0], m = o; m--; )
          l[m - 1] = arguments[m];
        return ii(Oe(f) ? gr(f) : [f], $t(l, 1));
      }
      var mC = je(function(o, l) {
        return St(o) ? Eo(o, $t(l, 1, St, !0)) : [];
      }), vC = je(function(o, l) {
        var f = Ur(l);
        return St(f) && (f = t), St(o) ? Eo(o, $t(l, 1, St, !0), we(f, 2)) : [];
      }), yC = je(function(o, l) {
        var f = Ur(l);
        return St(f) && (f = t), St(o) ? Eo(o, $t(l, 1, St, !0), t, f) : [];
      });
      function bC(o, l, f) {
        var m = o == null ? 0 : o.length;
        return m ? (l = f || l === t ? 1 : Ae(l), Hr(o, l < 0 ? 0 : l, m)) : [];
      }
      function wC(o, l, f) {
        var m = o == null ? 0 : o.length;
        return m ? (l = f || l === t ? 1 : Ae(l), l = m - l, Hr(o, 0, l < 0 ? 0 : l)) : [];
      }
      function xC(o, l) {
        return o && o.length ? ic(o, we(l, 3), !0, !0) : [];
      }
      function _C(o, l) {
        return o && o.length ? ic(o, we(l, 3), !0) : [];
      }
      function SC(o, l, f, m) {
        var w = o == null ? 0 : o.length;
        return w ? (f && typeof f != "number" && tr(o, l, f) && (f = 0, m = w), g2(o, l, f, m)) : [];
      }
      function Am(o, l, f) {
        var m = o == null ? 0 : o.length;
        if (!m)
          return -1;
        var w = f == null ? 0 : Ae(f);
        return w < 0 && (w = Rt(m + w, 0)), La(o, we(l, 3), w);
      }
      function Mm(o, l, f) {
        var m = o == null ? 0 : o.length;
        if (!m)
          return -1;
        var w = m - 1;
        return f !== t && (w = Ae(f), w = f < 0 ? Rt(m + w, 0) : Gt(w, m - 1)), La(o, we(l, 3), w, !0);
      }
      function Pm(o) {
        var l = o == null ? 0 : o.length;
        return l ? $t(o, 1) : [];
      }
      function CC(o) {
        var l = o == null ? 0 : o.length;
        return l ? $t(o, de) : [];
      }
      function TC(o, l) {
        var f = o == null ? 0 : o.length;
        return f ? (l = l === t ? 1 : Ae(l), $t(o, l)) : [];
      }
      function EC(o) {
        for (var l = -1, f = o == null ? 0 : o.length, m = {}; ++l < f; ) {
          var w = o[l];
          m[w[0]] = w[1];
        }
        return m;
      }
      function Dm(o) {
        return o && o.length ? o[0] : t;
      }
      function kC(o, l, f) {
        var m = o == null ? 0 : o.length;
        if (!m)
          return -1;
        var w = f == null ? 0 : Ae(f);
        return w < 0 && (w = Rt(m + w, 0)), xs(o, l, w);
      }
      function OC(o) {
        var l = o == null ? 0 : o.length;
        return l ? Hr(o, 0, -1) : [];
      }
      var IC = je(function(o) {
        var l = lt(o, sh);
        return l.length && l[0] === o[0] ? qu(l) : [];
      }), AC = je(function(o) {
        var l = Ur(o), f = lt(o, sh);
        return l === Ur(f) ? l = t : f.pop(), f.length && f[0] === o[0] ? qu(f, we(l, 2)) : [];
      }), MC = je(function(o) {
        var l = Ur(o), f = lt(o, sh);
        return l = typeof l == "function" ? l : t, l && f.pop(), f.length && f[0] === o[0] ? qu(f, t, l) : [];
      });
      function PC(o, l) {
        return o == null ? "" : OS.call(o, l);
      }
      function Ur(o) {
        var l = o == null ? 0 : o.length;
        return l ? o[l - 1] : t;
      }
      function DC(o, l, f) {
        var m = o == null ? 0 : o.length;
        if (!m)
          return -1;
        var w = m;
        return f !== t && (w = Ae(f), w = w < 0 ? Rt(m + w, 0) : Gt(w, m - 1)), l === l ? dS(o, l, w) : La(o, fg, w, !0);
      }
      function jC(o, l) {
        return o && o.length ? Ug(o, Ae(l)) : t;
      }
      var RC = je(jm);
      function jm(o, l) {
        return o && o.length && l && l.length ? Qu(o, l) : o;
      }
      function FC(o, l, f) {
        return o && o.length && l && l.length ? Qu(o, l, we(f, 2)) : o;
      }
      function LC(o, l, f) {
        return o && o.length && l && l.length ? Qu(o, l, t, f) : o;
      }
      var NC = Rn(function(o, l) {
        var f = o == null ? 0 : o.length, m = $u(o, l);
        return Xg(o, lt(l, function(w) {
          return Fn(w, f) ? +w : w;
        }).sort(nm)), m;
      });
      function BC(o, l) {
        var f = [];
        if (!(o && o.length))
          return f;
        var m = -1, w = [], T = o.length;
        for (l = we(l, 3); ++m < T; ) {
          var I = o[m];
          l(I, m, o) && (f.push(I), w.push(m));
        }
        return Xg(o, w), f;
      }
      function bh(o) {
        return o == null ? o : PS.call(o);
      }
      function VC(o, l, f) {
        var m = o == null ? 0 : o.length;
        return m ? (f && typeof f != "number" && tr(o, l, f) ? (l = 0, f = m) : (l = l == null ? 0 : Ae(l), f = f === t ? m : Ae(f)), Hr(o, l, f)) : [];
      }
      function zC(o, l) {
        return nc(o, l);
      }
      function WC(o, l, f) {
        return rh(o, l, we(f, 2));
      }
      function HC(o, l) {
        var f = o == null ? 0 : o.length;
        if (f) {
          var m = nc(o, l);
          if (m < f && rn(o[m], l))
            return m;
        }
        return -1;
      }
      function UC(o, l) {
        return nc(o, l, !0);
      }
      function $C(o, l, f) {
        return rh(o, l, we(f, 2), !0);
      }
      function YC(o, l) {
        var f = o == null ? 0 : o.length;
        if (f) {
          var m = nc(o, l, !0) - 1;
          if (rn(o[m], l))
            return m;
        }
        return -1;
      }
      function XC(o) {
        return o && o.length ? qg(o) : [];
      }
      function GC(o, l) {
        return o && o.length ? qg(o, we(l, 2)) : [];
      }
      function qC(o) {
        var l = o == null ? 0 : o.length;
        return l ? Hr(o, 1, l) : [];
      }
      function KC(o, l, f) {
        return o && o.length ? (l = f || l === t ? 1 : Ae(l), Hr(o, 0, l < 0 ? 0 : l)) : [];
      }
      function ZC(o, l, f) {
        var m = o == null ? 0 : o.length;
        return m ? (l = f || l === t ? 1 : Ae(l), l = m - l, Hr(o, l < 0 ? 0 : l, m)) : [];
      }
      function JC(o, l) {
        return o && o.length ? ic(o, we(l, 3), !1, !0) : [];
      }
      function QC(o, l) {
        return o && o.length ? ic(o, we(l, 3)) : [];
      }
      var eT = je(function(o) {
        return ci($t(o, 1, St, !0));
      }), tT = je(function(o) {
        var l = Ur(o);
        return St(l) && (l = t), ci($t(o, 1, St, !0), we(l, 2));
      }), rT = je(function(o) {
        var l = Ur(o);
        return l = typeof l == "function" ? l : t, ci($t(o, 1, St, !0), t, l);
      });
      function nT(o) {
        return o && o.length ? ci(o) : [];
      }
      function iT(o, l) {
        return o && o.length ? ci(o, we(l, 2)) : [];
      }
      function sT(o, l) {
        return l = typeof l == "function" ? l : t, o && o.length ? ci(o, t, l) : [];
      }
      function wh(o) {
        if (!(o && o.length))
          return [];
        var l = 0;
        return o = ni(o, function(f) {
          if (St(f))
            return l = Rt(f.length, l), !0;
        }), Lu(l, function(f) {
          return lt(o, ju(f));
        });
      }
      function Rm(o, l) {
        if (!(o && o.length))
          return [];
        var f = wh(o);
        return l == null ? f : lt(f, function(m) {
          return Er(l, t, m);
        });
      }
      var oT = je(function(o, l) {
        return St(o) ? Eo(o, l) : [];
      }), aT = je(function(o) {
        return ih(ni(o, St));
      }), cT = je(function(o) {
        var l = Ur(o);
        return St(l) && (l = t), ih(ni(o, St), we(l, 2));
      }), lT = je(function(o) {
        var l = Ur(o);
        return l = typeof l == "function" ? l : t, ih(ni(o, St), t, l);
      }), uT = je(wh);
      function hT(o, l) {
        return Qg(o || [], l || [], To);
      }
      function dT(o, l) {
        return Qg(o || [], l || [], Io);
      }
      var fT = je(function(o) {
        var l = o.length, f = l > 1 ? o[l - 1] : t;
        return f = typeof f == "function" ? (o.pop(), f) : t, Rm(o, f);
      });
      function Fm(o) {
        var l = S(o);
        return l.__chain__ = !0, l;
      }
      function pT(o, l) {
        return l(o), o;
      }
      function fc(o, l) {
        return l(o);
      }
      var gT = Rn(function(o) {
        var l = o.length, f = l ? o[0] : 0, m = this.__wrapped__, w = function(T) {
          return $u(T, o);
        };
        return l > 1 || this.__actions__.length || !(m instanceof Le) || !Fn(f) ? this.thru(w) : (m = m.slice(f, +f + (l ? 1 : 0)), m.__actions__.push({
          func: fc,
          args: [w],
          thisArg: t
        }), new zr(m, this.__chain__).thru(function(T) {
          return l && !T.length && T.push(t), T;
        }));
      });
      function mT() {
        return Fm(this);
      }
      function vT() {
        return new zr(this.value(), this.__chain__);
      }
      function yT() {
        this.__values__ === t && (this.__values__ = Km(this.value()));
        var o = this.__index__ >= this.__values__.length, l = o ? t : this.__values__[this.__index__++];
        return { done: o, value: l };
      }
      function bT() {
        return this;
      }
      function wT(o) {
        for (var l, f = this; f instanceof Ja; ) {
          var m = Im(f);
          m.__index__ = 0, m.__values__ = t, l ? w.__wrapped__ = m : l = m;
          var w = m;
          f = f.__wrapped__;
        }
        return w.__wrapped__ = o, l;
      }
      function xT() {
        var o = this.__wrapped__;
        if (o instanceof Le) {
          var l = o;
          return this.__actions__.length && (l = new Le(this)), l = l.reverse(), l.__actions__.push({
            func: fc,
            args: [bh],
            thisArg: t
          }), new zr(l, this.__chain__);
        }
        return this.thru(bh);
      }
      function _T() {
        return Jg(this.__wrapped__, this.__actions__);
      }
      var ST = sc(function(o, l, f) {
        Je.call(o, f) ? ++o[f] : Dn(o, f, 1);
      });
      function CT(o, l, f) {
        var m = Oe(o) ? hg : p2;
        return f && tr(o, l, f) && (l = t), m(o, we(l, 3));
      }
      function TT(o, l) {
        var f = Oe(o) ? ni : Rg;
        return f(o, we(l, 3));
      }
      var ET = lm(Am), kT = lm(Mm);
      function OT(o, l) {
        return $t(pc(o, l), 1);
      }
      function IT(o, l) {
        return $t(pc(o, l), de);
      }
      function AT(o, l, f) {
        return f = f === t ? 1 : Ae(f), $t(pc(o, l), f);
      }
      function Lm(o, l) {
        var f = Oe(o) ? Br : ai;
        return f(o, we(l, 3));
      }
      function Nm(o, l) {
        var f = Oe(o) ? q_ : jg;
        return f(o, we(l, 3));
      }
      var MT = sc(function(o, l, f) {
        Je.call(o, f) ? o[f].push(l) : Dn(o, f, [l]);
      });
      function PT(o, l, f, m) {
        o = mr(o) ? o : Ds(o), f = f && !m ? Ae(f) : 0;
        var w = o.length;
        return f < 0 && (f = Rt(w + f, 0)), bc(o) ? f <= w && o.indexOf(l, f) > -1 : !!w && xs(o, l, f) > -1;
      }
      var DT = je(function(o, l, f) {
        var m = -1, w = typeof l == "function", T = mr(o) ? U(o.length) : [];
        return ai(o, function(I) {
          T[++m] = w ? Er(l, I, f) : ko(I, l, f);
        }), T;
      }), jT = sc(function(o, l, f) {
        Dn(o, f, l);
      });
      function pc(o, l) {
        var f = Oe(o) ? lt : zg;
        return f(o, we(l, 3));
      }
      function RT(o, l, f, m) {
        return o == null ? [] : (Oe(l) || (l = l == null ? [] : [l]), f = m ? t : f, Oe(f) || (f = f == null ? [] : [f]), $g(o, l, f));
      }
      var FT = sc(function(o, l, f) {
        o[f ? 0 : 1].push(l);
      }, function() {
        return [[], []];
      });
      function LT(o, l, f) {
        var m = Oe(o) ? Pu : gg, w = arguments.length < 3;
        return m(o, we(l, 4), f, w, ai);
      }
      function NT(o, l, f) {
        var m = Oe(o) ? K_ : gg, w = arguments.length < 3;
        return m(o, we(l, 4), f, w, jg);
      }
      function BT(o, l) {
        var f = Oe(o) ? ni : Rg;
        return f(o, vc(we(l, 3)));
      }
      function VT(o) {
        var l = Oe(o) ? Ag : P2;
        return l(o);
      }
      function zT(o, l, f) {
        (f ? tr(o, l, f) : l === t) ? l = 1 : l = Ae(l);
        var m = Oe(o) ? l2 : D2;
        return m(o, l);
      }
      function WT(o) {
        var l = Oe(o) ? u2 : R2;
        return l(o);
      }
      function HT(o) {
        if (o == null)
          return 0;
        if (mr(o))
          return bc(o) ? Ss(o) : o.length;
        var l = qt(o);
        return l == st || l == A ? o.size : Zu(o).length;
      }
      function UT(o, l, f) {
        var m = Oe(o) ? Du : F2;
        return f && tr(o, l, f) && (l = t), m(o, we(l, 3));
      }
      var $T = je(function(o, l) {
        if (o == null)
          return [];
        var f = l.length;
        return f > 1 && tr(o, l[0], l[1]) ? l = [] : f > 2 && tr(l[0], l[1], l[2]) && (l = [l[0]]), $g(o, $t(l, 1), []);
      }), gc = TS || function() {
        return Ut.Date.now();
      };
      function YT(o, l) {
        if (typeof l != "function")
          throw new Vr(a);
        return o = Ae(o), function() {
          if (--o < 1)
            return l.apply(this, arguments);
        };
      }
      function Bm(o, l, f) {
        return l = f ? t : l, l = o && l == null ? o.length : l, jn(o, V, t, t, t, t, l);
      }
      function Vm(o, l) {
        var f;
        if (typeof l != "function")
          throw new Vr(a);
        return o = Ae(o), function() {
          return --o > 0 && (f = l.apply(this, arguments)), o <= 1 && (l = t), f;
        };
      }
      var xh = je(function(o, l, f) {
        var m = _;
        if (f.length) {
          var w = si(f, Ms(xh));
          m |= P;
        }
        return jn(o, m, l, f, w);
      }), zm = je(function(o, l, f) {
        var m = _ | C;
        if (f.length) {
          var w = si(f, Ms(zm));
          m |= P;
        }
        return jn(l, m, o, f, w);
      });
      function Wm(o, l, f) {
        l = f ? t : l;
        var m = jn(o, k, t, t, t, t, t, l);
        return m.placeholder = Wm.placeholder, m;
      }
      function Hm(o, l, f) {
        l = f ? t : l;
        var m = jn(o, O, t, t, t, t, t, l);
        return m.placeholder = Hm.placeholder, m;
      }
      function Um(o, l, f) {
        var m, w, T, I, M, N, q = 0, K = !1, J = !1, ae = !0;
        if (typeof o != "function")
          throw new Vr(a);
        l = $r(l) || 0, ft(f) && (K = !!f.leading, J = "maxWait" in f, T = J ? Rt($r(f.maxWait) || 0, l) : T, ae = "trailing" in f ? !!f.trailing : ae);
        function ve(Ct) {
          var nn = m, Bn = w;
          return m = w = t, q = Ct, I = o.apply(Bn, nn), I;
        }
        function xe(Ct) {
          return q = Ct, M = Po(Fe, l), K ? ve(Ct) : I;
        }
        function De(Ct) {
          var nn = Ct - N, Bn = Ct - q, lv = l - nn;
          return J ? Gt(lv, T - Bn) : lv;
        }
        function _e(Ct) {
          var nn = Ct - N, Bn = Ct - q;
          return N === t || nn >= l || nn < 0 || J && Bn >= T;
        }
        function Fe() {
          var Ct = gc();
          if (_e(Ct))
            return ze(Ct);
          M = Po(Fe, De(Ct));
        }
        function ze(Ct) {
          return M = t, ae && m ? ve(Ct) : (m = w = t, I);
        }
        function Ar() {
          M !== t && em(M), q = 0, m = N = w = M = t;
        }
        function rr() {
          return M === t ? I : ze(gc());
        }
        function Mr() {
          var Ct = gc(), nn = _e(Ct);
          if (m = arguments, w = this, N = Ct, nn) {
            if (M === t)
              return xe(N);
            if (J)
              return em(M), M = Po(Fe, l), ve(N);
          }
          return M === t && (M = Po(Fe, l)), I;
        }
        return Mr.cancel = Ar, Mr.flush = rr, Mr;
      }
      var XT = je(function(o, l) {
        return Dg(o, 1, l);
      }), GT = je(function(o, l, f) {
        return Dg(o, $r(l) || 0, f);
      });
      function qT(o) {
        return jn(o, $);
      }
      function mc(o, l) {
        if (typeof o != "function" || l != null && typeof l != "function")
          throw new Vr(a);
        var f = function() {
          var m = arguments, w = l ? l.apply(this, m) : m[0], T = f.cache;
          if (T.has(w))
            return T.get(w);
          var I = o.apply(this, m);
          return f.cache = T.set(w, I) || T, I;
        };
        return f.cache = new (mc.Cache || Pn)(), f;
      }
      mc.Cache = Pn;
      function vc(o) {
        if (typeof o != "function")
          throw new Vr(a);
        return function() {
          var l = arguments;
          switch (l.length) {
            case 0:
              return !o.call(this);
            case 1:
              return !o.call(this, l[0]);
            case 2:
              return !o.call(this, l[0], l[1]);
            case 3:
              return !o.call(this, l[0], l[1], l[2]);
          }
          return !o.apply(this, l);
        };
      }
      function KT(o) {
        return Vm(2, o);
      }
      var ZT = L2(function(o, l) {
        l = l.length == 1 && Oe(l[0]) ? lt(l[0], kr(we())) : lt($t(l, 1), kr(we()));
        var f = l.length;
        return je(function(m) {
          for (var w = -1, T = Gt(m.length, f); ++w < T; )
            m[w] = l[w].call(this, m[w]);
          return Er(o, this, m);
        });
      }), _h = je(function(o, l) {
        var f = si(l, Ms(_h));
        return jn(o, P, t, l, f);
      }), $m = je(function(o, l) {
        var f = si(l, Ms($m));
        return jn(o, R, t, l, f);
      }), JT = Rn(function(o, l) {
        return jn(o, F, t, t, t, l);
      });
      function QT(o, l) {
        if (typeof o != "function")
          throw new Vr(a);
        return l = l === t ? l : Ae(l), je(o, l);
      }
      function eE(o, l) {
        if (typeof o != "function")
          throw new Vr(a);
        return l = l == null ? 0 : Rt(Ae(l), 0), je(function(f) {
          var m = f[l], w = ui(f, 0, l);
          return m && ii(w, m), Er(o, this, w);
        });
      }
      function tE(o, l, f) {
        var m = !0, w = !0;
        if (typeof o != "function")
          throw new Vr(a);
        return ft(f) && (m = "leading" in f ? !!f.leading : m, w = "trailing" in f ? !!f.trailing : w), Um(o, l, {
          leading: m,
          maxWait: l,
          trailing: w
        });
      }
      function rE(o) {
        return Bm(o, 1);
      }
      function nE(o, l) {
        return _h(oh(l), o);
      }
      function iE() {
        if (!arguments.length)
          return [];
        var o = arguments[0];
        return Oe(o) ? o : [o];
      }
      function sE(o) {
        return Wr(o, v);
      }
      function oE(o, l) {
        return l = typeof l == "function" ? l : t, Wr(o, v, l);
      }
      function aE(o) {
        return Wr(o, p | v);
      }
      function cE(o, l) {
        return l = typeof l == "function" ? l : t, Wr(o, p | v, l);
      }
      function lE(o, l) {
        return l == null || Pg(o, l, Wt(l));
      }
      function rn(o, l) {
        return o === l || o !== o && l !== l;
      }
      var uE = lc(Gu), hE = lc(function(o, l) {
        return o >= l;
      }), Vi = Ng(/* @__PURE__ */ function() {
        return arguments;
      }()) ? Ng : function(o) {
        return vt(o) && Je.call(o, "callee") && !Cg.call(o, "callee");
      }, Oe = U.isArray, dE = sg ? kr(sg) : w2;
      function mr(o) {
        return o != null && yc(o.length) && !Ln(o);
      }
      function St(o) {
        return vt(o) && mr(o);
      }
      function fE(o) {
        return o === !0 || o === !1 || vt(o) && er(o) == hr;
      }
      var hi = kS || Dh, pE = og ? kr(og) : x2;
      function gE(o) {
        return vt(o) && o.nodeType === 1 && !Do(o);
      }
      function mE(o) {
        if (o == null)
          return !0;
        if (mr(o) && (Oe(o) || typeof o == "string" || typeof o.splice == "function" || hi(o) || Ps(o) || Vi(o)))
          return !o.length;
        var l = qt(o);
        if (l == st || l == A)
          return !o.size;
        if (Mo(o))
          return !Zu(o).length;
        for (var f in o)
          if (Je.call(o, f))
            return !1;
        return !0;
      }
      function vE(o, l) {
        return Oo(o, l);
      }
      function yE(o, l, f) {
        f = typeof f == "function" ? f : t;
        var m = f ? f(o, l) : t;
        return m === t ? Oo(o, l, t, f) : !!m;
      }
      function Sh(o) {
        if (!vt(o))
          return !1;
        var l = er(o);
        return l == dr || l == Pt || typeof o.message == "string" && typeof o.name == "string" && !Do(o);
      }
      function bE(o) {
        return typeof o == "number" && Eg(o);
      }
      function Ln(o) {
        if (!ft(o))
          return !1;
        var l = er(o);
        return l == ye || l == _r || l == dt || l == An;
      }
      function Ym(o) {
        return typeof o == "number" && o == Ae(o);
      }
      function yc(o) {
        return typeof o == "number" && o > -1 && o % 1 == 0 && o <= oe;
      }
      function ft(o) {
        var l = typeof o;
        return o != null && (l == "object" || l == "function");
      }
      function vt(o) {
        return o != null && typeof o == "object";
      }
      var Xm = ag ? kr(ag) : S2;
      function wE(o, l) {
        return o === l || Ku(o, l, fh(l));
      }
      function xE(o, l, f) {
        return f = typeof f == "function" ? f : t, Ku(o, l, fh(l), f);
      }
      function _E(o) {
        return Gm(o) && o != +o;
      }
      function SE(o) {
        if (oC(o))
          throw new ke(s);
        return Bg(o);
      }
      function CE(o) {
        return o === null;
      }
      function TE(o) {
        return o == null;
      }
      function Gm(o) {
        return typeof o == "number" || vt(o) && er(o) == zt;
      }
      function Do(o) {
        if (!vt(o) || er(o) != nt)
          return !1;
        var l = $a(o);
        if (l === null)
          return !0;
        var f = Je.call(l, "constructor") && l.constructor;
        return typeof f == "function" && f instanceof f && za.call(f) == xS;
      }
      var Ch = cg ? kr(cg) : C2;
      function EE(o) {
        return Ym(o) && o >= -9007199254740991 && o <= oe;
      }
      var qm = lg ? kr(lg) : T2;
      function bc(o) {
        return typeof o == "string" || !Oe(o) && vt(o) && er(o) == he;
      }
      function Ir(o) {
        return typeof o == "symbol" || vt(o) && er(o) == le;
      }
      var Ps = ug ? kr(ug) : E2;
      function kE(o) {
        return o === t;
      }
      function OE(o) {
        return vt(o) && qt(o) == et;
      }
      function IE(o) {
        return vt(o) && er(o) == Ge;
      }
      var AE = lc(Ju), ME = lc(function(o, l) {
        return o <= l;
      });
      function Km(o) {
        if (!o)
          return [];
        if (mr(o))
          return bc(o) ? en(o) : gr(o);
        if (wo && o[wo])
          return lS(o[wo]());
        var l = qt(o), f = l == st ? Bu : l == A ? Na : Ds;
        return f(o);
      }
      function Nn(o) {
        if (!o)
          return o === 0 ? o : 0;
        if (o = $r(o), o === de || o === -1 / 0) {
          var l = o < 0 ? -1 : 1;
          return l * ie;
        }
        return o === o ? o : 0;
      }
      function Ae(o) {
        var l = Nn(o), f = l % 1;
        return l === l ? f ? l - f : l : 0;
      }
      function Zm(o) {
        return o ? Fi(Ae(o), 0, re) : 0;
      }
      function $r(o) {
        if (typeof o == "number")
          return o;
        if (Ir(o))
          return pe;
        if (ft(o)) {
          var l = typeof o.valueOf == "function" ? o.valueOf() : o;
          o = ft(l) ? l + "" : l;
        }
        if (typeof o != "string")
          return o === 0 ? o : +o;
        o = mg(o);
        var f = d_.test(o);
        return f || p_.test(o) ? Y_(o.slice(2), f ? 2 : 8) : h_.test(o) ? pe : +o;
      }
      function Jm(o) {
        return vn(o, vr(o));
      }
      function PE(o) {
        return o ? Fi(Ae(o), -9007199254740991, oe) : o === 0 ? o : 0;
      }
      function qe(o) {
        return o == null ? "" : Or(o);
      }
      var DE = Is(function(o, l) {
        if (Mo(l) || mr(l)) {
          vn(l, Wt(l), o);
          return;
        }
        for (var f in l)
          Je.call(l, f) && To(o, f, l[f]);
      }), Qm = Is(function(o, l) {
        vn(l, vr(l), o);
      }), wc = Is(function(o, l, f, m) {
        vn(l, vr(l), o, m);
      }), jE = Is(function(o, l, f, m) {
        vn(l, Wt(l), o, m);
      }), RE = Rn($u);
      function FE(o, l) {
        var f = Os(o);
        return l == null ? f : Mg(f, l);
      }
      var LE = je(function(o, l) {
        o = tt(o);
        var f = -1, m = l.length, w = m > 2 ? l[2] : t;
        for (w && tr(l[0], l[1], w) && (m = 1); ++f < m; )
          for (var T = l[f], I = vr(T), M = -1, N = I.length; ++M < N; ) {
            var q = I[M], K = o[q];
            (K === t || rn(K, Ts[q]) && !Je.call(o, q)) && (o[q] = T[q]);
          }
        return o;
      }), NE = je(function(o) {
        return o.push(t, mm), Er(ev, t, o);
      });
      function BE(o, l) {
        return dg(o, we(l, 3), mn);
      }
      function VE(o, l) {
        return dg(o, we(l, 3), Xu);
      }
      function zE(o, l) {
        return o == null ? o : Yu(o, we(l, 3), vr);
      }
      function WE(o, l) {
        return o == null ? o : Fg(o, we(l, 3), vr);
      }
      function HE(o, l) {
        return o && mn(o, we(l, 3));
      }
      function UE(o, l) {
        return o && Xu(o, we(l, 3));
      }
      function $E(o) {
        return o == null ? [] : tc(o, Wt(o));
      }
      function YE(o) {
        return o == null ? [] : tc(o, vr(o));
      }
      function Th(o, l, f) {
        var m = o == null ? t : Li(o, l);
        return m === t ? f : m;
      }
      function XE(o, l) {
        return o != null && bm(o, l, m2);
      }
      function Eh(o, l) {
        return o != null && bm(o, l, v2);
      }
      var GE = hm(function(o, l, f) {
        l != null && typeof l.toString != "function" && (l = Wa.call(l)), o[l] = f;
      }, Oh(yr)), qE = hm(function(o, l, f) {
        l != null && typeof l.toString != "function" && (l = Wa.call(l)), Je.call(o, l) ? o[l].push(f) : o[l] = [f];
      }, we), KE = je(ko);
      function Wt(o) {
        return mr(o) ? Ig(o) : Zu(o);
      }
      function vr(o) {
        return mr(o) ? Ig(o, !0) : k2(o);
      }
      function ZE(o, l) {
        var f = {};
        return l = we(l, 3), mn(o, function(m, w, T) {
          Dn(f, l(m, w, T), m);
        }), f;
      }
      function JE(o, l) {
        var f = {};
        return l = we(l, 3), mn(o, function(m, w, T) {
          Dn(f, w, l(m, w, T));
        }), f;
      }
      var QE = Is(function(o, l, f) {
        rc(o, l, f);
      }), ev = Is(function(o, l, f, m) {
        rc(o, l, f, m);
      }), e5 = Rn(function(o, l) {
        var f = {};
        if (o == null)
          return f;
        var m = !1;
        l = lt(l, function(T) {
          return T = li(T, o), m || (m = T.length > 1), T;
        }), vn(o, hh(o), f), m && (f = Wr(f, p | g | v, G2));
        for (var w = l.length; w--; )
          nh(f, l[w]);
        return f;
      });
      function t5(o, l) {
        return tv(o, vc(we(l)));
      }
      var r5 = Rn(function(o, l) {
        return o == null ? {} : I2(o, l);
      });
      function tv(o, l) {
        if (o == null)
          return {};
        var f = lt(hh(o), function(m) {
          return [m];
        });
        return l = we(l), Yg(o, f, function(m, w) {
          return l(m, w[0]);
        });
      }
      function n5(o, l, f) {
        l = li(l, o);
        var m = -1, w = l.length;
        for (w || (w = 1, o = t); ++m < w; ) {
          var T = o == null ? t : o[yn(l[m])];
          T === t && (m = w, T = f), o = Ln(T) ? T.call(o) : T;
        }
        return o;
      }
      function i5(o, l, f) {
        return o == null ? o : Io(o, l, f);
      }
      function s5(o, l, f, m) {
        return m = typeof m == "function" ? m : t, o == null ? o : Io(o, l, f, m);
      }
      var rv = pm(Wt), nv = pm(vr);
      function o5(o, l, f) {
        var m = Oe(o), w = m || hi(o) || Ps(o);
        if (l = we(l, 4), f == null) {
          var T = o && o.constructor;
          w ? f = m ? new T() : [] : ft(o) ? f = Ln(T) ? Os($a(o)) : {} : f = {};
        }
        return (w ? Br : mn)(o, function(I, M, N) {
          return l(f, I, M, N);
        }), f;
      }
      function a5(o, l) {
        return o == null ? !0 : nh(o, l);
      }
      function c5(o, l, f) {
        return o == null ? o : Zg(o, l, oh(f));
      }
      function l5(o, l, f, m) {
        return m = typeof m == "function" ? m : t, o == null ? o : Zg(o, l, oh(f), m);
      }
      function Ds(o) {
        return o == null ? [] : Nu(o, Wt(o));
      }
      function u5(o) {
        return o == null ? [] : Nu(o, vr(o));
      }
      function h5(o, l, f) {
        return f === t && (f = l, l = t), f !== t && (f = $r(f), f = f === f ? f : 0), l !== t && (l = $r(l), l = l === l ? l : 0), Fi($r(o), l, f);
      }
      function d5(o, l, f) {
        return l = Nn(l), f === t ? (f = l, l = 0) : f = Nn(f), o = $r(o), y2(o, l, f);
      }
      function f5(o, l, f) {
        if (f && typeof f != "boolean" && tr(o, l, f) && (l = f = t), f === t && (typeof l == "boolean" ? (f = l, l = t) : typeof o == "boolean" && (f = o, o = t)), o === t && l === t ? (o = 0, l = 1) : (o = Nn(o), l === t ? (l = o, o = 0) : l = Nn(l)), o > l) {
          var m = o;
          o = l, l = m;
        }
        if (f || o % 1 || l % 1) {
          var w = kg();
          return Gt(o + w * (l - o + $_("1e-" + ((w + "").length - 1))), l);
        }
        return eh(o, l);
      }
      var p5 = As(function(o, l, f) {
        return l = l.toLowerCase(), o + (f ? iv(l) : l);
      });
      function iv(o) {
        return kh(qe(o).toLowerCase());
      }
      function sv(o) {
        return o = qe(o), o && o.replace(m_, iS).replace(R_, "");
      }
      function g5(o, l, f) {
        o = qe(o), l = Or(l);
        var m = o.length;
        f = f === t ? m : Fi(Ae(f), 0, m);
        var w = f;
        return f -= l.length, f >= 0 && o.slice(f, w) == l;
      }
      function m5(o) {
        return o = qe(o), o && jp.test(o) ? o.replace(Mi, sS) : o;
      }
      function v5(o) {
        return o = qe(o), o && Tr.test(o) ? o.replace(He, "\\$&") : o;
      }
      var y5 = As(function(o, l, f) {
        return o + (f ? "-" : "") + l.toLowerCase();
      }), b5 = As(function(o, l, f) {
        return o + (f ? " " : "") + l.toLowerCase();
      }), w5 = cm("toLowerCase");
      function x5(o, l, f) {
        o = qe(o), l = Ae(l);
        var m = l ? Ss(o) : 0;
        if (!l || m >= l)
          return o;
        var w = (l - m) / 2;
        return cc(qa(w), f) + o + cc(Ga(w), f);
      }
      function _5(o, l, f) {
        o = qe(o), l = Ae(l);
        var m = l ? Ss(o) : 0;
        return l && m < l ? o + cc(l - m, f) : o;
      }
      function S5(o, l, f) {
        o = qe(o), l = Ae(l);
        var m = l ? Ss(o) : 0;
        return l && m < l ? cc(l - m, f) + o : o;
      }
      function C5(o, l, f) {
        return f || l == null ? l = 0 : l && (l = +l), MS(qe(o).replace(gn, ""), l || 0);
      }
      function T5(o, l, f) {
        return (f ? tr(o, l, f) : l === t) ? l = 1 : l = Ae(l), th(qe(o), l);
      }
      function E5() {
        var o = arguments, l = qe(o[0]);
        return o.length < 3 ? l : l.replace(o[1], o[2]);
      }
      var k5 = As(function(o, l, f) {
        return o + (f ? "_" : "") + l.toLowerCase();
      });
      function O5(o, l, f) {
        return f && typeof f != "number" && tr(o, l, f) && (l = f = t), f = f === t ? re : f >>> 0, f ? (o = qe(o), o && (typeof l == "string" || l != null && !Ch(l)) && (l = Or(l), !l && _s(o)) ? ui(en(o), 0, f) : o.split(l, f)) : [];
      }
      var I5 = As(function(o, l, f) {
        return o + (f ? " " : "") + kh(l);
      });
      function A5(o, l, f) {
        return o = qe(o), f = f == null ? 0 : Fi(Ae(f), 0, o.length), l = Or(l), o.slice(f, f + l.length) == l;
      }
      function M5(o, l, f) {
        var m = S.templateSettings;
        f && tr(o, l, f) && (l = t), o = qe(o), l = wc({}, l, m, gm);
        var w = wc({}, l.imports, m.imports, gm), T = Wt(w), I = Nu(w, T), M, N, q = 0, K = l.interpolate || Da, J = "__p += '", ae = Vu(
          (l.escape || Da).source + "|" + K.source + "|" + (K === _u ? u_ : Da).source + "|" + (l.evaluate || Da).source + "|$",
          "g"
        ), ve = "//# sourceURL=" + (Je.call(l, "sourceURL") ? (l.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++V_ + "]") + `
`;
        o.replace(ae, function(_e, Fe, ze, Ar, rr, Mr) {
          return ze || (ze = Ar), J += o.slice(q, Mr).replace(v_, oS), Fe && (M = !0, J += `' +
__e(` + Fe + `) +
'`), rr && (N = !0, J += `';
` + rr + `;
__p += '`), ze && (J += `' +
((__t = (` + ze + `)) == null ? '' : __t) +
'`), q = Mr + _e.length, _e;
        }), J += `';
`;
        var xe = Je.call(l, "variable") && l.variable;
        if (!xe)
          J = `with (obj) {
` + J + `
}
`;
        else if (c_.test(xe))
          throw new ke(c);
        J = (N ? J.replace(ys, "") : J).replace(bs, "$1").replace(xu, "$1;"), J = "function(" + (xe || "obj") + `) {
` + (xe ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (M ? ", __e = _.escape" : "") + (N ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + J + `return __p
}`;
        var De = av(function() {
          return Ye(T, ve + "return " + J).apply(t, I);
        });
        if (De.source = J, Sh(De))
          throw De;
        return De;
      }
      function P5(o) {
        return qe(o).toLowerCase();
      }
      function D5(o) {
        return qe(o).toUpperCase();
      }
      function j5(o, l, f) {
        if (o = qe(o), o && (f || l === t))
          return mg(o);
        if (!o || !(l = Or(l)))
          return o;
        var m = en(o), w = en(l), T = vg(m, w), I = yg(m, w) + 1;
        return ui(m, T, I).join("");
      }
      function R5(o, l, f) {
        if (o = qe(o), o && (f || l === t))
          return o.slice(0, wg(o) + 1);
        if (!o || !(l = Or(l)))
          return o;
        var m = en(o), w = yg(m, en(l)) + 1;
        return ui(m, 0, w).join("");
      }
      function F5(o, l, f) {
        if (o = qe(o), o && (f || l === t))
          return o.replace(gn, "");
        if (!o || !(l = Or(l)))
          return o;
        var m = en(o), w = vg(m, en(l));
        return ui(m, w).join("");
      }
      function L5(o, l) {
        var f = z, m = G;
        if (ft(l)) {
          var w = "separator" in l ? l.separator : w;
          f = "length" in l ? Ae(l.length) : f, m = "omission" in l ? Or(l.omission) : m;
        }
        o = qe(o);
        var T = o.length;
        if (_s(o)) {
          var I = en(o);
          T = I.length;
        }
        if (f >= T)
          return o;
        var M = f - Ss(m);
        if (M < 1)
          return m;
        var N = I ? ui(I, 0, M).join("") : o.slice(0, M);
        if (w === t)
          return N + m;
        if (I && (M += N.length - M), Ch(w)) {
          if (o.slice(M).search(w)) {
            var q, K = N;
            for (w.global || (w = Vu(w.source, qe(Np.exec(w)) + "g")), w.lastIndex = 0; q = w.exec(K); )
              var J = q.index;
            N = N.slice(0, J === t ? M : J);
          }
        } else if (o.indexOf(Or(w), M) != M) {
          var ae = N.lastIndexOf(w);
          ae > -1 && (N = N.slice(0, ae));
        }
        return N + m;
      }
      function N5(o) {
        return o = qe(o), o && Ma.test(o) ? o.replace(Aa, fS) : o;
      }
      var B5 = As(function(o, l, f) {
        return o + (f ? " " : "") + l.toUpperCase();
      }), kh = cm("toUpperCase");
      function ov(o, l, f) {
        return o = qe(o), l = f ? t : l, l === t ? cS(o) ? mS(o) : Q_(o) : o.match(l) || [];
      }
      var av = je(function(o, l) {
        try {
          return Er(o, t, l);
        } catch (f) {
          return Sh(f) ? f : new ke(f);
        }
      }), V5 = Rn(function(o, l) {
        return Br(l, function(f) {
          f = yn(f), Dn(o, f, xh(o[f], o));
        }), o;
      });
      function z5(o) {
        var l = o == null ? 0 : o.length, f = we();
        return o = l ? lt(o, function(m) {
          if (typeof m[1] != "function")
            throw new Vr(a);
          return [f(m[0]), m[1]];
        }) : [], je(function(m) {
          for (var w = -1; ++w < l; ) {
            var T = o[w];
            if (Er(T[0], this, m))
              return Er(T[1], this, m);
          }
        });
      }
      function W5(o) {
        return f2(Wr(o, p));
      }
      function Oh(o) {
        return function() {
          return o;
        };
      }
      function H5(o, l) {
        return o == null || o !== o ? l : o;
      }
      var U5 = um(), $5 = um(!0);
      function yr(o) {
        return o;
      }
      function Ih(o) {
        return Vg(typeof o == "function" ? o : Wr(o, p));
      }
      function Y5(o) {
        return Wg(Wr(o, p));
      }
      function X5(o, l) {
        return Hg(o, Wr(l, p));
      }
      var G5 = je(function(o, l) {
        return function(f) {
          return ko(f, o, l);
        };
      }), q5 = je(function(o, l) {
        return function(f) {
          return ko(o, f, l);
        };
      });
      function Ah(o, l, f) {
        var m = Wt(l), w = tc(l, m);
        f == null && !(ft(l) && (w.length || !m.length)) && (f = l, l = o, o = this, w = tc(l, Wt(l)));
        var T = !(ft(f) && "chain" in f) || !!f.chain, I = Ln(o);
        return Br(w, function(M) {
          var N = l[M];
          o[M] = N, I && (o.prototype[M] = function() {
            var q = this.__chain__;
            if (T || q) {
              var K = o(this.__wrapped__), J = K.__actions__ = gr(this.__actions__);
              return J.push({ func: N, args: arguments, thisArg: o }), K.__chain__ = q, K;
            }
            return N.apply(o, ii([this.value()], arguments));
          });
        }), o;
      }
      function K5() {
        return Ut._ === this && (Ut._ = _S), this;
      }
      function Mh() {
      }
      function Z5(o) {
        return o = Ae(o), je(function(l) {
          return Ug(l, o);
        });
      }
      var J5 = ch(lt), Q5 = ch(hg), ek = ch(Du);
      function cv(o) {
        return gh(o) ? ju(yn(o)) : A2(o);
      }
      function tk(o) {
        return function(l) {
          return o == null ? t : Li(o, l);
        };
      }
      var rk = dm(), nk = dm(!0);
      function Ph() {
        return [];
      }
      function Dh() {
        return !1;
      }
      function ik() {
        return {};
      }
      function sk() {
        return "";
      }
      function ok() {
        return !0;
      }
      function ak(o, l) {
        if (o = Ae(o), o < 1 || o > oe)
          return [];
        var f = re, m = Gt(o, re);
        l = we(l), o -= re;
        for (var w = Lu(m, l); ++f < o; )
          l(f);
        return w;
      }
      function ck(o) {
        return Oe(o) ? lt(o, yn) : Ir(o) ? [o] : gr(Om(qe(o)));
      }
      function lk(o) {
        var l = ++wS;
        return qe(o) + l;
      }
      var uk = ac(function(o, l) {
        return o + l;
      }, 0), hk = lh("ceil"), dk = ac(function(o, l) {
        return o / l;
      }, 1), fk = lh("floor");
      function pk(o) {
        return o && o.length ? ec(o, yr, Gu) : t;
      }
      function gk(o, l) {
        return o && o.length ? ec(o, we(l, 2), Gu) : t;
      }
      function mk(o) {
        return pg(o, yr);
      }
      function vk(o, l) {
        return pg(o, we(l, 2));
      }
      function yk(o) {
        return o && o.length ? ec(o, yr, Ju) : t;
      }
      function bk(o, l) {
        return o && o.length ? ec(o, we(l, 2), Ju) : t;
      }
      var wk = ac(function(o, l) {
        return o * l;
      }, 1), xk = lh("round"), _k = ac(function(o, l) {
        return o - l;
      }, 0);
      function Sk(o) {
        return o && o.length ? Fu(o, yr) : 0;
      }
      function Ck(o, l) {
        return o && o.length ? Fu(o, we(l, 2)) : 0;
      }
      return S.after = YT, S.ary = Bm, S.assign = DE, S.assignIn = Qm, S.assignInWith = wc, S.assignWith = jE, S.at = RE, S.before = Vm, S.bind = xh, S.bindAll = V5, S.bindKey = zm, S.castArray = iE, S.chain = Fm, S.chunk = fC, S.compact = pC, S.concat = gC, S.cond = z5, S.conforms = W5, S.constant = Oh, S.countBy = ST, S.create = FE, S.curry = Wm, S.curryRight = Hm, S.debounce = Um, S.defaults = LE, S.defaultsDeep = NE, S.defer = XT, S.delay = GT, S.difference = mC, S.differenceBy = vC, S.differenceWith = yC, S.drop = bC, S.dropRight = wC, S.dropRightWhile = xC, S.dropWhile = _C, S.fill = SC, S.filter = TT, S.flatMap = OT, S.flatMapDeep = IT, S.flatMapDepth = AT, S.flatten = Pm, S.flattenDeep = CC, S.flattenDepth = TC, S.flip = qT, S.flow = U5, S.flowRight = $5, S.fromPairs = EC, S.functions = $E, S.functionsIn = YE, S.groupBy = MT, S.initial = OC, S.intersection = IC, S.intersectionBy = AC, S.intersectionWith = MC, S.invert = GE, S.invertBy = qE, S.invokeMap = DT, S.iteratee = Ih, S.keyBy = jT, S.keys = Wt, S.keysIn = vr, S.map = pc, S.mapKeys = ZE, S.mapValues = JE, S.matches = Y5, S.matchesProperty = X5, S.memoize = mc, S.merge = QE, S.mergeWith = ev, S.method = G5, S.methodOf = q5, S.mixin = Ah, S.negate = vc, S.nthArg = Z5, S.omit = e5, S.omitBy = t5, S.once = KT, S.orderBy = RT, S.over = J5, S.overArgs = ZT, S.overEvery = Q5, S.overSome = ek, S.partial = _h, S.partialRight = $m, S.partition = FT, S.pick = r5, S.pickBy = tv, S.property = cv, S.propertyOf = tk, S.pull = RC, S.pullAll = jm, S.pullAllBy = FC, S.pullAllWith = LC, S.pullAt = NC, S.range = rk, S.rangeRight = nk, S.rearg = JT, S.reject = BT, S.remove = BC, S.rest = QT, S.reverse = bh, S.sampleSize = zT, S.set = i5, S.setWith = s5, S.shuffle = WT, S.slice = VC, S.sortBy = $T, S.sortedUniq = XC, S.sortedUniqBy = GC, S.split = O5, S.spread = eE, S.tail = qC, S.take = KC, S.takeRight = ZC, S.takeRightWhile = JC, S.takeWhile = QC, S.tap = pT, S.throttle = tE, S.thru = fc, S.toArray = Km, S.toPairs = rv, S.toPairsIn = nv, S.toPath = ck, S.toPlainObject = Jm, S.transform = o5, S.unary = rE, S.union = eT, S.unionBy = tT, S.unionWith = rT, S.uniq = nT, S.uniqBy = iT, S.uniqWith = sT, S.unset = a5, S.unzip = wh, S.unzipWith = Rm, S.update = c5, S.updateWith = l5, S.values = Ds, S.valuesIn = u5, S.without = oT, S.words = ov, S.wrap = nE, S.xor = aT, S.xorBy = cT, S.xorWith = lT, S.zip = uT, S.zipObject = hT, S.zipObjectDeep = dT, S.zipWith = fT, S.entries = rv, S.entriesIn = nv, S.extend = Qm, S.extendWith = wc, Ah(S, S), S.add = uk, S.attempt = av, S.camelCase = p5, S.capitalize = iv, S.ceil = hk, S.clamp = h5, S.clone = sE, S.cloneDeep = aE, S.cloneDeepWith = cE, S.cloneWith = oE, S.conformsTo = lE, S.deburr = sv, S.defaultTo = H5, S.divide = dk, S.endsWith = g5, S.eq = rn, S.escape = m5, S.escapeRegExp = v5, S.every = CT, S.find = ET, S.findIndex = Am, S.findKey = BE, S.findLast = kT, S.findLastIndex = Mm, S.findLastKey = VE, S.floor = fk, S.forEach = Lm, S.forEachRight = Nm, S.forIn = zE, S.forInRight = WE, S.forOwn = HE, S.forOwnRight = UE, S.get = Th, S.gt = uE, S.gte = hE, S.has = XE, S.hasIn = Eh, S.head = Dm, S.identity = yr, S.includes = PT, S.indexOf = kC, S.inRange = d5, S.invoke = KE, S.isArguments = Vi, S.isArray = Oe, S.isArrayBuffer = dE, S.isArrayLike = mr, S.isArrayLikeObject = St, S.isBoolean = fE, S.isBuffer = hi, S.isDate = pE, S.isElement = gE, S.isEmpty = mE, S.isEqual = vE, S.isEqualWith = yE, S.isError = Sh, S.isFinite = bE, S.isFunction = Ln, S.isInteger = Ym, S.isLength = yc, S.isMap = Xm, S.isMatch = wE, S.isMatchWith = xE, S.isNaN = _E, S.isNative = SE, S.isNil = TE, S.isNull = CE, S.isNumber = Gm, S.isObject = ft, S.isObjectLike = vt, S.isPlainObject = Do, S.isRegExp = Ch, S.isSafeInteger = EE, S.isSet = qm, S.isString = bc, S.isSymbol = Ir, S.isTypedArray = Ps, S.isUndefined = kE, S.isWeakMap = OE, S.isWeakSet = IE, S.join = PC, S.kebabCase = y5, S.last = Ur, S.lastIndexOf = DC, S.lowerCase = b5, S.lowerFirst = w5, S.lt = AE, S.lte = ME, S.max = pk, S.maxBy = gk, S.mean = mk, S.meanBy = vk, S.min = yk, S.minBy = bk, S.stubArray = Ph, S.stubFalse = Dh, S.stubObject = ik, S.stubString = sk, S.stubTrue = ok, S.multiply = wk, S.nth = jC, S.noConflict = K5, S.noop = Mh, S.now = gc, S.pad = x5, S.padEnd = _5, S.padStart = S5, S.parseInt = C5, S.random = f5, S.reduce = LT, S.reduceRight = NT, S.repeat = T5, S.replace = E5, S.result = n5, S.round = xk, S.runInContext = L, S.sample = VT, S.size = HT, S.snakeCase = k5, S.some = UT, S.sortedIndex = zC, S.sortedIndexBy = WC, S.sortedIndexOf = HC, S.sortedLastIndex = UC, S.sortedLastIndexBy = $C, S.sortedLastIndexOf = YC, S.startCase = I5, S.startsWith = A5, S.subtract = _k, S.sum = Sk, S.sumBy = Ck, S.template = M5, S.times = ak, S.toFinite = Nn, S.toInteger = Ae, S.toLength = Zm, S.toLower = P5, S.toNumber = $r, S.toSafeInteger = PE, S.toString = qe, S.toUpper = D5, S.trim = j5, S.trimEnd = R5, S.trimStart = F5, S.truncate = L5, S.unescape = N5, S.uniqueId = lk, S.upperCase = B5, S.upperFirst = kh, S.each = Lm, S.eachRight = Nm, S.first = Dm, Ah(S, function() {
        var o = {};
        return mn(S, function(l, f) {
          Je.call(S.prototype, f) || (o[f] = l);
        }), o;
      }(), { chain: !1 }), S.VERSION = n, Br(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(o) {
        S[o].placeholder = S;
      }), Br(["drop", "take"], function(o, l) {
        Le.prototype[o] = function(f) {
          f = f === t ? 1 : Rt(Ae(f), 0);
          var m = this.__filtered__ && !l ? new Le(this) : this.clone();
          return m.__filtered__ ? m.__takeCount__ = Gt(f, m.__takeCount__) : m.__views__.push({
            size: Gt(f, re),
            type: o + (m.__dir__ < 0 ? "Right" : "")
          }), m;
        }, Le.prototype[o + "Right"] = function(f) {
          return this.reverse()[o](f).reverse();
        };
      }), Br(["filter", "map", "takeWhile"], function(o, l) {
        var f = l + 1, m = f == te || f == Z;
        Le.prototype[o] = function(w) {
          var T = this.clone();
          return T.__iteratees__.push({
            iteratee: we(w, 3),
            type: f
          }), T.__filtered__ = T.__filtered__ || m, T;
        };
      }), Br(["head", "last"], function(o, l) {
        var f = "take" + (l ? "Right" : "");
        Le.prototype[o] = function() {
          return this[f](1).value()[0];
        };
      }), Br(["initial", "tail"], function(o, l) {
        var f = "drop" + (l ? "" : "Right");
        Le.prototype[o] = function() {
          return this.__filtered__ ? new Le(this) : this[f](1);
        };
      }), Le.prototype.compact = function() {
        return this.filter(yr);
      }, Le.prototype.find = function(o) {
        return this.filter(o).head();
      }, Le.prototype.findLast = function(o) {
        return this.reverse().find(o);
      }, Le.prototype.invokeMap = je(function(o, l) {
        return typeof o == "function" ? new Le(this) : this.map(function(f) {
          return ko(f, o, l);
        });
      }), Le.prototype.reject = function(o) {
        return this.filter(vc(we(o)));
      }, Le.prototype.slice = function(o, l) {
        o = Ae(o);
        var f = this;
        return f.__filtered__ && (o > 0 || l < 0) ? new Le(f) : (o < 0 ? f = f.takeRight(-o) : o && (f = f.drop(o)), l !== t && (l = Ae(l), f = l < 0 ? f.dropRight(-l) : f.take(l - o)), f);
      }, Le.prototype.takeRightWhile = function(o) {
        return this.reverse().takeWhile(o).reverse();
      }, Le.prototype.toArray = function() {
        return this.take(re);
      }, mn(Le.prototype, function(o, l) {
        var f = /^(?:filter|find|map|reject)|While$/.test(l), m = /^(?:head|last)$/.test(l), w = S[m ? "take" + (l == "last" ? "Right" : "") : l], T = m || /^find/.test(l);
        w && (S.prototype[l] = function() {
          var I = this.__wrapped__, M = m ? [1] : arguments, N = I instanceof Le, q = M[0], K = N || Oe(I), J = function(Fe) {
            var ze = w.apply(S, ii([Fe], M));
            return m && ae ? ze[0] : ze;
          };
          K && f && typeof q == "function" && q.length != 1 && (N = K = !1);
          var ae = this.__chain__, ve = !!this.__actions__.length, xe = T && !ae, De = N && !ve;
          if (!T && K) {
            I = De ? I : new Le(this);
            var _e = o.apply(I, M);
            return _e.__actions__.push({ func: fc, args: [J], thisArg: t }), new zr(_e, ae);
          }
          return xe && De ? o.apply(this, M) : (_e = this.thru(J), xe ? m ? _e.value()[0] : _e.value() : _e);
        });
      }), Br(["pop", "push", "shift", "sort", "splice", "unshift"], function(o) {
        var l = Ba[o], f = /^(?:push|sort|unshift)$/.test(o) ? "tap" : "thru", m = /^(?:pop|shift)$/.test(o);
        S.prototype[o] = function() {
          var w = arguments;
          if (m && !this.__chain__) {
            var T = this.value();
            return l.apply(Oe(T) ? T : [], w);
          }
          return this[f](function(I) {
            return l.apply(Oe(I) ? I : [], w);
          });
        };
      }), mn(Le.prototype, function(o, l) {
        var f = S[l];
        if (f) {
          var m = f.name + "";
          Je.call(ks, m) || (ks[m] = []), ks[m].push({ name: l, func: f });
        }
      }), ks[oc(t, C).name] = [{
        name: "wrapper",
        func: t
      }], Le.prototype.clone = NS, Le.prototype.reverse = BS, Le.prototype.value = VS, S.prototype.at = gT, S.prototype.chain = mT, S.prototype.commit = vT, S.prototype.next = yT, S.prototype.plant = wT, S.prototype.reverse = xT, S.prototype.toJSON = S.prototype.valueOf = S.prototype.value = _T, S.prototype.first = S.prototype.head, wo && (S.prototype[wo] = bT), S;
    }, Cs = vS();
    Pi ? ((Pi.exports = Cs)._ = Cs, Iu._ = Cs) : Ut._ = Cs;
  }).call(jo);
})(hl, hl.exports);
var Xe = hl.exports;
const vP = () => {
  const { trackItemIds: r, trackItemsMap: e, fps: t, trackItemDetailsMap: n } = Zn(), i = Xe.merge(e, n);
  return /* @__PURE__ */ y.jsx(y.Fragment, { children: r.map((s) => {
    const a = i[s];
    return mP[a.type](a, {
      fps: t
    });
  }) });
};
var Lb = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(r) {
  (function() {
    var e = {}.hasOwnProperty;
    function t() {
      for (var s = "", a = 0; a < arguments.length; a++) {
        var c = arguments[a];
        c && (s = i(s, n(c)));
      }
      return s;
    }
    function n(s) {
      if (typeof s == "string" || typeof s == "number")
        return s;
      if (typeof s != "object")
        return "";
      if (Array.isArray(s))
        return t.apply(null, s);
      if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]"))
        return s.toString();
      var a = "";
      for (var c in s)
        e.call(s, c) && s[c] && (a = i(a, c));
      return a;
    }
    function i(s, a) {
      return a ? s ? s + " " + a : s + a : s;
    }
    r.exports ? (t.default = t, r.exports = t) : window.classNames = t;
  })();
})(Lb);
var yP = Lb.exports;
const Ho = /* @__PURE__ */ Ok(yP), bP = { asChild: { type: "boolean" } }, wP = { width: { type: "string", className: "rt-r-w", customProperties: ["--width"], responsive: !0 }, minWidth: { type: "string", className: "rt-r-min-w", customProperties: ["--min-width"], responsive: !0 }, maxWidth: { type: "string", className: "rt-r-max-w", customProperties: ["--max-width"], responsive: !0 } }, xP = { height: { type: "string", className: "rt-r-h", customProperties: ["--height"], responsive: !0 }, minHeight: { type: "string", className: "rt-r-min-h", customProperties: ["--min-height"], responsive: !0 }, maxHeight: { type: "string", className: "rt-r-max-h", customProperties: ["--max-height"], responsive: !0 } }, Kf = ["initial", "xs", "sm", "md", "lg", "xl"];
function Nb(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
function Go(r) {
  return typeof r == "object" && Object.keys(r).some((e) => Kf.includes(e));
}
function _P({ className: r, customProperties: e, ...t }) {
  const n = Bb({ allowArbitraryValues: !0, className: r, ...t }), i = SP({ customProperties: e, ...t });
  return [n, i];
}
function Bb({ allowArbitraryValues: r, value: e, className: t, propValues: n, parseValue: i = (s) => s }) {
  const s = [];
  if (e) {
    if (typeof e == "string" && n.includes(e)) return s0(t, e, i);
    if (Go(e)) {
      const a = e;
      for (const c in a) {
        if (!Nb(a, c) || !Kf.includes(c)) continue;
        const u = a[c];
        if (u !== void 0) {
          if (n.includes(u)) {
            const h = s0(t, u, i), d = c === "initial" ? h : `${c}:${h}`;
            s.push(d);
          } else if (r) {
            const h = c === "initial" ? t : `${c}:${t}`;
            s.push(h);
          }
        }
      }
      return s.join(" ");
    }
    if (r) return t;
  }
}
function s0(r, e, t) {
  const n = r ? "-" : "", i = t(e), s = i?.startsWith("-"), a = s ? "-" : "", c = s ? i?.substring(1) : i;
  return `${a}${r}${n}${c}`;
}
function SP({ customProperties: r, value: e, propValues: t, parseValue: n = (i) => i }) {
  let i = {};
  if (!(!e || typeof e == "string" && t.includes(e))) {
    if (typeof e == "string" && (i = Object.fromEntries(r.map((s) => [s, e]))), Go(e)) {
      const s = e;
      for (const a in s) {
        if (!Nb(s, a) || !Kf.includes(a)) continue;
        const c = s[a];
        if (!t.includes(c)) for (const u of r) i = { [a === "initial" ? u : `${u}-${a}`]: c, ...i };
      }
    }
    for (const s in i) {
      const a = i[s];
      a !== void 0 && (i[s] = n(a));
    }
    return i;
  }
}
function o0(...r) {
  let e = {};
  for (const t of r) t && (e = { ...e, ...t });
  return Object.keys(e).length ? e : void 0;
}
function CP(...r) {
  return Object.assign({}, ...r);
}
function TP(r, ...e) {
  let t, n;
  const i = { ...r }, s = CP(...e);
  for (const a in s) {
    let c = i[a];
    const u = s[a];
    if (u.default !== void 0 && c === void 0 && (c = u.default), u.type === "enum" && ![u.default, ...u.values].includes(c) && !Go(c) && (c = u.default), i[a] = c, "className" in u && u.className) {
      delete i[a];
      const h = "responsive" in u;
      if (!c || Go(c) && !h) continue;
      if (Go(c) && (u.default !== void 0 && c.initial === void 0 && (c.initial = u.default), u.type === "enum" && ([u.default, ...u.values].includes(c.initial) || (c.initial = u.default))), u.type === "enum") {
        const d = Bb({ allowArbitraryValues: !1, value: c, className: u.className, propValues: u.values, parseValue: u.parseValue });
        t = Ho(t, d);
        continue;
      }
      if (u.type === "string" || u.type === "enum | string") {
        const d = u.type === "string" ? [] : u.values, [p, g] = _P({ className: u.className, customProperties: u.customProperties, propValues: d, parseValue: u.parseValue, value: c });
        n = o0(n, g), t = Ho(t, p);
        continue;
      }
      if (u.type === "boolean" && c) {
        t = Ho(t, u.className);
        continue;
      }
    }
  }
  return i.className = Ho(t, r.className), i.style = o0(n, r.style), i;
}
const zi = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9"], EP = { m: { type: "enum | string", values: zi, responsive: !0, className: "rt-r-m", customProperties: ["--m"] }, mx: { type: "enum | string", values: zi, responsive: !0, className: "rt-r-mx", customProperties: ["--ml", "--mr"] }, my: { type: "enum | string", values: zi, responsive: !0, className: "rt-r-my", customProperties: ["--mt", "--mb"] }, mt: { type: "enum | string", values: zi, responsive: !0, className: "rt-r-mt", customProperties: ["--mt"] }, mr: { type: "enum | string", values: zi, responsive: !0, className: "rt-r-mr", customProperties: ["--mr"] }, mb: { type: "enum | string", values: zi, responsive: !0, className: "rt-r-mb", customProperties: ["--mb"] }, ml: { type: "enum | string", values: zi, responsive: !0, className: "rt-r-ml", customProperties: ["--ml"] } }, kP = Rk, Wi = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], OP = { p: { type: "enum | string", className: "rt-r-p", customProperties: ["--p"], values: Wi, responsive: !0 }, px: { type: "enum | string", className: "rt-r-px", customProperties: ["--pl", "--pr"], values: Wi, responsive: !0 }, py: { type: "enum | string", className: "rt-r-py", customProperties: ["--pt", "--pb"], values: Wi, responsive: !0 }, pt: { type: "enum | string", className: "rt-r-pt", customProperties: ["--pt"], values: Wi, responsive: !0 }, pr: { type: "enum | string", className: "rt-r-pr", customProperties: ["--pr"], values: Wi, responsive: !0 }, pb: { type: "enum | string", className: "rt-r-pb", customProperties: ["--pb"], values: Wi, responsive: !0 }, pl: { type: "enum | string", className: "rt-r-pl", customProperties: ["--pl"], values: Wi, responsive: !0 } }, Hh = ["visible", "hidden", "clip", "scroll", "auto"], IP = ["static", "relative", "absolute", "fixed", "sticky"], Vo = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9"], AP = ["0", "1"], MP = ["0", "1"], PP = { ...OP, ...wP, ...xP, position: { type: "enum", className: "rt-r-position", values: IP, responsive: !0 }, inset: { type: "enum | string", className: "rt-r-inset", customProperties: ["--inset"], values: Vo, responsive: !0 }, top: { type: "enum | string", className: "rt-r-top", customProperties: ["--top"], values: Vo, responsive: !0 }, right: { type: "enum | string", className: "rt-r-right", customProperties: ["--right"], values: Vo, responsive: !0 }, bottom: { type: "enum | string", className: "rt-r-bottom", customProperties: ["--bottom"], values: Vo, responsive: !0 }, left: { type: "enum | string", className: "rt-r-left", customProperties: ["--left"], values: Vo, responsive: !0 }, overflow: { type: "enum", className: "rt-r-overflow", values: Hh, responsive: !0 }, overflowX: { type: "enum", className: "rt-r-ox", values: Hh, responsive: !0 }, overflowY: { type: "enum", className: "rt-r-oy", values: Hh, responsive: !0 }, flexBasis: { type: "string", className: "rt-r-fb", customProperties: ["--flex-basis"], responsive: !0 }, flexShrink: { type: "enum | string", className: "rt-r-fs", customProperties: ["--flex-shrink"], values: AP, responsive: !0 }, flexGrow: { type: "enum | string", className: "rt-r-fg", customProperties: ["--flex-grow"], values: MP, responsive: !0 }, gridArea: { type: "string", className: "rt-r-ga", customProperties: ["--grid-area"], responsive: !0 }, gridColumn: { type: "string", className: "rt-r-gc", customProperties: ["--grid-column"], responsive: !0 }, gridColumnStart: { type: "string", className: "rt-r-gcs", customProperties: ["--grid-column-start"], responsive: !0 }, gridColumnEnd: { type: "string", className: "rt-r-gce", customProperties: ["--grid-column-end"], responsive: !0 }, gridRow: { type: "string", className: "rt-r-gr", customProperties: ["--grid-row"], responsive: !0 }, gridRowStart: { type: "string", className: "rt-r-grs", customProperties: ["--grid-row-start"], responsive: !0 }, gridRowEnd: { type: "string", className: "rt-r-gre", customProperties: ["--grid-row-end"], responsive: !0 } }, Uh = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], DP = { gap: { type: "enum | string", className: "rt-r-gap", customProperties: ["--gap"], values: Uh, responsive: !0 }, gapX: { type: "enum | string", className: "rt-r-cg", customProperties: ["--column-gap"], values: Uh, responsive: !0 }, gapY: { type: "enum | string", className: "rt-r-rg", customProperties: ["--row-gap"], values: Uh, responsive: !0 } }, jP = ["div", "span"], RP = ["none", "inline-flex", "flex"], FP = ["row", "column", "row-reverse", "column-reverse"], LP = ["start", "center", "end", "baseline", "stretch"], NP = ["start", "center", "end", "between"], BP = ["nowrap", "wrap", "wrap-reverse"], VP = { as: { type: "enum", values: jP, default: "div" }, ...bP, display: { type: "enum", className: "rt-r-display", values: RP, responsive: !0 }, direction: { type: "enum", className: "rt-r-fd", values: FP, responsive: !0 }, align: { type: "enum", className: "rt-r-ai", values: LP, responsive: !0 }, justify: { type: "enum", className: "rt-r-jc", values: NP, parseValue: zP, responsive: !0 }, wrap: { type: "enum", className: "rt-r-fw", values: BP, responsive: !0 }, ...DP };
function zP(r) {
  return r === "between" ? "space-between" : r;
}
const Zf = W.forwardRef((r, e) => {
  const { className: t, asChild: n, as: i = "div", ...s } = TP(r, VP, PP, EP);
  return W.createElement(n ? kP : i, { ...s, ref: e, className: Ho("rt-Flex", t) });
});
Zf.displayName = "Flex";
const WP = () => {
  const r = be(null), { setPlayerRef: e, duration: t, fps: n, size: i } = Zn();
  return ce(() => {
    e(r);
  }, []), /* @__PURE__ */ y.jsx(Zf, { className: "size-full", children: /* @__PURE__ */ y.jsx(
    lP,
    {
      ref: r,
      component: vP,
      durationInFrames: Math.round(t / 1e3 * n) || 5 * 30,
      compositionWidth: 1920,
      compositionHeight: 1080,
      style: { width: "100%", height: "100%" },
      inputProps: {},
      fps: n,
      controls: !0
    }
  ) });
}, HP = ({ scrollLeft: r }) => {
  const e = be(null), { playerRef: t, fps: n, scale: i } = Zn(), s = Of(t ?? void 0), a = It(s / n * 1e3, i.zoom) - r, [c, u] = ue(!1), [h, d] = ue(0), [p, g] = ue(a), v = () => {
    u(!1);
  }, b = (_) => {
    u(!0);
    const C = "touches" in _ ? _.touches[0].clientX : _.clientX;
    d(C), g(a);
  }, x = (_) => {
    if (c) {
      const E = ("touches" in _ ? _.touches[0].clientX : _.clientX) - h, k = p + E, O = ts(k, i.zoom);
      t?.current?.seekTo(O * n / 1e3);
    }
  };
  return ce(() => {
    const _ = (C) => {
      C.preventDefault();
    };
    return c ? (document.addEventListener("mousemove", x), document.addEventListener("mouseup", v), document.addEventListener("touchmove", x), document.addEventListener("touchend", v), document.addEventListener("dragstart", _)) : (document.removeEventListener("mousemove", x), document.removeEventListener("mouseup", v), document.removeEventListener("touchmove", x), document.removeEventListener("touchend", v)), () => {
      document.removeEventListener("mousemove", x), document.removeEventListener("mouseup", v), document.removeEventListener("touchmove", x), document.removeEventListener("touchend", v), document.removeEventListener("dragstart", _);
    };
  }, [c, x, v]), /* @__PURE__ */ y.jsx(
    "div",
    {
      ref: e,
      role: "button",
      tabIndex: 0,
      onMouseDown: (_) => {
        b(_);
      },
      onTouchStart: (_) => {
        b(_);
      },
      onKeyDown: (_) => {
        (_.key === "Enter" || _.key === " ") && b(_);
      },
      style: {
        position: "absolute",
        left: 40 + kf + a,
        top: 80,
        width: 1,
        height: "calc(100% - 80px)",
        background: "#d4d4d8",
        zIndex: 10,
        cursor: "pointer"
      },
      children: /* @__PURE__ */ y.jsxs("div", { className: "relative h-full", children: [
        /* @__PURE__ */ y.jsx("div", { className: "absolute top-0  h-full w-3 -translate-x-1/2" }),
        /* @__PURE__ */ y.jsx("div", { className: "absolute top-0  h-full w-0.5 -translate-x-1/2 bg-white/50" }),
        /* @__PURE__ */ y.jsx(
          "div",
          {
            style: {
              borderRadius: "0 0 20px 20px"
            },
            className: "absolute h-3 -translate-x-1/2 px-1.5",
            children: /* @__PURE__ */ y.jsx(
              "svg",
              {
                height: "12",
                viewBox: "0 0 12 12",
                fill: "none",
                children: /* @__PURE__ */ y.jsx(
                  "path",
                  {
                    fill: "currentColor",
                    d: "M11.6585 7.04881L6.6585 11.4238C6.28148 11.7537 5.71852 11.7537 5.3415 11.4238L0.341495 7.04881C0.12448 6.85892 0 6.58459 0 6.29623V1C0 0.447715 0.447715 0 1 0H11C11.5523 0 12 0.447715 12 1V6.29623C12 6.58459 11.8755 6.85892 11.6585 7.04881Z"
                  }
                )
              }
            )
          }
        )
      ] })
    }
  );
}, UP = (r) => {
  const {
    height: e = 40,
    // Increased height to give space for the text
    longLineSize: t = 8,
    shortLineSize: n = 6,
    offsetX: i = Id + kf,
    textOffsetY: s = 12,
    // Place the text above the lines but inside the canvas
    textFormat: a = o3,
    scrollLeft: c = 0,
    onClick: u
  } = r, { scale: h } = Zn(), d = be(null), [p, g] = ue(null), [v, b] = ue({
    width: 0,
    height: e
    // Increased height for text space
  });
  ce(() => {
    const E = d.current;
    if (E) {
      const k = E.getContext("2d");
      g(k), x(E, k, c);
    }
  }, []), ce(() => {
    p && x(d.current, p, c);
  }, [p, c, h]);
  const x = (E, k, O) => {
    if (!E || !k) return;
    const R = E.offsetParent.offsetWidth ?? E.offsetWidth, V = v.height;
    E.width = R, E.height = V, _(k, O, R, V), b({ width: R, height: V });
  }, _ = (E, k, O, P) => {
    const R = h.zoom, V = h.unit, F = h.segments;
    E.clearRect(0, 0, O, P), E.save(), E.strokeStyle = "#71717a", E.fillStyle = "#71717a", E.lineWidth = 1, E.font = `${e3}px ${t3}`, E.textBaseline = "top", E.translate(0.5, 0), E.beginPath();
    const $ = V * R * zl, z = Math.floor(k / $), H = Math.ceil((k + O) / $) - z;
    for (let Y = 0; Y <= H; ++Y) {
      const te = Y + z;
      if (te < 0) continue;
      const ge = te * $ / R, Z = (ge - k / R) * R;
      if (Z < -$ || Z >= O + $) continue;
      const de = a(ge), ie = -E.measureText(de).width / 2;
      E.fillText(de, Z + ie + i, s);
    }
    for (let Y = 0; Y <= H; ++Y) {
      const te = Y + z;
      if (te < 0) continue;
      const Z = te * $ - k + i;
      for (let de = 0; de < F; ++de) {
        const oe = Z + de / F * $;
        if (oe < 0 || oe >= O) continue;
        const ie = de % F ? n : t;
        ie === n ? E.strokeStyle = "#a1a1aa" : E.strokeStyle = "#d4d4d8";
        const pe = 32, [re, Ve] = [oe, pe], [Ze, We] = [re, Ve + ie];
        E.beginPath(), E.moveTo(re, Ve), E.lineTo(Ze, We), E.stroke();
      }
    }
    E.restore();
  }, C = (E) => {
    const k = d.current;
    if (!k) return;
    const O = k.getBoundingClientRect(), R = E.clientX - O.left + c - Id;
    u?.(R);
  };
  return /* @__PURE__ */ y.jsx(
    "div",
    {
      className: "border-border border-t",
      style: {
        position: "relative",
        width: "100%",
        height: `${v.height}px`,
        backgroundColor: "transparent"
      },
      children: /* @__PURE__ */ y.jsx(
        "canvas",
        {
          onClick: C,
          ref: d,
          height: v.height
        }
      )
    }
  );
}, $P = () => /* @__PURE__ */ y.jsx(
  Zf,
  {
    flexGrow: "1",
    justify: "center",
    width: "100%",
    height: "100%",
    className: "bg-scene py-3",
    children: /* @__PURE__ */ y.jsx("div", { className: "max-w-3xl flex-1  w-full h-full flex relative", children: /* @__PURE__ */ y.jsx(WP, {}) })
  }
);
function j(r, e, t) {
  return (e = function(n) {
    var i = function(s, a) {
      if (typeof s != "object" || !s) return s;
      var c = s[Symbol.toPrimitive];
      if (c !== void 0) {
        var u = c.call(s, a);
        if (typeof u != "object") return u;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (a === "string" ? String : Number)(s);
    }(n, "string");
    return typeof i == "symbol" ? i : i + "";
  }(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function a0(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function D(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? a0(Object(t), !0).forEach(function(n) {
      j(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : a0(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function ht(r, e) {
  if (r == null) return {};
  var t, n, i = function(a, c) {
    if (a == null) return {};
    var u = {};
    for (var h in a) if ({}.hasOwnProperty.call(a, h)) {
      if (c.indexOf(h) >= 0) continue;
      u[h] = a[h];
    }
    return u;
  }(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) >= 0 || {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function Oi(r, e) {
  return e || (e = r.slice(0)), Object.freeze(Object.defineProperties(r, { raw: { value: Object.freeze(e) } }));
}
class c0 {
  constructor() {
    j(this, "browserShadowBlurConstant", 1), j(this, "DPI", 96), j(this, "devicePixelRatio", typeof window < "u" ? window.devicePixelRatio : 1), j(this, "perfLimitSizeTotal", 2097152), j(this, "maxCacheSideLimit", 4096), j(this, "minCacheSideLimit", 256), j(this, "disableStyleCopyPaste", !1), j(this, "enableGLFiltering", !0), j(this, "textureSize", 4096), j(this, "forceGLPutImageData", !1), j(this, "cachesBoundsOfCurve", !1), j(this, "fontPaths", {}), j(this, "NUM_FRACTION_DIGITS", 4);
  }
}
const Ue = new class extends c0 {
  constructor(r) {
    super(), this.configure(r);
  }
  configure() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.assign(this, r);
  }
  addFonts() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.fontPaths = D(D({}, this.fontPaths), r);
  }
  removeFonts() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((r) => {
      delete this.fontPaths[r];
    });
  }
  clearFonts() {
    this.fontPaths = {};
  }
  restoreDefaults(r) {
    const e = new c0(), t = r?.reduce((n, i) => (n[i] = e[i], n), {}) || e;
    this.configure(t);
  }
}(), yi = function(r) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) t[n - 1] = arguments[n];
  return console[r]("fabric", ...t);
};
class _n extends Error {
  constructor(e, t) {
    super("fabric: ".concat(e), t);
  }
}
class Vb extends _n {
  constructor(e) {
    super("".concat(e, " 'options.signal' is in 'aborted' state"));
  }
}
class YP {
}
class XP extends YP {
  testPrecision(e, t) {
    const n = "precision ".concat(t, ` float;
void main(){}`), i = e.createShader(e.FRAGMENT_SHADER);
    return !!i && (e.shaderSource(i, n), e.compileShader(i), !!e.getShaderParameter(i, e.COMPILE_STATUS));
  }
  queryWebGL(e) {
    const t = e.getContext("webgl");
    t && (this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), this.GLPrecision = ["highp", "mediump", "lowp"].find((n) => this.testPrecision(t, n)), t.getExtension("WEBGL_lose_context").loseContext(), yi("log", "WebGL: max texture size ".concat(this.maxTextureSize)));
  }
  isSupported(e) {
    return !!this.maxTextureSize && this.maxTextureSize >= e;
  }
}
const GP = {};
let l0;
const kn = () => l0 || (l0 = { document, window, isTouchSupported: "ontouchstart" in window || "ontouchstart" in document || window && window.navigator && window.navigator.maxTouchPoints > 0, WebGLProbe: new XP(), dispose() {
}, copyPasteData: GP }), lo = () => kn().document, eu = () => kn().window, zb = () => {
  var r;
  return Math.max((r = Ue.devicePixelRatio) !== null && r !== void 0 ? r : eu().devicePixelRatio, 1);
}, qo = new class {
  constructor() {
    j(this, "charWidthsCache", {}), j(this, "boundsOfCurveCache", {});
  }
  getFontCache(r) {
    let { fontFamily: e, fontStyle: t, fontWeight: n } = r;
    e = e.toLowerCase(), this.charWidthsCache[e] || (this.charWidthsCache[e] = {});
    const i = this.charWidthsCache[e], s = "".concat(t.toLowerCase(), "_").concat((n + "").toLowerCase());
    return i[s] || (i[s] = {}), i[s];
  }
  clearFontCache(r) {
    (r = (r || "").toLowerCase()) ? this.charWidthsCache[r] && delete this.charWidthsCache[r] : this.charWidthsCache = {};
  }
  limitDimsByArea(r) {
    const { perfLimitSizeTotal: e } = Ue, t = Math.sqrt(e * r);
    return [Math.floor(t), Math.floor(e / t)];
  }
}(), Hd = "6.5.4";
function Qi() {
}
const bi = Math.PI / 2, Qn = 2 * Math.PI, Jf = Math.PI / 180, ar = Object.freeze([1, 0, 0, 1, 0, 0]), Qf = 16, pi = 0.4477152502, Pe = "center", Ke = "left", br = "top", Ud = "bottom", Tt = "right", wr = "none", ep = /\r?\n/, Wb = "moving", tu = "scaling", Hb = "rotating", tp = "rotate", Ub = "skewing", ia = "resizing", $b = "modifyPoly", qP = "modifyPath", dl = "changed", ru = "scale", cr = "scaleX", Rr = "scaleY", uo = "skewX", ho = "skewY", Nt = "fill", xr = "stroke", fl = "modified", Rs = "json", $h = "svg", ne = new class {
  constructor() {
    this[Rs] = /* @__PURE__ */ new Map(), this[$h] = /* @__PURE__ */ new Map();
  }
  has(r) {
    return this[Rs].has(r);
  }
  getClass(r) {
    const e = this[Rs].get(r);
    if (!e) throw new _n("No class registered for ".concat(r));
    return e;
  }
  setClass(r, e) {
    e ? this[Rs].set(e, r) : (this[Rs].set(r.type, r), this[Rs].set(r.type.toLowerCase(), r));
  }
  getSVGClass(r) {
    return this[$h].get(r);
  }
  setSVGClass(r, e) {
    this[$h].set(e ?? r.type.toLowerCase(), r);
  }
}(), pl = new class extends Array {
  remove(r) {
    const e = this.indexOf(r);
    e > -1 && this.splice(e, 1);
  }
  cancelAll() {
    const r = this.splice(0);
    return r.forEach((e) => e.abort()), r;
  }
  cancelByCanvas(r) {
    if (!r) return [];
    const e = this.filter((t) => {
      var n;
      return t.target === r || typeof t.target == "object" && ((n = t.target) === null || n === void 0 ? void 0 : n.canvas) === r;
    });
    return e.forEach((t) => t.abort()), e;
  }
  cancelByTarget(r) {
    if (!r) return [];
    const e = this.filter((t) => t.target === r);
    return e.forEach((t) => t.abort()), e;
  }
}();
class KP {
  constructor() {
    j(this, "__eventListeners", {});
  }
  on(e, t) {
    if (this.__eventListeners || (this.__eventListeners = {}), typeof e == "object") return Object.entries(e).forEach((n) => {
      let [i, s] = n;
      this.on(i, s);
    }), () => this.off(e);
    if (t) {
      const n = e;
      return this.__eventListeners[n] || (this.__eventListeners[n] = []), this.__eventListeners[n].push(t), () => this.off(n, t);
    }
    return () => !1;
  }
  once(e, t) {
    if (typeof e == "object") {
      const n = [];
      return Object.entries(e).forEach((i) => {
        let [s, a] = i;
        n.push(this.once(s, a));
      }), () => n.forEach((i) => i());
    }
    if (t) {
      const n = this.on(e, function() {
        for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++) s[a] = arguments[a];
        t.call(this, ...s), n();
      });
      return n;
    }
    return () => !1;
  }
  _removeEventListener(e, t) {
    if (this.__eventListeners[e]) if (t) {
      const n = this.__eventListeners[e], i = n.indexOf(t);
      i > -1 && n.splice(i, 1);
    } else this.__eventListeners[e] = [];
  }
  off(e, t) {
    if (this.__eventListeners) if (e === void 0) for (const n in this.__eventListeners) this._removeEventListener(n);
    else typeof e == "object" ? Object.entries(e).forEach((n) => {
      let [i, s] = n;
      this._removeEventListener(i, s);
    }) : this._removeEventListener(e, t);
  }
  fire(e, t) {
    var n;
    if (!this.__eventListeners) return;
    const i = (n = this.__eventListeners[e]) === null || n === void 0 ? void 0 : n.concat();
    if (i) for (let s = 0; s < i.length; s++) i[s].call(this, t || {});
  }
}
const $i = (r, e) => {
  const t = r.indexOf(e);
  return t !== -1 && r.splice(t, 1), r;
}, un = (r) => {
  if (r === 0) return 1;
  switch (Math.abs(r) / bi) {
    case 1:
    case 3:
      return 0;
    case 2:
      return -1;
  }
  return Math.cos(r);
}, hn = (r) => {
  if (r === 0) return 0;
  const e = r / bi, t = Math.sign(r);
  switch (e) {
    case 1:
      return t;
    case 2:
      return 0;
    case 3:
      return -t;
  }
  return Math.sin(r);
};
class B {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    typeof e == "object" ? (this.x = e.x, this.y = e.y) : (this.x = e, this.y = t);
  }
  add(e) {
    return new B(this.x + e.x, this.y + e.y);
  }
  addEquals(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  scalarAdd(e) {
    return new B(this.x + e, this.y + e);
  }
  scalarAddEquals(e) {
    return this.x += e, this.y += e, this;
  }
  subtract(e) {
    return new B(this.x - e.x, this.y - e.y);
  }
  subtractEquals(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  scalarSubtract(e) {
    return new B(this.x - e, this.y - e);
  }
  scalarSubtractEquals(e) {
    return this.x -= e, this.y -= e, this;
  }
  multiply(e) {
    return new B(this.x * e.x, this.y * e.y);
  }
  scalarMultiply(e) {
    return new B(this.x * e, this.y * e);
  }
  scalarMultiplyEquals(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return new B(this.x / e.x, this.y / e.y);
  }
  scalarDivide(e) {
    return new B(this.x / e, this.y / e);
  }
  scalarDivideEquals(e) {
    return this.x /= e, this.y /= e, this;
  }
  eq(e) {
    return this.x === e.x && this.y === e.y;
  }
  lt(e) {
    return this.x < e.x && this.y < e.y;
  }
  lte(e) {
    return this.x <= e.x && this.y <= e.y;
  }
  gt(e) {
    return this.x > e.x && this.y > e.y;
  }
  gte(e) {
    return this.x >= e.x && this.y >= e.y;
  }
  lerp(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;
    return t = Math.max(Math.min(1, t), 0), new B(this.x + (e.x - this.x) * t, this.y + (e.y - this.y) * t);
  }
  distanceFrom(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return Math.sqrt(t * t + n * n);
  }
  midPointFrom(e) {
    return this.lerp(e);
  }
  min(e) {
    return new B(Math.min(this.x, e.x), Math.min(this.y, e.y));
  }
  max(e) {
    return new B(Math.max(this.x, e.x), Math.max(this.y, e.y));
  }
  toString() {
    return "".concat(this.x, ",").concat(this.y);
  }
  setXY(e, t) {
    return this.x = e, this.y = t, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setFromPoint(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  swap(e) {
    const t = this.x, n = this.y;
    this.x = e.x, this.y = e.y, e.x = t, e.y = n;
  }
  clone() {
    return new B(this.x, this.y);
  }
  rotate(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : rp;
    const n = hn(e), i = un(e), s = this.subtract(t);
    return new B(s.x * i - s.y * n, s.x * n + s.y * i).add(t);
  }
  transform(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    return new B(e[0] * this.x + e[2] * this.y + (t ? 0 : e[4]), e[1] * this.x + e[3] * this.y + (t ? 0 : e[5]));
  }
}
const rp = new B(0, 0), Qc = (r) => !!r && Array.isArray(r._objects);
function Yb(r) {
  class e extends r {
    constructor() {
      super(...arguments), j(this, "_objects", []);
    }
    _onObjectAdded(n) {
    }
    _onObjectRemoved(n) {
    }
    _onStackOrderChanged(n) {
    }
    add() {
      for (var n = arguments.length, i = new Array(n), s = 0; s < n; s++) i[s] = arguments[s];
      const a = this._objects.push(...i);
      return i.forEach((c) => this._onObjectAdded(c)), a;
    }
    insertAt(n) {
      for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++) s[a - 1] = arguments[a];
      return this._objects.splice(n, 0, ...s), s.forEach((c) => this._onObjectAdded(c)), this._objects.length;
    }
    remove() {
      const n = this._objects, i = [];
      for (var s = arguments.length, a = new Array(s), c = 0; c < s; c++) a[c] = arguments[c];
      return a.forEach((u) => {
        const h = n.indexOf(u);
        h !== -1 && (n.splice(h, 1), i.push(u), this._onObjectRemoved(u));
      }), i;
    }
    forEachObject(n) {
      this.getObjects().forEach((i, s, a) => n(i, s, a));
    }
    getObjects() {
      for (var n = arguments.length, i = new Array(n), s = 0; s < n; s++) i[s] = arguments[s];
      return i.length === 0 ? [...this._objects] : this._objects.filter((a) => a.isType(...i));
    }
    item(n) {
      return this._objects[n];
    }
    isEmpty() {
      return this._objects.length === 0;
    }
    size() {
      return this._objects.length;
    }
    contains(n, i) {
      return !!this._objects.includes(n) || !!i && this._objects.some((s) => s instanceof e && s.contains(n, !0));
    }
    complexity() {
      return this._objects.reduce((n, i) => n += i.complexity ? i.complexity() : 0, 0);
    }
    sendObjectToBack(n) {
      return !(!n || n === this._objects[0]) && ($i(this._objects, n), this._objects.unshift(n), this._onStackOrderChanged(n), !0);
    }
    bringObjectToFront(n) {
      return !(!n || n === this._objects[this._objects.length - 1]) && ($i(this._objects, n), this._objects.push(n), this._onStackOrderChanged(n), !0);
    }
    sendObjectBackwards(n, i) {
      if (!n) return !1;
      const s = this._objects.indexOf(n);
      if (s !== 0) {
        const a = this.findNewLowerIndex(n, s, i);
        return $i(this._objects, n), this._objects.splice(a, 0, n), this._onStackOrderChanged(n), !0;
      }
      return !1;
    }
    bringObjectForward(n, i) {
      if (!n) return !1;
      const s = this._objects.indexOf(n);
      if (s !== this._objects.length - 1) {
        const a = this.findNewUpperIndex(n, s, i);
        return $i(this._objects, n), this._objects.splice(a, 0, n), this._onStackOrderChanged(n), !0;
      }
      return !1;
    }
    moveObjectTo(n, i) {
      return n !== this._objects[i] && ($i(this._objects, n), this._objects.splice(i, 0, n), this._onStackOrderChanged(n), !0);
    }
    findNewLowerIndex(n, i, s) {
      let a;
      if (s) {
        a = i;
        for (let c = i - 1; c >= 0; --c) if (n.isOverlapping(this._objects[c])) {
          a = c;
          break;
        }
      } else a = i - 1;
      return a;
    }
    findNewUpperIndex(n, i, s) {
      let a;
      if (s) {
        a = i;
        for (let c = i + 1; c < this._objects.length; ++c) if (n.isOverlapping(this._objects[c])) {
          a = c;
          break;
        }
      } else a = i + 1;
      return a;
    }
    collectObjects(n) {
      let { left: i, top: s, width: a, height: c } = n, { includeIntersecting: u = !0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const h = [], d = new B(i, s), p = d.add(new B(a, c));
      for (let g = this._objects.length - 1; g >= 0; g--) {
        const v = this._objects[g];
        v.selectable && v.visible && (u && v.intersectsWithRect(d, p) || v.isContainedWithinRect(d, p) || u && v.containsPoint(d) || u && v.containsPoint(p)) && h.push(v);
      }
      return h;
    }
  }
  return e;
}
class Xb extends KP {
  _setOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    for (const t in e) this.set(t, e[t]);
  }
  _setObject(e) {
    for (const t in e) this._set(t, e[t]);
  }
  set(e, t) {
    return typeof e == "object" ? this._setObject(e) : this._set(e, t), this;
  }
  _set(e, t) {
    this[e] = t;
  }
  toggle(e) {
    const t = this.get(e);
    return typeof t == "boolean" && this.set(e, !t), this;
  }
  get(e) {
    return this[e];
  }
}
function Ko(r) {
  return eu().requestAnimationFrame(r);
}
function Gb(r) {
  return eu().cancelAnimationFrame(r);
}
let ZP = 0;
const wi = () => ZP++, Kr = () => {
  const r = lo().createElement("canvas");
  if (!r || r.getContext === void 0) throw new _n("Failed to create `canvas` element");
  return r;
}, qb = () => lo().createElement("img"), dn = (r) => {
  const e = Kr();
  return e.width = r.width, e.height = r.height, e;
}, np = (r, e, t) => r.toDataURL("image/".concat(e), t), wt = (r) => r * Jf, xi = (r) => r / Jf, Kb = (r) => r.every((e, t) => e === ar[t]), Kt = (r, e, t) => new B(r).transform(e, t), jr = (r) => {
  const e = 1 / (r[0] * r[3] - r[1] * r[2]), t = [e * r[3], -e * r[1], -e * r[2], e * r[0], 0, 0], { x: n, y: i } = new B(r[4], r[5]).transform(t, !0);
  return t[4] = -n, t[5] = -i, t;
}, xt = (r, e, t) => [r[0] * e[0] + r[2] * e[1], r[1] * e[0] + r[3] * e[1], r[0] * e[2] + r[2] * e[3], r[1] * e[2] + r[3] * e[3], t ? 0 : r[0] * e[4] + r[2] * e[5] + r[4], t ? 0 : r[1] * e[4] + r[3] * e[5] + r[5]], nu = (r, e) => r.reduceRight((t, n) => n && t ? xt(n, t, e) : n || t, void 0) || ar.concat(), Zb = (r) => {
  let [e, t] = r;
  return Math.atan2(t, e);
}, Xs = (r) => {
  const e = Zb(r), t = Math.pow(r[0], 2) + Math.pow(r[1], 2), n = Math.sqrt(t), i = (r[0] * r[3] - r[2] * r[1]) / n, s = Math.atan2(r[0] * r[2] + r[1] * r[3], t);
  return { angle: xi(e), scaleX: n, scaleY: i, skewX: xi(s), skewY: 0, translateX: r[4] || 0, translateY: r[5] || 0 };
}, fo = function(r) {
  return [1, 0, 0, 1, r, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0];
};
function po() {
  let { angle: r = 0 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { x: e = 0, y: t = 0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const n = wt(r), i = un(n), s = hn(n);
  return [i, s, -s, i, e ? e - (i * e - s * t) : 0, t ? t - (s * e + i * t) : 0];
}
const iu = function(r) {
  return [r, 0, 0, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : r, 0, 0];
}, Jb = (r) => Math.tan(wt(r)), ip = (r) => [1, 0, Jb(r), 1, 0, 0], sp = (r) => [1, Jb(r), 0, 1, 0, 0], _a = (r) => {
  let { scaleX: e = 1, scaleY: t = 1, flipX: n = !1, flipY: i = !1, skewX: s = 0, skewY: a = 0 } = r, c = iu(n ? -e : e, i ? -t : t);
  return s && (c = xt(c, ip(s), !0)), a && (c = xt(c, sp(a), !0)), c;
}, Qb = (r) => {
  const { translateX: e = 0, translateY: t = 0, angle: n = 0 } = r;
  let i = fo(e, t);
  n && (i = xt(i, po({ angle: n })));
  const s = _a(r);
  return Kb(s) || (i = xt(i, s)), i;
}, Zo = function(r) {
  let { signal: e, crossOrigin: t = null } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise(function(n, i) {
    if (e && e.aborted) return i(new Vb("loadImage"));
    const s = qb();
    let a;
    e && (a = function(u) {
      s.src = "", i(u);
    }, e.addEventListener("abort", a, { once: !0 }));
    const c = function() {
      s.onload = s.onerror = null, a && e?.removeEventListener("abort", a), n(s);
    };
    r ? (s.onload = c, s.onerror = function() {
      a && e?.removeEventListener("abort", a), i(new _n("Error loading ".concat(s.src)));
    }, t && (s.crossOrigin = t), s.src = r) : c();
  });
}, Gs = function(r) {
  let { signal: e, reviver: t = Qi } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((n, i) => {
    const s = [];
    e && e.addEventListener("abort", i, { once: !0 }), Promise.all(r.map((a) => ne.getClass(a.type).fromObject(a, { signal: e }).then((c) => (t(a, c), s.push(c), c)))).then(n).catch((a) => {
      s.forEach((c) => {
        c.dispose && c.dispose();
      }), i(a);
    }).finally(() => {
      e && e.removeEventListener("abort", i);
    });
  });
}, Sa = function(r) {
  let { signal: e } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((t, n) => {
    const i = [];
    e && e.addEventListener("abort", n, { once: !0 });
    const s = Object.values(r).map((c) => c && c.type && ne.has(c.type) ? Gs([c], { signal: e }).then((u) => {
      let [h] = u;
      return i.push(h), h;
    }) : c), a = Object.keys(r);
    Promise.all(s).then((c) => c.reduce((u, h, d) => (u[a[d]] = h, u), {})).then(t).catch((c) => {
      i.forEach((u) => {
        u.dispose && u.dispose();
      }), n(c);
    }).finally(() => {
      e && e.removeEventListener("abort", n);
    });
  });
}, ps = function(r) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []).reduce((e, t) => (t in r && (e[t] = r[t]), e), {});
}, op = (r, e) => Object.keys(r).reduce((t, n) => (e(r[n], n, r) && (t[n] = r[n]), t), {}), u0 = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aqua: "#0FF", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000", blanchedalmond: "#FFEBCD", blue: "#00F", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#0FF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgrey: "#A9A9A9", darkgreen: "#006400", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", fuchsia: "#F0F", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", gray: "#808080", grey: "#808080", green: "#008000", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgray: "#D3D3D3", lightgrey: "#D3D3D3", lightgreen: "#90EE90", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#789", lightslategrey: "#789", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", lime: "#0F0", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#F0F", maroon: "#800000", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", navy: "#000080", oldlace: "#FDF5E6", olive: "#808000", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", purple: "#800080", rebeccapurple: "#639", red: "#F00", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", silver: "#C0C0C0", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", teal: "#008080", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", white: "#FFF", whitesmoke: "#F5F5F5", yellow: "#FF0", yellowgreen: "#9ACD32" }, Yh = (r, e, t) => (t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? r + 6 * (e - r) * t : t < 0.5 ? e : t < 2 / 3 ? r + (e - r) * (2 / 3 - t) * 6 : r), h0 = (r, e, t, n) => {
  r /= 255, e /= 255, t /= 255;
  const i = Math.max(r, e, t), s = Math.min(r, e, t);
  let a, c;
  const u = (i + s) / 2;
  if (i === s) a = c = 0;
  else {
    const h = i - s;
    switch (c = u > 0.5 ? h / (2 - i - s) : h / (i + s), i) {
      case r:
        a = (e - t) / h + (e < t ? 6 : 0);
        break;
      case e:
        a = (t - r) / h + 2;
        break;
      case t:
        a = (r - e) / h + 4;
    }
    a /= 6;
  }
  return [Math.round(360 * a), Math.round(100 * c), Math.round(100 * u), n];
}, d0 = function() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "1";
  return parseFloat(r) / (r.endsWith("%") ? 100 : 1);
}, Ec = (r) => Math.min(Math.round(r), 255).toString(16).toUpperCase().padStart(2, "0"), f0 = (r) => {
  let [e, t, n, i = 1] = r;
  const s = Math.round(0.3 * e + 0.59 * t + 0.11 * n);
  return [s, s, s, i];
};
class Qe {
  constructor(e) {
    if (j(this, "isUnrecognised", !1), e) if (e instanceof Qe) this.setSource([...e._source]);
    else if (Array.isArray(e)) {
      const [t, n, i, s = 1] = e;
      this.setSource([t, n, i, s]);
    } else this.setSource(this._tryParsingColor(e));
    else this.setSource([0, 0, 0, 1]);
  }
  _tryParsingColor(e) {
    return (e = e.toLowerCase()) in u0 && (e = u0[e]), e === "transparent" ? [255, 255, 255, 0] : Qe.sourceFromHex(e) || Qe.sourceFromRgb(e) || Qe.sourceFromHsl(e) || (this.isUnrecognised = !0) && [0, 0, 0, 1];
  }
  getSource() {
    return this._source;
  }
  setSource(e) {
    this._source = e;
  }
  toRgb() {
    const [e, t, n] = this.getSource();
    return "rgb(".concat(e, ",").concat(t, ",").concat(n, ")");
  }
  toRgba() {
    return "rgba(".concat(this.getSource().join(","), ")");
  }
  toHsl() {
    const [e, t, n] = h0(...this.getSource());
    return "hsl(".concat(e, ",").concat(t, "%,").concat(n, "%)");
  }
  toHsla() {
    const [e, t, n, i] = h0(...this.getSource());
    return "hsla(".concat(e, ",").concat(t, "%,").concat(n, "%,").concat(i, ")");
  }
  toHex() {
    return this.toHexa().slice(0, 6);
  }
  toHexa() {
    const [e, t, n, i] = this.getSource();
    return "".concat(Ec(e)).concat(Ec(t)).concat(Ec(n)).concat(Ec(Math.round(255 * i)));
  }
  getAlpha() {
    return this.getSource()[3];
  }
  setAlpha(e) {
    return this._source[3] = e, this;
  }
  toGrayscale() {
    return this.setSource(f0(this.getSource())), this;
  }
  toBlackWhite(e) {
    const [t, , , n] = f0(this.getSource()), i = t < (e || 127) ? 0 : 255;
    return this.setSource([i, i, i, n]), this;
  }
  overlayWith(e) {
    e instanceof Qe || (e = new Qe(e));
    const t = this.getSource(), n = e.getSource(), [i, s, a] = t.map((c, u) => Math.round(0.5 * c + 0.5 * n[u]));
    return this.setSource([i, s, a, t[3]]), this;
  }
  static fromRgb(e) {
    return Qe.fromRgba(e);
  }
  static fromRgba(e) {
    return new Qe(Qe.sourceFromRgb(e));
  }
  static sourceFromRgb(e) {
    const t = e.match(/^rgba?\(\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*(?:\s*[,/]\s*(\d{0,3}(?:\.\d+)?%?)\s*)?\)$/i);
    if (t) {
      const [n, i, s] = t.slice(1, 4).map((a) => {
        const c = parseFloat(a);
        return a.endsWith("%") ? Math.round(2.55 * c) : c;
      });
      return [n, i, s, d0(t[4])];
    }
  }
  static fromHsl(e) {
    return Qe.fromHsla(e);
  }
  static fromHsla(e) {
    return new Qe(Qe.sourceFromHsl(e));
  }
  static sourceFromHsl(e) {
    const t = e.match(/^hsla?\(\s*([+-]?\d{0,3}(?:\.\d+)?(?:deg|turn|rad)?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*(?:\s*[,/]\s*(\d*(?:\.\d+)?%?)\s*)?\)$/i);
    if (!t) return;
    const n = (Qe.parseAngletoDegrees(t[1]) % 360 + 360) % 360 / 360, i = parseFloat(t[2]) / 100, s = parseFloat(t[3]) / 100;
    let a, c, u;
    if (i === 0) a = c = u = s;
    else {
      const h = s <= 0.5 ? s * (i + 1) : s + i - s * i, d = 2 * s - h;
      a = Yh(d, h, n + 1 / 3), c = Yh(d, h, n), u = Yh(d, h, n - 1 / 3);
    }
    return [Math.round(255 * a), Math.round(255 * c), Math.round(255 * u), d0(t[4])];
  }
  static fromHex(e) {
    return new Qe(Qe.sourceFromHex(e));
  }
  static sourceFromHex(e) {
    if (e.match(/^#?(([0-9a-f]){3,4}|([0-9a-f]{2}){3,4})$/i)) {
      const t = e.slice(e.indexOf("#") + 1);
      let n;
      n = t.length <= 4 ? t.split("").map((u) => u + u) : t.match(/.{2}/g);
      const [i, s, a, c = 255] = n.map((u) => parseInt(u, 16));
      return [i, s, a, c / 255];
    }
  }
  static parseAngletoDegrees(e) {
    const t = e.toLowerCase(), n = parseFloat(t);
    return t.includes("rad") ? xi(n) : t.includes("turn") ? 360 * n : n;
  }
}
const ut = (r, e) => parseFloat(Number(r).toFixed(e)), es = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Qf;
  const t = /\D{0,2}$/.exec(r), n = parseFloat(r), i = Ue.DPI;
  switch (t?.[0]) {
    case "mm":
      return n * i / 25.4;
    case "cm":
      return n * i / 2.54;
    case "in":
      return n * i;
    case "pt":
      return n * i / 72;
    case "pc":
      return n * i / 72 * 12;
    case "em":
      return n * e;
    default:
      return n;
  }
}, ew = (r) => {
  const [e, t] = r.trim().split(" "), [n, i] = (s = e) && s !== wr ? [s.slice(1, 4), s.slice(5, 8)] : s === wr ? [s, s] : ["Mid", "Mid"];
  var s;
  return { meetOrSlice: t || "meet", alignX: n, alignY: i };
}, sa = (r) => "matrix(" + r.map((e) => ut(e, Ue.NUM_FRACTION_DIGITS)).join(" ") + ")", oa = function(r, e) {
  let t, n, i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
  if (e) if (e.toLive) t = "url(#SVGID_".concat(e.id, ")");
  else {
    const s = new Qe(e), a = s.getAlpha();
    t = s.toRgb(), a !== 1 && (n = a.toString());
  }
  else t = "none";
  return i ? "".concat(r, ": ").concat(t, "; ").concat(n ? "".concat(r, "-opacity: ").concat(n, "; ") : "") : "".concat(r, '="').concat(t, '" ').concat(n ? "".concat(r, '-opacity="').concat(n, '" ') : "");
}, Gr = (r) => !!r && r.toLive !== void 0, p0 = (r) => !!r && typeof r.toObject == "function", g0 = (r) => !!r && r.offsetX !== void 0 && "source" in r, Yi = (r) => !!r && "multiSelectionStacking" in r;
function tw(r) {
  const e = r && an(r);
  let t = 0, n = 0;
  if (!r || !e) return { left: t, top: n };
  let i = r;
  const s = e.documentElement, a = e.body || { scrollLeft: 0, scrollTop: 0 };
  for (; i && (i.parentNode || i.host) && (i = i.parentNode || i.host, i === e ? (t = a.scrollLeft || s.scrollLeft || 0, n = a.scrollTop || s.scrollTop || 0) : (t += i.scrollLeft || 0, n += i.scrollTop || 0), i.nodeType !== 1 || i.style.position !== "fixed"); ) ;
  return { left: t, top: n };
}
const an = (r) => r.ownerDocument || null, rw = (r) => {
  var e;
  return ((e = r.ownerDocument) === null || e === void 0 ? void 0 : e.defaultView) || null;
}, nw = function(r, e, t) {
  let { width: n, height: i } = t, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  r.width = n, r.height = i, s > 1 && (r.setAttribute("width", (n * s).toString()), r.setAttribute("height", (i * s).toString()), e.scale(s, s));
}, $d = (r, e) => {
  let { width: t, height: n } = e;
  t && (r.style.width = typeof t == "number" ? "".concat(t, "px") : t), n && (r.style.height = typeof n == "number" ? "".concat(n, "px") : n);
};
function m0(r) {
  return r.onselectstart !== void 0 && (r.onselectstart = () => !1), r.style.userSelect = wr, r;
}
class iw {
  constructor(e) {
    j(this, "_originalCanvasStyle", void 0), j(this, "lower", void 0);
    const t = this.createLowerCanvas(e);
    this.lower = { el: t, ctx: t.getContext("2d") };
  }
  createLowerCanvas(e) {
    const t = (n = e) && n.getContext !== void 0 ? e : e && lo().getElementById(e) || Kr();
    var n;
    if (t.hasAttribute("data-fabric")) throw new _n("Trying to initialize a canvas that has already been initialized. Did you forget to dispose the canvas?");
    return this._originalCanvasStyle = t.style.cssText, t.setAttribute("data-fabric", "main"), t.classList.add("lower-canvas"), t;
  }
  cleanupDOM(e) {
    let { width: t, height: n } = e;
    const { el: i } = this.lower;
    i.classList.remove("lower-canvas"), i.removeAttribute("data-fabric"), i.setAttribute("width", "".concat(t)), i.setAttribute("height", "".concat(n)), i.style.cssText = this._originalCanvasStyle || "", this._originalCanvasStyle = void 0;
  }
  setDimensions(e, t) {
    const { el: n, ctx: i } = this.lower;
    nw(n, i, e, t);
  }
  setCSSDimensions(e) {
    $d(this.lower.el, e);
  }
  calcOffset() {
    return function(e) {
      var t;
      const n = e && an(e), i = { left: 0, top: 0 };
      if (!n) return i;
      const s = ((t = rw(e)) === null || t === void 0 ? void 0 : t.getComputedStyle(e, null)) || {};
      i.left += parseInt(s.borderLeftWidth, 10) || 0, i.top += parseInt(s.borderTopWidth, 10) || 0, i.left += parseInt(s.paddingLeft, 10) || 0, i.top += parseInt(s.paddingTop, 10) || 0;
      let a = { left: 0, top: 0 };
      const c = n.documentElement;
      e.getBoundingClientRect !== void 0 && (a = e.getBoundingClientRect());
      const u = tw(e);
      return { left: a.left + u.left - (c.clientLeft || 0) + i.left, top: a.top + u.top - (c.clientTop || 0) + i.top };
    }(this.lower.el);
  }
  dispose() {
    kn().dispose(this.lower.el), delete this.lower;
  }
}
const JP = { backgroundVpt: !0, backgroundColor: "", overlayVpt: !0, overlayColor: "", includeDefaultValues: !0, svgViewportTransformation: !0, renderOnAddRemove: !0, skipOffscreen: !0, enableRetinaScaling: !0, imageSmoothingEnabled: !0, controlsAboveOverlay: !1, allowTouchScrolling: !1, viewportTransform: [...ar] };
class Ca extends Yb(Xb) {
  get lowerCanvasEl() {
    var e;
    return (e = this.elements.lower) === null || e === void 0 ? void 0 : e.el;
  }
  get contextContainer() {
    var e;
    return (e = this.elements.lower) === null || e === void 0 ? void 0 : e.ctx;
  }
  static getDefaults() {
    return Ca.ownDefaults;
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, this.constructor.getDefaults()), this.set(t), this.initElements(e), this._setDimensionsImpl({ width: this.width || this.elements.lower.el.width || 0, height: this.height || this.elements.lower.el.height || 0 }), this.skipControlsDrawing = !1, this.viewportTransform = [...this.viewportTransform], this.calcViewportBoundaries();
  }
  initElements(e) {
    this.elements = new iw(e);
  }
  add() {
    const e = super.add(...arguments);
    return arguments.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), e;
  }
  insertAt(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
    const s = super.insertAt(e, ...n);
    return n.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), s;
  }
  remove() {
    const e = super.remove(...arguments);
    return e.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), e;
  }
  _onObjectAdded(e) {
    e.canvas && e.canvas !== this && (yi("warn", `Canvas is trying to add an object that belongs to a different canvas.
Resulting to default behavior: removing object from previous canvas and adding to new canvas`), e.canvas.remove(e)), e._set("canvas", this), e.setCoords(), this.fire("object:added", { target: e }), e.fire("added", { target: this });
  }
  _onObjectRemoved(e) {
    e._set("canvas", void 0), this.fire("object:removed", { target: e }), e.fire("removed", { target: this });
  }
  _onStackOrderChanged() {
    this.renderOnAddRemove && this.requestRenderAll();
  }
  getRetinaScaling() {
    return this.enableRetinaScaling ? zb() : 1;
  }
  calcOffset() {
    return this._offset = this.elements.calcOffset();
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  setWidth(e, t) {
    return this.setDimensions({ width: e }, t);
  }
  setHeight(e, t) {
    return this.setDimensions({ height: e }, t);
  }
  _setDimensionsImpl(e) {
    let { cssOnly: t = !1, backstoreOnly: n = !1 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!t) {
      const i = D({ width: this.width, height: this.height }, e);
      this.elements.setDimensions(i, this.getRetinaScaling()), this.hasLostContext = !0, this.width = i.width, this.height = i.height;
    }
    n || this.elements.setCSSDimensions(e), this.calcOffset();
  }
  setDimensions(e, t) {
    this._setDimensionsImpl(e, t), t && t.cssOnly || this.requestRenderAll();
  }
  getZoom() {
    return this.viewportTransform[0];
  }
  setViewportTransform(e) {
    this.viewportTransform = e, this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll();
  }
  zoomToPoint(e, t) {
    const n = e, i = [...this.viewportTransform], s = Kt(e, jr(i));
    i[0] = t, i[3] = t;
    const a = Kt(s, i);
    i[4] += n.x - a.x, i[5] += n.y - a.y, this.setViewportTransform(i);
  }
  setZoom(e) {
    this.zoomToPoint(new B(0, 0), e);
  }
  absolutePan(e) {
    const t = [...this.viewportTransform];
    return t[4] = -e.x, t[5] = -e.y, this.setViewportTransform(t);
  }
  relativePan(e) {
    return this.absolutePan(new B(-e.x - this.viewportTransform[4], -e.y - this.viewportTransform[5]));
  }
  getElement() {
    return this.elements.lower.el;
  }
  clearContext(e) {
    e.clearRect(0, 0, this.width, this.height);
  }
  getContext() {
    return this.elements.lower.ctx;
  }
  clear() {
    this.remove(...this.getObjects()), this.backgroundImage = void 0, this.overlayImage = void 0, this.backgroundColor = "", this.overlayColor = "", this.clearContext(this.getContext()), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll();
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || this.renderCanvas(this.getContext(), this._objects);
  }
  renderAndReset() {
    this.nextRenderHandle = 0, this.renderAll();
  }
  requestRenderAll() {
    this.nextRenderHandle || this.disposed || this.destroyed || (this.nextRenderHandle = Ko(() => this.renderAndReset()));
  }
  calcViewportBoundaries() {
    const e = this.width, t = this.height, n = jr(this.viewportTransform), i = Kt({ x: 0, y: 0 }, n), s = Kt({ x: e, y: t }, n), a = i.min(s), c = i.max(s);
    return this.vptCoords = { tl: a, tr: new B(c.x, a.y), bl: new B(a.x, c.y), br: c };
  }
  cancelRequestedRender() {
    this.nextRenderHandle && (Gb(this.nextRenderHandle), this.nextRenderHandle = 0);
  }
  drawControls(e) {
  }
  renderCanvas(e, t) {
    if (this.destroyed) return;
    const n = this.viewportTransform, i = this.clipPath;
    this.calcViewportBoundaries(), this.clearContext(e), e.imageSmoothingEnabled = this.imageSmoothingEnabled, e.patternQuality = "best", this.fire("before:render", { ctx: e }), this._renderBackground(e), e.save(), e.transform(n[0], n[1], n[2], n[3], n[4], n[5]), this._renderObjects(e, t), e.restore(), this.controlsAboveOverlay || this.skipControlsDrawing || this.drawControls(e), i && (i._set("canvas", this), i.shouldCache(), i._transformDone = !0, i.renderCache({ forClipping: !0 }), this.drawClipPathOnCanvas(e, i)), this._renderOverlay(e), this.controlsAboveOverlay && !this.skipControlsDrawing && this.drawControls(e), this.fire("after:render", { ctx: e }), this.__cleanupTask && (this.__cleanupTask(), this.__cleanupTask = void 0);
  }
  drawClipPathOnCanvas(e, t) {
    const n = this.viewportTransform;
    e.save(), e.transform(...n), e.globalCompositeOperation = "destination-in", t.transform(e), e.scale(1 / t.zoomX, 1 / t.zoomY), e.drawImage(t._cacheCanvas, -t.cacheTranslationX, -t.cacheTranslationY), e.restore();
  }
  _renderObjects(e, t) {
    for (let n = 0, i = t.length; n < i; ++n) t[n] && t[n].render(e);
  }
  _renderBackgroundOrOverlay(e, t) {
    const n = this["".concat(t, "Color")], i = this["".concat(t, "Image")], s = this.viewportTransform, a = this["".concat(t, "Vpt")];
    if (!n && !i) return;
    const c = Gr(n);
    if (n) {
      if (e.save(), e.beginPath(), e.moveTo(0, 0), e.lineTo(this.width, 0), e.lineTo(this.width, this.height), e.lineTo(0, this.height), e.closePath(), e.fillStyle = c ? n.toLive(e) : n, a && e.transform(...s), c) {
        e.transform(1, 0, 0, 1, n.offsetX || 0, n.offsetY || 0);
        const u = n.gradientTransform || n.patternTransform;
        u && e.transform(...u);
      }
      e.fill(), e.restore();
    }
    if (i) {
      e.save();
      const { skipOffscreen: u } = this;
      this.skipOffscreen = a, a && e.transform(...s), i.render(e), this.skipOffscreen = u, e.restore();
    }
  }
  _renderBackground(e) {
    this._renderBackgroundOrOverlay(e, "background");
  }
  _renderOverlay(e) {
    this._renderBackgroundOrOverlay(e, "overlay");
  }
  getCenter() {
    return { top: this.height / 2, left: this.width / 2 };
  }
  getCenterPoint() {
    return new B(this.width / 2, this.height / 2);
  }
  centerObjectH(e) {
    return this._centerObject(e, new B(this.getCenterPoint().x, e.getCenterPoint().y));
  }
  centerObjectV(e) {
    return this._centerObject(e, new B(e.getCenterPoint().x, this.getCenterPoint().y));
  }
  centerObject(e) {
    return this._centerObject(e, this.getCenterPoint());
  }
  viewportCenterObject(e) {
    return this._centerObject(e, this.getVpCenter());
  }
  viewportCenterObjectH(e) {
    return this._centerObject(e, new B(this.getVpCenter().x, e.getCenterPoint().y));
  }
  viewportCenterObjectV(e) {
    return this._centerObject(e, new B(e.getCenterPoint().x, this.getVpCenter().y));
  }
  getVpCenter() {
    return Kt(this.getCenterPoint(), jr(this.viewportTransform));
  }
  _centerObject(e, t) {
    e.setXY(t, Pe, Pe), e.setCoords(), this.renderOnAddRemove && this.requestRenderAll();
  }
  toDatalessJSON(e) {
    return this.toDatalessObject(e);
  }
  toObject(e) {
    return this._toObjectMethod("toObject", e);
  }
  toJSON() {
    return this.toObject();
  }
  toDatalessObject(e) {
    return this._toObjectMethod("toDatalessObject", e);
  }
  _toObjectMethod(e, t) {
    const n = this.clipPath, i = n && !n.excludeFromExport ? this._toObject(n, e, t) : null;
    return D(D(D({ version: Hd }, ps(this, t)), {}, { objects: this._objects.filter((s) => !s.excludeFromExport).map((s) => this._toObject(s, e, t)) }, this.__serializeBgOverlay(e, t)), i ? { clipPath: i } : null);
  }
  _toObject(e, t, n) {
    let i;
    this.includeDefaultValues || (i = e.includeDefaultValues, e.includeDefaultValues = !1);
    const s = e[t](n);
    return this.includeDefaultValues || (e.includeDefaultValues = !!i), s;
  }
  __serializeBgOverlay(e, t) {
    const n = {}, i = this.backgroundImage, s = this.overlayImage, a = this.backgroundColor, c = this.overlayColor;
    return Gr(a) ? a.excludeFromExport || (n.background = a.toObject(t)) : a && (n.background = a), Gr(c) ? c.excludeFromExport || (n.overlay = c.toObject(t)) : c && (n.overlay = c), i && !i.excludeFromExport && (n.backgroundImage = this._toObject(i, e, t)), s && !s.excludeFromExport && (n.overlayImage = this._toObject(s, e, t)), n;
  }
  toSVG() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
    e.reviver = t;
    const n = [];
    return this._setSVGPreamble(n, e), this._setSVGHeader(n, e), this.clipPath && n.push('<g clip-path="url(#'.concat(this.clipPath.clipPathId, `)" >
`)), this._setSVGBgOverlayColor(n, "background"), this._setSVGBgOverlayImage(n, "backgroundImage", t), this._setSVGObjects(n, t), this.clipPath && n.push(`</g>
`), this._setSVGBgOverlayColor(n, "overlay"), this._setSVGBgOverlayImage(n, "overlayImage", t), n.push("</svg>"), n.join("");
  }
  _setSVGPreamble(e, t) {
    t.suppressPreamble || e.push('<?xml version="1.0" encoding="', t.encoding || "UTF-8", `" standalone="no" ?>
`, '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', `"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
`);
  }
  _setSVGHeader(e, t) {
    const n = t.width || "".concat(this.width), i = t.height || "".concat(this.height), s = Ue.NUM_FRACTION_DIGITS, a = t.viewBox;
    let c;
    if (a) c = 'viewBox="'.concat(a.x, " ").concat(a.y, " ").concat(a.width, " ").concat(a.height, '" ');
    else if (this.svgViewportTransformation) {
      const u = this.viewportTransform;
      c = 'viewBox="'.concat(ut(-u[4] / u[0], s), " ").concat(ut(-u[5] / u[3], s), " ").concat(ut(this.width / u[0], s), " ").concat(ut(this.height / u[3], s), '" ');
    } else c = 'viewBox="0 0 '.concat(this.width, " ").concat(this.height, '" ');
    e.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', n, '" ', 'height="', i, '" ', c, `xml:space="preserve">
`, "<desc>Created with Fabric.js ", Hd, `</desc>
`, `<defs>
`, this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(t), `</defs>
`);
  }
  createSVGClipPathMarkup(e) {
    const t = this.clipPath;
    return t ? (t.clipPathId = "CLIPPATH_".concat(wi()), '<clipPath id="'.concat(t.clipPathId, `" >
`).concat(t.toClipPathSVG(e.reviver), `</clipPath>
`)) : "";
  }
  createSVGRefElementsMarkup() {
    return ["background", "overlay"].map((e) => {
      const t = this["".concat(e, "Color")];
      if (Gr(t)) {
        const n = this["".concat(e, "Vpt")], i = this.viewportTransform, s = { isType: () => !1, width: this.width / (n ? i[0] : 1), height: this.height / (n ? i[3] : 1) };
        return t.toSVG(s, { additionalTransform: n ? sa(i) : "" });
      }
    }).join("");
  }
  createSVGFontFacesMarkup() {
    const e = [], t = {}, n = Ue.fontPaths;
    this._objects.forEach(function s(a) {
      e.push(a), Qc(a) && a._objects.forEach(s);
    }), e.forEach((s) => {
      if (!(a = s) || typeof a._renderText != "function") return;
      var a;
      const { styles: c, fontFamily: u } = s;
      !t[u] && n[u] && (t[u] = !0, c && Object.values(c).forEach((h) => {
        Object.values(h).forEach((d) => {
          let { fontFamily: p = "" } = d;
          !t[p] && n[p] && (t[p] = !0);
        });
      }));
    });
    const i = Object.keys(t).map((s) => `		@font-face {
			font-family: '`.concat(s, `';
			src: url('`).concat(n[s], `');
		}
`)).join("");
    return i ? `	<style type="text/css"><![CDATA[
`.concat(i, `]]></style>
`) : "";
  }
  _setSVGObjects(e, t) {
    this.forEachObject((n) => {
      n.excludeFromExport || this._setSVGObject(e, n, t);
    });
  }
  _setSVGObject(e, t, n) {
    e.push(t.toSVG(n));
  }
  _setSVGBgOverlayImage(e, t, n) {
    const i = this[t];
    i && !i.excludeFromExport && i.toSVG && e.push(i.toSVG(n));
  }
  _setSVGBgOverlayColor(e, t) {
    const n = this["".concat(t, "Color")];
    if (n) if (Gr(n)) {
      const i = n.repeat || "", s = this.width, a = this.height, c = this["".concat(t, "Vpt")] ? sa(jr(this.viewportTransform)) : "";
      e.push('<rect transform="'.concat(c, " translate(").concat(s / 2, ",").concat(a / 2, ')" x="').concat(n.offsetX - s / 2, '" y="').concat(n.offsetY - a / 2, '" width="').concat(i !== "repeat-y" && i !== "no-repeat" || !g0(n) ? s : n.source.width, '" height="').concat(i !== "repeat-x" && i !== "no-repeat" || !g0(n) ? a : n.source.height, '" fill="url(#SVGID_').concat(n.id, `)"></rect>
`));
    } else e.push('<rect x="0" y="0" width="100%" height="100%" ', 'fill="', n, '"', `></rect>
`);
  }
  loadFromJSON(e, t) {
    let { signal: n } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return Promise.reject(new _n("`json` is undefined"));
    const i = typeof e == "string" ? JSON.parse(e) : e, { objects: s = [], backgroundImage: a, background: c, overlayImage: u, overlay: h, clipPath: d } = i, p = this.renderOnAddRemove;
    return this.renderOnAddRemove = !1, Promise.all([Gs(s, { reviver: t, signal: n }), Sa({ backgroundImage: a, backgroundColor: c, overlayImage: u, overlayColor: h, clipPath: d }, { signal: n })]).then((g) => {
      let [v, b] = g;
      return this.clear(), this.add(...v), this.set(i), this.set(b), this.renderOnAddRemove = p, this;
    });
  }
  clone(e) {
    const t = this.toObject(e);
    return this.cloneWithoutData().loadFromJSON(t);
  }
  cloneWithoutData() {
    const e = dn(this);
    return new this.constructor(e);
  }
  toDataURL() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { format: t = "png", quality: n = 1, multiplier: i = 1, enableRetinaScaling: s = !1 } = e, a = i * (s ? this.getRetinaScaling() : 1);
    return np(this.toCanvasElement(a, e), t, n);
  }
  toCanvasElement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, { width: t, height: n, left: i, top: s, filter: a } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const c = (t || this.width) * e, u = (n || this.height) * e, h = this.getZoom(), d = this.width, p = this.height, g = this.skipControlsDrawing, v = h * e, b = this.viewportTransform, x = [v, 0, 0, v, (b[4] - (i || 0)) * e, (b[5] - (s || 0)) * e], _ = this.enableRetinaScaling, C = dn({ width: c, height: u }), E = a ? this._objects.filter((k) => a(k)) : this._objects;
    return this.enableRetinaScaling = !1, this.viewportTransform = x, this.width = c, this.height = u, this.skipControlsDrawing = !0, this.calcViewportBoundaries(), this.renderCanvas(C.getContext("2d"), E), this.viewportTransform = b, this.width = d, this.height = p, this.calcViewportBoundaries(), this.enableRetinaScaling = _, this.skipControlsDrawing = g, C;
  }
  dispose() {
    return !this.disposed && this.elements.cleanupDOM({ width: this.width, height: this.height }), pl.cancelByCanvas(this), this.disposed = !0, new Promise((e, t) => {
      const n = () => {
        this.destroy(), e(!0);
      };
      n.kill = t, this.__cleanupTask && this.__cleanupTask.kill("aborted"), this.destroyed ? e(!1) : this.nextRenderHandle ? this.__cleanupTask = n : n();
    });
  }
  destroy() {
    this.destroyed = !0, this.cancelRequestedRender(), this.forEachObject((e) => e.dispose()), this._objects = [], this.backgroundImage && this.backgroundImage.dispose(), this.backgroundImage = void 0, this.overlayImage && this.overlayImage.dispose(), this.overlayImage = void 0, this.elements.dispose();
  }
  toString() {
    return "#<Canvas (".concat(this.complexity(), "): { objects: ").concat(this._objects.length, " }>");
  }
}
j(Ca, "ownDefaults", JP);
const QP = ["touchstart", "touchmove", "touchend"], sw = (r) => {
  const e = tw(r.target), t = function(n) {
    const i = n.changedTouches;
    return i && i[0] ? i[0] : n;
  }(r);
  return new B(t.clientX + e.left, t.clientY + e.top);
}, gl = (r) => QP.includes(r.type) || r.pointerType === "touch", Yd = (r) => {
  r.preventDefault(), r.stopPropagation();
}, Tn = (r) => {
  let e = 0, t = 0, n = 0, i = 0;
  for (let s = 0, a = r.length; s < a; s++) {
    const { x: c, y: u } = r[s];
    (c > n || !s) && (n = c), (c < e || !s) && (e = c), (u > i || !s) && (i = u), (u < t || !s) && (t = u);
  }
  return { left: e, top: t, width: n - e, height: i - t };
}, eD = ["translateX", "translateY", "scaleX", "scaleY"], ow = (r, e) => qs(r, xt(e, r.calcOwnMatrix())), qs = (r, e) => {
  const t = Xs(e), { translateX: n, translateY: i, scaleX: s, scaleY: a } = t, c = ht(t, eD), u = new B(n, i);
  r.flipX = !1, r.flipY = !1, Object.assign(r, c), r.set({ scaleX: s, scaleY: a }), r.setPositionByOrigin(u, Pe, Pe);
}, aw = (r) => {
  r.scaleX = 1, r.scaleY = 1, r.skewX = 0, r.skewY = 0, r.flipX = !1, r.flipY = !1, r.rotate(0);
}, ap = (r) => ({ scaleX: r.scaleX, scaleY: r.scaleY, skewX: r.skewX, skewY: r.skewY, angle: r.angle, left: r.left, flipX: r.flipX, flipY: r.flipY, top: r.top }), su = (r, e, t) => {
  const n = r / 2, i = e / 2, s = [new B(-n, -i), new B(n, -i), new B(-n, i), new B(n, i)].map((c) => c.transform(t)), a = Tn(s);
  return new B(a.width, a.height);
}, Ta = function() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ar;
  return xt(jr(arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ar), r);
}, Gn = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ar, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ar;
  return r.transform(Ta(e, t));
}, cw = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ar, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ar;
  return r.transform(Ta(e, t), !0);
}, Xd = (r, e, t) => {
  const n = Ta(e, t);
  return qs(r, xt(n, r.calcOwnMatrix())), n;
}, cp = (r, e) => {
  var t;
  const { transform: { target: n } } = e;
  (t = n.canvas) === null || t === void 0 || t.fire("object:".concat(r), D(D({}, e), {}, { target: n })), n.fire(r, e);
}, tD = { left: -0.5, top: -0.5, center: 0, bottom: 0.5, right: 0.5 }, kt = (r) => typeof r == "string" ? tD[r] : r - 0.5, ml = "not-allowed";
function lw(r) {
  return kt(r.originX) === kt(Pe) && kt(r.originY) === kt(Pe);
}
function v0(r) {
  return 0.5 - kt(r);
}
const cn = (r, e) => r[e], lp = (r, e, t, n) => ({ e: r, transform: e, pointer: new B(t, n) });
function uw(r, e) {
  const t = r.getTotalAngle() + xi(Math.atan2(e.y, e.x)) + 360;
  return Math.round(t % 360 / 45);
}
function ou(r, e, t, n, i) {
  var s;
  let { target: a, corner: c } = r;
  const u = a.controls[c], h = ((s = a.canvas) === null || s === void 0 ? void 0 : s.getZoom()) || 1, d = a.padding / h, p = function(g, v, b, x) {
    const _ = g.getRelativeCenterPoint(), C = b !== void 0 && x !== void 0 ? g.translateToGivenOrigin(_, Pe, Pe, b, x) : new B(g.left, g.top);
    return (g.angle ? v.rotate(-wt(g.angle), _) : v).subtract(C);
  }(a, new B(n, i), e, t);
  return p.x >= d && (p.x -= d), p.x <= -d && (p.x += d), p.y >= d && (p.y -= d), p.y <= d && (p.y += d), p.x -= u.offsetX, p.y -= u.offsetY, p;
}
const hw = (r, e, t, n) => {
  const { target: i, offsetX: s, offsetY: a } = e, c = t - s, u = n - a, h = !cn(i, "lockMovementX") && i.left !== c, d = !cn(i, "lockMovementY") && i.top !== u;
  return h && i.set(Ke, c), d && i.set(br, u), (h || d) && cp(Wb, lp(r, e, t, n)), h || d;
};
class dw {
  getSvgStyles(e) {
    const t = this.fillRule ? this.fillRule : "nonzero", n = this.strokeWidth ? this.strokeWidth : "0", i = this.strokeDashArray ? this.strokeDashArray.join(" ") : wr, s = this.strokeDashOffset ? this.strokeDashOffset : "0", a = this.strokeLineCap ? this.strokeLineCap : "butt", c = this.strokeLineJoin ? this.strokeLineJoin : "miter", u = this.strokeMiterLimit ? this.strokeMiterLimit : "4", h = this.opacity !== void 0 ? this.opacity : "1", d = this.visible ? "" : " visibility: hidden;", p = e ? "" : this.getSvgFilter(), g = oa(Nt, this.fill);
    return [oa(xr, this.stroke), "stroke-width: ", n, "; ", "stroke-dasharray: ", i, "; ", "stroke-linecap: ", a, "; ", "stroke-dashoffset: ", s, "; ", "stroke-linejoin: ", c, "; ", "stroke-miterlimit: ", u, "; ", g, "fill-rule: ", t, "; ", "opacity: ", h, ";", p, d].join("");
  }
  getSvgFilter() {
    return this.shadow ? "filter: url(#SVGID_".concat(this.shadow.id, ");") : "";
  }
  getSvgCommons() {
    return [this.id ? 'id="'.concat(this.id, '" ') : "", this.clipPath ? 'clip-path="url(#'.concat(this.clipPath.clipPathId, ')" ') : ""].join("");
  }
  getSvgTransform(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const n = e ? this.calcTransformMatrix() : this.calcOwnMatrix(), i = 'transform="'.concat(sa(n));
    return "".concat(i).concat(t, '" ');
  }
  _toSVG(e) {
    return [""];
  }
  toSVG(e) {
    return this._createBaseSVGMarkup(this._toSVG(e), { reviver: e });
  }
  toClipPathSVG(e) {
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(e), { reviver: e });
  }
  _createBaseClipPathSVGMarkup(e) {
    let { reviver: t, additionalTransform: n = "" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = [this.getSvgTransform(!0, n), this.getSvgCommons()].join(""), s = e.indexOf("COMMON_PARTS");
    return e[s] = i, t ? t(e.join("")) : e.join("");
  }
  _createBaseSVGMarkup(e) {
    let { noStyle: t, reviver: n, withShadow: i, additionalTransform: s } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const a = t ? "" : 'style="'.concat(this.getSvgStyles(), '" '), c = i ? 'style="'.concat(this.getSvgFilter(), '" ') : "", u = this.clipPath, h = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", d = u && u.absolutePositioned, p = this.stroke, g = this.fill, v = this.shadow, b = [], x = e.indexOf("COMMON_PARTS");
    let _;
    u && (u.clipPathId = "CLIPPATH_".concat(wi()), _ = '<clipPath id="'.concat(u.clipPathId, `" >
`).concat(u.toClipPathSVG(n), `</clipPath>
`)), d && b.push("<g ", c, this.getSvgCommons(), ` >
`), b.push("<g ", this.getSvgTransform(!1), d ? "" : c + this.getSvgCommons(), ` >
`);
    const C = [a, h, t ? "" : this.addPaintOrder(), " ", s ? 'transform="'.concat(s, '" ') : ""].join("");
    return e[x] = C, Gr(g) && b.push(g.toSVG(this)), Gr(p) && b.push(p.toSVG(this)), v && b.push(v.toSVG(this)), u && b.push(_), b.push(e.join("")), b.push(`</g>
`), d && b.push(`</g>
`), n ? n(b.join("")) : b.join("");
  }
  addPaintOrder() {
    return this.paintFirst !== Nt ? ' paint-order="'.concat(this.paintFirst, '" ') : "";
  }
}
function au(r) {
  return new RegExp("^(" + r.join("|") + ")\\b", "i");
}
var y0;
const rs = String.raw(y0 || (y0 = Oi(["(?:[-+]?(?:d*.d+|d+.?)(?:[eE][-+]?d+)?)"], ["(?:[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?)"]))), rD = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + rs + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + rs + "))?\\s+(.*)"), nD = { cx: Ke, x: Ke, r: "radius", cy: br, y: br, display: "visible", visibility: "visible", transform: "transformMatrix", "fill-opacity": "fillOpacity", "fill-rule": "fillRule", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "letter-spacing": "charSpacing", "paint-order": "paintFirst", "stroke-dasharray": "strokeDashArray", "stroke-dashoffset": "strokeDashOffset", "stroke-linecap": "strokeLineCap", "stroke-linejoin": "strokeLineJoin", "stroke-miterlimit": "strokeMiterLimit", "stroke-opacity": "strokeOpacity", "stroke-width": "strokeWidth", "text-decoration": "textDecoration", "text-anchor": "textAnchor", opacity: "opacity", "clip-path": "clipPath", "clip-rule": "clipRule", "vector-effect": "strokeUniform", "image-rendering": "imageSmoothing" }, Xh = "font-size", Gh = "clip-path";
au(["path", "circle", "polygon", "polyline", "ellipse", "rect", "line", "image", "text"]);
au(["symbol", "image", "marker", "pattern", "view", "svg"]);
const b0 = au(["symbol", "g", "a", "svg", "clipPath", "defs"]), iD = new B(1, 0), fw = new B(), up = (r, e) => r.rotate(e), vl = (r, e) => new B(e).subtract(r), yl = (r) => r.distanceFrom(fw), bl = (r, e) => Math.atan2(Hs(r, e), gw(r, e)), pw = (r) => bl(iD, r), cu = (r) => r.eq(fw) ? r : r.scalarDivide(yl(r)), hp = function(r) {
  let e = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
  return cu(new B(-r.y, r.x).scalarMultiply(e ? 1 : -1));
}, Hs = (r, e) => r.x * e.y - r.y * e.x, gw = (r, e) => r.x * e.x + r.y * e.y, Gd = (r, e, t) => {
  if (r.eq(e) || r.eq(t)) return !0;
  const n = Hs(e, t), i = Hs(e, r), s = Hs(t, r);
  return n >= 0 ? i >= 0 && s <= 0 : !(i <= 0 && s >= 0);
}, w0 = "(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?", x0 = new RegExp("(?:\\s|^)" + w0 + w0 + "(" + rs + "?(?:px)?)?(?:\\s?|$)(?:$|\\s)");
class qn {
  constructor(e) {
    const t = typeof e == "string" ? qn.parseShadow(e) : e;
    Object.assign(this, qn.ownDefaults, t), this.id = wi();
  }
  static parseShadow(e) {
    const t = e.trim(), [, n = 0, i = 0, s = 0] = (x0.exec(t) || []).map((a) => parseFloat(a) || 0);
    return { color: (t.replace(x0, "") || "rgb(0,0,0)").trim(), offsetX: n, offsetY: i, blur: s };
  }
  toString() {
    return [this.offsetX, this.offsetY, this.blur, this.color].join("px ");
  }
  toSVG(e) {
    const t = up(new B(this.offsetX, this.offsetY), wt(-e.angle)), n = new Qe(this.color);
    let i = 40, s = 40;
    return e.width && e.height && (i = 100 * ut((Math.abs(t.x) + this.blur) / e.width, Ue.NUM_FRACTION_DIGITS) + 20, s = 100 * ut((Math.abs(t.y) + this.blur) / e.height, Ue.NUM_FRACTION_DIGITS) + 20), e.flipX && (t.x *= -1), e.flipY && (t.y *= -1), '<filter id="SVGID_'.concat(this.id, '" y="-').concat(s, '%" height="').concat(100 + 2 * s, '%" x="-').concat(i, '%" width="').concat(100 + 2 * i, `%" >
	<feGaussianBlur in="SourceAlpha" stdDeviation="`).concat(ut(this.blur ? this.blur / 2 : 0, Ue.NUM_FRACTION_DIGITS), `"></feGaussianBlur>
	<feOffset dx="`).concat(ut(t.x, Ue.NUM_FRACTION_DIGITS), '" dy="').concat(ut(t.y, Ue.NUM_FRACTION_DIGITS), `" result="oBlur" ></feOffset>
	<feFlood flood-color="`).concat(n.toRgb(), '" flood-opacity="').concat(n.getAlpha(), `"/>
	<feComposite in2="oBlur" operator="in" />
	<feMerge>
		<feMergeNode></feMergeNode>
		<feMergeNode in="SourceGraphic"></feMergeNode>
	</feMerge>
</filter>
`);
  }
  toObject() {
    const e = { color: this.color, blur: this.blur, offsetX: this.offsetX, offsetY: this.offsetY, affectStroke: this.affectStroke, nonScaling: this.nonScaling, type: this.constructor.type }, t = qn.ownDefaults;
    return this.includeDefaultValues ? e : op(e, (n, i) => n !== t[i]);
  }
  static async fromObject(e) {
    return new this(e);
  }
}
j(qn, "ownDefaults", { color: "rgb(0,0,0)", blur: 0, offsetX: 0, offsetY: 0, affectStroke: !1, includeDefaultValues: !0, nonScaling: !1 }), j(qn, "type", "shadow"), ne.setClass(qn, "shadow");
const ns = (r, e, t) => Math.max(r, Math.min(e, t)), sD = [br, Ke, cr, Rr, "flipX", "flipY", "originX", "originY", "angle", "opacity", "globalCompositeOperation", "shadow", "visible", uo, ho], ei = [Nt, xr, "strokeWidth", "strokeDashArray", "width", "height", "paintFirst", "strokeUniform", "strokeLineCap", "strokeDashOffset", "strokeLineJoin", "strokeMiterLimit", "backgroundColor", "clipPath"], oD = { top: 0, left: 0, width: 0, height: 0, angle: 0, flipX: !1, flipY: !1, scaleX: 1, scaleY: 1, minScaleLimit: 0, skewX: 0, skewY: 0, originX: Ke, originY: br, strokeWidth: 1, strokeUniform: !1, padding: 0, opacity: 1, paintFirst: Nt, fill: "rgb(0,0,0)", fillRule: "nonzero", stroke: null, strokeDashArray: null, strokeDashOffset: 0, strokeLineCap: "butt", strokeLineJoin: "miter", strokeMiterLimit: 4, globalCompositeOperation: "source-over", backgroundColor: "", shadow: null, visible: !0, includeDefaultValues: !0, excludeFromExport: !1, objectCaching: !0, clipPath: void 0, inverted: !1, absolutePositioned: !1, centeredRotation: !0, centeredScaling: !1, dirty: !0 }, qh = (r, e, t, n) => (r < Math.abs(e) ? (r = e, n = t / 4) : n = e === 0 && r === 0 ? t / Qn * Math.asin(1) : t / Qn * Math.asin(e / r), { a: r, c: e, p: t, s: n }), _0 = (r, e, t, n, i) => r * Math.pow(2, 10 * (n -= 1)) * Math.sin((n * i - e) * Qn / t), mw = (r, e, t, n) => -t * Math.cos(r / n * bi) + t + e, qd = (r, e, t, n) => (r /= n) < 1 / 2.75 ? t * (7.5625 * r * r) + e : r < 2 / 2.75 ? t * (7.5625 * (r -= 1.5 / 2.75) * r + 0.75) + e : r < 2.5 / 2.75 ? t * (7.5625 * (r -= 2.25 / 2.75) * r + 0.9375) + e : t * (7.5625 * (r -= 2.625 / 2.75) * r + 0.984375) + e, S0 = (r, e, t, n) => t - qd(n - r, 0, t, n) + e;
var aD = Object.freeze({ __proto__: null, defaultEasing: mw, easeInBack: function(r, e, t, n) {
  let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1.70158;
  return t * (r /= n) * r * ((i + 1) * r - i) + e;
}, easeInBounce: S0, easeInCirc: (r, e, t, n) => -t * (Math.sqrt(1 - (r /= n) * r) - 1) + e, easeInCubic: (r, e, t, n) => t * (r / n) ** 3 + e, easeInElastic: (r, e, t, n) => {
  const i = t;
  let s = 0;
  if (r === 0) return e;
  if ((r /= n) === 1) return e + t;
  s || (s = 0.3 * n);
  const { a, s: c, p: u } = qh(i, t, s, 1.70158);
  return -_0(a, c, u, r, n) + e;
}, easeInExpo: (r, e, t, n) => r === 0 ? e : t * 2 ** (10 * (r / n - 1)) + e, easeInOutBack: function(r, e, t, n) {
  let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1.70158;
  return (r /= n / 2) < 1 ? t / 2 * (r * r * ((1 + (i *= 1.525)) * r - i)) + e : t / 2 * ((r -= 2) * r * ((1 + (i *= 1.525)) * r + i) + 2) + e;
}, easeInOutBounce: (r, e, t, n) => r < n / 2 ? 0.5 * S0(2 * r, 0, t, n) + e : 0.5 * qd(2 * r - n, 0, t, n) + 0.5 * t + e, easeInOutCirc: (r, e, t, n) => (r /= n / 2) < 1 ? -t / 2 * (Math.sqrt(1 - r ** 2) - 1) + e : t / 2 * (Math.sqrt(1 - (r -= 2) * r) + 1) + e, easeInOutCubic: (r, e, t, n) => (r /= n / 2) < 1 ? t / 2 * r ** 3 + e : t / 2 * ((r - 2) ** 3 + 2) + e, easeInOutElastic: (r, e, t, n) => {
  const i = t;
  let s = 0;
  if (r === 0) return e;
  if ((r /= n / 2) === 2) return e + t;
  s || (s = n * (0.3 * 1.5));
  const { a, s: c, p: u, c: h } = qh(i, t, s, 1.70158);
  return r < 1 ? -0.5 * _0(a, c, u, r, n) + e : a * Math.pow(2, -10 * (r -= 1)) * Math.sin((r * n - c) * Qn / u) * 0.5 + h + e;
}, easeInOutExpo: (r, e, t, n) => r === 0 ? e : r === n ? e + t : (r /= n / 2) < 1 ? t / 2 * 2 ** (10 * (r - 1)) + e : t / 2 * -(2 ** (-10 * --r) + 2) + e, easeInOutQuad: (r, e, t, n) => (r /= n / 2) < 1 ? t / 2 * r ** 2 + e : -t / 2 * (--r * (r - 2) - 1) + e, easeInOutQuart: (r, e, t, n) => (r /= n / 2) < 1 ? t / 2 * r ** 4 + e : -t / 2 * ((r -= 2) * r ** 3 - 2) + e, easeInOutQuint: (r, e, t, n) => (r /= n / 2) < 1 ? t / 2 * r ** 5 + e : t / 2 * ((r - 2) ** 5 + 2) + e, easeInOutSine: (r, e, t, n) => -t / 2 * (Math.cos(Math.PI * r / n) - 1) + e, easeInQuad: (r, e, t, n) => t * (r /= n) * r + e, easeInQuart: (r, e, t, n) => t * (r /= n) * r ** 3 + e, easeInQuint: (r, e, t, n) => t * (r / n) ** 5 + e, easeInSine: (r, e, t, n) => -t * Math.cos(r / n * bi) + t + e, easeOutBack: function(r, e, t, n) {
  let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1.70158;
  return t * ((r = r / n - 1) * r * ((i + 1) * r + i) + 1) + e;
}, easeOutBounce: qd, easeOutCirc: (r, e, t, n) => t * Math.sqrt(1 - (r = r / n - 1) * r) + e, easeOutCubic: (r, e, t, n) => t * ((r / n - 1) ** 3 + 1) + e, easeOutElastic: (r, e, t, n) => {
  const i = t;
  let s = 0;
  if (r === 0) return e;
  if ((r /= n) === 1) return e + t;
  s || (s = 0.3 * n);
  const { a, s: c, p: u, c: h } = qh(i, t, s, 1.70158);
  return a * 2 ** (-10 * r) * Math.sin((r * n - c) * Qn / u) + h + e;
}, easeOutExpo: (r, e, t, n) => r === n ? e + t : t * -(2 ** (-10 * r / n) + 1) + e, easeOutQuad: (r, e, t, n) => -t * (r /= n) * (r - 2) + e, easeOutQuart: (r, e, t, n) => -t * ((r = r / n - 1) * r ** 3 - 1) + e, easeOutQuint: (r, e, t, n) => t * ((r / n - 1) ** 5 + 1) + e, easeOutSine: (r, e, t, n) => t * Math.sin(r / n * bi) + e });
const cD = () => !1;
class dp {
  constructor(e) {
    let { startValue: t, byValue: n, duration: i = 500, delay: s = 0, easing: a = mw, onStart: c = Qi, onChange: u = Qi, onComplete: h = Qi, abort: d = cD, target: p } = e;
    j(this, "_state", "pending"), j(this, "durationProgress", 0), j(this, "valueProgress", 0), this.tick = this.tick.bind(this), this.duration = i, this.delay = s, this.easing = a, this._onStart = c, this._onChange = u, this._onComplete = h, this._abort = d, this.target = p, this.startValue = t, this.byValue = n, this.value = this.startValue, this.endValue = Object.freeze(this.calculate(this.duration).value);
  }
  get state() {
    return this._state;
  }
  isDone() {
    return this._state === "aborted" || this._state === "completed";
  }
  start() {
    const e = (t) => {
      this._state === "pending" && (this.startTime = t || +/* @__PURE__ */ new Date(), this._state = "running", this._onStart(), this.tick(this.startTime));
    };
    this.register(), this.delay > 0 ? setTimeout(() => Ko(e), this.delay) : Ko(e);
  }
  tick(e) {
    const t = (e || +/* @__PURE__ */ new Date()) - this.startTime, n = Math.min(t, this.duration);
    this.durationProgress = n / this.duration;
    const { value: i, valueProgress: s } = this.calculate(n);
    this.value = Object.freeze(i), this.valueProgress = s, this._state !== "aborted" && (this._abort(this.value, this.valueProgress, this.durationProgress) ? (this._state = "aborted", this.unregister()) : t >= this.duration ? (this.durationProgress = this.valueProgress = 1, this._onChange(this.endValue, this.valueProgress, this.durationProgress), this._state = "completed", this._onComplete(this.endValue, this.valueProgress, this.durationProgress), this.unregister()) : (this._onChange(this.value, this.valueProgress, this.durationProgress), Ko(this.tick)));
  }
  register() {
    pl.push(this);
  }
  unregister() {
    pl.remove(this);
  }
  abort() {
    this._state = "aborted", this.unregister();
  }
}
const lD = ["startValue", "endValue"];
class uD extends dp {
  constructor(e) {
    let { startValue: t = 0, endValue: n = 100 } = e;
    super(D(D({}, ht(e, lD)), {}, { startValue: t, byValue: n - t }));
  }
  calculate(e) {
    const t = this.easing(e, this.startValue, this.byValue, this.duration);
    return { value: t, valueProgress: Math.abs((t - this.startValue) / this.byValue) };
  }
}
const hD = ["startValue", "endValue"];
class dD extends dp {
  constructor(e) {
    let { startValue: t = [0], endValue: n = [100] } = e;
    super(D(D({}, ht(e, hD)), {}, { startValue: t, byValue: n.map((i, s) => i - t[s]) }));
  }
  calculate(e) {
    const t = this.startValue.map((n, i) => this.easing(e, n, this.byValue[i], this.duration, i));
    return { value: t, valueProgress: Math.abs((t[0] - this.startValue[0]) / this.byValue[0]) };
  }
}
const fD = ["startValue", "endValue", "easing", "onChange", "onComplete", "abort"], pD = (r, e, t, n) => e + t * (1 - Math.cos(r / n * bi)), Kh = (r) => r && ((e, t, n) => r(new Qe(e).toRgba(), t, n));
class gD extends dp {
  constructor(e) {
    let { startValue: t, endValue: n, easing: i = pD, onChange: s, onComplete: a, abort: c } = e, u = ht(e, fD);
    const h = new Qe(t).getSource(), d = new Qe(n).getSource();
    super(D(D({}, u), {}, { startValue: h, byValue: d.map((p, g) => p - h[g]), easing: i, onChange: Kh(s), onComplete: Kh(a), abort: Kh(c) }));
  }
  calculate(e) {
    const [t, n, i, s] = this.startValue.map((c, u) => this.easing(e, c, this.byValue[u], this.duration, u)), a = [...[t, n, i].map(Math.round), ns(0, s, 1)];
    return { value: a, valueProgress: a.map((c, u) => this.byValue[u] !== 0 ? Math.abs((c - this.startValue[u]) / this.byValue[u]) : 0).find((c) => c !== 0) || 0 };
  }
}
function fp(r) {
  const e = ((t) => Array.isArray(t.startValue) || Array.isArray(t.endValue))(r) ? new dD(r) : new uD(r);
  return e.start(), e;
}
function vw(r) {
  const e = new gD(r);
  return e.start(), e;
}
class pt {
  constructor(e) {
    this.status = e, this.points = [];
  }
  includes(e) {
    return this.points.some((t) => t.eq(e));
  }
  append() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    return this.points = this.points.concat(t.filter((i) => !this.includes(i))), this;
  }
  static isPointContained(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
    if (t.eq(n)) return e.eq(t);
    if (t.x === n.x) return e.x === t.x && (i || e.y >= Math.min(t.y, n.y) && e.y <= Math.max(t.y, n.y));
    if (t.y === n.y) return e.y === t.y && (i || e.x >= Math.min(t.x, n.x) && e.x <= Math.max(t.x, n.x));
    {
      const s = vl(t, n), a = vl(t, e).divide(s);
      return i ? Math.abs(a.x) === Math.abs(a.y) : a.x === a.y && a.x >= 0 && a.x <= 1;
    }
  }
  static isPointInPolygon(e, t) {
    const n = new B(e).setX(Math.min(e.x - 1, ...t.map((s) => s.x)));
    let i = 0;
    for (let s = 0; s < t.length; s++) {
      const a = this.intersectSegmentSegment(t[s], t[(s + 1) % t.length], e, n);
      if (a.includes(e)) return !0;
      i += +(a.status === "Intersection");
    }
    return i % 2 == 1;
  }
  static intersectLineLine(e, t, n, i) {
    let s = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], a = !(arguments.length > 5 && arguments[5] !== void 0) || arguments[5];
    const c = t.x - e.x, u = t.y - e.y, h = i.x - n.x, d = i.y - n.y, p = e.x - n.x, g = e.y - n.y, v = h * g - d * p, b = c * g - u * p, x = d * c - h * u;
    if (x !== 0) {
      const _ = v / x, C = b / x;
      return (s || 0 <= _ && _ <= 1) && (a || 0 <= C && C <= 1) ? new pt("Intersection").append(new B(e.x + _ * c, e.y + _ * u)) : new pt();
    }
    if (v === 0 || b === 0) {
      const _ = s || a || pt.isPointContained(e, n, i) || pt.isPointContained(t, n, i) || pt.isPointContained(n, e, t) || pt.isPointContained(i, e, t);
      return new pt(_ ? "Coincident" : void 0);
    }
    return new pt("Parallel");
  }
  static intersectSegmentLine(e, t, n, i) {
    return pt.intersectLineLine(e, t, n, i, !1, !0);
  }
  static intersectSegmentSegment(e, t, n, i) {
    return pt.intersectLineLine(e, t, n, i, !1, !1);
  }
  static intersectLinePolygon(e, t, n) {
    let i = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
    const s = new pt(), a = n.length;
    for (let c, u, h, d = 0; d < a; d++) {
      if (c = n[d], u = n[(d + 1) % a], h = pt.intersectLineLine(e, t, c, u, i, !1), h.status === "Coincident") return h;
      s.append(...h.points);
    }
    return s.points.length > 0 && (s.status = "Intersection"), s;
  }
  static intersectSegmentPolygon(e, t, n) {
    return pt.intersectLinePolygon(e, t, n, !1);
  }
  static intersectPolygonPolygon(e, t) {
    const n = new pt(), i = e.length, s = [];
    for (let a = 0; a < i; a++) {
      const c = e[a], u = e[(a + 1) % i], h = pt.intersectSegmentPolygon(c, u, t);
      h.status === "Coincident" ? (s.push(h), n.append(c, u)) : n.append(...h.points);
    }
    return s.length > 0 && s.length === e.length ? new pt("Coincident") : (n.points.length > 0 && (n.status = "Intersection"), n);
  }
  static intersectPolygonRectangle(e, t, n) {
    const i = t.min(n), s = t.max(n), a = new B(s.x, i.y), c = new B(i.x, s.y);
    return pt.intersectPolygonPolygon(e, [i, a, s, c]);
  }
}
class mD extends Xb {
  getX() {
    return this.getXY().x;
  }
  setX(e) {
    this.setXY(this.getXY().setX(e));
  }
  getY() {
    return this.getXY().y;
  }
  setY(e) {
    this.setXY(this.getXY().setY(e));
  }
  getRelativeX() {
    return this.left;
  }
  setRelativeX(e) {
    this.left = e;
  }
  getRelativeY() {
    return this.top;
  }
  setRelativeY(e) {
    this.top = e;
  }
  getXY() {
    const e = this.getRelativeXY();
    return this.group ? Kt(e, this.group.calcTransformMatrix()) : e;
  }
  setXY(e, t, n) {
    this.group && (e = Kt(e, jr(this.group.calcTransformMatrix()))), this.setRelativeXY(e, t, n);
  }
  getRelativeXY() {
    return new B(this.left, this.top);
  }
  setRelativeXY(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.originX, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.originY;
    this.setPositionByOrigin(e, t, n);
  }
  isStrokeAccountedForInDimensions() {
    return !1;
  }
  getCoords() {
    const { tl: e, tr: t, br: n, bl: i } = this.aCoords || (this.aCoords = this.calcACoords()), s = [e, t, n, i];
    if (this.group) {
      const a = this.group.calcTransformMatrix();
      return s.map((c) => Kt(c, a));
    }
    return s;
  }
  intersectsWithRect(e, t) {
    return pt.intersectPolygonRectangle(this.getCoords(), e, t).status === "Intersection";
  }
  intersectsWithObject(e) {
    const t = pt.intersectPolygonPolygon(this.getCoords(), e.getCoords());
    return t.status === "Intersection" || t.status === "Coincident" || e.isContainedWithinObject(this) || this.isContainedWithinObject(e);
  }
  isContainedWithinObject(e) {
    return this.getCoords().every((t) => e.containsPoint(t));
  }
  isContainedWithinRect(e, t) {
    const { left: n, top: i, width: s, height: a } = this.getBoundingRect();
    return n >= e.x && n + s <= t.x && i >= e.y && i + a <= t.y;
  }
  isOverlapping(e) {
    return this.intersectsWithObject(e) || this.isContainedWithinObject(e) || e.isContainedWithinObject(this);
  }
  containsPoint(e) {
    return pt.isPointInPolygon(e, this.getCoords());
  }
  isOnScreen() {
    if (!this.canvas) return !1;
    const { tl: e, br: t } = this.canvas.vptCoords;
    return !!this.getCoords().some((n) => n.x <= t.x && n.x >= e.x && n.y <= t.y && n.y >= e.y) || !!this.intersectsWithRect(e, t) || this.containsPoint(e.midPointFrom(t));
  }
  isPartiallyOnScreen() {
    if (!this.canvas) return !1;
    const { tl: e, br: t } = this.canvas.vptCoords;
    return this.intersectsWithRect(e, t) ? !0 : this.getCoords().every((n) => (n.x >= t.x || n.x <= e.x) && (n.y >= t.y || n.y <= e.y)) && this.containsPoint(e.midPointFrom(t));
  }
  getBoundingRect() {
    return Tn(this.getCoords());
  }
  getScaledWidth() {
    return this._getTransformedDimensions().x;
  }
  getScaledHeight() {
    return this._getTransformedDimensions().y;
  }
  scale(e) {
    this._set(cr, e), this._set(Rr, e), this.setCoords();
  }
  scaleToWidth(e) {
    const t = this.getBoundingRect().width / this.getScaledWidth();
    return this.scale(e / this.width / t);
  }
  scaleToHeight(e) {
    const t = this.getBoundingRect().height / this.getScaledHeight();
    return this.scale(e / this.height / t);
  }
  getCanvasRetinaScaling() {
    var e;
    return ((e = this.canvas) === null || e === void 0 ? void 0 : e.getRetinaScaling()) || 1;
  }
  getTotalAngle() {
    return this.group ? xi(Zb(this.calcTransformMatrix())) : this.angle;
  }
  getViewportTransform() {
    var e;
    return ((e = this.canvas) === null || e === void 0 ? void 0 : e.viewportTransform) || ar.concat();
  }
  calcACoords() {
    const e = po({ angle: this.angle }), { x: t, y: n } = this.getRelativeCenterPoint(), i = fo(t, n), s = xt(i, e), a = this._getTransformedDimensions(), c = a.x / 2, u = a.y / 2;
    return { tl: Kt({ x: -c, y: -u }, s), tr: Kt({ x: c, y: -u }, s), bl: Kt({ x: -c, y: u }, s), br: Kt({ x: c, y: u }, s) };
  }
  setCoords() {
    this.aCoords = this.calcACoords();
  }
  transformMatrixKey() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], t = [];
    return !e && this.group && (t = this.group.transformMatrixKey(e)), t.push(this.top, this.left, this.width, this.height, this.scaleX, this.scaleY, this.angle, this.strokeWidth, this.skewX, this.skewY, +this.flipX, +this.flipY, kt(this.originX), kt(this.originY)), t;
  }
  calcTransformMatrix() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], t = this.calcOwnMatrix();
    if (e || !this.group) return t;
    const n = this.transformMatrixKey(e), i = this.matrixCache;
    return i && i.key.every((s, a) => s === n[a]) ? i.value : (this.group && (t = xt(this.group.calcTransformMatrix(!1), t)), this.matrixCache = { key: n, value: t }, t);
  }
  calcOwnMatrix() {
    const e = this.transformMatrixKey(!0), t = this.ownMatrixCache;
    if (t && t.key === e) return t.value;
    const n = this.getRelativeCenterPoint(), i = { angle: this.angle, translateX: n.x, translateY: n.y, scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, flipX: this.flipX, flipY: this.flipY }, s = Qb(i);
    return this.ownMatrixCache = { key: e, value: s }, s;
  }
  _getNonTransformedDimensions() {
    return new B(this.width, this.height).scalarAdd(this.strokeWidth);
  }
  _calculateCurrentDimensions(e) {
    return this._getTransformedDimensions(e).transform(this.getViewportTransform(), !0).scalarAdd(2 * this.padding);
  }
  _getTransformedDimensions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = D({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, width: this.width, height: this.height, strokeWidth: this.strokeWidth }, e), n = t.strokeWidth;
    let i = n, s = 0;
    this.strokeUniform && (i = 0, s = n);
    const a = t.width + i, c = t.height + i;
    let u;
    return u = t.skewX === 0 && t.skewY === 0 ? new B(a * t.scaleX, c * t.scaleY) : su(a, c, _a(t)), u.scalarAdd(s);
  }
  translateToGivenOrigin(e, t, n, i, s) {
    let a = e.x, c = e.y;
    const u = kt(i) - kt(t), h = kt(s) - kt(n);
    if (u || h) {
      const d = this._getTransformedDimensions();
      a += u * d.x, c += h * d.y;
    }
    return new B(a, c);
  }
  translateToCenterPoint(e, t, n) {
    if (t === Pe && n === Pe) return e;
    const i = this.translateToGivenOrigin(e, t, n, Pe, Pe);
    return this.angle ? i.rotate(wt(this.angle), e) : i;
  }
  translateToOriginPoint(e, t, n) {
    const i = this.translateToGivenOrigin(e, Pe, Pe, t, n);
    return this.angle ? i.rotate(wt(this.angle), e) : i;
  }
  getCenterPoint() {
    const e = this.getRelativeCenterPoint();
    return this.group ? Kt(e, this.group.calcTransformMatrix()) : e;
  }
  getRelativeCenterPoint() {
    return this.translateToCenterPoint(new B(this.left, this.top), this.originX, this.originY);
  }
  getPointByOrigin(e, t) {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), e, t);
  }
  setPositionByOrigin(e, t, n) {
    const i = this.translateToCenterPoint(e, t, n), s = this.translateToOriginPoint(i, this.originX, this.originY);
    this.set({ left: s.x, top: s.y });
  }
  _getLeftTopCoords() {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), Ke, br);
  }
}
const vD = ["type"], yD = ["extraParam"];
let zn = class el extends mD {
  static getDefaults() {
    return el.ownDefaults;
  }
  get type() {
    const e = this.constructor.type;
    return e === "FabricObject" ? "object" : e.toLowerCase();
  }
  set type(e) {
    yi("warn", "Setting type has no effect", e);
  }
  constructor(e) {
    super(), j(this, "_cacheContext", null), Object.assign(this, el.ownDefaults), this.setOptions(e);
  }
  _createCacheCanvas() {
    this._cacheCanvas = Kr(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = !0;
  }
  _limitCacheSize(e) {
    const t = e.width, n = e.height, i = Ue.maxCacheSideLimit, s = Ue.minCacheSideLimit;
    if (t <= i && n <= i && t * n <= Ue.perfLimitSizeTotal) return t < s && (e.width = s), n < s && (e.height = s), e;
    const a = t / n, [c, u] = qo.limitDimsByArea(a), h = ns(s, c, i), d = ns(s, u, i);
    return t > h && (e.zoomX /= t / h, e.width = h, e.capped = !0), n > d && (e.zoomY /= n / d, e.height = d, e.capped = !0), e;
  }
  _getCacheCanvasDimensions() {
    const e = this.getTotalObjectScaling(), t = this._getTransformedDimensions({ skewX: 0, skewY: 0 }), n = t.x * e.x / this.scaleX, i = t.y * e.y / this.scaleY;
    return { width: Math.ceil(n + 2), height: Math.ceil(i + 2), zoomX: e.x, zoomY: e.y, x: n, y: i };
  }
  _updateCacheCanvas() {
    const e = this._cacheCanvas, t = this._cacheContext, { width: n, height: i, zoomX: s, zoomY: a, x: c, y: u } = this._limitCacheSize(this._getCacheCanvasDimensions()), h = n !== e.width || i !== e.height, d = this.zoomX !== s || this.zoomY !== a;
    if (!e || !t) return !1;
    if (h || d) {
      n !== e.width || i !== e.height ? (e.width = n, e.height = i) : (t.setTransform(1, 0, 0, 1, 0, 0), t.clearRect(0, 0, e.width, e.height));
      const p = c / 2, g = u / 2;
      return this.cacheTranslationX = Math.round(e.width / 2 - p) + p, this.cacheTranslationY = Math.round(e.height / 2 - g) + g, t.translate(this.cacheTranslationX, this.cacheTranslationY), t.scale(s, a), this.zoomX = s, this.zoomY = a, !0;
    }
    return !1;
  }
  setOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setOptions(e);
  }
  transform(e) {
    const t = this.group && !this.group._transformDone || this.group && this.canvas && e === this.canvas.contextTop, n = this.calcTransformMatrix(!t);
    e.transform(n[0], n[1], n[2], n[3], n[4], n[5]);
  }
  getObjectScaling() {
    if (!this.group) return new B(Math.abs(this.scaleX), Math.abs(this.scaleY));
    const e = Xs(this.calcTransformMatrix());
    return new B(Math.abs(e.scaleX), Math.abs(e.scaleY));
  }
  getTotalObjectScaling() {
    const e = this.getObjectScaling();
    if (this.canvas) {
      const t = this.canvas.getZoom(), n = this.getCanvasRetinaScaling();
      return e.scalarMultiply(t * n);
    }
    return e;
  }
  getObjectOpacity() {
    let e = this.opacity;
    return this.group && (e *= this.group.getObjectOpacity()), e;
  }
  _constrainScale(e) {
    return Math.abs(e) < this.minScaleLimit ? e < 0 ? -this.minScaleLimit : this.minScaleLimit : e === 0 ? 1e-4 : e;
  }
  _set(e, t) {
    e !== cr && e !== Rr || (t = this._constrainScale(t)), e === cr && t < 0 ? (this.flipX = !this.flipX, t *= -1) : e === "scaleY" && t < 0 ? (this.flipY = !this.flipY, t *= -1) : e !== "shadow" || !t || t instanceof qn || (t = new qn(t));
    const n = this[e] !== t;
    return this[e] = t, n && this.constructor.cacheProperties.includes(e) && (this.dirty = !0), this.parent && (this.dirty || n && this.constructor.stateProperties.includes(e)) && this.parent._set("dirty", !0), this;
  }
  isNotVisible() {
    return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;
  }
  render(e) {
    this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (e.save(), this._setupCompositeOperation(e), this.drawSelectionBackground(e), this.transform(e), this._setOpacity(e), this._setShadow(e), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(e)) : (this._removeCacheCanvas(), this.drawObject(e, !1, {}), this.dirty = !1), e.restore());
  }
  drawSelectionBackground(e) {
  }
  renderCache(e) {
    if (e = e || {}, this._cacheCanvas && this._cacheContext || this._createCacheCanvas(), this.isCacheDirty() && this._cacheContext) {
      const { zoomX: t, zoomY: n, cacheTranslationX: i, cacheTranslationY: s } = this, { width: a, height: c } = this._cacheCanvas;
      this.drawObject(this._cacheContext, e.forClipping, { zoomX: t, zoomY: n, cacheTranslationX: i, cacheTranslationY: s, width: a, height: c, parentClipPaths: [] }), this.dirty = !1;
    }
  }
  _removeCacheCanvas() {
    this._cacheCanvas = void 0, this._cacheContext = null;
  }
  hasStroke() {
    return this.stroke && this.stroke !== "transparent" && this.strokeWidth !== 0;
  }
  hasFill() {
    return this.fill && this.fill !== "transparent";
  }
  needsItsOwnCache() {
    return !!(this.paintFirst === xr && this.hasFill() && this.hasStroke() && this.shadow) || !!this.clipPath;
  }
  shouldCache() {
    return this.ownCaching = this.objectCaching && (!this.parent || !this.parent.isOnACache()) || this.needsItsOwnCache(), this.ownCaching;
  }
  willDrawShadow() {
    return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
  }
  drawClipPathOnCache(e, t, n) {
    e.save(), t.inverted ? e.globalCompositeOperation = "destination-out" : e.globalCompositeOperation = "destination-in", e.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(n, 0, 0), e.restore();
  }
  drawObject(e, t, n) {
    const i = this.fill, s = this.stroke;
    t ? (this.fill = "black", this.stroke = "", this._setClippingProperties(e)) : this._renderBackground(e), this._render(e), this._drawClipPath(e, this.clipPath, n), this.fill = i, this.stroke = s;
  }
  createClipPathLayer(e, t) {
    const n = dn(t), i = n.getContext("2d");
    if (i.translate(t.cacheTranslationX, t.cacheTranslationY), i.scale(t.zoomX, t.zoomY), e._cacheCanvas = n, t.parentClipPaths.forEach((s) => {
      s.transform(i);
    }), t.parentClipPaths.push(e), e.absolutePositioned) {
      const s = jr(this.calcTransformMatrix());
      i.transform(s[0], s[1], s[2], s[3], s[4], s[5]);
    }
    return e.transform(i), e.drawObject(i, !0, t), n;
  }
  _drawClipPath(e, t, n) {
    if (!t) return;
    t._transformDone = !0;
    const i = this.createClipPathLayer(t, n);
    this.drawClipPathOnCache(e, t, i);
  }
  drawCacheOnCanvas(e) {
    e.scale(1 / this.zoomX, 1 / this.zoomY), e.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
  }
  isCacheDirty() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
    if (this.isNotVisible()) return !1;
    const t = this._cacheCanvas, n = this._cacheContext;
    return !(!t || !n || e || !this._updateCacheCanvas()) || !!(this.dirty || this.clipPath && this.clipPath.absolutePositioned) && (t && n && !e && (n.save(), n.setTransform(1, 0, 0, 1, 0, 0), n.clearRect(0, 0, t.width, t.height), n.restore()), !0);
  }
  _renderBackground(e) {
    if (!this.backgroundColor) return;
    const t = this._getNonTransformedDimensions();
    e.fillStyle = this.backgroundColor, e.fillRect(-t.x / 2, -t.y / 2, t.x, t.y), this._removeShadow(e);
  }
  _setOpacity(e) {
    this.group && !this.group._transformDone ? e.globalAlpha = this.getObjectOpacity() : e.globalAlpha *= this.opacity;
  }
  _setStrokeStyles(e, t) {
    const n = t.stroke;
    n && (e.lineWidth = t.strokeWidth, e.lineCap = t.strokeLineCap, e.lineDashOffset = t.strokeDashOffset, e.lineJoin = t.strokeLineJoin, e.miterLimit = t.strokeMiterLimit, Gr(n) ? n.gradientUnits === "percentage" || n.gradientTransform || n.patternTransform ? this._applyPatternForTransformedGradient(e, n) : (e.strokeStyle = n.toLive(e), this._applyPatternGradientTransform(e, n)) : e.strokeStyle = t.stroke);
  }
  _setFillStyles(e, t) {
    let { fill: n } = t;
    n && (Gr(n) ? (e.fillStyle = n.toLive(e), this._applyPatternGradientTransform(e, n)) : e.fillStyle = n);
  }
  _setClippingProperties(e) {
    e.globalAlpha = 1, e.strokeStyle = "transparent", e.fillStyle = "#000000";
  }
  _setLineDash(e, t) {
    t && t.length !== 0 && e.setLineDash(t);
  }
  _setShadow(e) {
    if (!this.shadow) return;
    const t = this.shadow, n = this.canvas, i = this.getCanvasRetinaScaling(), [s, , , a] = n?.viewportTransform || ar, c = s * i, u = a * i, h = t.nonScaling ? new B(1, 1) : this.getObjectScaling();
    e.shadowColor = t.color, e.shadowBlur = t.blur * Ue.browserShadowBlurConstant * (c + u) * (h.x + h.y) / 4, e.shadowOffsetX = t.offsetX * c * h.x, e.shadowOffsetY = t.offsetY * u * h.y;
  }
  _removeShadow(e) {
    this.shadow && (e.shadowColor = "", e.shadowBlur = e.shadowOffsetX = e.shadowOffsetY = 0);
  }
  _applyPatternGradientTransform(e, t) {
    if (!Gr(t)) return { offsetX: 0, offsetY: 0 };
    const n = t.gradientTransform || t.patternTransform, i = -this.width / 2 + t.offsetX || 0, s = -this.height / 2 + t.offsetY || 0;
    return t.gradientUnits === "percentage" ? e.transform(this.width, 0, 0, this.height, i, s) : e.transform(1, 0, 0, 1, i, s), n && e.transform(n[0], n[1], n[2], n[3], n[4], n[5]), { offsetX: i, offsetY: s };
  }
  _renderPaintInOrder(e) {
    this.paintFirst === xr ? (this._renderStroke(e), this._renderFill(e)) : (this._renderFill(e), this._renderStroke(e));
  }
  _render(e) {
  }
  _renderFill(e) {
    this.fill && (e.save(), this._setFillStyles(e, this), this.fillRule === "evenodd" ? e.fill("evenodd") : e.fill(), e.restore());
  }
  _renderStroke(e) {
    if (this.stroke && this.strokeWidth !== 0) {
      if (this.shadow && !this.shadow.affectStroke && this._removeShadow(e), e.save(), this.strokeUniform) {
        const t = this.getObjectScaling();
        e.scale(1 / t.x, 1 / t.y);
      }
      this._setLineDash(e, this.strokeDashArray), this._setStrokeStyles(e, this), e.stroke(), e.restore();
    }
  }
  _applyPatternForTransformedGradient(e, t) {
    var n;
    const i = this._limitCacheSize(this._getCacheCanvasDimensions()), s = this.getCanvasRetinaScaling(), a = i.x / this.scaleX / s, c = i.y / this.scaleY / s, u = dn({ width: Math.ceil(a), height: Math.ceil(c) }), h = u.getContext("2d");
    h && (h.beginPath(), h.moveTo(0, 0), h.lineTo(a, 0), h.lineTo(a, c), h.lineTo(0, c), h.closePath(), h.translate(a / 2, c / 2), h.scale(i.zoomX / this.scaleX / s, i.zoomY / this.scaleY / s), this._applyPatternGradientTransform(h, t), h.fillStyle = t.toLive(e), h.fill(), e.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), e.scale(s * this.scaleX / i.zoomX, s * this.scaleY / i.zoomY), e.strokeStyle = (n = h.createPattern(u, "no-repeat")) !== null && n !== void 0 ? n : "");
  }
  _findCenterFromElement() {
    return new B(this.left + this.width / 2, this.top + this.height / 2);
  }
  clone(e) {
    const t = this.toObject(e);
    return this.constructor.fromObject(t);
  }
  cloneAsImage(e) {
    const t = this.toCanvasElement(e);
    return new (ne.getClass("image"))(t);
  }
  toCanvasElement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = ap(this), n = this.group, i = this.shadow, s = Math.abs, a = e.enableRetinaScaling ? zb() : 1, c = (e.multiplier || 1) * a, u = e.canvasProvider || ((E) => new Ca(E, { enableRetinaScaling: !1, renderOnAddRemove: !1, skipOffscreen: !1 }));
    delete this.group, e.withoutTransform && aw(this), e.withoutShadow && (this.shadow = null), e.viewportTransform && Xd(this, this.getViewportTransform()), this.setCoords();
    const h = Kr(), d = this.getBoundingRect(), p = this.shadow, g = new B();
    if (p) {
      const E = p.blur, k = p.nonScaling ? new B(1, 1) : this.getObjectScaling();
      g.x = 2 * Math.round(s(p.offsetX) + E) * s(k.x), g.y = 2 * Math.round(s(p.offsetY) + E) * s(k.y);
    }
    const v = d.width + g.x, b = d.height + g.y;
    h.width = Math.ceil(v), h.height = Math.ceil(b);
    const x = u(h);
    e.format === "jpeg" && (x.backgroundColor = "#fff"), this.setPositionByOrigin(new B(x.width / 2, x.height / 2), Pe, Pe);
    const _ = this.canvas;
    x._objects = [this], this.set("canvas", x), this.setCoords();
    const C = x.toCanvasElement(c || 1, e);
    return this.set("canvas", _), this.shadow = i, n && (this.group = n), this.set(t), this.setCoords(), x._objects = [], x.destroy(), C;
  }
  toDataURL() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return np(this.toCanvasElement(e), e.format || "png", e.quality || 1);
  }
  isType() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    return t.includes(this.constructor.type) || t.includes(this.type);
  }
  complexity() {
    return 1;
  }
  toJSON() {
    return this.toObject();
  }
  rotate(e) {
    const { centeredRotation: t, originX: n, originY: i } = this;
    if (t) {
      const { x: s, y: a } = this.getRelativeCenterPoint();
      this.originX = Pe, this.originY = Pe, this.left = s, this.top = a;
    }
    if (this.set("angle", e), t) {
      const { x: s, y: a } = this.translateToOriginPoint(this.getRelativeCenterPoint(), n, i);
      this.left = s, this.top = a, this.originX = n, this.originY = i;
    }
  }
  setOnGroup() {
  }
  _setupCompositeOperation(e) {
    this.globalCompositeOperation && (e.globalCompositeOperation = this.globalCompositeOperation);
  }
  dispose() {
    pl.cancelByTarget(this), this.off(), this._set("canvas", void 0), this._cacheCanvas && kn().dispose(this._cacheCanvas), this._cacheCanvas = void 0, this._cacheContext = null;
  }
  animate(e, t) {
    return Object.entries(e).reduce((n, i) => {
      let [s, a] = i;
      return n[s] = this._animate(s, a, t), n;
    }, {});
  }
  _animate(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = e.split("."), s = this.constructor.colorProperties.includes(i[i.length - 1]), { abort: a, startValue: c, onChange: u, onComplete: h } = n, d = D(D({}, n), {}, { target: this, startValue: c ?? i.reduce((p, g) => p[g], this), endValue: t, abort: a?.bind(this), onChange: (p, g, v) => {
      i.reduce((b, x, _) => (_ === i.length - 1 && (b[x] = p), b[x]), this), u && u(p, g, v);
    }, onComplete: (p, g, v) => {
      this.setCoords(), h && h(p, g, v);
    } });
    return s ? vw(d) : fp(d);
  }
  isDescendantOf(e) {
    const { parent: t, group: n } = this;
    return t === e || n === e || !!t && t.isDescendantOf(e) || !!n && n !== t && n.isDescendantOf(e);
  }
  getAncestors() {
    const e = [];
    let t = this;
    do
      t = t.parent, t && e.push(t);
    while (t);
    return e;
  }
  findCommonAncestors(e) {
    if (this === e) return { fork: [], otherFork: [], common: [this, ...this.getAncestors()] };
    const t = this.getAncestors(), n = e.getAncestors();
    if (t.length === 0 && n.length > 0 && this === n[n.length - 1]) return { fork: [], otherFork: [e, ...n.slice(0, n.length - 1)], common: [this] };
    for (let i, s = 0; s < t.length; s++) {
      if (i = t[s], i === e) return { fork: [this, ...t.slice(0, s)], otherFork: [], common: t.slice(s) };
      for (let a = 0; a < n.length; a++) {
        if (this === n[a]) return { fork: [], otherFork: [e, ...n.slice(0, a)], common: [this, ...t] };
        if (i === n[a]) return { fork: [this, ...t.slice(0, s)], otherFork: [e, ...n.slice(0, a)], common: t.slice(s) };
      }
    }
    return { fork: [this, ...t], otherFork: [e, ...n], common: [] };
  }
  hasCommonAncestors(e) {
    const t = this.findCommonAncestors(e);
    return t && !!t.common.length;
  }
  isInFrontOf(e) {
    if (this === e) return;
    const t = this.findCommonAncestors(e);
    if (t.fork.includes(e)) return !0;
    if (t.otherFork.includes(this)) return !1;
    const n = t.common[0] || this.canvas;
    if (!n) return;
    const i = t.fork.pop(), s = t.otherFork.pop(), a = n._objects.indexOf(i), c = n._objects.indexOf(s);
    return a > -1 && a > c;
  }
  toObject() {
    const e = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).concat(el.customProperties, this.constructor.customProperties || []);
    let t;
    const n = Ue.NUM_FRACTION_DIGITS, { clipPath: i, fill: s, stroke: a, shadow: c, strokeDashArray: u, left: h, top: d, originX: p, originY: g, width: v, height: b, strokeWidth: x, strokeLineCap: _, strokeDashOffset: C, strokeLineJoin: E, strokeUniform: k, strokeMiterLimit: O, scaleX: P, scaleY: R, angle: V, flipX: F, flipY: $, opacity: z, visible: G, backgroundColor: H, fillRule: Y, paintFirst: te, globalCompositeOperation: ge, skewX: Z, skewY: de } = this;
    i && !i.excludeFromExport && (t = i.toObject(e.concat("inverted", "absolutePositioned")));
    const oe = (pe) => ut(pe, n), ie = D(D({}, ps(this, e)), {}, { type: this.constructor.type, version: Hd, originX: p, originY: g, left: oe(h), top: oe(d), width: oe(v), height: oe(b), fill: p0(s) ? s.toObject() : s, stroke: p0(a) ? a.toObject() : a, strokeWidth: oe(x), strokeDashArray: u && u.concat(), strokeLineCap: _, strokeDashOffset: C, strokeLineJoin: E, strokeUniform: k, strokeMiterLimit: oe(O), scaleX: oe(P), scaleY: oe(R), angle: oe(V), flipX: F, flipY: $, opacity: oe(z), shadow: c && c.toObject(), visible: G, backgroundColor: H, fillRule: Y, paintFirst: te, globalCompositeOperation: ge, skewX: oe(Z), skewY: oe(de) }, t ? { clipPath: t } : null);
    return this.includeDefaultValues ? ie : this._removeDefaultValues(ie);
  }
  toDatalessObject(e) {
    return this.toObject(e);
  }
  _removeDefaultValues(e) {
    const t = this.constructor.getDefaults(), n = Object.keys(t).length > 0 ? t : Object.getPrototypeOf(this);
    return op(e, (i, s) => {
      if (s === Ke || s === br || s === "type") return !0;
      const a = n[s];
      return i !== a && !(Array.isArray(i) && Array.isArray(a) && i.length === 0 && a.length === 0);
    });
  }
  toString() {
    return "#<".concat(this.constructor.type, ">");
  }
  static _fromObject(e) {
    let t = ht(e, vD), n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { extraParam: i } = n, s = ht(n, yD);
    return Sa(t, s).then((a) => i ? (delete a[i], new this(t[i], a)) : new this(a));
  }
  static fromObject(e, t) {
    return this._fromObject(e, t);
  }
};
j(zn, "stateProperties", sD), j(zn, "cacheProperties", ei), j(zn, "ownDefaults", oD), j(zn, "type", "FabricObject"), j(zn, "colorProperties", [Nt, xr, "backgroundColor"]), j(zn, "customProperties", []), ne.setClass(zn), ne.setClass(zn, "object");
const Ii = (r, e, t) => (n, i, s, a) => {
  const c = e(n, i, s, a);
  return c && cp(r, D(D({}, lp(n, i, s, a)), t)), c;
};
function gs(r) {
  return (e, t, n, i) => {
    const { target: s, originX: a, originY: c } = t, u = s.getRelativeCenterPoint(), h = s.translateToOriginPoint(u, a, c), d = r(e, t, n, i);
    return s.setPositionByOrigin(h, t.originX, t.originY), d;
  };
}
const Kd = Ii(ia, gs((r, e, t, n) => {
  const i = ou(e, e.originX, e.originY, t, n);
  if (kt(e.originX) === kt(Pe) || kt(e.originX) === kt(Tt) && i.x < 0 || kt(e.originX) === kt(Ke) && i.x > 0) {
    const { target: s } = e, a = s.strokeWidth / (s.strokeUniform ? s.scaleX : 1), c = lw(e) ? 2 : 1, u = s.width, h = Math.abs(i.x * c / s.scaleX) - a;
    return s.set("width", Math.max(h, 1)), u !== s.width;
  }
  return !1;
}));
function yw(r, e, t, n, i) {
  n = n || {};
  const s = this.sizeX || n.cornerSize || i.cornerSize, a = this.sizeY || n.cornerSize || i.cornerSize, c = n.transparentCorners !== void 0 ? n.transparentCorners : i.transparentCorners, u = c ? xr : Nt, h = !c && (n.cornerStrokeColor || i.cornerStrokeColor);
  let d, p = e, g = t;
  r.save(), r.fillStyle = n.cornerColor || i.cornerColor || "", r.strokeStyle = n.cornerStrokeColor || i.cornerStrokeColor || "", s > a ? (d = s, r.scale(1, a / s), g = t * s / a) : a > s ? (d = a, r.scale(s / a, 1), p = e * a / s) : d = s, r.beginPath(), r.arc(p, g, d / 2, 0, Qn, !1), r[u](), h && r.stroke(), r.restore();
}
function bw(r, e, t, n, i) {
  n = n || {};
  const s = this.sizeX || n.cornerSize || i.cornerSize, a = this.sizeY || n.cornerSize || i.cornerSize, c = n.transparentCorners !== void 0 ? n.transparentCorners : i.transparentCorners, u = c ? xr : Nt, h = !c && (n.cornerStrokeColor || i.cornerStrokeColor), d = s / 2, p = a / 2;
  r.save(), r.fillStyle = n.cornerColor || i.cornerColor || "", r.strokeStyle = n.cornerStrokeColor || i.cornerStrokeColor || "", r.translate(e, t);
  const g = i.getTotalAngle();
  r.rotate(wt(g)), r["".concat(u, "Rect")](-d, -p, s, a), h && r.strokeRect(-d, -p, s, a), r.restore();
}
class gt {
  constructor(e) {
    j(this, "visible", !0), j(this, "actionName", ru), j(this, "angle", 0), j(this, "x", 0), j(this, "y", 0), j(this, "offsetX", 0), j(this, "offsetY", 0), j(this, "sizeX", 0), j(this, "sizeY", 0), j(this, "touchSizeX", 0), j(this, "touchSizeY", 0), j(this, "cursorStyle", "crosshair"), j(this, "withConnection", !1), Object.assign(this, e);
  }
  shouldActivate(e, t, n, i) {
    var s;
    let { tl: a, tr: c, br: u, bl: h } = i;
    return ((s = t.canvas) === null || s === void 0 ? void 0 : s.getActiveObject()) === t && t.isControlVisible(e) && pt.isPointInPolygon(n, [a, c, u, h]);
  }
  getActionHandler(e, t, n) {
    return this.actionHandler;
  }
  getMouseDownHandler(e, t, n) {
    return this.mouseDownHandler;
  }
  getMouseUpHandler(e, t, n) {
    return this.mouseUpHandler;
  }
  cursorStyleHandler(e, t, n) {
    return t.cursorStyle;
  }
  getActionName(e, t, n) {
    return t.actionName;
  }
  getVisibility(e, t) {
    var n, i;
    return (n = (i = e._controlsVisibility) === null || i === void 0 ? void 0 : i[t]) !== null && n !== void 0 ? n : this.visible;
  }
  setVisibility(e, t, n) {
    this.visible = e;
  }
  positionHandler(e, t, n, i) {
    return new B(this.x * e.x + this.offsetX, this.y * e.y + this.offsetY).transform(t);
  }
  calcCornerCoords(e, t, n, i, s, a) {
    const c = nu([fo(n, i), po({ angle: e }), iu((s ? this.touchSizeX : this.sizeX) || t, (s ? this.touchSizeY : this.sizeY) || t)]);
    return { tl: new B(-0.5, -0.5).transform(c), tr: new B(0.5, -0.5).transform(c), br: new B(0.5, 0.5).transform(c), bl: new B(-0.5, 0.5).transform(c) };
  }
  render(e, t, n, i, s) {
    ((i = i || {}).cornerStyle || s.cornerStyle) === "circle" ? yw.call(this, e, t, n, i, s) : bw.call(this, e, t, n, i, s);
  }
}
const ww = (r, e, t) => t.lockRotation ? ml : e.cursorStyle, xw = Ii(Hb, gs((r, e, t, n) => {
  let { target: i, ex: s, ey: a, theta: c, originX: u, originY: h } = e;
  const d = i.translateToOriginPoint(i.getRelativeCenterPoint(), u, h);
  if (cn(i, "lockRotation")) return !1;
  const p = Math.atan2(a - d.y, s - d.x), g = Math.atan2(n - d.y, t - d.x);
  let v = xi(g - p + c);
  if (i.snapAngle && i.snapAngle > 0) {
    const x = i.snapAngle, _ = i.snapThreshold || x, C = Math.ceil(v / x) * x, E = Math.floor(v / x) * x;
    Math.abs(v - E) < _ ? v = E : Math.abs(v - C) < _ && (v = C);
  }
  v < 0 && (v = 360 + v), v %= 360;
  const b = i.angle !== v;
  return i.angle = v, b;
}));
function _w(r, e) {
  const t = e.canvas, n = r[t.uniScaleKey];
  return t.uniformScaling && !n || !t.uniformScaling && n;
}
function Sw(r, e, t) {
  const n = cn(r, "lockScalingX"), i = cn(r, "lockScalingY");
  if (n && i || !e && (n || i) && t || n && e === "x" || i && e === "y") return !0;
  const { width: s, height: a, strokeWidth: c } = r;
  return s === 0 && c === 0 && e !== "y" || a === 0 && c === 0 && e !== "x";
}
const bD = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"], Bs = (r, e, t) => {
  const n = _w(r, t);
  if (Sw(t, e.x !== 0 && e.y === 0 ? "x" : e.x === 0 && e.y !== 0 ? "y" : "", n)) return ml;
  const i = uw(t, e);
  return "".concat(bD[i], "-resize");
};
function pp(r, e, t, n) {
  let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const s = e.target, a = i.by, c = _w(r, s);
  let u, h, d, p, g, v;
  if (Sw(s, a, c)) return !1;
  if (e.gestureScale) h = e.scaleX * e.gestureScale, d = e.scaleY * e.gestureScale;
  else {
    if (u = ou(e, e.originX, e.originY, t, n), g = a !== "y" ? Math.sign(u.x || e.signX || 1) : 1, v = a !== "x" ? Math.sign(u.y || e.signY || 1) : 1, e.signX || (e.signX = g), e.signY || (e.signY = v), cn(s, "lockScalingFlip") && (e.signX !== g || e.signY !== v)) return !1;
    if (p = s._getTransformedDimensions(), c && !a) {
      const _ = Math.abs(u.x) + Math.abs(u.y), { original: C } = e, E = _ / (Math.abs(p.x * C.scaleX / s.scaleX) + Math.abs(p.y * C.scaleY / s.scaleY));
      h = C.scaleX * E, d = C.scaleY * E;
    } else h = Math.abs(u.x * s.scaleX / p.x), d = Math.abs(u.y * s.scaleY / p.y);
    lw(e) && (h *= 2, d *= 2), e.signX !== g && a !== "y" && (e.originX = v0(e.originX), h *= -1, e.signX = g), e.signY !== v && a !== "x" && (e.originY = v0(e.originY), d *= -1, e.signY = v);
  }
  const b = s.scaleX, x = s.scaleY;
  return a ? (a === "x" && s.set(cr, h), a === "y" && s.set(Rr, d)) : (!cn(s, "lockScalingX") && s.set(cr, h), !cn(s, "lockScalingY") && s.set(Rr, d)), b !== s.scaleX || x !== s.scaleY;
}
const Uo = Ii(tu, gs((r, e, t, n) => pp(r, e, t, n))), Cw = Ii(tu, gs((r, e, t, n) => pp(r, e, t, n, { by: "x" }))), Tw = Ii(tu, gs((r, e, t, n) => pp(r, e, t, n, { by: "y" }))), wD = ["target", "ex", "ey", "skewingSide"], Zh = { x: { counterAxis: "y", scale: cr, skew: uo, lockSkewing: "lockSkewingX", origin: "originX", flip: "flipX" }, y: { counterAxis: "x", scale: Rr, skew: ho, lockSkewing: "lockSkewingY", origin: "originY", flip: "flipY" } }, xD = ["ns", "nesw", "ew", "nwse"], Ew = (r, e, t) => {
  if (e.x !== 0 && cn(t, "lockSkewingY") || e.y !== 0 && cn(t, "lockSkewingX")) return ml;
  const n = uw(t, e) % 4;
  return "".concat(xD[n], "-resize");
};
function kw(r, e, t, n, i) {
  const { target: s } = t, { counterAxis: a, origin: c, lockSkewing: u, skew: h, flip: d } = Zh[r];
  if (cn(s, u)) return !1;
  const { origin: p, flip: g } = Zh[a], v = kt(t[p]) * (s[g] ? -1 : 1), b = -Math.sign(v) * (s[d] ? -1 : 1), x = 0.5 * -((s[h] === 0 && ou(t, Pe, Pe, n, i)[r] > 0 || s[h] > 0 ? 1 : -1) * b) + 0.5;
  return Ii(Ub, gs((C, E, k, O) => function(P, R, V) {
    let { target: F, ex: $, ey: z, skewingSide: G } = R, H = ht(R, wD);
    const { skew: Y } = Zh[P], te = V.subtract(new B($, z)).divide(new B(F.scaleX, F.scaleY))[P], ge = F[Y], Z = H[Y], de = Math.tan(wt(Z)), oe = P === "y" ? F._getTransformedDimensions({ scaleX: 1, scaleY: 1, skewX: 0 }).x : F._getTransformedDimensions({ scaleX: 1, scaleY: 1 }).y, ie = 2 * te * G / Math.max(oe, 1) + de, pe = xi(Math.atan(ie));
    F.set(Y, pe);
    const re = ge !== F[Y];
    if (re && P === "y") {
      const { skewX: Ve, scaleX: Ze } = F, We = F._getTransformedDimensions({ skewY: ge }), Ee = F._getTransformedDimensions(), Ie = Ve !== 0 ? We.x / Ee.x : 1;
      Ie !== 1 && F.set(cr, Ie * Ze);
    }
    return re;
  }(r, E, new B(k, O))))(e, D(D({}, t), {}, { [c]: x, skewingSide: b }), n, i);
}
const Ow = (r, e, t, n) => kw("x", r, e, t, n), Iw = (r, e, t, n) => kw("y", r, e, t, n);
function lu(r, e) {
  return r[e.canvas.altActionKey];
}
const $o = (r, e, t) => {
  const n = lu(r, t);
  return e.x === 0 ? n ? uo : Rr : e.y === 0 ? n ? ho : cr : "";
}, Ki = (r, e, t) => lu(r, t) ? Ew(0, e, t) : Bs(r, e, t), Zd = (r, e, t, n) => lu(r, e.target) ? Iw(r, e, t, n) : Cw(r, e, t, n), Jd = (r, e, t, n) => lu(r, e.target) ? Ow(r, e, t, n) : Tw(r, e, t, n), gp = () => ({ ml: new gt({ x: -0.5, y: 0, cursorStyleHandler: Ki, actionHandler: Zd, getActionName: $o }), mr: new gt({ x: 0.5, y: 0, cursorStyleHandler: Ki, actionHandler: Zd, getActionName: $o }), mb: new gt({ x: 0, y: 0.5, cursorStyleHandler: Ki, actionHandler: Jd, getActionName: $o }), mt: new gt({ x: 0, y: -0.5, cursorStyleHandler: Ki, actionHandler: Jd, getActionName: $o }), tl: new gt({ x: -0.5, y: -0.5, cursorStyleHandler: Bs, actionHandler: Uo }), tr: new gt({ x: 0.5, y: -0.5, cursorStyleHandler: Bs, actionHandler: Uo }), bl: new gt({ x: -0.5, y: 0.5, cursorStyleHandler: Bs, actionHandler: Uo }), br: new gt({ x: 0.5, y: 0.5, cursorStyleHandler: Bs, actionHandler: Uo }), mtr: new gt({ x: 0, y: -0.5, actionHandler: xw, cursorStyleHandler: ww, offsetY: -40, withConnection: !0, actionName: tp }) }), Aw = () => ({ mr: new gt({ x: 0.5, y: 0, actionHandler: Kd, cursorStyleHandler: Ki, actionName: ia }), ml: new gt({ x: -0.5, y: 0, actionHandler: Kd, cursorStyleHandler: Ki, actionName: ia }) }), Mw = () => D(D({}, gp()), Aw());
class aa extends zn {
  static getDefaults() {
    return D(D({}, super.getDefaults()), aa.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, this.constructor.createControls(), aa.ownDefaults), this.setOptions(e);
  }
  static createControls() {
    return { controls: gp() };
  }
  _updateCacheCanvas() {
    const e = this.canvas;
    if (this.noScaleCache && e && e._currentTransform) {
      const t = e._currentTransform, n = t.target, i = t.action;
      if (this === n && i && i.startsWith(ru)) return !1;
    }
    return super._updateCacheCanvas();
  }
  getActiveControl() {
    const e = this.__corner;
    return e ? { key: e, control: this.controls[e], coord: this.oCoords[e] } : void 0;
  }
  findControl(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    if (!this.hasControls || !this.canvas) return;
    this.__corner = void 0;
    const n = Object.entries(this.oCoords);
    for (let i = n.length - 1; i >= 0; i--) {
      const [s, a] = n[i], c = this.controls[s];
      if (c.shouldActivate(s, this, e, t ? a.touchCorner : a.corner)) return this.__corner = s, { key: s, control: c, coord: this.oCoords[s] };
    }
  }
  calcOCoords() {
    const e = this.getViewportTransform(), t = this.getCenterPoint(), n = fo(t.x, t.y), i = po({ angle: this.getTotalAngle() - (this.group && this.flipX ? 180 : 0) }), s = xt(n, i), a = xt(e, s), c = xt(a, [1 / e[0], 0, 0, 1 / e[3], 0, 0]), u = this.group ? Xs(this.calcTransformMatrix()) : void 0;
    u && (u.scaleX = Math.abs(u.scaleX), u.scaleY = Math.abs(u.scaleY));
    const h = this._calculateCurrentDimensions(u), d = {};
    return this.forEachControl((p, g) => {
      const v = p.positionHandler(h, c, this, p);
      d[g] = Object.assign(v, this._calcCornerCoords(p, v));
    }), d;
  }
  _calcCornerCoords(e, t) {
    const n = this.getTotalAngle();
    return { corner: e.calcCornerCoords(n, this.cornerSize, t.x, t.y, !1, this), touchCorner: e.calcCornerCoords(n, this.touchCornerSize, t.x, t.y, !0, this) };
  }
  setCoords() {
    super.setCoords(), this.canvas && (this.oCoords = this.calcOCoords());
  }
  forEachControl(e) {
    for (const t in this.controls) e(this.controls[t], t, this);
  }
  drawSelectionBackground(e) {
    if (!this.selectionBackgroundColor || this.canvas && this.canvas._activeObject !== this) return;
    e.save();
    const t = this.getRelativeCenterPoint(), n = this._calculateCurrentDimensions(), i = this.getViewportTransform();
    e.translate(t.x, t.y), e.scale(1 / i[0], 1 / i[3]), e.rotate(wt(this.angle)), e.fillStyle = this.selectionBackgroundColor, e.fillRect(-n.x / 2, -n.y / 2, n.x, n.y), e.restore();
  }
  strokeBorders(e, t) {
    e.strokeRect(-t.x / 2, -t.y / 2, t.x, t.y);
  }
  _drawBorders(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = D({ hasControls: this.hasControls, borderColor: this.borderColor, borderDashArray: this.borderDashArray }, n);
    e.save(), e.strokeStyle = i.borderColor, this._setLineDash(e, i.borderDashArray), this.strokeBorders(e, t), i.hasControls && this.drawControlsConnectingLines(e, t), e.restore();
  }
  _renderControls(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { hasBorders: n, hasControls: i } = this, s = D({ hasBorders: n, hasControls: i }, t), a = this.getViewportTransform(), c = s.hasBorders, u = s.hasControls, h = xt(a, this.calcTransformMatrix()), d = Xs(h);
    e.save(), e.translate(d.translateX, d.translateY), e.lineWidth = this.borderScaleFactor, this.group === this.parent && (e.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (d.angle -= 180), e.rotate(wt(this.group ? d.angle : this.angle)), c && this.drawBorders(e, d, t), u && this.drawControls(e, t), e.restore();
  }
  drawBorders(e, t, n) {
    let i;
    if (n && n.forActiveSelection || this.group) {
      const s = su(this.width, this.height, _a(t)), a = this.isStrokeAccountedForInDimensions() ? rp : (this.strokeUniform ? new B().scalarAdd(this.canvas ? this.canvas.getZoom() : 1) : new B(t.scaleX, t.scaleY)).scalarMultiply(this.strokeWidth);
      i = s.add(a).scalarAdd(this.borderScaleFactor).scalarAdd(2 * this.padding);
    } else i = this._calculateCurrentDimensions().scalarAdd(this.borderScaleFactor);
    this._drawBorders(e, i, n);
  }
  drawControlsConnectingLines(e, t) {
    let n = !1;
    e.beginPath(), this.forEachControl((i, s) => {
      i.withConnection && i.getVisibility(this, s) && (n = !0, e.moveTo(i.x * t.x, i.y * t.y), e.lineTo(i.x * t.x + i.offsetX, i.y * t.y + i.offsetY));
    }), n && e.stroke();
  }
  drawControls(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e.save();
    const n = this.getCanvasRetinaScaling(), { cornerStrokeColor: i, cornerDashArray: s, cornerColor: a } = this, c = D({ cornerStrokeColor: i, cornerDashArray: s, cornerColor: a }, t);
    e.setTransform(n, 0, 0, n, 0, 0), e.strokeStyle = e.fillStyle = c.cornerColor, this.transparentCorners || (e.strokeStyle = c.cornerStrokeColor), this._setLineDash(e, c.cornerDashArray), this.forEachControl((u, h) => {
      if (u.getVisibility(this, h)) {
        const d = this.oCoords[h];
        u.render(e, d.x, d.y, c, this);
      }
    }), e.restore();
  }
  isControlVisible(e) {
    return this.controls[e] && this.controls[e].getVisibility(this, e);
  }
  setControlVisible(e, t) {
    this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[e] = t;
  }
  setControlsVisibility() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.entries(e).forEach((t) => {
      let [n, i] = t;
      return this.setControlVisible(n, i);
    });
  }
  clearContextTop(e) {
    if (!this.canvas) return;
    const t = this.canvas.contextTop;
    if (!t) return;
    const n = this.canvas.viewportTransform;
    t.save(), t.transform(n[0], n[1], n[2], n[3], n[4], n[5]), this.transform(t);
    const i = this.width + 4, s = this.height + 4;
    return t.clearRect(-i / 2, -s / 2, i, s), e || t.restore(), t;
  }
  onDeselect(e) {
    return !1;
  }
  onSelect(e) {
    return !1;
  }
  shouldStartDragging(e) {
    return !1;
  }
  onDragStart(e) {
    return !1;
  }
  canDrop(e) {
    return !1;
  }
  renderDragSourceEffect(e) {
  }
  renderDropTargetEffect(e) {
  }
}
function Pw(r, e) {
  return e.forEach((t) => {
    Object.getOwnPropertyNames(t.prototype).forEach((n) => {
      n !== "constructor" && Object.defineProperty(r.prototype, n, Object.getOwnPropertyDescriptor(t.prototype, n) || /* @__PURE__ */ Object.create(null));
    });
  }), r;
}
j(aa, "ownDefaults", { noScaleCache: !0, lockMovementX: !1, lockMovementY: !1, lockRotation: !1, lockScalingX: !1, lockScalingY: !1, lockSkewingX: !1, lockSkewingY: !1, lockScalingFlip: !1, cornerSize: 13, touchCornerSize: 24, transparentCorners: !0, cornerColor: "rgb(178,204,255)", cornerStrokeColor: "", cornerStyle: "rect", cornerDashArray: null, hasControls: !0, borderColor: "rgb(178,204,255)", borderDashArray: null, borderOpacityWhenMoving: 0.4, borderScaleFactor: 1, hasBorders: !0, selectionBackgroundColor: "", selectable: !0, evented: !0, perPixelTargetFind: !1, activeOn: "down", hoverCursor: null, moveCursor: null });
class rt extends aa {
}
Pw(rt, [dw]), ne.setClass(rt), ne.setClass(rt, "object");
const Dw = (r, e, t, n) => {
  const i = 2 * (n = Math.round(n)) + 1, { data: s } = r.getImageData(e - n, t - n, i, i);
  for (let a = 3; a < s.length; a += 4)
    if (s[a] > 0) return !1;
  return !0;
};
class jw {
  constructor(e) {
    this.options = e, this.strokeProjectionMagnitude = this.options.strokeWidth / 2, this.scale = new B(this.options.scaleX, this.options.scaleY), this.strokeUniformScalar = this.options.strokeUniform ? new B(1 / this.options.scaleX, 1 / this.options.scaleY) : new B(1, 1);
  }
  createSideVector(e, t) {
    const n = vl(e, t);
    return this.options.strokeUniform ? n.multiply(this.scale) : n;
  }
  projectOrthogonally(e, t, n) {
    return this.applySkew(e.add(this.calcOrthogonalProjection(e, t, n)));
  }
  isSkewed() {
    return this.options.skewX !== 0 || this.options.skewY !== 0;
  }
  applySkew(e) {
    const t = new B(e);
    return t.y += t.x * Math.tan(wt(this.options.skewY)), t.x += t.y * Math.tan(wt(this.options.skewX)), t;
  }
  scaleUnitVector(e, t) {
    return e.multiply(this.strokeUniformScalar).scalarMultiply(t);
  }
}
const _D = new B();
class Us extends jw {
  static getOrthogonalRotationFactor(e, t) {
    const n = t ? bl(e, t) : pw(e);
    return Math.abs(n) < bi ? -1 : 1;
  }
  constructor(e, t, n, i) {
    super(i), j(this, "AB", void 0), j(this, "AC", void 0), j(this, "alpha", void 0), j(this, "bisector", void 0), this.A = new B(e), this.B = new B(t), this.C = new B(n), this.AB = this.createSideVector(this.A, this.B), this.AC = this.createSideVector(this.A, this.C), this.alpha = bl(this.AB, this.AC), this.bisector = cu(up(this.AB.eq(_D) ? this.AC : this.AB, this.alpha / 2));
  }
  calcOrthogonalProjection(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;
    const i = this.createSideVector(e, t), s = hp(i), a = Us.getOrthogonalRotationFactor(s, this.bisector);
    return this.scaleUnitVector(s, n * a);
  }
  projectBevel() {
    const e = [];
    return (this.alpha % Qn == 0 ? [this.B] : [this.B, this.C]).forEach((t) => {
      e.push(this.projectOrthogonally(this.A, t)), e.push(this.projectOrthogonally(this.A, t, -this.strokeProjectionMagnitude));
    }), e;
  }
  projectMiter() {
    const e = [], t = Math.abs(this.alpha), n = 1 / Math.sin(t / 2), i = this.scaleUnitVector(this.bisector, -this.strokeProjectionMagnitude * n), s = this.options.strokeUniform ? yl(this.scaleUnitVector(this.bisector, this.options.strokeMiterLimit)) : this.options.strokeMiterLimit;
    return yl(i) / this.strokeProjectionMagnitude <= s && e.push(this.applySkew(this.A.add(i))), e.push(...this.projectBevel()), e;
  }
  projectRoundNoSkew(e, t) {
    const n = [], i = new B(Us.getOrthogonalRotationFactor(this.bisector), Us.getOrthogonalRotationFactor(new B(this.bisector.y, this.bisector.x)));
    return [new B(1, 0).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(i), new B(0, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(i)].forEach((s) => {
      Gd(s, e, t) && n.push(this.A.add(s));
    }), n;
  }
  projectRoundWithSkew(e, t) {
    const n = [], { skewX: i, skewY: s, scaleX: a, scaleY: c, strokeUniform: u } = this.options, h = new B(Math.tan(wt(i)), Math.tan(wt(s))), d = this.strokeProjectionMagnitude, p = u ? d / c / Math.sqrt(1 / c ** 2 + 1 / a ** 2 * h.y ** 2) : d / Math.sqrt(1 + h.y ** 2), g = new B(Math.sqrt(Math.max(d ** 2 - p ** 2, 0)), p), v = u ? d / Math.sqrt(1 + h.x ** 2 * (1 / c) ** 2 / (1 / a + 1 / a * h.x * h.y) ** 2) : d / Math.sqrt(1 + h.x ** 2 / (1 + h.x * h.y) ** 2), b = new B(v, Math.sqrt(Math.max(d ** 2 - v ** 2, 0)));
    return [b, b.scalarMultiply(-1), g, g.scalarMultiply(-1)].map((x) => this.applySkew(u ? x.multiply(this.strokeUniformScalar) : x)).forEach((x) => {
      Gd(x, e, t) && n.push(this.applySkew(this.A).add(x));
    }), n;
  }
  projectRound() {
    const e = [];
    e.push(...this.projectBevel());
    const t = this.alpha % Qn == 0, n = this.applySkew(this.A), i = e[t ? 0 : 2].subtract(n), s = e[t ? 1 : 0].subtract(n), a = t ? this.applySkew(this.AB.scalarMultiply(-1)) : this.applySkew(this.bisector.multiply(this.strokeUniformScalar).scalarMultiply(-1)), c = Hs(i, a) > 0, u = c ? i : s, h = c ? s : i;
    return this.isSkewed() ? e.push(...this.projectRoundWithSkew(u, h)) : e.push(...this.projectRoundNoSkew(u, h)), e;
  }
  projectPoints() {
    switch (this.options.strokeLineJoin) {
      case "miter":
        return this.projectMiter();
      case "round":
        return this.projectRound();
      default:
        return this.projectBevel();
    }
  }
  project() {
    return this.projectPoints().map((e) => ({ originPoint: this.A, projectedPoint: e, angle: this.alpha, bisector: this.bisector }));
  }
}
class C0 extends jw {
  constructor(e, t, n) {
    super(n), this.A = new B(e), this.T = new B(t);
  }
  calcOrthogonalProjection(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;
    const i = this.createSideVector(e, t);
    return this.scaleUnitVector(hp(i), n);
  }
  projectButt() {
    return [this.projectOrthogonally(this.A, this.T, this.strokeProjectionMagnitude), this.projectOrthogonally(this.A, this.T, -this.strokeProjectionMagnitude)];
  }
  projectRound() {
    const e = [];
    if (!this.isSkewed() && this.A.eq(this.T)) {
      const t = new B(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      e.push(this.applySkew(this.A.add(t)), this.applySkew(this.A.subtract(t)));
    } else e.push(...new Us(this.A, this.T, this.T, this.options).projectRound());
    return e;
  }
  projectSquare() {
    const e = [];
    if (this.A.eq(this.T)) {
      const t = new B(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      e.push(this.A.add(t), this.A.subtract(t));
    } else {
      const t = this.calcOrthogonalProjection(this.A, this.T, this.strokeProjectionMagnitude), n = this.scaleUnitVector(cu(this.createSideVector(this.A, this.T)), -this.strokeProjectionMagnitude), i = this.A.add(n);
      e.push(i.add(t), i.subtract(t));
    }
    return e.map((t) => this.applySkew(t));
  }
  projectPoints() {
    switch (this.options.strokeLineCap) {
      case "round":
        return this.projectRound();
      case "square":
        return this.projectSquare();
      default:
        return this.projectButt();
    }
  }
  project() {
    return this.projectPoints().map((e) => ({ originPoint: this.A, projectedPoint: e }));
  }
}
const Rw = function(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
  const n = [];
  if (r.length === 0) return n;
  const i = r.reduce((s, a) => (s[s.length - 1].eq(a) || s.push(new B(a)), s), [new B(r[0])]);
  if (i.length === 1) t = !0;
  else if (!t) {
    const s = i[0], a = ((c, u) => {
      for (let h = c.length - 1; h >= 0; h--) if (u(c[h], h, c)) return h;
      return -1;
    })(i, (c) => !c.eq(s));
    i.splice(a + 1);
  }
  return i.forEach((s, a, c) => {
    let u, h;
    a === 0 ? (h = c[1], u = t ? s : c[c.length - 1]) : a === c.length - 1 ? (u = c[a - 1], h = t ? s : c[0]) : (u = c[a - 1], h = c[a + 1]), t && c.length === 1 ? n.push(...new C0(s, s, e).project()) : !t || a !== 0 && a !== c.length - 1 ? n.push(...new Us(s, u, h, e).project()) : n.push(...new C0(s, a === 0 ? h : u, e).project());
  }), n;
}, mp = (r) => {
  const e = {};
  return Object.keys(r).forEach((t) => {
    e[t] = {}, Object.keys(r[t]).forEach((n) => {
      e[t][n] = D({}, r[t][n]);
    });
  }), e;
}, Fw = (r) => r.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), uu = (r) => {
  const e = [];
  for (let t, n = 0; n < r.length; n++) (t = SD(r, n)) !== !1 && e.push(t);
  return e;
}, SD = (r, e) => {
  const t = r.charCodeAt(e);
  if (isNaN(t)) return "";
  if (t < 55296 || t > 57343) return r.charAt(e);
  if (55296 <= t && t <= 56319) {
    if (r.length <= e + 1) throw "High surrogate without following low surrogate";
    const i = r.charCodeAt(e + 1);
    if (56320 > i || i > 57343) throw "High surrogate without following low surrogate";
    return r.charAt(e) + r.charAt(e + 1);
  }
  if (e === 0) throw "Low surrogate without preceding high surrogate";
  const n = r.charCodeAt(e - 1);
  if (55296 > n || n > 56319) throw "Low surrogate without preceding high surrogate";
  return !1;
};
var CD = Object.freeze({ __proto__: null, capitalize: function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
  return "".concat(r.charAt(0).toUpperCase()).concat(e ? r.slice(1) : r.slice(1).toLowerCase());
}, escapeXml: Fw, graphemeSplit: uu });
const hu = function(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
  return r.fill !== e.fill || r.stroke !== e.stroke || r.strokeWidth !== e.strokeWidth || r.fontSize !== e.fontSize || r.fontFamily !== e.fontFamily || r.fontWeight !== e.fontWeight || r.fontStyle !== e.fontStyle || r.textBackgroundColor !== e.textBackgroundColor || r.deltaY !== e.deltaY || t && (r.overline !== e.overline || r.underline !== e.underline || r.linethrough !== e.linethrough);
}, Lw = (r, e) => {
  const t = e.split(`
`), n = [];
  let i = -1, s = {};
  r = mp(r);
  for (let a = 0; a < t.length; a++) {
    const c = uu(t[a]);
    if (r[a]) for (let u = 0; u < c.length; u++) {
      i++;
      const h = r[a][u];
      h && Object.keys(h).length > 0 && (hu(s, h, !0) ? n.push({ start: i, end: i + 1, style: h }) : n[n.length - 1].end++), s = h || {};
    }
    else i += c.length, s = {};
  }
  return n;
}, Nw = (r, e) => {
  if (!Array.isArray(r)) return mp(r);
  const t = e.split(ep), n = {};
  let i = -1, s = 0;
  for (let a = 0; a < t.length; a++) {
    const c = uu(t[a]);
    for (let u = 0; u < c.length; u++) i++, r[s] && r[s].start <= i && i < r[s].end && (n[a] = n[a] || {}, n[a][u] = D({}, r[s].style), i === r[s].end - 1 && s++);
  }
  return n;
}, Ai = ["display", "transform", Nt, "fill-opacity", "fill-rule", "opacity", xr, "stroke-dasharray", "stroke-linecap", "stroke-dashoffset", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id", "paint-order", "vector-effect", "instantiated_by_use", "clip-path"];
function T0(r, e) {
  const t = r.nodeName, n = r.getAttribute("class"), i = r.getAttribute("id"), s = "(?![a-zA-Z\\-]+)";
  let a;
  if (a = new RegExp("^" + t, "i"), e = e.replace(a, ""), i && e.length && (a = new RegExp("#" + i + s, "i"), e = e.replace(a, "")), n && e.length) {
    const c = n.split(" ");
    for (let u = c.length; u--; ) a = new RegExp("\\." + c[u] + s, "i"), e = e.replace(a, "");
  }
  return e.length === 0;
}
function TD(r, e) {
  let t = !0;
  const n = T0(r, e.pop());
  return n && e.length && (t = function(i, s) {
    let a, c = !0;
    for (; i.parentElement && i.parentElement.nodeType === 1 && s.length; ) c && (a = s.pop()), c = T0(i = i.parentElement, a);
    return s.length === 0;
  }(r, e)), n && t && e.length === 0;
}
const ED = (r) => {
  var e;
  return (e = nD[r]) !== null && e !== void 0 ? e : r;
}, kD = new RegExp("(".concat(rs, ")"), "gi"), OD = (r) => r.replace(kD, " $1 ").replace(/,/gi, " ").replace(/\s+/gi, " ");
var E0, k0, O0, I0, A0, M0, P0;
const sr = "(".concat(rs, ")"), ID = String.raw(E0 || (E0 = Oi(["(skewX)(", ")"], ["(skewX)\\(", "\\)"])), sr), AD = String.raw(k0 || (k0 = Oi(["(skewY)(", ")"], ["(skewY)\\(", "\\)"])), sr), MD = String.raw(O0 || (O0 = Oi(["(rotate)(", "(?: ", " ", ")?)"], ["(rotate)\\(", "(?: ", " ", ")?\\)"])), sr, sr, sr), PD = String.raw(I0 || (I0 = Oi(["(scale)(", "(?: ", ")?)"], ["(scale)\\(", "(?: ", ")?\\)"])), sr, sr), DD = String.raw(A0 || (A0 = Oi(["(translate)(", "(?: ", ")?)"], ["(translate)\\(", "(?: ", ")?\\)"])), sr, sr), jD = String.raw(M0 || (M0 = Oi(["(matrix)(", " ", " ", " ", " ", " ", ")"], ["(matrix)\\(", " ", " ", " ", " ", " ", "\\)"])), sr, sr, sr, sr, sr, sr), vp = "(?:".concat(jD, "|").concat(DD, "|").concat(MD, "|").concat(PD, "|").concat(ID, "|").concat(AD, ")"), RD = "(?:".concat(vp, "*)"), FD = String.raw(P0 || (P0 = Oi(["^s*(?:", "?)s*$"], ["^\\s*(?:", "?)\\s*$"])), RD), LD = new RegExp(FD), ND = new RegExp(vp), BD = new RegExp(vp, "g");
function Qd(r) {
  const e = [];
  if (!(r = OD(r).replace(/\s*([()])\s*/gi, "$1")) || r && !LD.test(r)) return [...ar];
  for (const t of r.matchAll(BD)) {
    const n = ND.exec(t[0]);
    if (!n) continue;
    let i = ar;
    const s = n.filter((b) => !!b), [, a, ...c] = s, [u, h, d, p, g, v] = c.map((b) => parseFloat(b));
    switch (a) {
      case "translate":
        i = fo(u, h);
        break;
      case tp:
        i = po({ angle: u }, { x: h, y: d });
        break;
      case ru:
        i = iu(u, h);
        break;
      case uo:
        i = ip(u);
        break;
      case ho:
        i = sp(u);
        break;
      case "matrix":
        i = [u, h, d, p, g, v];
    }
    e.push(i);
  }
  return nu(e);
}
function VD(r, e, t, n) {
  const i = Array.isArray(e);
  let s, a = e;
  if (r !== Nt && r !== xr || e !== wr) {
    if (r === "strokeUniform") return e === "non-scaling-stroke";
    if (r === "strokeDashArray") a = e === wr ? null : e.replace(/,/g, " ").split(/\s+/).map(parseFloat);
    else if (r === "transformMatrix") a = t && t.transformMatrix ? xt(t.transformMatrix, Qd(e)) : Qd(e);
    else if (r === "visible") a = e !== wr && e !== "hidden", t && t.visible === !1 && (a = !1);
    else if (r === "opacity") a = parseFloat(e), t && t.opacity !== void 0 && (a *= t.opacity);
    else if (r === "textAnchor") a = e === "start" ? Ke : e === "end" ? Tt : Pe;
    else if (r === "charSpacing") s = es(e, n) / n * 1e3;
    else if (r === "paintFirst") {
      const c = e.indexOf(Nt), u = e.indexOf(xr);
      a = Nt, (c > -1 && u > -1 && u < c || c === -1 && u > -1) && (a = xr);
    } else {
      if (r === "href" || r === "xlink:href" || r === "font" || r === "id") return e;
      if (r === "imageSmoothing") return e === "optimizeQuality";
      s = i ? e.map(es) : es(e, n);
    }
  } else a = "";
  return !i && isNaN(s) ? a : s;
}
function zD(r, e) {
  const t = r.match(rD);
  if (!t) return;
  const n = t[1], i = t[3], s = t[4], a = t[5], c = t[6];
  n && (e.fontStyle = n), i && (e.fontWeight = isNaN(parseFloat(i)) ? i : parseFloat(i)), s && (e.fontSize = es(s)), c && (e.fontFamily = c), a && (e.lineHeight = a === "normal" ? 1 : a);
}
function WD(r, e) {
  r.replace(/;\s*$/, "").split(";").forEach((t) => {
    if (!t) return;
    const [n, i] = t.split(":");
    e[n.trim().toLowerCase()] = i.trim();
  });
}
function HD(r) {
  const e = {}, t = r.getAttribute("style");
  return t && (typeof t == "string" ? WD(t, e) : function(n, i) {
    Object.entries(n).forEach((s) => {
      let [a, c] = s;
      c !== void 0 && (i[a.toLowerCase()] = c);
    });
  }(t, e)), e;
}
const UD = { stroke: "strokeOpacity", fill: "fillOpacity" };
function ti(r, e, t) {
  if (!r) return {};
  let n, i = {}, s = Qf;
  r.parentNode && b0.test(r.parentNode.nodeName) && (i = ti(r.parentElement, e, t), i.fontSize && (n = s = es(i.fontSize)));
  const a = D(D(D({}, e.reduce((h, d) => {
    const p = r.getAttribute(d);
    return p && (h[d] = p), h;
  }, {})), function(h) {
    let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = {};
    for (const g in d) TD(h, g.split(" ")) && (p = D(D({}, p), d[g]));
    return p;
  }(r, t)), HD(r));
  a[Gh] && r.setAttribute(Gh, a[Gh]), a[Xh] && (n = es(a[Xh], s), a[Xh] = "".concat(n));
  const c = {};
  for (const h in a) {
    const d = ED(h), p = VD(d, a[h], i, n);
    c[d] = p;
  }
  c && c.font && zD(c.font, c);
  const u = D(D({}, i), c);
  return b0.test(r.nodeName) ? u : function(h) {
    const d = rt.getDefaults();
    return Object.entries(UD).forEach((p) => {
      let [g, v] = p;
      if (h[v] === void 0 || h[g] === "") return;
      if (h[g] === void 0) {
        if (!d[g]) return;
        h[g] = d[g];
      }
      if (h[g].indexOf("url(") === 0) return;
      const b = new Qe(h[g]);
      h[g] = b.setAlpha(ut(b.getAlpha() * h[v], 2)).toRgba();
    }), h;
  }(u);
}
const $D = ["left", "top", "width", "height", "visible"], Bw = ["rx", "ry"];
class Ot extends rt {
  static getDefaults() {
    return D(D({}, super.getDefaults()), Ot.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, Ot.ownDefaults), this.setOptions(e), this._initRxRy();
  }
  _initRxRy() {
    const { rx: e, ry: t } = this;
    e && !t ? this.ry = e : t && !e && (this.rx = t);
  }
  _render(e) {
    const { width: t, height: n } = this, i = -t / 2, s = -n / 2, a = this.rx ? Math.min(this.rx, t / 2) : 0, c = this.ry ? Math.min(this.ry, n / 2) : 0, u = a !== 0 || c !== 0;
    e.beginPath(), e.moveTo(i + a, s), e.lineTo(i + t - a, s), u && e.bezierCurveTo(i + t - pi * a, s, i + t, s + pi * c, i + t, s + c), e.lineTo(i + t, s + n - c), u && e.bezierCurveTo(i + t, s + n - pi * c, i + t - pi * a, s + n, i + t - a, s + n), e.lineTo(i + a, s + n), u && e.bezierCurveTo(i + pi * a, s + n, i, s + n - pi * c, i, s + n - c), e.lineTo(i, s + c), u && e.bezierCurveTo(i, s + pi * c, i + pi * a, s, i + a, s), e.closePath(), this._renderPaintInOrder(e);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...Bw, ...e]);
  }
  _toSVG() {
    const { width: e, height: t, rx: n, ry: i } = this;
    return ["<rect ", "COMMON_PARTS", 'x="'.concat(-e / 2, '" y="').concat(-t / 2, '" rx="').concat(n, '" ry="').concat(i, '" width="').concat(e, '" height="').concat(t, `" />
`)];
  }
  static async fromElement(e, t, n) {
    const i = ti(e, this.ATTRIBUTE_NAMES, n), { left: s = 0, top: a = 0, width: c = 0, height: u = 0, visible: h = !0 } = i, d = ht(i, $D);
    return new this(D(D(D({}, t), d), {}, { left: s, top: a, width: c, height: u, visible: !!(h && c && u) }));
  }
}
j(Ot, "type", "Rect"), j(Ot, "cacheProperties", [...ei, ...Bw]), j(Ot, "ownDefaults", { rx: 0, ry: 0 }), j(Ot, "ATTRIBUTE_NAMES", [...Ai, "x", "y", "rx", "ry", "width", "height"]), ne.setClass(Ot), ne.setSVGClass(Ot);
const Yn = "initialization", wl = "added", yp = "removed", xl = "imperative", Vw = (r, e) => {
  const { strokeUniform: t, strokeWidth: n, width: i, height: s, group: a } = e, c = a && a !== r ? Ta(a.calcTransformMatrix(), r.calcTransformMatrix()) : null, u = c ? e.getRelativeCenterPoint().transform(c) : e.getRelativeCenterPoint(), h = !e.isStrokeAccountedForInDimensions(), d = t && h ? cw(new B(n, n), void 0, r.calcTransformMatrix()) : rp, p = !t && h ? n : 0, g = su(i + p, s + p, nu([c, e.calcOwnMatrix()], !0)).add(d).scalarDivide(2);
  return [u.subtract(g), u.add(g)];
};
class du {
  calcLayoutResult(e, t) {
    if (this.shouldPerformLayout(e)) return this.calcBoundingBox(t, e);
  }
  shouldPerformLayout(e) {
    let { type: t, prevStrategy: n, strategy: i } = e;
    return t === Yn || t === xl || !!n && i !== n;
  }
  shouldLayoutClipPath(e) {
    let { type: t, target: { clipPath: n } } = e;
    return t !== Yn && n && !n.absolutePositioned;
  }
  getInitialSize(e, t) {
    return t.size;
  }
  calcBoundingBox(e, t) {
    const { type: n, target: i } = t;
    if (n === xl && t.overrides) return t.overrides;
    if (e.length === 0) return;
    const { left: s, top: a, width: c, height: u } = Tn(e.map((p) => Vw(i, p)).reduce((p, g) => p.concat(g), [])), h = new B(c, u), d = new B(s, a).add(h.scalarDivide(2));
    if (n === Yn) {
      const p = this.getInitialSize(t, { size: h, center: d });
      return { center: d, relativeCorrection: new B(0, 0), size: p };
    }
    return { center: d.transform(i.calcOwnMatrix()), size: h };
  }
}
j(du, "type", "strategy");
class ef extends du {
  shouldPerformLayout(e) {
    return !0;
  }
}
j(ef, "type", "fit-content"), ne.setClass(ef);
const YD = ["strategy"], XD = ["target", "strategy", "bubbles", "prevStrategy"], zw = "layoutManager";
class ca {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new ef();
    j(this, "strategy", void 0), this.strategy = e, this._subscriptions = /* @__PURE__ */ new Map();
  }
  performLayout(e) {
    const t = D(D({ bubbles: !0, strategy: this.strategy }, e), {}, { prevStrategy: this._prevLayoutStrategy, stopPropagation() {
      this.bubbles = !1;
    } });
    this.onBeforeLayout(t);
    const n = this.getLayoutResult(t);
    n && this.commitLayout(t, n), this.onAfterLayout(t, n), this._prevLayoutStrategy = t.strategy;
  }
  attachHandlers(e, t) {
    const { target: n } = t;
    return [fl, Wb, ia, Hb, tu, Ub, dl, $b, qP].map((i) => e.on(i, (s) => this.performLayout(i === fl ? { type: "object_modified", trigger: i, e: s, target: n } : { type: "object_modifying", trigger: i, e: s, target: n })));
  }
  subscribe(e, t) {
    this.unsubscribe(e, t);
    const n = this.attachHandlers(e, t);
    this._subscriptions.set(e, n);
  }
  unsubscribe(e, t) {
    (this._subscriptions.get(e) || []).forEach((n) => n()), this._subscriptions.delete(e);
  }
  unsubscribeTargets(e) {
    e.targets.forEach((t) => this.unsubscribe(t, e));
  }
  subscribeTargets(e) {
    e.targets.forEach((t) => this.subscribe(t, e));
  }
  onBeforeLayout(e) {
    const { target: t, type: n } = e, { canvas: i } = t;
    if (n === Yn || n === wl ? this.subscribeTargets(e) : n === yp && this.unsubscribeTargets(e), t.fire("layout:before", { context: e }), i && i.fire("object:layout:before", { target: t, context: e }), n === xl && e.deep) {
      const s = ht(e, YD);
      t.forEachObject((a) => a.layoutManager && a.layoutManager.performLayout(D(D({}, s), {}, { bubbles: !1, target: a })));
    }
  }
  getLayoutResult(e) {
    const { target: t, strategy: n, type: i } = e, s = n.calcLayoutResult(e, t.getObjects());
    if (!s) return;
    const a = i === Yn ? new B() : t.getRelativeCenterPoint(), { center: c, correction: u = new B(), relativeCorrection: h = new B() } = s, d = a.subtract(c).add(u).transform(i === Yn ? ar : jr(t.calcOwnMatrix()), !0).add(h);
    return { result: s, prevCenter: a, nextCenter: c, offset: d };
  }
  commitLayout(e, t) {
    const { target: n } = e, { result: { size: i }, nextCenter: s } = t;
    var a, c;
    n.set({ width: i.x, height: i.y }), this.layoutObjects(e, t), e.type === Yn ? n.set({ left: (a = e.x) !== null && a !== void 0 ? a : s.x + i.x * kt(n.originX), top: (c = e.y) !== null && c !== void 0 ? c : s.y + i.y * kt(n.originY) }) : (n.setPositionByOrigin(s, Pe, Pe), n.setCoords(), n.set("dirty", !0));
  }
  layoutObjects(e, t) {
    const { target: n } = e;
    n.forEachObject((i) => {
      i.group === n && this.layoutObject(e, t, i);
    }), e.strategy.shouldLayoutClipPath(e) && this.layoutObject(e, t, n.clipPath);
  }
  layoutObject(e, t, n) {
    let { offset: i } = t;
    n.set({ left: n.left + i.x, top: n.top + i.y });
  }
  onAfterLayout(e, t) {
    const { target: n, strategy: i, bubbles: s, prevStrategy: a } = e, c = ht(e, XD), { canvas: u } = n;
    n.fire("layout:after", { context: e, result: t }), u && u.fire("object:layout:after", { context: e, result: t, target: n });
    const h = n.parent;
    s && h != null && h.layoutManager && ((c.path || (c.path = [])).push(n), h.layoutManager.performLayout(D(D({}, c), {}, { target: h }))), n.set("dirty", !0);
  }
  dispose() {
    const { _subscriptions: e } = this;
    e.forEach((t) => t.forEach((n) => n())), e.clear();
  }
  toObject() {
    return { type: zw, strategy: this.strategy.constructor.type };
  }
  toJSON() {
    return this.toObject();
  }
}
ne.setClass(ca, zw);
const GD = ["type", "objects", "layoutManager"];
class qD extends ca {
  performLayout() {
  }
}
class qr extends Yb(rt) {
  static getDefaults() {
    return D(D({}, super.getDefaults()), qr.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), j(this, "_activeObjects", []), j(this, "__objectSelectionTracker", void 0), j(this, "__objectSelectionDisposer", void 0), Object.assign(this, qr.ownDefaults), this.setOptions(t), this.groupInit(e, t);
  }
  groupInit(e, t) {
    var n;
    this._objects = [...e], this.__objectSelectionTracker = this.__objectSelectionMonitor.bind(this, !0), this.__objectSelectionDisposer = this.__objectSelectionMonitor.bind(this, !1), this.forEachObject((i) => {
      this.enterGroup(i, !1);
    }), this.layoutManager = (n = t.layoutManager) !== null && n !== void 0 ? n : new ca(), this.layoutManager.performLayout({ type: Yn, target: this, targets: [...e], x: t.left, y: t.top });
  }
  canEnterGroup(e) {
    return e === this || this.isDescendantOf(e) ? (yi("error", "Group: circular object trees are not supported, this call has no effect"), !1) : this._objects.indexOf(e) === -1 || (yi("error", "Group: duplicate objects are not supported inside group, this call has no effect"), !1);
  }
  _filterObjectsBeforeEnteringGroup(e) {
    return e.filter((t, n, i) => this.canEnterGroup(t) && i.indexOf(t) === n);
  }
  add() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    const i = this._filterObjectsBeforeEnteringGroup(t), s = super.add(...i);
    return this._onAfterObjectsChange(wl, i), s;
  }
  insertAt(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
    const s = this._filterObjectsBeforeEnteringGroup(n), a = super.insertAt(e, ...s);
    return this._onAfterObjectsChange(wl, s), a;
  }
  remove() {
    const e = super.remove(...arguments);
    return this._onAfterObjectsChange(yp, e), e;
  }
  _onObjectAdded(e) {
    this.enterGroup(e, !0), this.fire("object:added", { target: e }), e.fire("added", { target: this });
  }
  _onObjectRemoved(e, t) {
    this.exitGroup(e, t), this.fire("object:removed", { target: e }), e.fire("removed", { target: this });
  }
  _onAfterObjectsChange(e, t) {
    this.layoutManager.performLayout({ type: e, targets: t, target: this });
  }
  _onStackOrderChanged() {
    this._set("dirty", !0);
  }
  _set(e, t) {
    const n = this[e];
    return super._set(e, t), e === "canvas" && n !== t && (this._objects || []).forEach((i) => {
      i._set(e, t);
    }), this;
  }
  _shouldSetNestedCoords() {
    return this.subTargetCheck;
  }
  removeAll() {
    return this._activeObjects = [], this.remove(...this._objects);
  }
  __objectSelectionMonitor(e, t) {
    let { target: n } = t;
    const i = this._activeObjects;
    if (e) i.push(n), this._set("dirty", !0);
    else if (i.length > 0) {
      const s = i.indexOf(n);
      s > -1 && (i.splice(s, 1), this._set("dirty", !0));
    }
  }
  _watchObject(e, t) {
    e && this._watchObject(!1, t), e ? (t.on("selected", this.__objectSelectionTracker), t.on("deselected", this.__objectSelectionDisposer)) : (t.off("selected", this.__objectSelectionTracker), t.off("deselected", this.__objectSelectionDisposer));
  }
  enterGroup(e, t) {
    e.group && e.group.remove(e), e._set("parent", this), this._enterGroup(e, t);
  }
  _enterGroup(e, t) {
    t && qs(e, xt(jr(this.calcTransformMatrix()), e.calcTransformMatrix())), this._shouldSetNestedCoords() && e.setCoords(), e._set("group", this), e._set("canvas", this.canvas), this._watchObject(!0, e);
    const n = this.canvas && this.canvas.getActiveObject && this.canvas.getActiveObject();
    n && (n === e || e.isDescendantOf(n)) && this._activeObjects.push(e);
  }
  exitGroup(e, t) {
    this._exitGroup(e, t), e._set("parent", void 0), e._set("canvas", void 0);
  }
  _exitGroup(e, t) {
    e._set("group", void 0), t || (qs(e, xt(this.calcTransformMatrix(), e.calcTransformMatrix())), e.setCoords()), this._watchObject(!1, e);
    const n = this._activeObjects.length > 0 ? this._activeObjects.indexOf(e) : -1;
    n > -1 && this._activeObjects.splice(n, 1);
  }
  shouldCache() {
    const e = rt.prototype.shouldCache.call(this);
    if (e) {
      for (let t = 0; t < this._objects.length; t++) if (this._objects[t].willDrawShadow()) return this.ownCaching = !1, !1;
    }
    return e;
  }
  willDrawShadow() {
    if (super.willDrawShadow()) return !0;
    for (let e = 0; e < this._objects.length; e++) if (this._objects[e].willDrawShadow()) return !0;
    return !1;
  }
  isOnACache() {
    return this.ownCaching || !!this.parent && this.parent.isOnACache();
  }
  drawObject(e, t, n) {
    this._renderBackground(e);
    for (let s = 0; s < this._objects.length; s++) {
      var i;
      const a = this._objects[s];
      (i = this.canvas) !== null && i !== void 0 && i.preserveObjectStacking && a.group !== this ? (e.save(), e.transform(...jr(this.calcTransformMatrix())), a.render(e), e.restore()) : a.group === this && a.render(e);
    }
    this._drawClipPath(e, this.clipPath, n);
  }
  setCoords() {
    super.setCoords(), this._shouldSetNestedCoords() && this.forEachObject((e) => e.setCoords());
  }
  triggerLayout() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.layoutManager.performLayout(D({ target: this, type: xl }, e));
  }
  render(e) {
    this._transformDone = !0, super.render(e), this._transformDone = !1;
  }
  __serializeObjects(e, t) {
    const n = this.includeDefaultValues;
    return this._objects.filter(function(i) {
      return !i.excludeFromExport;
    }).map(function(i) {
      const s = i.includeDefaultValues;
      i.includeDefaultValues = n;
      const a = i[e || "toObject"](t);
      return i.includeDefaultValues = s, a;
    });
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = this.layoutManager.toObject();
    return D(D(D({}, super.toObject(["subTargetCheck", "interactive", ...e])), t.strategy !== "fit-content" || this.includeDefaultValues ? { layoutManager: t } : {}), {}, { objects: this.__serializeObjects("toObject", e) });
  }
  toString() {
    return "#<Group: (".concat(this.complexity(), ")>");
  }
  dispose() {
    this.layoutManager.unsubscribeTargets({ targets: this.getObjects(), target: this }), this._activeObjects = [], this.forEachObject((e) => {
      this._watchObject(!1, e), e.dispose();
    }), super.dispose();
  }
  _createSVGBgRect(e) {
    if (!this.backgroundColor) return "";
    const t = Ot.prototype._toSVG.call(this), n = t.indexOf("COMMON_PARTS");
    t[n] = 'for="group" ';
    const i = t.join("");
    return e ? e(i) : i;
  }
  _toSVG(e) {
    const t = ["<g ", "COMMON_PARTS", ` >
`], n = this._createSVGBgRect(e);
    n && t.push("		", n);
    for (let i = 0; i < this._objects.length; i++) t.push("		", this._objects[i].toSVG(e));
    return t.push(`</g>
`), t;
  }
  getSvgStyles() {
    const e = this.opacity !== void 0 && this.opacity !== 1 ? "opacity: ".concat(this.opacity, ";") : "", t = this.visible ? "" : " visibility: hidden;";
    return [e, this.getSvgFilter(), t].join("");
  }
  toClipPathSVG(e) {
    const t = [], n = this._createSVGBgRect(e);
    n && t.push("	", n);
    for (let i = 0; i < this._objects.length; i++) t.push("	", this._objects[i].toClipPathSVG(e));
    return this._createBaseClipPathSVGMarkup(t, { reviver: e });
  }
  static fromObject(e, t) {
    let { type: n, objects: i = [], layoutManager: s } = e, a = ht(e, GD);
    return Promise.all([Gs(i, t), Sa(a, t)]).then((c) => {
      let [u, h] = c;
      const d = new this(u, D(D(D({}, a), h), {}, { layoutManager: new qD() }));
      if (s) {
        const p = ne.getClass(s.type), g = ne.getClass(s.strategy);
        d.layoutManager = new p(new g());
      } else d.layoutManager = new ca();
      return d.layoutManager.subscribeTargets({ type: Yn, target: d, targets: d.getObjects() }), d.setCoords(), d;
    });
  }
}
j(qr, "type", "Group"), j(qr, "ownDefaults", { strokeWidth: 0, subTargetCheck: !1, interactive: !1 }), ne.setClass(qr);
const Ww = (r, e) => Math.min(e.width / r.width, e.height / r.height), Hw = (r, e) => Math.max(e.width / r.width, e.height / r.height), tf = "\\s*,?\\s*", zo = "".concat(tf, "(").concat(rs, ")"), KD = "".concat(zo).concat(zo).concat(zo).concat(tf, "([01])").concat(tf, "([01])").concat(zo).concat(zo), ZD = { m: "l", M: "L" }, JD = (r, e, t, n, i, s, a, c, u, h, d) => {
  const p = un(r), g = hn(r), v = un(e), b = hn(e), x = t * i * v - n * s * b + a, _ = n * i * v + t * s * b + c;
  return ["C", h + u * (-t * i * g - n * s * p), d + u * (-n * i * g + t * s * p), x + u * (t * i * b + n * s * v), _ + u * (n * i * b - t * s * v), x, _];
}, D0 = (r, e, t, n) => {
  const i = Math.atan2(e, r), s = Math.atan2(n, t);
  return s >= i ? s - i : 2 * Math.PI - (i - s);
};
function rf(r, e, t, n, i, s, a, c) {
  let u;
  if (Ue.cachesBoundsOfCurve && (u = [...arguments].join(), qo.boundsOfCurveCache[u])) return qo.boundsOfCurveCache[u];
  const h = Math.sqrt, d = Math.abs, p = [], g = [[0, 0], [0, 0]];
  let v = 6 * r - 12 * t + 6 * i, b = -3 * r + 9 * t - 9 * i + 3 * a, x = 3 * t - 3 * r;
  for (let O = 0; O < 2; ++O) {
    if (O > 0 && (v = 6 * e - 12 * n + 6 * s, b = -3 * e + 9 * n - 9 * s + 3 * c, x = 3 * n - 3 * e), d(b) < 1e-12) {
      if (d(v) < 1e-12) continue;
      const $ = -x / v;
      0 < $ && $ < 1 && p.push($);
      continue;
    }
    const P = v * v - 4 * x * b;
    if (P < 0) continue;
    const R = h(P), V = (-v + R) / (2 * b);
    0 < V && V < 1 && p.push(V);
    const F = (-v - R) / (2 * b);
    0 < F && F < 1 && p.push(F);
  }
  let _ = p.length;
  const C = _, E = $w(r, e, t, n, i, s, a, c);
  for (; _--; ) {
    const { x: O, y: P } = E(p[_]);
    g[0][_] = O, g[1][_] = P;
  }
  g[0][C] = r, g[1][C] = e, g[0][C + 1] = a, g[1][C + 1] = c;
  const k = [new B(Math.min(...g[0]), Math.min(...g[1])), new B(Math.max(...g[0]), Math.max(...g[1]))];
  return Ue.cachesBoundsOfCurve && (qo.boundsOfCurveCache[u] = k), k;
}
const QD = (r, e, t) => {
  let [n, i, s, a, c, u, h, d] = t;
  const p = ((g, v, b, x, _, C, E) => {
    if (b === 0 || x === 0) return [];
    let k = 0, O = 0, P = 0;
    const R = Math.PI, V = E * Jf, F = hn(V), $ = un(V), z = 0.5 * (-$ * g - F * v), G = 0.5 * (-$ * v + F * g), H = b ** 2, Y = x ** 2, te = G ** 2, ge = z ** 2, Z = H * Y - H * te - Y * ge;
    let de = Math.abs(b), oe = Math.abs(x);
    if (Z < 0) {
      const Pt = Math.sqrt(1 - Z / (H * Y));
      de *= Pt, oe *= Pt;
    } else P = (_ === C ? -1 : 1) * Math.sqrt(Z / (H * te + Y * ge));
    const ie = P * de * G / oe, pe = -P * oe * z / de, re = $ * ie - F * pe + 0.5 * g, Ve = F * ie + $ * pe + 0.5 * v;
    let Ze = D0(1, 0, (z - ie) / de, (G - pe) / oe), We = D0((z - ie) / de, (G - pe) / oe, (-z - ie) / de, (-G - pe) / oe);
    C === 0 && We > 0 ? We -= 2 * R : C === 1 && We < 0 && (We += 2 * R);
    const Ee = Math.ceil(Math.abs(We / R * 2)), Ie = [], dt = We / Ee, hr = 8 / 3 * Math.sin(dt / 4) * Math.sin(dt / 4) / Math.sin(dt / 2);
    let Ht = Ze + dt;
    for (let Pt = 0; Pt < Ee; Pt++) Ie[Pt] = JD(Ze, Ht, $, F, de, oe, re, Ve, hr, k, O), k = Ie[Pt][5], O = Ie[Pt][6], Ze = Ht, Ht += dt;
    return Ie;
  })(h - r, d - e, i, s, c, u, a);
  for (let g = 0, v = p.length; g < v; g++) p[g][1] += r, p[g][2] += e, p[g][3] += r, p[g][4] += e, p[g][5] += r, p[g][6] += e;
  return p;
}, Uw = (r) => {
  let e = 0, t = 0, n = 0, i = 0;
  const s = [];
  let a, c = 0, u = 0;
  for (const h of r) {
    const d = [...h];
    let p;
    switch (d[0]) {
      case "l":
        d[1] += e, d[2] += t;
      case "L":
        e = d[1], t = d[2], p = ["L", e, t];
        break;
      case "h":
        d[1] += e;
      case "H":
        e = d[1], p = ["L", e, t];
        break;
      case "v":
        d[1] += t;
      case "V":
        t = d[1], p = ["L", e, t];
        break;
      case "m":
        d[1] += e, d[2] += t;
      case "M":
        e = d[1], t = d[2], n = d[1], i = d[2], p = ["M", e, t];
        break;
      case "c":
        d[1] += e, d[2] += t, d[3] += e, d[4] += t, d[5] += e, d[6] += t;
      case "C":
        c = d[3], u = d[4], e = d[5], t = d[6], p = ["C", d[1], d[2], c, u, e, t];
        break;
      case "s":
        d[1] += e, d[2] += t, d[3] += e, d[4] += t;
      case "S":
        a === "C" ? (c = 2 * e - c, u = 2 * t - u) : (c = e, u = t), e = d[3], t = d[4], p = ["C", c, u, d[1], d[2], e, t], c = p[3], u = p[4];
        break;
      case "q":
        d[1] += e, d[2] += t, d[3] += e, d[4] += t;
      case "Q":
        c = d[1], u = d[2], e = d[3], t = d[4], p = ["Q", c, u, e, t];
        break;
      case "t":
        d[1] += e, d[2] += t;
      case "T":
        a === "Q" ? (c = 2 * e - c, u = 2 * t - u) : (c = e, u = t), e = d[1], t = d[2], p = ["Q", c, u, e, t];
        break;
      case "a":
        d[6] += e, d[7] += t;
      case "A":
        QD(e, t, d).forEach((g) => s.push(g)), e = d[6], t = d[7];
        break;
      case "z":
      case "Z":
        e = n, t = i, p = ["Z"];
    }
    p ? (s.push(p), a = p[0]) : a = "";
  }
  return s;
}, _l = (r, e, t, n) => Math.sqrt((t - r) ** 2 + (n - e) ** 2), $w = (r, e, t, n, i, s, a, c) => (u) => {
  const h = u ** 3, d = ((v) => 3 * v ** 2 * (1 - v))(u), p = ((v) => 3 * v * (1 - v) ** 2)(u), g = ((v) => (1 - v) ** 3)(u);
  return new B(a * h + i * d + t * p + r * g, c * h + s * d + n * p + e * g);
}, Yw = (r) => r ** 2, Xw = (r) => 2 * r * (1 - r), Gw = (r) => (1 - r) ** 2, e6 = (r, e, t, n, i, s, a, c) => (u) => {
  const h = Yw(u), d = Xw(u), p = Gw(u), g = 3 * (p * (t - r) + d * (i - t) + h * (a - i)), v = 3 * (p * (n - e) + d * (s - n) + h * (c - s));
  return Math.atan2(v, g);
}, t6 = (r, e, t, n, i, s) => (a) => {
  const c = Yw(a), u = Xw(a), h = Gw(a);
  return new B(i * c + t * u + r * h, s * c + n * u + e * h);
}, r6 = (r, e, t, n, i, s) => (a) => {
  const c = 1 - a, u = 2 * (c * (t - r) + a * (i - t)), h = 2 * (c * (n - e) + a * (s - n));
  return Math.atan2(h, u);
}, j0 = (r, e, t) => {
  let n = new B(e, t), i = 0;
  for (let s = 1; s <= 100; s += 1) {
    const a = r(s / 100);
    i += _l(n.x, n.y, a.x, a.y), n = a;
  }
  return i;
}, n6 = (r, e) => {
  let t, n = 0, i = 0, s = { x: r.x, y: r.y }, a = D({}, s), c = 0.01, u = 0;
  const h = r.iterator, d = r.angleFinder;
  for (; i < e && c > 1e-4; ) a = h(n), u = n, t = _l(s.x, s.y, a.x, a.y), t + i > e ? (n -= c, c /= 2) : (s = a, n += c, i += t);
  return D(D({}, a), {}, { angle: d(u) });
}, bp = (r) => {
  let e, t, n = 0, i = 0, s = 0, a = 0, c = 0;
  const u = [];
  for (const h of r) {
    const d = { x: i, y: s, command: h[0], length: 0 };
    switch (h[0]) {
      case "M":
        t = d, t.x = a = i = h[1], t.y = c = s = h[2];
        break;
      case "L":
        t = d, t.length = _l(i, s, h[1], h[2]), i = h[1], s = h[2];
        break;
      case "C":
        e = $w(i, s, h[1], h[2], h[3], h[4], h[5], h[6]), t = d, t.iterator = e, t.angleFinder = e6(i, s, h[1], h[2], h[3], h[4], h[5], h[6]), t.length = j0(e, i, s), i = h[5], s = h[6];
        break;
      case "Q":
        e = t6(i, s, h[1], h[2], h[3], h[4]), t = d, t.iterator = e, t.angleFinder = r6(i, s, h[1], h[2], h[3], h[4]), t.length = j0(e, i, s), i = h[3], s = h[4];
        break;
      case "Z":
        t = d, t.destX = a, t.destY = c, t.length = _l(i, s, a, c), i = a, s = c;
    }
    n += t.length, u.push(t);
  }
  return u.push({ length: n, x: i, y: s }), u;
}, qw = function(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : bp(r), n = 0;
  for (; e - t[n].length > 0 && n < t.length - 2; ) e -= t[n].length, n++;
  const i = t[n], s = e / i.length, a = r[n];
  switch (i.command) {
    case "M":
      return { x: i.x, y: i.y, angle: 0 };
    case "Z":
      return D(D({}, new B(i.x, i.y).lerp(new B(i.destX, i.destY), s)), {}, { angle: Math.atan2(i.destY - i.y, i.destX - i.x) });
    case "L":
      return D(D({}, new B(i.x, i.y).lerp(new B(a[1], a[2]), s)), {}, { angle: Math.atan2(a[2] - i.y, a[1] - i.x) });
    case "C":
    case "Q":
      return n6(i, e);
  }
}, i6 = new RegExp("[mzlhvcsqta][^mzlhvcsqta]*", "gi"), R0 = new RegExp(KD, "g"), s6 = new RegExp(rs, "gi"), o6 = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, Kw = (r) => {
  var e;
  const t = [], n = (e = r.match(i6)) !== null && e !== void 0 ? e : [];
  for (const i of n) {
    const s = i[0];
    if (s === "z" || s === "Z") {
      t.push([s]);
      continue;
    }
    const a = o6[s.toLowerCase()];
    let c = [];
    if (s === "a" || s === "A") {
      R0.lastIndex = 0;
      for (let u = null; u = R0.exec(i); ) c.push(...u.slice(1));
    } else c = i.match(s6) || [];
    for (let u = 0; u < c.length; u += a) {
      const h = new Array(a), d = ZD[s];
      h[0] = u > 0 && d ? d : s;
      for (let p = 0; p < a; p++) h[p + 1] = parseFloat(c[u + p]);
      t.push(h);
    }
  }
  return t;
}, a6 = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = new B(r[0]), n = new B(r[1]), i = 1, s = 0;
  const a = [], c = r.length, u = c > 2;
  let h;
  for (u && (i = r[2].x < n.x ? -1 : r[2].x === n.x ? 0 : 1, s = r[2].y < n.y ? -1 : r[2].y === n.y ? 0 : 1), a.push(["M", t.x - i * e, t.y - s * e]), h = 1; h < c; h++) {
    if (!t.eq(n)) {
      const d = t.midPointFrom(n);
      a.push(["Q", t.x, t.y, d.x, d.y]);
    }
    t = r[h], h + 1 < r.length && (n = r[h + 1]);
  }
  return u && (i = t.x > r[h - 2].x ? 1 : t.x === r[h - 2].x ? 0 : -1, s = t.y > r[h - 2].y ? 1 : t.y === r[h - 2].y ? 0 : -1), a.push(["L", t.x + i * e, t.y + s * e]), a;
}, Zw = (r, e) => r.map((t) => t.map((n, i) => i === 0 || e === void 0 ? n : ut(n, e)).join(" ")).join(" ");
function Sl(r, e) {
  const t = r.style;
  t && e && (typeof e == "string" ? t.cssText += ";" + e : Object.entries(e).forEach((n) => {
    let [i, s] = n;
    return t.setProperty(i, s);
  }));
}
const c6 = (r, e) => Math.floor(Math.random() * (e - r + 1)) + r;
function l6(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = e.onComplete || Qi, n = new (eu()).XMLHttpRequest(), i = e.signal, s = function() {
    n.abort();
  }, a = function() {
    i && i.removeEventListener("abort", s), n.onerror = n.ontimeout = Qi;
  };
  if (i && i.aborted) throw new Vb("request");
  return i && i.addEventListener("abort", s, { once: !0 }), n.onreadystatechange = function() {
    n.readyState === 4 && (a(), t(n), n.onreadystatechange = Qi);
  }, n.onerror = n.ontimeout = a, n.open("get", r, !0), n.send(), n;
}
const u6 = (r, e) => {
  let t = r._findCenterFromElement();
  r.transformMatrix && (((n) => {
    if (n.transformMatrix) {
      const { scaleX: i, scaleY: s, angle: a, skewX: c } = Xs(n.transformMatrix);
      n.flipX = !1, n.flipY = !1, n.set(cr, i), n.set(Rr, s), n.angle = a, n.skewX = c, n.skewY = 0;
    }
  })(r), t = t.transform(r.transformMatrix)), delete r.transformMatrix, e && (r.scaleX *= e.scaleX, r.scaleY *= e.scaleY, r.cropX = e.cropX, r.cropY = e.cropY, t.x += e.offsetLeft, t.y += e.offsetTop, r.width = e.width, r.height = e.height), r.setPositionByOrigin(t, Pe, Pe);
};
var Jw = Object.freeze({ __proto__: null, addTransformToObject: ow, animate: fp, animateColor: vw, applyTransformToObject: qs, calcAngleBetweenVectors: bl, calcDimensionsMatrix: _a, calcPlaneChangeMatrix: Ta, calcVectorRotation: pw, cancelAnimFrame: Gb, capValue: ns, composeMatrix: Qb, copyCanvasElement: (r) => {
  var e;
  const t = dn(r);
  return (e = t.getContext("2d")) === null || e === void 0 || e.drawImage(r, 0, 0), t;
}, cos: un, createCanvasElement: Kr, createImage: qb, createRotateMatrix: po, createScaleMatrix: iu, createSkewXMatrix: ip, createSkewYMatrix: sp, createTranslateMatrix: fo, createVector: vl, crossProduct: Hs, degreesToRadians: wt, dotProduct: gw, ease: aD, enlivenObjectEnlivables: Sa, enlivenObjects: Gs, findScaleToCover: Hw, findScaleToFit: Ww, getBoundsOfCurve: rf, getOrthonormalVector: hp, getPathSegmentsInfo: bp, getPointOnPath: qw, getPointer: sw, getRandomInt: c6, getRegularPolygonPath: (r, e) => {
  const t = 2 * Math.PI / r;
  let n = -bi;
  r % 2 == 0 && (n += t / 2);
  const i = new Array(r + 1);
  for (let s = 0; s < r; s++) {
    const a = s * t + n, { x: c, y: u } = new B(un(a), hn(a)).scalarMultiply(e);
    i[s] = [s === 0 ? "M" : "L", c, u];
  }
  return i[r] = ["Z"], i;
}, getSmoothPathFromPoints: a6, getSvgAttributes: (r) => {
  const e = ["instantiated_by_use", "style", "id", "class"];
  switch (r) {
    case "linearGradient":
      return e.concat(["x1", "y1", "x2", "y2", "gradientUnits", "gradientTransform"]);
    case "radialGradient":
      return e.concat(["gradientUnits", "gradientTransform", "cx", "cy", "r", "fx", "fy", "fr"]);
    case "stop":
      return e.concat(["offset", "stop-color", "stop-opacity"]);
  }
  return e;
}, getUnitVector: cu, groupSVGElements: (r, e) => r && r.length === 1 ? r[0] : new qr(r, e), hasStyleChanged: hu, invertTransform: jr, isBetweenVectors: Gd, isIdentityMatrix: Kb, isTouchEvent: gl, isTransparent: Dw, joinPath: Zw, loadImage: Zo, magnitude: yl, makeBoundingBoxFromPoints: Tn, makePathSimpler: Uw, matrixToSVG: sa, mergeClipPaths: (r, e) => {
  var t;
  let n = r, i = e;
  n.inverted && !i.inverted && (n = e, i = r), Xd(i, (t = i.group) === null || t === void 0 ? void 0 : t.calcTransformMatrix(), n.calcTransformMatrix());
  const s = n.inverted && i.inverted;
  return s && (n.inverted = i.inverted = !1), new qr([n], { clipPath: i, inverted: s });
}, multiplyTransformMatrices: xt, multiplyTransformMatrixArray: nu, parsePath: Kw, parsePreserveAspectRatioAttribute: ew, parseUnit: es, pick: ps, projectStrokeOnPoints: Rw, qrDecompose: Xs, radiansToDegrees: xi, removeFromArray: $i, removeTransformFromObject: (r, e) => {
  const t = jr(e), n = xt(t, r.calcOwnMatrix());
  qs(r, n);
}, removeTransformMatrixForSvgParsing: u6, request: l6, requestAnimFrame: Ko, resetObjectTransform: aw, rotatePoint: (r, e, t) => r.rotate(t, e), rotateVector: up, saveObjectTransform: ap, sendObjectToPlane: Xd, sendPointToPlane: Gn, sendVectorToPlane: cw, setStyle: Sl, sin: hn, sizeAfterTransform: su, string: CD, stylesFromArray: Nw, stylesToArray: Lw, toDataURL: np, toFixed: ut, transformPath: (r, e, t) => (t && (e = xt(e, [1, 0, 0, 1, -t.x, -t.y])), r.map((n) => {
  const i = [...n];
  for (let s = 1; s < n.length - 1; s += 2) {
    const { x: a, y: c } = Kt({ x: n[s], y: n[s + 1] }, e);
    i[s] = a, i[s + 1] = c;
  }
  return i;
})), transformPoint: Kt });
class h6 extends iw {
  constructor(e) {
    let { allowTouchScrolling: t = !1, containerClass: n = "" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e), j(this, "upper", void 0), j(this, "container", void 0);
    const { el: i } = this.lower, s = this.createUpperCanvas();
    this.upper = { el: s, ctx: s.getContext("2d") }, this.applyCanvasStyle(i, { allowTouchScrolling: t }), this.applyCanvasStyle(s, { allowTouchScrolling: t, styles: { position: "absolute", left: "0", top: "0" } });
    const a = this.createContainerElement();
    a.classList.add(n), i.parentNode && i.parentNode.replaceChild(a, i), a.append(i, s), this.container = a;
  }
  createUpperCanvas() {
    const { el: e } = this.lower, t = Kr();
    return t.className = e.className, t.classList.remove("lower-canvas"), t.classList.add("upper-canvas"), t.setAttribute("data-fabric", "top"), t.style.cssText = e.style.cssText, t.setAttribute("draggable", "true"), t;
  }
  createContainerElement() {
    const e = lo().createElement("div");
    return e.setAttribute("data-fabric", "wrapper"), Sl(e, { position: "relative" }), m0(e), e;
  }
  applyCanvasStyle(e, t) {
    const { styles: n, allowTouchScrolling: i } = t;
    Sl(e, D(D({}, n), {}, { "touch-action": i ? "manipulation" : wr })), m0(e);
  }
  setDimensions(e, t) {
    super.setDimensions(e, t);
    const { el: n, ctx: i } = this.upper;
    nw(n, i, e, t);
  }
  setCSSDimensions(e) {
    super.setCSSDimensions(e), $d(this.upper.el, e), $d(this.container, e);
  }
  cleanupDOM(e) {
    const t = this.container, { el: n } = this.lower, { el: i } = this.upper;
    super.cleanupDOM(e), t.removeChild(i), t.removeChild(n), t.parentNode && t.parentNode.replaceChild(n, t);
  }
  dispose() {
    super.dispose(), kn().dispose(this.upper.el), delete this.upper, delete this.container;
  }
}
class fu extends Ca {
  constructor() {
    super(...arguments), j(this, "targets", []), j(this, "_hoveredTargets", []), j(this, "_objectsToRender", void 0), j(this, "_currentTransform", null), j(this, "_groupSelector", null), j(this, "contextTopDirty", !1);
  }
  static getDefaults() {
    return D(D({}, super.getDefaults()), fu.ownDefaults);
  }
  get upperCanvasEl() {
    var e;
    return (e = this.elements.upper) === null || e === void 0 ? void 0 : e.el;
  }
  get contextTop() {
    var e;
    return (e = this.elements.upper) === null || e === void 0 ? void 0 : e.ctx;
  }
  get wrapperEl() {
    return this.elements.container;
  }
  initElements(e) {
    this.elements = new h6(e, { allowTouchScrolling: this.allowTouchScrolling, containerClass: this.containerClass }), this._createCacheCanvas();
  }
  _onObjectAdded(e) {
    this._objectsToRender = void 0, super._onObjectAdded(e);
  }
  _onObjectRemoved(e) {
    this._objectsToRender = void 0, e === this._activeObject && (this.fire("before:selection:cleared", { deselected: [e] }), this._discardActiveObject(), this.fire("selection:cleared", { deselected: [e] }), e.fire("deselected", { target: e })), e === this._hoveredTarget && (this._hoveredTarget = void 0, this._hoveredTargets = []), super._onObjectRemoved(e);
  }
  _onStackOrderChanged() {
    this._objectsToRender = void 0, super._onStackOrderChanged();
  }
  _chooseObjectsToRender() {
    const e = this._activeObject;
    return !this.preserveObjectStacking && e ? this._objects.filter((t) => !t.group && t !== e).concat(e) : this._objects;
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || (!this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = !1), !this._objectsToRender && (this._objectsToRender = this._chooseObjectsToRender()), this.renderCanvas(this.getContext(), this._objectsToRender));
  }
  renderTopLayer(e) {
    e.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(e), this.contextTopDirty = !0), e.restore();
  }
  renderTop() {
    const e = this.contextTop;
    this.clearContext(e), this.renderTopLayer(e), this.fire("after:render", { ctx: e });
  }
  setTargetFindTolerance(e) {
    e = Math.round(e), this.targetFindTolerance = e;
    const t = this.getRetinaScaling(), n = Math.ceil((2 * e + 1) * t);
    this.pixelFindCanvasEl.width = this.pixelFindCanvasEl.height = n, this.pixelFindContext.scale(t, t);
  }
  isTargetTransparent(e, t, n) {
    const i = this.targetFindTolerance, s = this.pixelFindContext;
    this.clearContext(s), s.save(), s.translate(-t + i, -n + i), s.transform(...this.viewportTransform);
    const a = e.selectionBackgroundColor;
    e.selectionBackgroundColor = "", e.render(s), e.selectionBackgroundColor = a, s.restore();
    const c = Math.round(i * this.getRetinaScaling());
    return Dw(s, c, c, c);
  }
  _isSelectionKeyPressed(e) {
    const t = this.selectionKey;
    return !!t && (Array.isArray(t) ? !!t.find((n) => !!n && e[n] === !0) : e[t]);
  }
  _shouldClearSelection(e, t) {
    const n = this.getActiveObjects(), i = this._activeObject;
    return !!(!t || t && i && n.length > 1 && n.indexOf(t) === -1 && i !== t && !this._isSelectionKeyPressed(e) || t && !t.evented || t && !t.selectable && i && i !== t);
  }
  _shouldCenterTransform(e, t, n) {
    if (!e) return;
    let i;
    return t === ru || t === cr || t === Rr || t === ia ? i = this.centeredScaling || e.centeredScaling : t === tp && (i = this.centeredRotation || e.centeredRotation), i ? !n : n;
  }
  _getOriginFromCorner(e, t) {
    const n = { x: e.originX, y: e.originY };
    return t && (["ml", "tl", "bl"].includes(t) ? n.x = Tt : ["mr", "tr", "br"].includes(t) && (n.x = Ke), ["tl", "mt", "tr"].includes(t) ? n.y = Ud : ["bl", "mb", "br"].includes(t) && (n.y = br)), n;
  }
  _setupCurrentTransform(e, t, n) {
    var i;
    const s = t.group ? Gn(this.getScenePoint(e), void 0, t.group.calcTransformMatrix()) : this.getScenePoint(e), { key: a = "", control: c } = t.getActiveControl() || {}, u = n && c ? (i = c.getActionHandler(e, t, c)) === null || i === void 0 ? void 0 : i.bind(c) : hw, h = ((v, b, x, _) => {
      if (!b || !v) return "drag";
      const C = _.controls[b];
      return C.getActionName(x, C, _);
    })(n, a, e, t), d = e[this.centeredKey], p = this._shouldCenterTransform(t, h, d) ? { x: Pe, y: Pe } : this._getOriginFromCorner(t, a), g = { target: t, action: h, actionHandler: u, actionPerformed: !1, corner: a, scaleX: t.scaleX, scaleY: t.scaleY, skewX: t.skewX, skewY: t.skewY, offsetX: s.x - t.left, offsetY: s.y - t.top, originX: p.x, originY: p.y, ex: s.x, ey: s.y, lastX: s.x, lastY: s.y, theta: wt(t.angle), width: t.width, height: t.height, shiftKey: e.shiftKey, altKey: d, original: D(D({}, ap(t)), {}, { originX: p.x, originY: p.y }) };
    this._currentTransform = g, this.fire("before:transform", { e, transform: g });
  }
  setCursor(e) {
    this.upperCanvasEl.style.cursor = e;
  }
  _drawSelection(e) {
    const { x: t, y: n, deltaX: i, deltaY: s } = this._groupSelector, a = new B(t, n).transform(this.viewportTransform), c = new B(t + i, n + s).transform(this.viewportTransform), u = this.selectionLineWidth / 2;
    let h = Math.min(a.x, c.x), d = Math.min(a.y, c.y), p = Math.max(a.x, c.x), g = Math.max(a.y, c.y);
    this.selectionColor && (e.fillStyle = this.selectionColor, e.fillRect(h, d, p - h, g - d)), this.selectionLineWidth && this.selectionBorderColor && (e.lineWidth = this.selectionLineWidth, e.strokeStyle = this.selectionBorderColor, h += u, d += u, p -= u, g -= u, rt.prototype._setLineDash.call(this, e, this.selectionDashArray), e.strokeRect(h, d, p - h, g - d));
  }
  findTarget(e) {
    if (this.skipTargetFind) return;
    const t = this.getViewportPoint(e), n = this._activeObject, i = this.getActiveObjects();
    if (this.targets = [], n && i.length >= 1) {
      if (n.findControl(t, gl(e)) || i.length > 1 && this.searchPossibleTargets([n], t)) return n;
      if (n === this.searchPossibleTargets([n], t)) {
        if (this.preserveObjectStacking) {
          const s = this.targets;
          this.targets = [];
          const a = this.searchPossibleTargets(this._objects, t);
          return e[this.altSelectionKey] && a && a !== n ? (this.targets = s, n) : a;
        }
        return n;
      }
    }
    return this.searchPossibleTargets(this._objects, t);
  }
  _pointIsInObjectSelectionArea(e, t) {
    let n = e.getCoords();
    const i = this.getZoom(), s = e.padding / i;
    if (s) {
      const [a, c, u, h] = n, d = Math.atan2(c.y - a.y, c.x - a.x), p = un(d) * s, g = hn(d) * s, v = p + g, b = p - g;
      n = [new B(a.x - b, a.y - v), new B(c.x + v, c.y - b), new B(u.x + b, u.y + v), new B(h.x - v, h.y + b)];
    }
    return pt.isPointInPolygon(t, n);
  }
  _checkTarget(e, t) {
    return !!(e && e.visible && e.evented && this._pointIsInObjectSelectionArea(e, Gn(t, void 0, this.viewportTransform)) && (!this.perPixelTargetFind && !e.perPixelTargetFind || e.isEditing || !this.isTargetTransparent(e, t.x, t.y)));
  }
  _searchPossibleTargets(e, t) {
    let n = e.length;
    for (; n--; ) {
      const i = e[n];
      if (this._checkTarget(i, t)) {
        if (Qc(i) && i.subTargetCheck) {
          const s = this._searchPossibleTargets(i._objects, t);
          s && this.targets.push(s);
        }
        return i;
      }
    }
  }
  searchPossibleTargets(e, t) {
    const n = this._searchPossibleTargets(e, t);
    if (n && Qc(n) && n.interactive && this.targets[0]) {
      const i = this.targets;
      for (let s = i.length - 1; s > 0; s--) {
        const a = i[s];
        if (!Qc(a) || !a.interactive) return a;
      }
      return i[0];
    }
    return n;
  }
  getViewportPoint(e) {
    return this._pointer ? this._pointer : this.getPointer(e, !0);
  }
  getScenePoint(e) {
    return this._absolutePointer ? this._absolutePointer : this.getPointer(e);
  }
  getPointer(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    const n = this.upperCanvasEl, i = n.getBoundingClientRect();
    let s = sw(e), a = i.width || 0, c = i.height || 0;
    a && c || (br in i && Ud in i && (c = Math.abs(i.top - i.bottom)), Tt in i && Ke in i && (a = Math.abs(i.right - i.left))), this.calcOffset(), s.x = s.x - this._offset.left, s.y = s.y - this._offset.top, t || (s = Gn(s, void 0, this.viewportTransform));
    const u = this.getRetinaScaling();
    u !== 1 && (s.x /= u, s.y /= u);
    const h = a === 0 || c === 0 ? new B(1, 1) : new B(n.width / a, n.height / c);
    return s.multiply(h);
  }
  _setDimensionsImpl(e, t) {
    this._resetTransformEventData(), super._setDimensionsImpl(e, t), this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);
  }
  _createCacheCanvas() {
    this.pixelFindCanvasEl = Kr(), this.pixelFindContext = this.pixelFindCanvasEl.getContext("2d", { willReadFrequently: !0 }), this.setTargetFindTolerance(this.targetFindTolerance);
  }
  getTopContext() {
    return this.elements.upper.ctx;
  }
  getSelectionContext() {
    return this.elements.upper.ctx;
  }
  getSelectionElement() {
    return this.elements.upper.el;
  }
  getActiveObject() {
    return this._activeObject;
  }
  getActiveObjects() {
    const e = this._activeObject;
    return Yi(e) ? e.getObjects() : e ? [e] : [];
  }
  _fireSelectionEvents(e, t) {
    let n = !1, i = !1;
    const s = this.getActiveObjects(), a = [], c = [];
    e.forEach((u) => {
      s.includes(u) || (n = !0, u.fire("deselected", { e: t, target: u }), c.push(u));
    }), s.forEach((u) => {
      e.includes(u) || (n = !0, u.fire("selected", { e: t, target: u }), a.push(u));
    }), e.length > 0 && s.length > 0 ? (i = !0, n && this.fire("selection:updated", { e: t, selected: a, deselected: c })) : s.length > 0 ? (i = !0, this.fire("selection:created", { e: t, selected: a })) : e.length > 0 && (i = !0, this.fire("selection:cleared", { e: t, deselected: c })), i && (this._objectsToRender = void 0);
  }
  setActiveObject(e, t) {
    const n = this.getActiveObjects(), i = this._setActiveObject(e, t);
    return this._fireSelectionEvents(n, t), i;
  }
  _setActiveObject(e, t) {
    const n = this._activeObject;
    return n !== e && !(!this._discardActiveObject(t, e) && this._activeObject) && !e.onSelect({ e: t }) && (this._activeObject = e, Yi(e) && n !== e && e.set("canvas", this), e.setCoords(), !0);
  }
  _discardActiveObject(e, t) {
    const n = this._activeObject;
    return !!n && !n.onDeselect({ e, object: t }) && (this._currentTransform && this._currentTransform.target === n && this.endCurrentTransform(e), Yi(n) && n === this._hoveredTarget && (this._hoveredTarget = void 0), this._activeObject = void 0, !0);
  }
  discardActiveObject(e) {
    const t = this.getActiveObjects(), n = this.getActiveObject();
    t.length && this.fire("before:selection:cleared", { e, deselected: [n] });
    const i = this._discardActiveObject(e);
    return this._fireSelectionEvents(t, e), i;
  }
  endCurrentTransform(e) {
    const t = this._currentTransform;
    this._finalizeCurrentTransform(e), t && t.target && (t.target.isMoving = !1), this._currentTransform = null;
  }
  _finalizeCurrentTransform(e) {
    const t = this._currentTransform, n = t.target, i = { e, target: n, transform: t, action: t.action };
    n._scaling && (n._scaling = !1), n.setCoords(), t.actionPerformed && (this.fire("object:modified", i), n.fire(fl, i));
  }
  setViewportTransform(e) {
    super.setViewportTransform(e);
    const t = this._activeObject;
    t && t.setCoords();
  }
  destroy() {
    const e = this._activeObject;
    Yi(e) && (e.removeAll(), e.dispose()), delete this._activeObject, super.destroy(), this.pixelFindContext = null, this.pixelFindCanvasEl = void 0;
  }
  clear() {
    this.discardActiveObject(), this._activeObject = void 0, this.clearContext(this.contextTop), super.clear();
  }
  drawControls(e) {
    const t = this._activeObject;
    t && t._renderControls(e);
  }
  _toObject(e, t, n) {
    const i = this._realizeGroupTransformOnObject(e), s = super._toObject(e, t, n);
    return e.set(i), s;
  }
  _realizeGroupTransformOnObject(e) {
    const { group: t } = e;
    if (t && Yi(t) && this._activeObject === t) {
      const n = ps(e, ["angle", "flipX", "flipY", Ke, cr, Rr, uo, ho, br]);
      return ow(e, t.calcOwnMatrix()), n;
    }
    return {};
  }
  _setSVGObject(e, t, n) {
    const i = this._realizeGroupTransformOnObject(t);
    super._setSVGObject(e, t, n), t.set(i);
  }
}
j(fu, "ownDefaults", { uniformScaling: !0, uniScaleKey: "shiftKey", centeredScaling: !1, centeredRotation: !1, centeredKey: "altKey", altActionKey: "shiftKey", selection: !0, selectionKey: "shiftKey", selectionColor: "rgba(100, 100, 255, 0.3)", selectionDashArray: [], selectionBorderColor: "rgba(255, 255, 255, 0.3)", selectionLineWidth: 1, selectionFullyContained: !1, hoverCursor: "move", moveCursor: "move", defaultCursor: "default", freeDrawingCursor: "crosshair", notAllowedCursor: "not-allowed", perPixelTargetFind: !1, targetFindTolerance: 0, skipTargetFind: !1, stopContextMenu: !1, fireRightClick: !1, fireMiddleClick: !1, enablePointerEvents: !1, containerClass: "canvas-container", preserveObjectStacking: !1 });
class d6 {
  constructor(e) {
    j(this, "targets", []), j(this, "__disposer", void 0);
    const t = () => {
      const { hiddenTextarea: i } = e.getActiveObject() || {};
      i && i.focus();
    }, n = e.upperCanvasEl;
    n.addEventListener("click", t), this.__disposer = () => n.removeEventListener("click", t);
  }
  exitTextEditing() {
    this.target = void 0, this.targets.forEach((e) => {
      e.isEditing && e.exitEditing();
    });
  }
  add(e) {
    this.targets.push(e);
  }
  remove(e) {
    this.unregister(e), $i(this.targets, e);
  }
  register(e) {
    this.target = e;
  }
  unregister(e) {
    e === this.target && (this.target = void 0);
  }
  onMouseMove(e) {
    var t;
    !((t = this.target) === null || t === void 0) && t.isEditing && this.target.updateSelectionOnMouseMove(e);
  }
  clear() {
    this.targets = [], this.target = void 0;
  }
  dispose() {
    this.clear(), this.__disposer(), delete this.__disposer;
  }
}
const f6 = ["target", "oldTarget", "fireCanvas", "e"], Dr = { passive: !1 }, Fs = (r, e) => {
  const t = r.getViewportPoint(e), n = r.getScenePoint(e);
  return { viewportPoint: t, scenePoint: n, pointer: t, absolutePointer: n };
}, gi = function(r) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) t[n - 1] = arguments[n];
  return r.addEventListener(...t);
}, Yr = function(r) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) t[n - 1] = arguments[n];
  return r.removeEventListener(...t);
}, p6 = { mouse: { in: "over", out: "out", targetIn: "mouseover", targetOut: "mouseout", canvasIn: "mouse:over", canvasOut: "mouse:out" }, drag: { in: "enter", out: "leave", targetIn: "dragenter", targetOut: "dragleave", canvasIn: "drag:enter", canvasOut: "drag:leave" } };
class nf extends fu {
  constructor(e) {
    super(e, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}), j(this, "_isClick", void 0), j(this, "textEditingManager", new d6(this)), ["_onMouseDown", "_onTouchStart", "_onMouseMove", "_onMouseUp", "_onTouchEnd", "_onResize", "_onMouseWheel", "_onMouseOut", "_onMouseEnter", "_onContextMenu", "_onDoubleClick", "_onDragStart", "_onDragEnd", "_onDragProgress", "_onDragOver", "_onDragEnter", "_onDragLeave", "_onDrop"].forEach((t) => {
      this[t] = this[t].bind(this);
    }), this.addOrRemove(gi, "add");
  }
  _getEventPrefix() {
    return this.enablePointerEvents ? "pointer" : "mouse";
  }
  addOrRemove(e, t) {
    const n = this.upperCanvasEl, i = this._getEventPrefix();
    e(rw(n), "resize", this._onResize), e(n, i + "down", this._onMouseDown), e(n, "".concat(i, "move"), this._onMouseMove, Dr), e(n, "".concat(i, "out"), this._onMouseOut), e(n, "".concat(i, "enter"), this._onMouseEnter), e(n, "wheel", this._onMouseWheel), e(n, "contextmenu", this._onContextMenu), e(n, "dblclick", this._onDoubleClick), e(n, "dragstart", this._onDragStart), e(n, "dragend", this._onDragEnd), e(n, "dragover", this._onDragOver), e(n, "dragenter", this._onDragEnter), e(n, "dragleave", this._onDragLeave), e(n, "drop", this._onDrop), this.enablePointerEvents || e(n, "touchstart", this._onTouchStart, Dr);
  }
  removeListeners() {
    this.addOrRemove(Yr, "remove");
    const e = this._getEventPrefix(), t = an(this.upperCanvasEl);
    Yr(t, "".concat(e, "up"), this._onMouseUp), Yr(t, "touchend", this._onTouchEnd, Dr), Yr(t, "".concat(e, "move"), this._onMouseMove, Dr), Yr(t, "touchmove", this._onMouseMove, Dr), clearTimeout(this._willAddMouseDown);
  }
  _onMouseWheel(e) {
    this.__onMouseWheel(e);
  }
  _onMouseOut(e) {
    const t = this._hoveredTarget, n = D({ e }, Fs(this, e));
    this.fire("mouse:out", D(D({}, n), {}, { target: t })), this._hoveredTarget = void 0, t && t.fire("mouseout", D({}, n)), this._hoveredTargets.forEach((i) => {
      this.fire("mouse:out", D(D({}, n), {}, { target: i })), i && i.fire("mouseout", D({}, n));
    }), this._hoveredTargets = [];
  }
  _onMouseEnter(e) {
    this._currentTransform || this.findTarget(e) || (this.fire("mouse:over", D({ e }, Fs(this, e))), this._hoveredTarget = void 0, this._hoveredTargets = []);
  }
  _onDragStart(e) {
    this._isClick = !1;
    const t = this.getActiveObject();
    if (t && t.onDragStart(e)) {
      this._dragSource = t;
      const n = { e, target: t };
      return this.fire("dragstart", n), t.fire("dragstart", n), void gi(this.upperCanvasEl, "drag", this._onDragProgress);
    }
    Yd(e);
  }
  _renderDragEffects(e, t, n) {
    let i = !1;
    const s = this._dropTarget;
    s && s !== t && s !== n && (s.clearContextTop(), i = !0), t?.clearContextTop(), n !== t && n?.clearContextTop();
    const a = this.contextTop;
    a.save(), a.transform(...this.viewportTransform), t && (a.save(), t.transform(a), t.renderDragSourceEffect(e), a.restore(), i = !0), n && (a.save(), n.transform(a), n.renderDropTargetEffect(e), a.restore(), i = !0), a.restore(), i && (this.contextTopDirty = !0);
  }
  _onDragEnd(e) {
    const t = !!e.dataTransfer && e.dataTransfer.dropEffect !== wr, n = t ? this._activeObject : void 0, i = { e, target: this._dragSource, subTargets: this.targets, dragSource: this._dragSource, didDrop: t, dropTarget: n };
    Yr(this.upperCanvasEl, "drag", this._onDragProgress), this.fire("dragend", i), this._dragSource && this._dragSource.fire("dragend", i), delete this._dragSource, this._onMouseUp(e);
  }
  _onDragProgress(e) {
    const t = { e, target: this._dragSource, dragSource: this._dragSource, dropTarget: this._draggedoverTarget };
    this.fire("drag", t), this._dragSource && this._dragSource.fire("drag", t);
  }
  findDragTargets(e) {
    return this.targets = [], { target: this._searchPossibleTargets(this._objects, this.getViewportPoint(e)), targets: [...this.targets] };
  }
  _onDragOver(e) {
    const t = "dragover", { target: n, targets: i } = this.findDragTargets(e), s = this._dragSource, a = { e, target: n, subTargets: i, dragSource: s, canDrop: !1, dropTarget: void 0 };
    let c;
    this.fire(t, a), this._fireEnterLeaveEvents(n, a), n && (n.canDrop(e) && (c = n), n.fire(t, a));
    for (let u = 0; u < i.length; u++) {
      const h = i[u];
      h.canDrop(e) && (c = h), h.fire(t, a);
    }
    this._renderDragEffects(e, s, c), this._dropTarget = c;
  }
  _onDragEnter(e) {
    const { target: t, targets: n } = this.findDragTargets(e), i = { e, target: t, subTargets: n, dragSource: this._dragSource };
    this.fire("dragenter", i), this._fireEnterLeaveEvents(t, i);
  }
  _onDragLeave(e) {
    const t = { e, target: this._draggedoverTarget, subTargets: this.targets, dragSource: this._dragSource };
    this.fire("dragleave", t), this._fireEnterLeaveEvents(void 0, t), this._renderDragEffects(e, this._dragSource), this._dropTarget = void 0, this.targets = [], this._hoveredTargets = [];
  }
  _onDrop(e) {
    const { target: t, targets: n } = this.findDragTargets(e), i = this._basicEventHandler("drop:before", D({ e, target: t, subTargets: n, dragSource: this._dragSource }, Fs(this, e)));
    i.didDrop = !1, i.dropTarget = void 0, this._basicEventHandler("drop", i), this.fire("drop:after", i);
  }
  _onContextMenu(e) {
    const t = this.findTarget(e), n = this.targets || [], i = this._basicEventHandler("contextmenu:before", { e, target: t, subTargets: n });
    return this.stopContextMenu && Yd(e), this._basicEventHandler("contextmenu", i), !1;
  }
  _onDoubleClick(e) {
    this._cacheTransformEventData(e), this._handleEvent(e, "dblclick"), this._resetTransformEventData();
  }
  getPointerId(e) {
    const t = e.changedTouches;
    return t ? t[0] && t[0].identifier : this.enablePointerEvents ? e.pointerId : -1;
  }
  _isMainEvent(e) {
    return e.isPrimary === !0 || e.isPrimary !== !1 && (e.type === "touchend" && e.touches.length === 0 || !e.changedTouches || e.changedTouches[0].identifier === this.mainTouchId);
  }
  _onTouchStart(e) {
    let t = !this.allowTouchScrolling;
    const n = this._activeObject;
    this.mainTouchId === void 0 && (this.mainTouchId = this.getPointerId(e)), this.__onMouseDown(e), (this.isDrawingMode || n && this._target === n) && (t = !0), t && e.preventDefault(), this._resetTransformEventData();
    const i = this.upperCanvasEl, s = this._getEventPrefix(), a = an(i);
    gi(a, "touchend", this._onTouchEnd, Dr), t && gi(a, "touchmove", this._onMouseMove, Dr), Yr(i, "".concat(s, "down"), this._onMouseDown);
  }
  _onMouseDown(e) {
    this.__onMouseDown(e), this._resetTransformEventData();
    const t = this.upperCanvasEl, n = this._getEventPrefix();
    Yr(t, "".concat(n, "move"), this._onMouseMove, Dr);
    const i = an(t);
    gi(i, "".concat(n, "up"), this._onMouseUp), gi(i, "".concat(n, "move"), this._onMouseMove, Dr);
  }
  _onTouchEnd(e) {
    if (e.touches.length > 0) return;
    this.__onMouseUp(e), this._resetTransformEventData(), delete this.mainTouchId;
    const t = this._getEventPrefix(), n = an(this.upperCanvasEl);
    Yr(n, "touchend", this._onTouchEnd, Dr), Yr(n, "touchmove", this._onMouseMove, Dr), this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(() => {
      gi(this.upperCanvasEl, "".concat(t, "down"), this._onMouseDown), this._willAddMouseDown = 0;
    }, 400);
  }
  _onMouseUp(e) {
    this.__onMouseUp(e), this._resetTransformEventData();
    const t = this.upperCanvasEl, n = this._getEventPrefix();
    if (this._isMainEvent(e)) {
      const i = an(this.upperCanvasEl);
      Yr(i, "".concat(n, "up"), this._onMouseUp), Yr(i, "".concat(n, "move"), this._onMouseMove, Dr), gi(t, "".concat(n, "move"), this._onMouseMove, Dr);
    }
  }
  _onMouseMove(e) {
    const t = this.getActiveObject();
    !this.allowTouchScrolling && (!t || !t.shouldStartDragging(e)) && e.preventDefault && e.preventDefault(), this.__onMouseMove(e);
  }
  _onResize() {
    this.calcOffset(), this._resetTransformEventData();
  }
  _shouldRender(e) {
    const t = this.getActiveObject();
    return !!t != !!e || t && e && t !== e;
  }
  __onMouseUp(e) {
    var t;
    this._cacheTransformEventData(e), this._handleEvent(e, "up:before");
    const n = this._currentTransform, i = this._isClick, s = this._target, { button: a } = e;
    if (a) return (this.fireMiddleClick && a === 1 || this.fireRightClick && a === 2) && this._handleEvent(e, "up"), void this._resetTransformEventData();
    if (this.isDrawingMode && this._isCurrentlyDrawing) return void this._onMouseUpInDrawingMode(e);
    if (!this._isMainEvent(e)) return;
    let c, u, h = !1;
    if (n && (this._finalizeCurrentTransform(e), h = n.actionPerformed), !i) {
      const d = s === this._activeObject;
      this.handleSelection(e), h || (h = this._shouldRender(s) || !d && s === this._activeObject);
    }
    if (s) {
      const d = s.findControl(this.getViewportPoint(e), gl(e)), { key: p, control: g } = d || {};
      if (u = p, s.selectable && s !== this._activeObject && s.activeOn === "up") this.setActiveObject(s, e), h = !0;
      else if (g) {
        const v = g.getMouseUpHandler(e, s, g);
        v && (c = this.getScenePoint(e), v.call(g, e, n, c.x, c.y));
      }
      s.isMoving = !1;
    }
    if (n && (n.target !== s || n.corner !== u)) {
      const d = n.target && n.target.controls[n.corner], p = d && d.getMouseUpHandler(e, n.target, d);
      c = c || this.getScenePoint(e), p && p.call(d, e, n, c.x, c.y);
    }
    this._setCursorFromEvent(e, s), this._handleEvent(e, "up"), this._groupSelector = null, this._currentTransform = null, s && (s.__corner = void 0), h ? this.requestRenderAll() : i || (t = this._activeObject) !== null && t !== void 0 && t.isEditing || this.renderTop();
  }
  _basicEventHandler(e, t) {
    const { target: n, subTargets: i = [] } = t;
    this.fire(e, t), n && n.fire(e, t);
    for (let s = 0; s < i.length; s++) i[s] !== n && i[s].fire(e, t);
    return t;
  }
  _handleEvent(e, t) {
    const n = this._target, i = this.targets || [], s = D(D({ e, target: n, subTargets: i }, Fs(this, e)), {}, { transform: this._currentTransform }, t === "up:before" || t === "up" ? { isClick: this._isClick, currentTarget: this.findTarget(e), currentSubTargets: this.targets } : {});
    this.fire("mouse:".concat(t), s), n && n.fire("mouse".concat(t), s);
    for (let a = 0; a < i.length; a++) i[a] !== n && i[a].fire("mouse".concat(t), s);
  }
  _onMouseDownInDrawingMode(e) {
    this._isCurrentlyDrawing = !0, this.getActiveObject() && (this.discardActiveObject(e), this.requestRenderAll());
    const t = this.getScenePoint(e);
    this.freeDrawingBrush && this.freeDrawingBrush.onMouseDown(t, { e, pointer: t }), this._handleEvent(e, "down");
  }
  _onMouseMoveInDrawingMode(e) {
    if (this._isCurrentlyDrawing) {
      const t = this.getScenePoint(e);
      this.freeDrawingBrush && this.freeDrawingBrush.onMouseMove(t, { e, pointer: t });
    }
    this.setCursor(this.freeDrawingCursor), this._handleEvent(e, "move");
  }
  _onMouseUpInDrawingMode(e) {
    const t = this.getScenePoint(e);
    this.freeDrawingBrush ? this._isCurrentlyDrawing = !!this.freeDrawingBrush.onMouseUp({ e, pointer: t }) : this._isCurrentlyDrawing = !1, this._handleEvent(e, "up");
  }
  __onMouseDown(e) {
    this._isClick = !0, this._cacheTransformEventData(e), this._handleEvent(e, "down:before");
    let t = this._target;
    const { button: n } = e;
    if (n) return (this.fireMiddleClick && n === 1 || this.fireRightClick && n === 2) && this._handleEvent(e, "down"), void this._resetTransformEventData();
    if (this.isDrawingMode) return void this._onMouseDownInDrawingMode(e);
    if (!this._isMainEvent(e) || this._currentTransform) return;
    let i = this._shouldRender(t), s = !1;
    if (this.handleMultiSelection(e, t) ? (t = this._activeObject, s = !0, i = !0) : this._shouldClearSelection(e, t) && this.discardActiveObject(e), this.selection && (!t || !t.selectable && !t.isEditing && t !== this._activeObject)) {
      const a = this.getScenePoint(e);
      this._groupSelector = { x: a.x, y: a.y, deltaY: 0, deltaX: 0 };
    }
    if (t) {
      const a = t === this._activeObject;
      t.selectable && t.activeOn === "down" && this.setActiveObject(t, e);
      const c = t.findControl(this.getViewportPoint(e), gl(e));
      if (t === this._activeObject && (c || !s)) {
        this._setupCurrentTransform(e, t, a);
        const u = c ? c.control : void 0, h = this.getScenePoint(e), d = u && u.getMouseDownHandler(e, t, u);
        d && d.call(u, e, this._currentTransform, h.x, h.y);
      }
    }
    i && (this._objectsToRender = void 0), this._handleEvent(e, "down"), i && this.requestRenderAll();
  }
  _resetTransformEventData() {
    this._target = this._pointer = this._absolutePointer = void 0;
  }
  _cacheTransformEventData(e) {
    this._resetTransformEventData(), this._pointer = this.getViewportPoint(e), this._absolutePointer = Gn(this._pointer, void 0, this.viewportTransform), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e);
  }
  __onMouseMove(e) {
    if (this._isClick = !1, this._cacheTransformEventData(e), this._handleEvent(e, "move:before"), this.isDrawingMode) return void this._onMouseMoveInDrawingMode(e);
    if (!this._isMainEvent(e)) return;
    const t = this._groupSelector;
    if (t) {
      const n = this.getScenePoint(e);
      t.deltaX = n.x - t.x, t.deltaY = n.y - t.y, this.renderTop();
    } else if (this._currentTransform) this._transformObject(e);
    else {
      const n = this.findTarget(e);
      this._setCursorFromEvent(e, n), this._fireOverOutEvents(e, n);
    }
    this.textEditingManager.onMouseMove(e), this._handleEvent(e, "move"), this._resetTransformEventData();
  }
  _fireOverOutEvents(e, t) {
    const n = this._hoveredTarget, i = this._hoveredTargets, s = this.targets, a = Math.max(i.length, s.length);
    this.fireSyntheticInOutEvents("mouse", { e, target: t, oldTarget: n, fireCanvas: !0 });
    for (let c = 0; c < a; c++) this.fireSyntheticInOutEvents("mouse", { e, target: s[c], oldTarget: i[c] });
    this._hoveredTarget = t, this._hoveredTargets = this.targets.concat();
  }
  _fireEnterLeaveEvents(e, t) {
    const n = this._draggedoverTarget, i = this._hoveredTargets, s = this.targets, a = Math.max(i.length, s.length);
    this.fireSyntheticInOutEvents("drag", D(D({}, t), {}, { target: e, oldTarget: n, fireCanvas: !0 }));
    for (let c = 0; c < a; c++) this.fireSyntheticInOutEvents("drag", D(D({}, t), {}, { target: s[c], oldTarget: i[c] }));
    this._draggedoverTarget = e;
  }
  fireSyntheticInOutEvents(e, t) {
    let { target: n, oldTarget: i, fireCanvas: s, e: a } = t, c = ht(t, f6);
    const { targetIn: u, targetOut: h, canvasIn: d, canvasOut: p } = p6[e], g = i !== n;
    if (i && g) {
      const v = D(D({}, c), {}, { e: a, target: i, nextTarget: n }, Fs(this, a));
      s && this.fire(p, v), i.fire(h, v);
    }
    if (n && g) {
      const v = D(D({}, c), {}, { e: a, target: n, previousTarget: i }, Fs(this, a));
      s && this.fire(d, v), n.fire(u, v);
    }
  }
  __onMouseWheel(e) {
    this._cacheTransformEventData(e), this._handleEvent(e, "wheel"), this._resetTransformEventData();
  }
  _transformObject(e) {
    const t = this.getScenePoint(e), n = this._currentTransform, i = n.target, s = i.group ? Gn(t, void 0, i.group.calcTransformMatrix()) : t;
    n.shiftKey = e.shiftKey, n.altKey = !!this.centeredKey && e[this.centeredKey], this._performTransformAction(e, n, s), n.actionPerformed && this.requestRenderAll();
  }
  _performTransformAction(e, t, n) {
    const { action: i, actionHandler: s, target: a } = t, c = !!s && s(e, t, n.x, n.y);
    c && a.setCoords(), i === "drag" && c && (t.target.isMoving = !0, this.setCursor(t.target.moveCursor || this.moveCursor)), t.actionPerformed = t.actionPerformed || c;
  }
  _setCursorFromEvent(e, t) {
    if (!t) return void this.setCursor(this.defaultCursor);
    let n = t.hoverCursor || this.hoverCursor;
    const i = Yi(this._activeObject) ? this._activeObject : null, s = (!i || t.group !== i) && t.findControl(this.getViewportPoint(e));
    if (s) {
      const a = s.control;
      this.setCursor(a.cursorStyleHandler(e, a, t));
    } else t.subTargetCheck && this.targets.concat().reverse().map((a) => {
      n = a.hoverCursor || n;
    }), this.setCursor(n);
  }
  handleMultiSelection(e, t) {
    const n = this._activeObject, i = Yi(n);
    if (n && this._isSelectionKeyPressed(e) && this.selection && t && t.selectable && (n !== t || i) && (i || !t.isDescendantOf(n) && !n.isDescendantOf(t)) && !t.onSelect({ e }) && !n.getActiveControl()) {
      if (i) {
        const s = n.getObjects();
        if (t === n) {
          const a = this.getViewportPoint(e);
          if (!(t = this.searchPossibleTargets(s, a) || this.searchPossibleTargets(this._objects, a)) || !t.selectable) return !1;
        }
        t.group === n ? (n.remove(t), this._hoveredTarget = t, this._hoveredTargets = [...this.targets], n.size() === 1 && this._setActiveObject(n.item(0), e)) : (n.multiSelectAdd(t), this._hoveredTarget = n, this._hoveredTargets = [...this.targets]), this._fireSelectionEvents(s, e);
      } else {
        n.isEditing && n.exitEditing();
        const s = new (ne.getClass("ActiveSelection"))([], { canvas: this });
        s.multiSelectAdd(n, t), this._hoveredTarget = s, this._setActiveObject(s, e), this._fireSelectionEvents([n], e);
      }
      return !0;
    }
    return !1;
  }
  handleSelection(e) {
    if (!this.selection || !this._groupSelector) return !1;
    const { x: t, y: n, deltaX: i, deltaY: s } = this._groupSelector, a = new B(t, n), c = a.add(new B(i, s)), u = a.min(c), h = a.max(c).subtract(u), d = this.collectObjects({ left: u.x, top: u.y, width: h.x, height: h.y }, { includeIntersecting: !this.selectionFullyContained }), p = a.eq(c) ? d[0] ? [d[0]] : [] : d.length > 1 ? d.filter((g) => !g.onSelect({ e })).reverse() : d;
    if (p.length === 1) this.setActiveObject(p[0], e);
    else if (p.length > 1) {
      const g = ne.getClass("ActiveSelection");
      this.setActiveObject(new g(p, { canvas: this }), e);
    }
    return this._groupSelector = null, !0;
  }
  clear() {
    this.textEditingManager.clear(), super.clear();
  }
  destroy() {
    this.removeListeners(), this.textEditingManager.dispose(), super.destroy();
  }
}
const Qw = { x1: 0, y1: 0, x2: 0, y2: 0 }, g6 = D(D({}, Qw), {}, { r1: 0, r2: 0 }), Vs = (r, e) => isNaN(r) && typeof e == "number" ? e : r, m6 = /^(\d+\.\d+)%|(\d+)%$/;
function ex(r) {
  return r && m6.test(r);
}
function tx(r, e) {
  const t = typeof r == "number" ? r : typeof r == "string" ? parseFloat(r) / (ex(r) ? 100 : 1) : NaN;
  return ns(0, Vs(t, e), 1);
}
const v6 = /\s*;\s*/, y6 = /\s*:\s*/;
function b6(r, e) {
  let t, n;
  const i = r.getAttribute("style");
  if (i) {
    const a = i.split(v6);
    a[a.length - 1] === "" && a.pop();
    for (let c = a.length; c--; ) {
      const [u, h] = a[c].split(y6).map((d) => d.trim());
      u === "stop-color" ? t = h : u === "stop-opacity" && (n = h);
    }
  }
  const s = new Qe(t || r.getAttribute("stop-color") || "rgb(0,0,0)");
  return { offset: tx(r.getAttribute("offset"), 0), color: s.toRgb(), opacity: Vs(parseFloat(n || r.getAttribute("stop-opacity") || ""), 1) * s.getAlpha() * e };
}
function w6(r, e) {
  const t = [], n = r.getElementsByTagName("stop"), i = tx(e, 1);
  for (let s = n.length; s--; ) t.push(b6(n[s], i));
  return t;
}
function rx(r) {
  return r.nodeName === "linearGradient" || r.nodeName === "LINEARGRADIENT" ? "linear" : "radial";
}
function nx(r) {
  return r.getAttribute("gradientUnits") === "userSpaceOnUse" ? "pixels" : "percentage";
}
function sn(r, e) {
  return r.getAttribute(e);
}
function x6(r, e) {
  return function(t, n) {
    let i, { width: s, height: a, gradientUnits: c } = n;
    return Object.keys(t).reduce((u, h) => {
      const d = t[h];
      return d === "Infinity" ? i = 1 : d === "-Infinity" ? i = 0 : (i = typeof d == "string" ? parseFloat(d) : d, typeof d == "string" && ex(d) && (i *= 0.01, c === "pixels" && (h !== "x1" && h !== "x2" && h !== "r2" || (i *= s), h !== "y1" && h !== "y2" || (i *= a)))), u[h] = i, u;
    }, {});
  }(rx(r) === "linear" ? function(t) {
    return { x1: sn(t, "x1") || 0, y1: sn(t, "y1") || 0, x2: sn(t, "x2") || "100%", y2: sn(t, "y2") || 0 };
  }(r) : function(t) {
    return { x1: sn(t, "fx") || sn(t, "cx") || "50%", y1: sn(t, "fy") || sn(t, "cy") || "50%", r1: 0, x2: sn(t, "cx") || "50%", y2: sn(t, "cy") || "50%", r2: sn(t, "r") || "50%" };
  }(r), D(D({}, e), {}, { gradientUnits: nx(r) }));
}
class kc {
  constructor(e) {
    const { type: t = "linear", gradientUnits: n = "pixels", coords: i = {}, colorStops: s = [], offsetX: a = 0, offsetY: c = 0, gradientTransform: u, id: h } = e || {};
    Object.assign(this, { type: t, gradientUnits: n, coords: D(D({}, t === "radial" ? g6 : Qw), i), colorStops: s, offsetX: a, offsetY: c, gradientTransform: u, id: h ? "".concat(h, "_").concat(wi()) : wi() });
  }
  addColorStop(e) {
    for (const t in e) {
      const n = new Qe(e[t]);
      this.colorStops.push({ offset: parseFloat(t), color: n.toRgb(), opacity: n.getAlpha() });
    }
    return this;
  }
  toObject(e) {
    return D(D({}, ps(this, e)), {}, { type: this.type, coords: D({}, this.coords), colorStops: this.colorStops.map((t) => D({}, t)), offsetX: this.offsetX, offsetY: this.offsetY, gradientUnits: this.gradientUnits, gradientTransform: this.gradientTransform ? [...this.gradientTransform] : void 0 });
  }
  toSVG(e) {
    let { additionalTransform: t } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = [], i = this.gradientTransform ? this.gradientTransform.concat() : ar.concat(), s = this.gradientUnits === "pixels" ? "userSpaceOnUse" : "objectBoundingBox", a = this.colorStops.map((p) => D({}, p)).sort((p, g) => p.offset - g.offset);
    let c = -this.offsetX, u = -this.offsetY;
    var h;
    s === "objectBoundingBox" ? (c /= e.width, u /= e.height) : (c += e.width / 2, u += e.height / 2), (h = e) && typeof h._renderPathCommands == "function" && this.gradientUnits !== "percentage" && (c -= e.pathOffset.x, u -= e.pathOffset.y), i[4] -= c, i[5] -= u;
    const d = ['id="SVGID_'.concat(this.id, '"'), 'gradientUnits="'.concat(s, '"'), 'gradientTransform="'.concat(t ? t + " " : "").concat(sa(i), '"'), ""].join(" ");
    if (this.type === "linear") {
      const { x1: p, y1: g, x2: v, y2: b } = this.coords;
      n.push("<linearGradient ", d, ' x1="', p, '" y1="', g, '" x2="', v, '" y2="', b, `">
`);
    } else if (this.type === "radial") {
      const { x1: p, y1: g, x2: v, y2: b, r1: x, r2: _ } = this.coords, C = x > _;
      n.push("<radialGradient ", d, ' cx="', C ? p : v, '" cy="', C ? g : b, '" r="', C ? x : _, '" fx="', C ? v : p, '" fy="', C ? b : g, `">
`), C && (a.reverse(), a.forEach((k) => {
        k.offset = 1 - k.offset;
      }));
      const E = Math.min(x, _);
      if (E > 0) {
        const k = E / Math.max(x, _);
        a.forEach((O) => {
          O.offset += k * (1 - O.offset);
        });
      }
    }
    return a.forEach((p) => {
      let { color: g, offset: v, opacity: b } = p;
      n.push("<stop ", 'offset="', 100 * v + "%", '" style="stop-color:', g, b !== void 0 ? ";stop-opacity: " + b : ";", `"/>
`);
    }), n.push(this.type === "linear" ? "</linearGradient>" : "</radialGradient>", `
`), n.join("");
  }
  toLive(e) {
    const { x1: t, y1: n, x2: i, y2: s, r1: a, r2: c } = this.coords, u = this.type === "linear" ? e.createLinearGradient(t, n, i, s) : e.createRadialGradient(t, n, a, i, s, c);
    return this.colorStops.forEach((h) => {
      let { color: d, opacity: p, offset: g } = h;
      u.addColorStop(g, p !== void 0 ? new Qe(d).setAlpha(p).toRgba() : d);
    }), u;
  }
  static async fromObject(e) {
    const { colorStops: t, gradientTransform: n } = e;
    return new this(D(D({}, e), {}, { colorStops: t ? t.map((i) => D({}, i)) : void 0, gradientTransform: n ? [...n] : void 0 }));
  }
  static fromElement(e, t, n) {
    const i = nx(e), s = t._findCenterFromElement();
    return new this(D({ id: e.getAttribute("id") || void 0, type: rx(e), coords: x6(e, { width: n.viewBoxWidth || n.width, height: n.viewBoxHeight || n.height }), colorStops: w6(e, n.opacity), gradientUnits: i, gradientTransform: Qd(e.getAttribute("gradientTransform") || "") }, i === "pixels" ? { offsetX: t.width / 2 - s.x, offsetY: t.height / 2 - s.y } : { offsetX: 0, offsetY: 0 }));
  }
}
j(kc, "type", "Gradient"), ne.setClass(kc, "gradient"), ne.setClass(kc, "linear"), ne.setClass(kc, "radial");
const _6 = ["type", "source", "patternTransform"];
class Jh {
  get type() {
    return "pattern";
  }
  set type(e) {
    yi("warn", "Setting type has no effect", e);
  }
  constructor(e) {
    j(this, "repeat", "repeat"), j(this, "offsetX", 0), j(this, "offsetY", 0), j(this, "crossOrigin", ""), this.id = wi(), Object.assign(this, e);
  }
  isImageSource() {
    return !!this.source && typeof this.source.src == "string";
  }
  isCanvasSource() {
    return !!this.source && !!this.source.toDataURL;
  }
  sourceToString() {
    return this.isImageSource() ? this.source.src : this.isCanvasSource() ? this.source.toDataURL() : "";
  }
  toLive(e) {
    return this.source && (!this.isImageSource() || this.source.complete && this.source.naturalWidth !== 0 && this.source.naturalHeight !== 0) ? e.createPattern(this.source, this.repeat) : null;
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const { repeat: t, crossOrigin: n } = this;
    return D(D({}, ps(this, e)), {}, { type: "pattern", source: this.sourceToString(), repeat: t, crossOrigin: n, offsetX: ut(this.offsetX, Ue.NUM_FRACTION_DIGITS), offsetY: ut(this.offsetY, Ue.NUM_FRACTION_DIGITS), patternTransform: this.patternTransform ? [...this.patternTransform] : null });
  }
  toSVG(e) {
    let { width: t, height: n } = e;
    const { source: i, repeat: s, id: a } = this, c = Vs(this.offsetX / t, 0), u = Vs(this.offsetY / n, 0), h = s === "repeat-y" || s === "no-repeat" ? 1 + Math.abs(c || 0) : Vs(i.width / t, 0), d = s === "repeat-x" || s === "no-repeat" ? 1 + Math.abs(u || 0) : Vs(i.height / n, 0);
    return ['<pattern id="SVGID_'.concat(a, '" x="').concat(c, '" y="').concat(u, '" width="').concat(h, '" height="').concat(d, '">'), '<image x="0" y="0" width="'.concat(i.width, '" height="').concat(i.height, '" xlink:href="').concat(this.sourceToString(), '"></image>'), "</pattern>", ""].join(`
`);
  }
  static async fromObject(e, t) {
    let { type: n, source: i, patternTransform: s } = e, a = ht(e, _6);
    const c = await Zo(i, D(D({}, t), {}, { crossOrigin: a.crossOrigin }));
    return new this(D(D({}, a), {}, { patternTransform: s && s.slice(0), source: c }));
  }
}
j(Jh, "type", "Pattern"), ne.setClass(Jh), ne.setClass(Jh, "pattern");
const S6 = ["path", "left", "top"], C6 = ["d"];
class Xi extends rt {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { path: n, left: i, top: s } = t, a = ht(t, S6);
    super(), Object.assign(this, Xi.ownDefaults), this.setOptions(a), this._setPath(e || [], !0), typeof i == "number" && this.set(Ke, i), typeof s == "number" && this.set(br, s);
  }
  _setPath(e, t) {
    this.path = Uw(Array.isArray(e) ? e : Kw(e)), this.setBoundingBox(t);
  }
  _findCenterFromElement() {
    const e = this._calcBoundsFromPath();
    return new B(e.left + e.width / 2, e.top + e.height / 2);
  }
  _renderPathCommands(e) {
    const t = -this.pathOffset.x, n = -this.pathOffset.y;
    e.beginPath();
    for (const i of this.path) switch (i[0]) {
      case "L":
        e.lineTo(i[1] + t, i[2] + n);
        break;
      case "M":
        e.moveTo(i[1] + t, i[2] + n);
        break;
      case "C":
        e.bezierCurveTo(i[1] + t, i[2] + n, i[3] + t, i[4] + n, i[5] + t, i[6] + n);
        break;
      case "Q":
        e.quadraticCurveTo(i[1] + t, i[2] + n, i[3] + t, i[4] + n);
        break;
      case "Z":
        e.closePath();
    }
  }
  _render(e) {
    this._renderPathCommands(e), this._renderPaintInOrder(e);
  }
  toString() {
    return "#<Path (".concat(this.complexity(), '): { "top": ').concat(this.top, ', "left": ').concat(this.left, " }>");
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return D(D({}, super.toObject(e)), {}, { path: this.path.map((t) => t.slice()) });
  }
  toDatalessObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = this.toObject(e);
    return this.sourcePath && (delete t.path, t.sourcePath = this.sourcePath), t;
  }
  _toSVG() {
    const e = Zw(this.path, Ue.NUM_FRACTION_DIGITS);
    return ["<path ", "COMMON_PARTS", 'd="'.concat(e, `" stroke-linecap="round" />
`)];
  }
  _getOffsetTransform() {
    const e = Ue.NUM_FRACTION_DIGITS;
    return " translate(".concat(ut(-this.pathOffset.x, e), ", ").concat(ut(-this.pathOffset.y, e), ")");
  }
  toClipPathSVG(e) {
    const t = this._getOffsetTransform();
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(), { reviver: e, additionalTransform: t });
  }
  toSVG(e) {
    const t = this._getOffsetTransform();
    return this._createBaseSVGMarkup(this._toSVG(), { reviver: e, additionalTransform: t });
  }
  complexity() {
    return this.path.length;
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(e) {
    const { width: t, height: n, pathOffset: i } = this._calcDimensions();
    this.set({ width: t, height: n, pathOffset: i }), e && this.setPositionByOrigin(i, Pe, Pe);
  }
  _calcBoundsFromPath() {
    const e = [];
    let t = 0, n = 0, i = 0, s = 0;
    for (const a of this.path) switch (a[0]) {
      case "L":
        i = a[1], s = a[2], e.push({ x: t, y: n }, { x: i, y: s });
        break;
      case "M":
        i = a[1], s = a[2], t = i, n = s;
        break;
      case "C":
        e.push(...rf(i, s, a[1], a[2], a[3], a[4], a[5], a[6])), i = a[5], s = a[6];
        break;
      case "Q":
        e.push(...rf(i, s, a[1], a[2], a[1], a[2], a[3], a[4])), i = a[3], s = a[4];
        break;
      case "Z":
        i = t, s = n;
    }
    return Tn(e);
  }
  _calcDimensions() {
    const e = this._calcBoundsFromPath();
    return D(D({}, e), {}, { pathOffset: new B(e.left + e.width / 2, e.top + e.height / 2) });
  }
  static fromObject(e) {
    return this._fromObject(e, { extraParam: "path" });
  }
  static async fromElement(e, t, n) {
    const i = ti(e, this.ATTRIBUTE_NAMES, n), { d: s } = i;
    return new this(s, D(D(D({}, ht(i, C6)), t), {}, { left: void 0, top: void 0 }));
  }
}
j(Xi, "type", "Path"), j(Xi, "cacheProperties", [...ei, "path", "fillRule"]), j(Xi, "ATTRIBUTE_NAMES", [...Ai, "d"]), ne.setClass(Xi), ne.setSVGClass(Xi);
const T6 = ["left", "top", "radius"], ix = ["radius", "startAngle", "endAngle", "counterClockwise"];
class Hn extends rt {
  static getDefaults() {
    return D(D({}, super.getDefaults()), Hn.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, Hn.ownDefaults), this.setOptions(e);
  }
  _set(e, t) {
    return super._set(e, t), e === "radius" && this.setRadius(t), this;
  }
  _render(e) {
    e.beginPath(), e.arc(0, 0, this.radius, wt(this.startAngle), wt(this.endAngle), this.counterClockwise), this._renderPaintInOrder(e);
  }
  getRadiusX() {
    return this.get("radius") * this.get(cr);
  }
  getRadiusY() {
    return this.get("radius") * this.get(Rr);
  }
  setRadius(e) {
    this.radius = e, this.set({ width: 2 * e, height: 2 * e });
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...ix, ...e]);
  }
  _toSVG() {
    const e = (this.endAngle - this.startAngle) % 360;
    if (e === 0) return ["<circle ", "COMMON_PARTS", 'cx="0" cy="0" ', 'r="', "".concat(this.radius), `" />
`];
    {
      const { radius: t } = this, n = wt(this.startAngle), i = wt(this.endAngle), s = un(n) * t, a = hn(n) * t, c = un(i) * t, u = hn(i) * t, h = e > 180 ? 1 : 0, d = this.counterClockwise ? 0 : 1;
      return ['<path d="M '.concat(s, " ").concat(a, " A ").concat(t, " ").concat(t, " 0 ").concat(h, " ").concat(d, " ").concat(c, " ").concat(u, '" '), "COMMON_PARTS", ` />
`];
    }
  }
  static async fromElement(e, t, n) {
    const i = ti(e, this.ATTRIBUTE_NAMES, n), { left: s = 0, top: a = 0, radius: c = 0 } = i;
    return new this(D(D({}, ht(i, T6)), {}, { radius: c, left: s - c, top: a - c }));
  }
  static fromObject(e) {
    return super._fromObject(e);
  }
}
j(Hn, "type", "Circle"), j(Hn, "cacheProperties", [...ei, ...ix]), j(Hn, "ownDefaults", { radius: 0, startAngle: 0, endAngle: 360, counterClockwise: !1 }), j(Hn, "ATTRIBUTE_NAMES", ["cx", "cy", "r", ...Ai]), ne.setClass(Hn), ne.setSVGClass(Hn);
const E6 = ["x1", "y1", "x2", "y2"], k6 = ["x1", "y1", "x2", "y2"], sf = ["x1", "x2", "y1", "y2"];
class Gi extends rt {
  constructor() {
    let [e, t, n, i] = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0, 0], s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, Gi.ownDefaults), this.setOptions(s), this.x1 = e, this.x2 = n, this.y1 = t, this.y2 = i, this._setWidthHeight();
    const { left: a, top: c } = s;
    typeof a == "number" && this.set(Ke, a), typeof c == "number" && this.set(br, c);
  }
  _setWidthHeight() {
    const { x1: e, y1: t, x2: n, y2: i } = this;
    this.width = Math.abs(n - e), this.height = Math.abs(i - t);
    const { left: s, top: a, width: c, height: u } = Tn([{ x: e, y: t }, { x: n, y: i }]), h = new B(s + c / 2, a + u / 2);
    this.setPositionByOrigin(h, Pe, Pe);
  }
  _set(e, t) {
    return super._set(e, t), sf.includes(e) && this._setWidthHeight(), this;
  }
  _render(e) {
    e.beginPath();
    const t = this.calcLinePoints();
    e.moveTo(t.x1, t.y1), e.lineTo(t.x2, t.y2), e.lineWidth = this.strokeWidth;
    const n = e.strokeStyle;
    var i;
    Gr(this.stroke) ? e.strokeStyle = this.stroke.toLive(e) : e.strokeStyle = (i = this.stroke) !== null && i !== void 0 ? i : e.fillStyle, this.stroke && this._renderStroke(e), e.strokeStyle = n;
  }
  _findCenterFromElement() {
    return new B((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return D(D({}, super.toObject(e)), this.calcLinePoints());
  }
  _getNonTransformedDimensions() {
    const e = super._getNonTransformedDimensions();
    return this.strokeLineCap === "butt" && (this.width === 0 && (e.y -= this.strokeWidth), this.height === 0 && (e.x -= this.strokeWidth)), e;
  }
  calcLinePoints() {
    const { x1: e, x2: t, y1: n, y2: i, width: s, height: a } = this, c = e <= t ? -1 : 1, u = n <= i ? -1 : 1;
    return { x1: c * s / 2, x2: c * -s / 2, y1: u * a / 2, y2: u * -a / 2 };
  }
  _toSVG() {
    const { x1: e, x2: t, y1: n, y2: i } = this.calcLinePoints();
    return ["<line ", "COMMON_PARTS", 'x1="'.concat(e, '" y1="').concat(n, '" x2="').concat(t, '" y2="').concat(i, `" />
`)];
  }
  static async fromElement(e, t, n) {
    const i = ti(e, this.ATTRIBUTE_NAMES, n), { x1: s = 0, y1: a = 0, x2: c = 0, y2: u = 0 } = i;
    return new this([s, a, c, u], ht(i, E6));
  }
  static fromObject(e) {
    let { x1: t, y1: n, x2: i, y2: s } = e, a = ht(e, k6);
    return this._fromObject(D(D({}, a), {}, { points: [t, n, i, s] }), { extraParam: "points" });
  }
}
j(Gi, "type", "Line"), j(Gi, "cacheProperties", [...ei, ...sf]), j(Gi, "ATTRIBUTE_NAMES", Ai.concat(sf)), ne.setClass(Gi), ne.setSVGClass(Gi);
class Zi extends rt {
  static getDefaults() {
    return D(D({}, super.getDefaults()), Zi.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, Zi.ownDefaults), this.setOptions(e);
  }
  _render(e) {
    const t = this.width / 2, n = this.height / 2;
    e.beginPath(), e.moveTo(-t, n), e.lineTo(0, -n), e.lineTo(t, n), e.closePath(), this._renderPaintInOrder(e);
  }
  _toSVG() {
    const e = this.width / 2, t = this.height / 2;
    return ["<polygon ", "COMMON_PARTS", 'points="', "".concat(-e, " ").concat(t, ",0 ").concat(-t, ",").concat(e, " ").concat(t), '" />'];
  }
}
j(Zi, "type", "Triangle"), j(Zi, "ownDefaults", { width: 100, height: 100 }), ne.setClass(Zi), ne.setSVGClass(Zi);
const sx = ["rx", "ry"];
class Un extends rt {
  static getDefaults() {
    return D(D({}, super.getDefaults()), Un.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, Un.ownDefaults), this.setOptions(e);
  }
  _set(e, t) {
    switch (super._set(e, t), e) {
      case "rx":
        this.rx = t, this.set("width", 2 * t);
        break;
      case "ry":
        this.ry = t, this.set("height", 2 * t);
    }
    return this;
  }
  getRx() {
    return this.get("rx") * this.get(cr);
  }
  getRy() {
    return this.get("ry") * this.get(Rr);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...sx, ...e]);
  }
  _toSVG() {
    return ["<ellipse ", "COMMON_PARTS", 'cx="0" cy="0" rx="'.concat(this.rx, '" ry="').concat(this.ry, `" />
`)];
  }
  _render(e) {
    e.beginPath(), e.save(), e.transform(1, 0, 0, this.ry / this.rx, 0, 0), e.arc(0, 0, this.rx, 0, Qn, !1), e.restore(), this._renderPaintInOrder(e);
  }
  static async fromElement(e, t, n) {
    const i = ti(e, this.ATTRIBUTE_NAMES, n);
    return i.left = (i.left || 0) - i.rx, i.top = (i.top || 0) - i.ry, new this(i);
  }
}
function O6(r) {
  if (!r) return [];
  const e = r.replace(/,/g, " ").trim().split(/\s+/), t = [];
  for (let n = 0; n < e.length; n += 2) t.push({ x: parseFloat(e[n]), y: parseFloat(e[n + 1]) });
  return t;
}
j(Un, "type", "Ellipse"), j(Un, "cacheProperties", [...ei, ...sx]), j(Un, "ownDefaults", { rx: 0, ry: 0 }), j(Un, "ATTRIBUTE_NAMES", [...Ai, "cx", "cy", "rx", "ry"]), ne.setClass(Un), ne.setSVGClass(Un);
const I6 = ["left", "top"], ox = { exactBoundingBox: !1 };
class on extends rt {
  static getDefaults() {
    return D(D({}, super.getDefaults()), on.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), j(this, "strokeDiff", void 0), Object.assign(this, on.ownDefaults), this.setOptions(t), this.points = e;
    const { left: n, top: i } = t;
    this.initialized = !0, this.setBoundingBox(!0), typeof n == "number" && this.set(Ke, n), typeof i == "number" && this.set(br, i);
  }
  isOpen() {
    return !0;
  }
  _projectStrokeOnPoints(e) {
    return Rw(this.points, e, this.isOpen());
  }
  _calcDimensions(e) {
    e = D({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, strokeLineCap: this.strokeLineCap, strokeLineJoin: this.strokeLineJoin, strokeMiterLimit: this.strokeMiterLimit, strokeUniform: this.strokeUniform, strokeWidth: this.strokeWidth }, e || {});
    const t = this.exactBoundingBox ? this._projectStrokeOnPoints(e).map((h) => h.projectedPoint) : this.points;
    if (t.length === 0) return { left: 0, top: 0, width: 0, height: 0, pathOffset: new B(), strokeOffset: new B(), strokeDiff: new B() };
    const n = Tn(t), i = _a(D(D({}, e), {}, { scaleX: 1, scaleY: 1 })), s = Tn(this.points.map((h) => Kt(h, i, !0))), a = new B(this.scaleX, this.scaleY);
    let c = n.left + n.width / 2, u = n.top + n.height / 2;
    return this.exactBoundingBox && (c -= u * Math.tan(wt(this.skewX)), u -= c * Math.tan(wt(this.skewY))), D(D({}, n), {}, { pathOffset: new B(c, u), strokeOffset: new B(s.left, s.top).subtract(new B(n.left, n.top)).multiply(a), strokeDiff: new B(n.width, n.height).subtract(new B(s.width, s.height)).multiply(a) });
  }
  _findCenterFromElement() {
    const e = Tn(this.points);
    return new B(e.left + e.width / 2, e.top + e.height / 2);
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(e) {
    const { left: t, top: n, width: i, height: s, pathOffset: a, strokeOffset: c, strokeDiff: u } = this._calcDimensions();
    this.set({ width: i, height: s, pathOffset: a, strokeOffset: c, strokeDiff: u }), e && this.setPositionByOrigin(new B(t + i / 2, n + s / 2), Pe, Pe);
  }
  isStrokeAccountedForInDimensions() {
    return this.exactBoundingBox;
  }
  _getNonTransformedDimensions() {
    return this.exactBoundingBox ? new B(this.width, this.height) : super._getNonTransformedDimensions();
  }
  _getTransformedDimensions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this.exactBoundingBox) {
      let a;
      if (Object.keys(e).some((c) => this.strokeUniform || this.constructor.layoutProperties.includes(c))) {
        var t, n;
        const { width: c, height: u } = this._calcDimensions(e);
        a = new B((t = e.width) !== null && t !== void 0 ? t : c, (n = e.height) !== null && n !== void 0 ? n : u);
      } else {
        var i, s;
        a = new B((i = e.width) !== null && i !== void 0 ? i : this.width, (s = e.height) !== null && s !== void 0 ? s : this.height);
      }
      return a.multiply(new B(e.scaleX || this.scaleX, e.scaleY || this.scaleY));
    }
    return super._getTransformedDimensions(e);
  }
  _set(e, t) {
    const n = this.initialized && this[e] !== t, i = super._set(e, t);
    return this.exactBoundingBox && n && ((e === cr || e === Rr) && this.strokeUniform && this.constructor.layoutProperties.includes("strokeUniform") || this.constructor.layoutProperties.includes(e)) && this.setDimensions(), i;
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return D(D({}, super.toObject(e)), {}, { points: this.points.map((t) => {
      let { x: n, y: i } = t;
      return { x: n, y: i };
    }) });
  }
  _toSVG() {
    const e = [], t = this.pathOffset.x, n = this.pathOffset.y, i = Ue.NUM_FRACTION_DIGITS;
    for (let s = 0, a = this.points.length; s < a; s++) e.push(ut(this.points[s].x - t, i), ",", ut(this.points[s].y - n, i), " ");
    return ["<".concat(this.constructor.type.toLowerCase(), " "), "COMMON_PARTS", 'points="'.concat(e.join(""), `" />
`)];
  }
  _render(e) {
    const t = this.points.length, n = this.pathOffset.x, i = this.pathOffset.y;
    if (t && !isNaN(this.points[t - 1].y)) {
      e.beginPath(), e.moveTo(this.points[0].x - n, this.points[0].y - i);
      for (let s = 0; s < t; s++) {
        const a = this.points[s];
        e.lineTo(a.x - n, a.y - i);
      }
      !this.isOpen() && e.closePath(), this._renderPaintInOrder(e);
    }
  }
  complexity() {
    return this.points.length;
  }
  static async fromElement(e, t, n) {
    return new this(O6(e.getAttribute("points")), D(D({}, ht(ti(e, this.ATTRIBUTE_NAMES, n), I6)), t));
  }
  static fromObject(e) {
    return this._fromObject(e, { extraParam: "points" });
  }
}
j(on, "ownDefaults", ox), j(on, "type", "Polyline"), j(on, "layoutProperties", [uo, ho, "strokeLineCap", "strokeLineJoin", "strokeMiterLimit", "strokeWidth", "strokeUniform", "points"]), j(on, "cacheProperties", [...ei, "points"]), j(on, "ATTRIBUTE_NAMES", [...Ai]), ne.setClass(on), ne.setSVGClass(on);
class Oc extends on {
  isOpen() {
    return !1;
  }
}
j(Oc, "ownDefaults", ox), j(Oc, "type", "Polygon"), ne.setClass(Oc), ne.setSVGClass(Oc);
const ax = ["fontSize", "fontWeight", "fontFamily", "fontStyle"], cx = ["underline", "overline", "linethrough"], lx = [...ax, "lineHeight", "text", "charSpacing", "textAlign", "styles", "path", "pathStartOffset", "pathSide", "pathAlign"], ux = [...lx, ...cx, "textBackgroundColor", "direction"], A6 = [...ax, ...cx, xr, "strokeWidth", Nt, "deltaY", "textBackgroundColor"], M6 = { _reNewline: ep, _reSpacesAndTabs: /[ \t\r]/g, _reSpaceAndTab: /[ \t\r]/, _reWords: /\S+/g, fontSize: 40, fontWeight: "normal", fontFamily: "Times New Roman", underline: !1, overline: !1, linethrough: !1, textAlign: Ke, fontStyle: "normal", lineHeight: 1.16, superscript: { size: 0.6, baseline: -0.35 }, subscript: { size: 0.6, baseline: 0.11 }, textBackgroundColor: "", stroke: null, shadow: null, path: void 0, pathStartOffset: 0, pathSide: Ke, pathAlign: "baseline", _fontSizeFraction: 0.222, offsets: { underline: 0.1, linethrough: -0.315, overline: -0.88 }, _fontSizeMult: 1.13, charSpacing: 0, deltaY: 0, direction: "ltr", CACHE_FONT_SIZE: 400, MIN_TEXT_WIDTH: 2 }, wn = "justify", Cl = "justify-left", Jo = "justify-right", Qo = "justify-center";
class hx extends rt {
  isEmptyStyles(e) {
    if (!this.styles || e !== void 0 && !this.styles[e]) return !0;
    const t = e === void 0 ? this.styles : { line: this.styles[e] };
    for (const n in t) for (const i in t[n]) for (const s in t[n][i]) return !1;
    return !0;
  }
  styleHas(e, t) {
    if (!this.styles || t !== void 0 && !this.styles[t]) return !1;
    const n = t === void 0 ? this.styles : { 0: this.styles[t] };
    for (const i in n) for (const s in n[i]) if (n[i][s][e] !== void 0) return !0;
    return !1;
  }
  cleanStyle(e) {
    if (!this.styles) return !1;
    const t = this.styles;
    let n, i, s = 0, a = !0, c = 0;
    for (const u in t) {
      n = 0;
      for (const h in t[u]) {
        const d = t[u][h] || {};
        s++, d[e] !== void 0 ? (i ? d[e] !== i && (a = !1) : i = d[e], d[e] === this[e] && delete d[e]) : a = !1, Object.keys(d).length !== 0 ? n++ : delete t[u][h];
      }
      n === 0 && delete t[u];
    }
    for (let u = 0; u < this._textLines.length; u++) c += this._textLines[u].length;
    a && s === c && (this[e] = i, this.removeStyle(e));
  }
  removeStyle(e) {
    if (!this.styles) return;
    const t = this.styles;
    let n, i, s;
    for (i in t) {
      for (s in n = t[i], n) delete n[s][e], Object.keys(n[s]).length === 0 && delete n[s];
      Object.keys(n).length === 0 && delete t[i];
    }
  }
  _extendStyles(e, t) {
    const { lineIndex: n, charIndex: i } = this.get2DCursorLocation(e);
    this._getLineStyle(n) || this._setLineStyle(n);
    const s = op(D(D({}, this._getStyleDeclaration(n, i)), t), (a) => a !== void 0);
    this._setStyleDeclaration(n, i, s);
  }
  getSelectionStyles(e, t, n) {
    const i = [];
    for (let s = e; s < (t || e); s++) i.push(this.getStyleAtPosition(s, n));
    return i;
  }
  getStyleAtPosition(e, t) {
    const { lineIndex: n, charIndex: i } = this.get2DCursorLocation(e);
    return t ? this.getCompleteStyleDeclaration(n, i) : this._getStyleDeclaration(n, i);
  }
  setSelectionStyles(e, t, n) {
    for (let i = t; i < (n || t); i++) this._extendStyles(i, e);
    this._forceClearCache = !0;
  }
  _getStyleDeclaration(e, t) {
    var n;
    const i = this.styles && this.styles[e];
    return i && (n = i[t]) !== null && n !== void 0 ? n : {};
  }
  getCompleteStyleDeclaration(e, t) {
    return D(D({}, ps(this, this.constructor._styleProperties)), this._getStyleDeclaration(e, t));
  }
  _setStyleDeclaration(e, t, n) {
    this.styles[e][t] = n;
  }
  _deleteStyleDeclaration(e, t) {
    delete this.styles[e][t];
  }
  _getLineStyle(e) {
    return !!this.styles[e];
  }
  _setLineStyle(e) {
    this.styles[e] = {};
  }
  _deleteLineStyle(e) {
    delete this.styles[e];
  }
}
j(hx, "_styleProperties", A6);
const P6 = /  +/g, D6 = /"/g;
function Qh(r, e, t, n, i) {
  return "		".concat(function(s, a) {
    let { left: c, top: u, width: h, height: d } = a, p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ue.NUM_FRACTION_DIGITS;
    const g = oa(Nt, s, !1), [v, b, x, _] = [c, u, h, d].map((C) => ut(C, p));
    return "<rect ".concat(g, ' x="').concat(v, '" y="').concat(b, '" width="').concat(x, '" height="').concat(_, '"></rect>');
  }(r, { left: e, top: t, width: n, height: i }), `
`);
}
const j6 = ["textAnchor", "textDecoration", "dx", "dy", "top", "left", "fontSize", "strokeWidth"];
let ed;
class nr extends hx {
  static getDefaults() {
    return D(D({}, super.getDefaults()), nr.ownDefaults);
  }
  constructor(e, t) {
    super(), j(this, "__charBounds", []), Object.assign(this, nr.ownDefaults), this.setOptions(t), this.styles || (this.styles = {}), this.text = e, this.initialized = !0, this.path && this.setPathInfo(), this.initDimensions(), this.setCoords();
  }
  setPathInfo() {
    const e = this.path;
    e && (e.segmentsInfo = bp(e.path));
  }
  _splitText() {
    const e = this._splitTextIntoLines(this.text);
    return this.textLines = e.lines, this._textLines = e.graphemeLines, this._unwrappedTextLines = e._unwrappedLines, this._text = e.graphemeText, e;
  }
  initDimensions() {
    this._splitText(), this._clearCache(), this.dirty = !0, this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), this.textAlign.includes(wn) && this.enlargeSpaces();
  }
  enlargeSpaces() {
    let e, t, n, i, s, a, c;
    for (let u = 0, h = this._textLines.length; u < h; u++) if ((this.textAlign === wn || u !== h - 1 && !this.isEndOfWrapping(u)) && (i = 0, s = this._textLines[u], t = this.getLineWidth(u), t < this.width && (c = this.textLines[u].match(this._reSpacesAndTabs)))) {
      n = c.length, e = (this.width - t) / n;
      for (let d = 0; d <= s.length; d++) a = this.__charBounds[u][d], this._reSpaceAndTab.test(s[d]) ? (a.width += e, a.kernedWidth += e, a.left += i, i += e) : a.left += i;
    }
  }
  isEndOfWrapping(e) {
    return e === this._textLines.length - 1;
  }
  missingNewlineOffset(e) {
    return 1;
  }
  get2DCursorLocation(e, t) {
    const n = t ? this._unwrappedTextLines : this._textLines;
    let i;
    for (i = 0; i < n.length; i++) {
      if (e <= n[i].length) return { lineIndex: i, charIndex: e };
      e -= n[i].length + this.missingNewlineOffset(i, t);
    }
    return { lineIndex: i - 1, charIndex: n[i - 1].length < e ? n[i - 1].length : e };
  }
  toString() {
    return "#<Text (".concat(this.complexity(), '): { "text": "').concat(this.text, '", "fontFamily": "').concat(this.fontFamily, '" }>');
  }
  _getCacheCanvasDimensions() {
    const e = super._getCacheCanvasDimensions(), t = this.fontSize;
    return e.width += t * e.zoomX, e.height += t * e.zoomY, e;
  }
  _render(e) {
    const t = this.path;
    t && !t.isNotVisible() && t._render(e), this._setTextStyles(e), this._renderTextLinesBackground(e), this._renderTextDecoration(e, "underline"), this._renderText(e), this._renderTextDecoration(e, "overline"), this._renderTextDecoration(e, "linethrough");
  }
  _renderText(e) {
    this.paintFirst === xr ? (this._renderTextStroke(e), this._renderTextFill(e)) : (this._renderTextFill(e), this._renderTextStroke(e));
  }
  _setTextStyles(e, t, n) {
    if (e.textBaseline = "alphabetic", this.path) switch (this.pathAlign) {
      case Pe:
        e.textBaseline = "middle";
        break;
      case "ascender":
        e.textBaseline = br;
        break;
      case "descender":
        e.textBaseline = Ud;
    }
    e.font = this._getFontDeclaration(t, n);
  }
  calcTextWidth() {
    let e = this.getLineWidth(0);
    for (let t = 1, n = this._textLines.length; t < n; t++) {
      const i = this.getLineWidth(t);
      i > e && (e = i);
    }
    return e;
  }
  _renderTextLine(e, t, n, i, s, a) {
    this._renderChars(e, t, n, i, s, a);
  }
  _renderTextLinesBackground(e) {
    if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor")) return;
    const t = e.fillStyle, n = this._getLeftOffset();
    let i = this._getTopOffset();
    for (let s = 0, a = this._textLines.length; s < a; s++) {
      const c = this.getHeightOfLine(s);
      if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor", s)) {
        i += c;
        continue;
      }
      const u = this._textLines[s].length, h = this._getLineLeftOffset(s);
      let d, p, g = 0, v = 0, b = this.getValueOfPropertyAt(s, 0, "textBackgroundColor");
      for (let x = 0; x < u; x++) {
        const _ = this.__charBounds[s][x];
        p = this.getValueOfPropertyAt(s, x, "textBackgroundColor"), this.path ? (e.save(), e.translate(_.renderLeft, _.renderTop), e.rotate(_.angle), e.fillStyle = p, p && e.fillRect(-_.width / 2, -c / this.lineHeight * (1 - this._fontSizeFraction), _.width, c / this.lineHeight), e.restore()) : p !== b ? (d = n + h + v, this.direction === "rtl" && (d = this.width - d - g), e.fillStyle = b, b && e.fillRect(d, i, g, c / this.lineHeight), v = _.left, g = _.width, b = p) : g += _.kernedWidth;
      }
      p && !this.path && (d = n + h + v, this.direction === "rtl" && (d = this.width - d - g), e.fillStyle = p, e.fillRect(d, i, g, c / this.lineHeight)), i += c;
    }
    e.fillStyle = t, this._removeShadow(e);
  }
  _measureChar(e, t, n, i) {
    const s = qo.getFontCache(t), a = this._getFontDeclaration(t), c = n + e, u = n && a === this._getFontDeclaration(i), h = t.fontSize / this.CACHE_FONT_SIZE;
    let d, p, g, v;
    if (n && s[n] !== void 0 && (g = s[n]), s[e] !== void 0 && (v = d = s[e]), u && s[c] !== void 0 && (p = s[c], v = p - g), d === void 0 || g === void 0 || p === void 0) {
      const b = function() {
        return ed || (ed = dn({ width: 0, height: 0 }).getContext("2d")), ed;
      }();
      this._setTextStyles(b, t, !0), d === void 0 && (v = d = b.measureText(e).width, s[e] = d), g === void 0 && u && n && (g = b.measureText(n).width, s[n] = g), u && p === void 0 && (p = b.measureText(c).width, s[c] = p, v = p - g);
    }
    return { width: d * h, kernedWidth: v * h };
  }
  getHeightOfChar(e, t) {
    return this.getValueOfPropertyAt(e, t, "fontSize");
  }
  measureLine(e) {
    const t = this._measureLine(e);
    return this.charSpacing !== 0 && (t.width -= this._getWidthOfCharSpacing()), t.width < 0 && (t.width = 0), t;
  }
  _measureLine(e) {
    let t, n, i = 0;
    const s = this.pathSide === Tt, a = this.path, c = this._textLines[e], u = c.length, h = new Array(u);
    this.__charBounds[e] = h;
    for (let d = 0; d < u; d++) {
      const p = c[d];
      n = this._getGraphemeBox(p, e, d, t), h[d] = n, i += n.kernedWidth, t = p;
    }
    if (h[u] = { left: n ? n.left + n.width : 0, width: 0, kernedWidth: 0, height: this.fontSize, deltaY: 0 }, a && a.segmentsInfo) {
      let d = 0;
      const p = a.segmentsInfo[a.segmentsInfo.length - 1].length;
      switch (this.textAlign) {
        case Ke:
          d = s ? p - i : 0;
          break;
        case Pe:
          d = (p - i) / 2;
          break;
        case Tt:
          d = s ? 0 : p - i;
      }
      d += this.pathStartOffset * (s ? -1 : 1);
      for (let g = s ? u - 1 : 0; s ? g >= 0 : g < u; s ? g-- : g++) n = h[g], d > p ? d %= p : d < 0 && (d += p), this._setGraphemeOnPath(d, n), d += n.kernedWidth;
    }
    return { width: i, numOfSpaces: 0 };
  }
  _setGraphemeOnPath(e, t) {
    const n = e + t.kernedWidth / 2, i = this.path, s = qw(i.path, n, i.segmentsInfo);
    t.renderLeft = s.x - i.pathOffset.x, t.renderTop = s.y - i.pathOffset.y, t.angle = s.angle + (this.pathSide === Tt ? Math.PI : 0);
  }
  _getGraphemeBox(e, t, n, i, s) {
    const a = this.getCompleteStyleDeclaration(t, n), c = i ? this.getCompleteStyleDeclaration(t, n - 1) : {}, u = this._measureChar(e, a, i, c);
    let h, d = u.kernedWidth, p = u.width;
    this.charSpacing !== 0 && (h = this._getWidthOfCharSpacing(), p += h, d += h);
    const g = { width: p, left: 0, height: a.fontSize, kernedWidth: d, deltaY: a.deltaY };
    if (n > 0 && !s) {
      const v = this.__charBounds[t][n - 1];
      g.left = v.left + v.width + u.kernedWidth - u.width;
    }
    return g;
  }
  getHeightOfLine(e) {
    if (this.__lineHeights[e]) return this.__lineHeights[e];
    let t = this.getHeightOfChar(e, 0);
    for (let n = 1, i = this._textLines[e].length; n < i; n++) t = Math.max(this.getHeightOfChar(e, n), t);
    return this.__lineHeights[e] = t * this.lineHeight * this._fontSizeMult;
  }
  calcTextHeight() {
    let e, t = 0;
    for (let n = 0, i = this._textLines.length; n < i; n++) e = this.getHeightOfLine(n), t += n === i - 1 ? e / this.lineHeight : e;
    return t;
  }
  _getLeftOffset() {
    return this.direction === "ltr" ? -this.width / 2 : this.width / 2;
  }
  _getTopOffset() {
    return -this.height / 2;
  }
  _renderTextCommon(e, t) {
    e.save();
    let n = 0;
    const i = this._getLeftOffset(), s = this._getTopOffset();
    for (let a = 0, c = this._textLines.length; a < c; a++) {
      const u = this.getHeightOfLine(a), h = u / this.lineHeight, d = this._getLineLeftOffset(a);
      this._renderTextLine(t, e, this._textLines[a], i + d, s + n + h, a), n += u;
    }
    e.restore();
  }
  _renderTextFill(e) {
    (this.fill || this.styleHas(Nt)) && this._renderTextCommon(e, "fillText");
  }
  _renderTextStroke(e) {
    (this.stroke && this.strokeWidth !== 0 || !this.isEmptyStyles()) && (this.shadow && !this.shadow.affectStroke && this._removeShadow(e), e.save(), this._setLineDash(e, this.strokeDashArray), e.beginPath(), this._renderTextCommon(e, "strokeText"), e.closePath(), e.restore());
  }
  _renderChars(e, t, n, i, s, a) {
    const c = this.getHeightOfLine(a), u = this.textAlign.includes(wn), h = this.path, d = !u && this.charSpacing === 0 && this.isEmptyStyles(a) && !h, p = this.direction === "ltr", g = this.direction === "ltr" ? 1 : -1, v = t.direction;
    let b, x, _, C, E, k = "", O = 0;
    if (t.save(), v !== this.direction && (t.canvas.setAttribute("dir", p ? "ltr" : "rtl"), t.direction = p ? "ltr" : "rtl", t.textAlign = p ? Ke : Tt), s -= c * this._fontSizeFraction / this.lineHeight, d) return this._renderChar(e, t, a, 0, n.join(""), i, s), void t.restore();
    for (let P = 0, R = n.length - 1; P <= R; P++) C = P === R || this.charSpacing || h, k += n[P], _ = this.__charBounds[a][P], O === 0 ? (i += g * (_.kernedWidth - _.width), O += _.width) : O += _.kernedWidth, u && !C && this._reSpaceAndTab.test(n[P]) && (C = !0), C || (b = b || this.getCompleteStyleDeclaration(a, P), x = this.getCompleteStyleDeclaration(a, P + 1), C = hu(b, x, !1)), C && (h ? (t.save(), t.translate(_.renderLeft, _.renderTop), t.rotate(_.angle), this._renderChar(e, t, a, P, k, -O / 2, 0), t.restore()) : (E = i, this._renderChar(e, t, a, P, k, E, s)), k = "", b = x, i += g * O, O = 0);
    t.restore();
  }
  _applyPatternGradientTransformText(e) {
    const t = this.width + this.strokeWidth, n = this.height + this.strokeWidth, i = dn({ width: t, height: n }), s = i.getContext("2d");
    return i.width = t, i.height = n, s.beginPath(), s.moveTo(0, 0), s.lineTo(t, 0), s.lineTo(t, n), s.lineTo(0, n), s.closePath(), s.translate(t / 2, n / 2), s.fillStyle = e.toLive(s), this._applyPatternGradientTransform(s, e), s.fill(), s.createPattern(i, "no-repeat");
  }
  handleFiller(e, t, n) {
    let i, s;
    return Gr(n) ? n.gradientUnits === "percentage" || n.gradientTransform || n.patternTransform ? (i = -this.width / 2, s = -this.height / 2, e.translate(i, s), e[t] = this._applyPatternGradientTransformText(n), { offsetX: i, offsetY: s }) : (e[t] = n.toLive(e), this._applyPatternGradientTransform(e, n)) : (e[t] = n, { offsetX: 0, offsetY: 0 });
  }
  _setStrokeStyles(e, t) {
    let { stroke: n, strokeWidth: i } = t;
    return e.lineWidth = i, e.lineCap = this.strokeLineCap, e.lineDashOffset = this.strokeDashOffset, e.lineJoin = this.strokeLineJoin, e.miterLimit = this.strokeMiterLimit, this.handleFiller(e, "strokeStyle", n);
  }
  _setFillStyles(e, t) {
    let { fill: n } = t;
    return this.handleFiller(e, "fillStyle", n);
  }
  _renderChar(e, t, n, i, s, a, c) {
    const u = this._getStyleDeclaration(n, i), h = this.getCompleteStyleDeclaration(n, i), d = e === "fillText" && h.fill, p = e === "strokeText" && h.stroke && h.strokeWidth;
    if (p || d) {
      if (t.save(), t.font = this._getFontDeclaration(h), u.textBackgroundColor && this._removeShadow(t), u.deltaY && (c += u.deltaY), d) {
        const g = this._setFillStyles(t, h);
        t.fillText(s, a - g.offsetX, c - g.offsetY);
      }
      if (p) {
        const g = this._setStrokeStyles(t, h);
        t.strokeText(s, a - g.offsetX, c - g.offsetY);
      }
      t.restore();
    }
  }
  setSuperscript(e, t) {
    this._setScript(e, t, this.superscript);
  }
  setSubscript(e, t) {
    this._setScript(e, t, this.subscript);
  }
  _setScript(e, t, n) {
    const i = this.get2DCursorLocation(e, !0), s = this.getValueOfPropertyAt(i.lineIndex, i.charIndex, "fontSize"), a = this.getValueOfPropertyAt(i.lineIndex, i.charIndex, "deltaY"), c = { fontSize: s * n.size, deltaY: a + s * n.baseline };
    this.setSelectionStyles(c, e, t);
  }
  _getLineLeftOffset(e) {
    const t = this.getLineWidth(e), n = this.width - t, i = this.textAlign, s = this.direction, a = this.isEndOfWrapping(e);
    let c = 0;
    return i === wn || i === Qo && !a || i === Jo && !a || i === Cl && !a ? 0 : (i === Pe && (c = n / 2), i === Tt && (c = n), i === Qo && (c = n / 2), i === Jo && (c = n), s === "rtl" && (i === Tt || i === wn || i === Jo ? c = 0 : i === Ke || i === Cl ? c = -n : i !== Pe && i !== Qo || (c = -n / 2)), c);
  }
  _clearCache() {
    this._forceClearCache = !1, this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [];
  }
  getLineWidth(e) {
    if (this.__lineWidths[e] !== void 0) return this.__lineWidths[e];
    const { width: t } = this.measureLine(e);
    return this.__lineWidths[e] = t, t;
  }
  _getWidthOfCharSpacing() {
    return this.charSpacing !== 0 ? this.fontSize * this.charSpacing / 1e3 : 0;
  }
  getValueOfPropertyAt(e, t, n) {
    var i;
    return (i = this._getStyleDeclaration(e, t)[n]) !== null && i !== void 0 ? i : this[n];
  }
  _renderTextDecoration(e, t) {
    if (!this[t] && !this.styleHas(t)) return;
    let n = this._getTopOffset();
    const i = this._getLeftOffset(), s = this.path, a = this._getWidthOfCharSpacing(), c = this.offsets[t];
    for (let u = 0, h = this._textLines.length; u < h; u++) {
      const d = this.getHeightOfLine(u);
      if (!this[t] && !this.styleHas(t, u)) {
        n += d;
        continue;
      }
      const p = this._textLines[u], g = d / this.lineHeight, v = this._getLineLeftOffset(u);
      let b, x, _ = 0, C = 0, E = this.getValueOfPropertyAt(u, 0, t), k = this.getValueOfPropertyAt(u, 0, Nt);
      const O = n + g * (1 - this._fontSizeFraction);
      let P = this.getHeightOfChar(u, 0), R = this.getValueOfPropertyAt(u, 0, "deltaY");
      for (let F = 0, $ = p.length; F < $; F++) {
        const z = this.__charBounds[u][F];
        b = this.getValueOfPropertyAt(u, F, t), x = this.getValueOfPropertyAt(u, F, Nt);
        const G = this.getHeightOfChar(u, F), H = this.getValueOfPropertyAt(u, F, "deltaY");
        if (s && b && x) e.save(), e.fillStyle = k, e.translate(z.renderLeft, z.renderTop), e.rotate(z.angle), e.fillRect(-z.kernedWidth / 2, c * G + H, z.kernedWidth, this.fontSize / 15), e.restore();
        else if ((b !== E || x !== k || G !== P || H !== R) && C > 0) {
          let Y = i + v + _;
          this.direction === "rtl" && (Y = this.width - Y - C), E && k && (e.fillStyle = k, e.fillRect(Y, O + c * P + R, C, this.fontSize / 15)), _ = z.left, C = z.width, E = b, k = x, P = G, R = H;
        } else C += z.kernedWidth;
      }
      let V = i + v + _;
      this.direction === "rtl" && (V = this.width - V - C), e.fillStyle = x, b && x && e.fillRect(V, O + c * P + R, C - a, this.fontSize / 15), n += d;
    }
    this._removeShadow(e);
  }
  _getFontDeclaration() {
    let { fontFamily: e = this.fontFamily, fontStyle: t = this.fontStyle, fontWeight: n = this.fontWeight, fontSize: i = this.fontSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = arguments.length > 1 ? arguments[1] : void 0;
    const a = e.includes("'") || e.includes('"') || e.includes(",") || nr.genericFonts.includes(e.toLowerCase()) ? e : '"'.concat(e, '"');
    return [t, n, "".concat(s ? this.CACHE_FONT_SIZE : i, "px"), a].join(" ");
  }
  render(e) {
    this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._forceClearCache && this.initDimensions(), super.render(e)));
  }
  graphemeSplit(e) {
    return uu(e);
  }
  _splitTextIntoLines(e) {
    const t = e.split(this._reNewline), n = new Array(t.length), i = [`
`];
    let s = [];
    for (let a = 0; a < t.length; a++) n[a] = this.graphemeSplit(t[a]), s = s.concat(n[a], i);
    return s.pop(), { _unwrappedLines: n, lines: t, graphemeText: s, graphemeLines: n };
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return D(D({}, super.toObject([...ux, ...e])), {}, { styles: Lw(this.styles, this.text) }, this.path ? { path: this.path.toObject() } : {});
  }
  set(e, t) {
    const { textLayoutProperties: n } = this.constructor;
    super.set(e, t);
    let i = !1, s = !1;
    if (typeof e == "object") for (const a in e) a === "path" && this.setPathInfo(), i = i || n.includes(a), s = s || a === "path";
    else i = n.includes(e), s = e === "path";
    return s && this.setPathInfo(), i && this.initialized && (this.initDimensions(), this.setCoords()), this;
  }
  complexity() {
    return 1;
  }
  static async fromElement(e, t, n) {
    const i = ti(e, nr.ATTRIBUTE_NAMES, n), s = D(D({}, t), i), { textAnchor: a = Ke, textDecoration: c = "", dx: u = 0, dy: h = 0, top: d = 0, left: p = 0, fontSize: g = Qf, strokeWidth: v = 1 } = s, b = ht(s, j6), x = new this((e.textContent || "").replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " "), D({ left: p + u, top: d + h, underline: c.includes("underline"), overline: c.includes("overline"), linethrough: c.includes("line-through"), strokeWidth: 0, fontSize: g }, b)), _ = x.getScaledHeight() / x.height, C = ((x.height + x.strokeWidth) * x.lineHeight - x.height) * _, E = x.getScaledHeight() + C;
    let k = 0;
    return a === Pe && (k = x.getScaledWidth() / 2), a === Tt && (k = x.getScaledWidth()), x.set({ left: x.left - k, top: x.top - (E - x.fontSize * (0.07 + x._fontSizeFraction)) / x.lineHeight, strokeWidth: v }), x;
  }
  static fromObject(e) {
    return this._fromObject(D(D({}, e), {}, { styles: Nw(e.styles || {}, e.text) }), { extraParam: "text" });
  }
}
j(nr, "textLayoutProperties", lx), j(nr, "cacheProperties", [...ei, ...ux]), j(nr, "ownDefaults", M6), j(nr, "type", "Text"), j(nr, "genericFonts", ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]), j(nr, "ATTRIBUTE_NAMES", Ai.concat("x", "y", "dx", "dy", "font-family", "font-style", "font-weight", "font-size", "letter-spacing", "text-decoration", "text-anchor")), Pw(nr, [class extends dw {
  _toSVG() {
    const r = this._getSVGLeftTopOffsets(), e = this._getSVGTextAndBg(r.textTop, r.textLeft);
    return this._wrapSVGTextAndBg(e);
  }
  toSVG(r) {
    return this._createBaseSVGMarkup(this._toSVG(), { reviver: r, noStyle: !0, withShadow: !0 });
  }
  _getSVGLeftTopOffsets() {
    return { textLeft: -this.width / 2, textTop: -this.height / 2, lineTop: this.getHeightOfLine(0) };
  }
  _wrapSVGTextAndBg(r) {
    let { textBgRects: e, textSpans: t } = r;
    const n = this.getSvgTextDecoration(this);
    return [e.join(""), '		<text xml:space="preserve" ', this.fontFamily ? 'font-family="'.concat(this.fontFamily.replace(D6, "'"), '" ') : "", this.fontSize ? 'font-size="'.concat(this.fontSize, '" ') : "", this.fontStyle ? 'font-style="'.concat(this.fontStyle, '" ') : "", this.fontWeight ? 'font-weight="'.concat(this.fontWeight, '" ') : "", n ? 'text-decoration="'.concat(n, '" ') : "", this.direction === "rtl" ? 'direction="'.concat(this.direction, '" ') : "", 'style="', this.getSvgStyles(!0), '"', this.addPaintOrder(), " >", t.join(""), `</text>
`];
  }
  _getSVGTextAndBg(r, e) {
    const t = [], n = [];
    let i, s = r;
    this.backgroundColor && n.push(...Qh(this.backgroundColor, -this.width / 2, -this.height / 2, this.width, this.height));
    for (let a = 0, c = this._textLines.length; a < c; a++) i = this._getLineLeftOffset(a), this.direction === "rtl" && (i += this.width), (this.textBackgroundColor || this.styleHas("textBackgroundColor", a)) && this._setSVGTextLineBg(n, a, e + i, s), this._setSVGTextLineText(t, a, e + i, s), s += this.getHeightOfLine(a);
    return { textSpans: t, textBgRects: n };
  }
  _createTextCharSpan(r, e, t, n) {
    const i = this.getSvgSpanStyles(e, r !== r.trim() || !!r.match(P6)), s = i ? 'style="'.concat(i, '"') : "", a = e.deltaY, c = a ? ' dy="'.concat(ut(a, Ue.NUM_FRACTION_DIGITS), '" ') : "";
    return '<tspan x="'.concat(ut(t, Ue.NUM_FRACTION_DIGITS), '" y="').concat(ut(n, Ue.NUM_FRACTION_DIGITS), '" ').concat(c).concat(s, ">").concat(Fw(r), "</tspan>");
  }
  _setSVGTextLineText(r, e, t, n) {
    const i = this.getHeightOfLine(e), s = this.textAlign.includes(wn), a = this._textLines[e];
    let c, u, h, d, p, g = "", v = 0;
    n += i * (1 - this._fontSizeFraction) / this.lineHeight;
    for (let b = 0, x = a.length - 1; b <= x; b++) p = b === x || this.charSpacing, g += a[b], h = this.__charBounds[e][b], v === 0 ? (t += h.kernedWidth - h.width, v += h.width) : v += h.kernedWidth, s && !p && this._reSpaceAndTab.test(a[b]) && (p = !0), p || (c = c || this.getCompleteStyleDeclaration(e, b), u = this.getCompleteStyleDeclaration(e, b + 1), p = hu(c, u, !0)), p && (d = this._getStyleDeclaration(e, b), r.push(this._createTextCharSpan(g, d, t, n)), g = "", c = u, this.direction === "rtl" ? t -= v : t += v, v = 0);
  }
  _setSVGTextLineBg(r, e, t, n) {
    const i = this._textLines[e], s = this.getHeightOfLine(e) / this.lineHeight;
    let a, c = 0, u = 0, h = this.getValueOfPropertyAt(e, 0, "textBackgroundColor");
    for (let d = 0; d < i.length; d++) {
      const { left: p, width: g, kernedWidth: v } = this.__charBounds[e][d];
      a = this.getValueOfPropertyAt(e, d, "textBackgroundColor"), a !== h ? (h && r.push(...Qh(h, t + u, n, c, s)), u = p, c = g, h = a) : c += v;
    }
    a && r.push(...Qh(h, t + u, n, c, s));
  }
  _getSVGLineTopOffset(r) {
    let e, t = 0;
    for (e = 0; e < r; e++) t += this.getHeightOfLine(e);
    const n = this.getHeightOfLine(e);
    return { lineTop: t, offset: (this._fontSizeMult - this._fontSizeFraction) * n / (this.lineHeight * this._fontSizeMult) };
  }
  getSvgStyles(r) {
    return "".concat(super.getSvgStyles(r), " white-space: pre;");
  }
  getSvgSpanStyles(r, e) {
    const { fontFamily: t, strokeWidth: n, stroke: i, fill: s, fontSize: a, fontStyle: c, fontWeight: u, deltaY: h } = r, d = this.getSvgTextDecoration(r);
    return [i ? oa(xr, i) : "", n ? "stroke-width: ".concat(n, "; ") : "", t ? "font-family: ".concat(t.includes("'") || t.includes('"') ? t : "'".concat(t, "'"), "; ") : "", a ? "font-size: ".concat(a, "px; ") : "", c ? "font-style: ".concat(c, "; ") : "", u ? "font-weight: ".concat(u, "; ") : "", d && "text-decoration: ".concat(d, "; "), s ? oa(Nt, s) : "", h ? "baseline-shift: ".concat(-h, "; ") : "", e ? "white-space: pre; " : ""].join("");
  }
  getSvgTextDecoration(r) {
    return ["overline", "underline", "line-through"].filter((e) => r[e.replace("-", "")]).join(" ");
  }
}]), ne.setClass(nr), ne.setSVGClass(nr);
class R6 {
  constructor(e) {
    j(this, "target", void 0), j(this, "__mouseDownInPlace", !1), j(this, "__dragStartFired", !1), j(this, "__isDraggingOver", !1), j(this, "__dragStartSelection", void 0), j(this, "__dragImageDisposer", void 0), j(this, "_dispose", void 0), this.target = e;
    const t = [this.target.on("dragenter", this.dragEnterHandler.bind(this)), this.target.on("dragover", this.dragOverHandler.bind(this)), this.target.on("dragleave", this.dragLeaveHandler.bind(this)), this.target.on("dragend", this.dragEndHandler.bind(this)), this.target.on("drop", this.dropHandler.bind(this))];
    this._dispose = () => {
      t.forEach((n) => n()), this._dispose = void 0;
    };
  }
  isPointerOverSelection(e) {
    const t = this.target, n = t.getSelectionStartFromPointer(e);
    return t.isEditing && n >= t.selectionStart && n <= t.selectionEnd && t.selectionStart < t.selectionEnd;
  }
  start(e) {
    return this.__mouseDownInPlace = this.isPointerOverSelection(e);
  }
  isActive() {
    return this.__mouseDownInPlace;
  }
  end(e) {
    const t = this.isActive();
    return t && !this.__dragStartFired && (this.target.setCursorByClick(e), this.target.initDelayedCursor(!0)), this.__mouseDownInPlace = !1, this.__dragStartFired = !1, this.__isDraggingOver = !1, t;
  }
  getDragStartSelection() {
    return this.__dragStartSelection;
  }
  setDragImage(e, t) {
    var n;
    let { selectionStart: i, selectionEnd: s } = t;
    const a = this.target, c = a.canvas, u = new B(a.flipX ? -1 : 1, a.flipY ? -1 : 1), h = a._getCursorBoundaries(i), d = new B(h.left + h.leftOffset, h.top + h.topOffset).multiply(u).transform(a.calcTransformMatrix()), p = c.getScenePoint(e).subtract(d), g = a.getCanvasRetinaScaling(), v = a.getBoundingRect(), b = d.subtract(new B(v.left, v.top)), x = c.viewportTransform, _ = b.add(p).transform(x, !0), C = a.backgroundColor, E = mp(a.styles);
    a.backgroundColor = "";
    const k = { stroke: "transparent", fill: "transparent", textBackgroundColor: "transparent" };
    a.setSelectionStyles(k, 0, i), a.setSelectionStyles(k, s, a.text.length), a.dirty = !0;
    const O = a.toCanvasElement({ enableRetinaScaling: c.enableRetinaScaling, viewportTransform: !0 });
    a.backgroundColor = C, a.styles = E, a.dirty = !0, Sl(O, { position: "fixed", left: "".concat(-O.width, "px"), border: wr, width: "".concat(O.width / g, "px"), height: "".concat(O.height / g, "px") }), this.__dragImageDisposer && this.__dragImageDisposer(), this.__dragImageDisposer = () => {
      O.remove();
    }, an(e.target || this.target.hiddenTextarea).body.appendChild(O), (n = e.dataTransfer) === null || n === void 0 || n.setDragImage(O, _.x, _.y);
  }
  onDragStart(e) {
    this.__dragStartFired = !0;
    const t = this.target, n = this.isActive();
    if (n && e.dataTransfer) {
      const i = this.__dragStartSelection = { selectionStart: t.selectionStart, selectionEnd: t.selectionEnd }, s = t._text.slice(i.selectionStart, i.selectionEnd).join(""), a = D({ text: t.text, value: s }, i);
      e.dataTransfer.setData("text/plain", s), e.dataTransfer.setData("application/fabric", JSON.stringify({ value: s, styles: t.getSelectionStyles(i.selectionStart, i.selectionEnd, !0) })), e.dataTransfer.effectAllowed = "copyMove", this.setDragImage(e, a);
    }
    return t.abortCursorAnimation(), n;
  }
  canDrop(e) {
    if (this.target.editable && !this.target.getActiveControl() && !e.defaultPrevented) {
      if (this.isActive() && this.__dragStartSelection) {
        const t = this.target.getSelectionStartFromPointer(e), n = this.__dragStartSelection;
        return t < n.selectionStart || t > n.selectionEnd;
      }
      return !0;
    }
    return !1;
  }
  targetCanDrop(e) {
    return this.target.canDrop(e);
  }
  dragEnterHandler(e) {
    let { e: t } = e;
    const n = this.targetCanDrop(t);
    !this.__isDraggingOver && n && (this.__isDraggingOver = !0);
  }
  dragOverHandler(e) {
    const { e: t } = e, n = this.targetCanDrop(t);
    !this.__isDraggingOver && n ? this.__isDraggingOver = !0 : this.__isDraggingOver && !n && (this.__isDraggingOver = !1), this.__isDraggingOver && (t.preventDefault(), e.canDrop = !0, e.dropTarget = this.target);
  }
  dragLeaveHandler() {
    (this.__isDraggingOver || this.isActive()) && (this.__isDraggingOver = !1);
  }
  dropHandler(e) {
    var t;
    const { e: n } = e, i = n.defaultPrevented;
    this.__isDraggingOver = !1, n.preventDefault();
    let s = (t = n.dataTransfer) === null || t === void 0 ? void 0 : t.getData("text/plain");
    if (s && !i) {
      const a = this.target, c = a.canvas;
      let u = a.getSelectionStartFromPointer(n);
      const { styles: h } = n.dataTransfer.types.includes("application/fabric") ? JSON.parse(n.dataTransfer.getData("application/fabric")) : {}, d = s[Math.max(0, s.length - 1)], p = 0;
      if (this.__dragStartSelection) {
        const g = this.__dragStartSelection.selectionStart, v = this.__dragStartSelection.selectionEnd;
        u > g && u <= v ? u = g : u > v && (u -= v - g), a.removeChars(g, v), delete this.__dragStartSelection;
      }
      a._reNewline.test(d) && (a._reNewline.test(a._text[u]) || u === a._text.length) && (s = s.trimEnd()), e.didDrop = !0, e.dropTarget = a, a.insertChars(s, h, u), c.setActiveObject(a), a.enterEditing(n), a.selectionStart = Math.min(u + p, a._text.length), a.selectionEnd = Math.min(a.selectionStart + s.length, a._text.length), a.hiddenTextarea.value = a.text, a._updateTextarea(), a.hiddenTextarea.focus(), a.fire(dl, { index: u + p, action: "drop" }), c.fire("text:changed", { target: a }), c.contextTopDirty = !0, c.requestRenderAll();
    }
  }
  dragEndHandler(e) {
    let { e: t } = e;
    if (this.isActive() && this.__dragStartFired && this.__dragStartSelection) {
      var n;
      const i = this.target, s = this.target.canvas, { selectionStart: a, selectionEnd: c } = this.__dragStartSelection, u = ((n = t.dataTransfer) === null || n === void 0 ? void 0 : n.dropEffect) || wr;
      u === wr ? (i.selectionStart = a, i.selectionEnd = c, i._updateTextarea(), i.hiddenTextarea.focus()) : (i.clearContextTop(), u === "move" && (i.removeChars(a, c), i.selectionStart = i.selectionEnd = a, i.hiddenTextarea && (i.hiddenTextarea.value = i.text), i._updateTextarea(), i.fire(dl, { index: a, action: "dragend" }), s.fire("text:changed", { target: i }), s.requestRenderAll()), i.exitEditing());
    }
    this.__dragImageDisposer && this.__dragImageDisposer(), delete this.__dragImageDisposer, delete this.__dragStartSelection, this.__isDraggingOver = !1;
  }
  dispose() {
    this._dispose && this._dispose();
  }
}
const F0 = /[ \n\.,;!\?\-]/;
class F6 extends nr {
  constructor() {
    super(...arguments), j(this, "_currentCursorOpacity", 1);
  }
  initBehavior() {
    this._tick = this._tick.bind(this), this._onTickComplete = this._onTickComplete.bind(this), this.updateSelectionOnMouseMove = this.updateSelectionOnMouseMove.bind(this);
  }
  onDeselect(e) {
    return this.isEditing && this.exitEditing(), this.selected = !1, super.onDeselect(e);
  }
  _animateCursor(e) {
    let { toValue: t, duration: n, delay: i, onComplete: s } = e;
    return fp({ startValue: this._currentCursorOpacity, endValue: t, duration: n, delay: i, onComplete: s, abort: () => !this.canvas || this.selectionStart !== this.selectionEnd, onChange: (a) => {
      this._currentCursorOpacity = a, this.renderCursorOrSelection();
    } });
  }
  _tick(e) {
    this._currentTickState = this._animateCursor({ toValue: 0, duration: this.cursorDuration / 2, delay: Math.max(e || 0, 100), onComplete: this._onTickComplete });
  }
  _onTickComplete() {
    var e;
    (e = this._currentTickCompleteState) === null || e === void 0 || e.abort(), this._currentTickCompleteState = this._animateCursor({ toValue: 1, duration: this.cursorDuration, onComplete: this._tick });
  }
  initDelayedCursor(e) {
    this.abortCursorAnimation(), this._tick(e ? 0 : this.cursorDelay);
  }
  abortCursorAnimation() {
    let e = !1;
    [this._currentTickState, this._currentTickCompleteState].forEach((t) => {
      t && !t.isDone() && (e = !0, t.abort());
    }), this._currentCursorOpacity = 1, e && this.clearContextTop();
  }
  restartCursorIfNeeded() {
    [this._currentTickState, this._currentTickCompleteState].some((e) => !e || e.isDone()) && this.initDelayedCursor();
  }
  selectAll() {
    return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this;
  }
  getSelectedText() {
    return this._text.slice(this.selectionStart, this.selectionEnd).join("");
  }
  findWordBoundaryLeft(e) {
    let t = 0, n = e - 1;
    if (this._reSpace.test(this._text[n])) for (; this._reSpace.test(this._text[n]); ) t++, n--;
    for (; /\S/.test(this._text[n]) && n > -1; ) t++, n--;
    return e - t;
  }
  findWordBoundaryRight(e) {
    let t = 0, n = e;
    if (this._reSpace.test(this._text[n])) for (; this._reSpace.test(this._text[n]); ) t++, n++;
    for (; /\S/.test(this._text[n]) && n < this._text.length; ) t++, n++;
    return e + t;
  }
  findLineBoundaryLeft(e) {
    let t = 0, n = e - 1;
    for (; !/\n/.test(this._text[n]) && n > -1; ) t++, n--;
    return e - t;
  }
  findLineBoundaryRight(e) {
    let t = 0, n = e;
    for (; !/\n/.test(this._text[n]) && n < this._text.length; ) t++, n++;
    return e + t;
  }
  searchWordBoundary(e, t) {
    const n = this._text;
    let i = e > 0 && this._reSpace.test(n[e]) && (t === -1 || !ep.test(n[e - 1])) ? e - 1 : e, s = n[i];
    for (; i > 0 && i < n.length && !F0.test(s); ) i += t, s = n[i];
    return t === -1 && F0.test(s) && i++, i;
  }
  selectWord(e) {
    e = e || this.selectionStart;
    const t = this.searchWordBoundary(e, -1), n = Math.max(t, this.searchWordBoundary(e, 1));
    this.selectionStart = t, this.selectionEnd = n, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection();
  }
  selectLine(e) {
    e = e || this.selectionStart;
    const t = this.findLineBoundaryLeft(e), n = this.findLineBoundaryRight(e);
    return this.selectionStart = t, this.selectionEnd = n, this._fireSelectionChanged(), this._updateTextarea(), this;
  }
  enterEditing(e) {
    !this.isEditing && this.editable && (this.enterEditingImpl(), this.fire("editing:entered", e ? { e } : void 0), this._fireSelectionChanged(), this.canvas && (this.canvas.fire("text:editing:entered", { target: this, e }), this.canvas.requestRenderAll()));
  }
  enterEditingImpl() {
    this.canvas && (this.canvas.calcOffset(), this.canvas.textEditingManager.exitTextEditing()), this.isEditing = !0, this.initHiddenTextarea(), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick();
  }
  updateSelectionOnMouseMove(e) {
    if (this.getActiveControl()) return;
    const t = this.hiddenTextarea;
    an(t).activeElement !== t && t.focus();
    const n = this.getSelectionStartFromPointer(e), i = this.selectionStart, s = this.selectionEnd;
    (n === this.__selectionStartOnMouseDown && i !== s || i !== n && s !== n) && (n > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = n) : (this.selectionStart = n, this.selectionEnd = this.__selectionStartOnMouseDown), this.selectionStart === i && this.selectionEnd === s || (this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()));
  }
  _setEditingProps() {
    this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0;
  }
  fromStringToGraphemeSelection(e, t, n) {
    const i = n.slice(0, e), s = this.graphemeSplit(i).length;
    if (e === t) return { selectionStart: s, selectionEnd: s };
    const a = n.slice(e, t);
    return { selectionStart: s, selectionEnd: s + this.graphemeSplit(a).length };
  }
  fromGraphemeToStringSelection(e, t, n) {
    const i = n.slice(0, e).join("").length;
    return e === t ? { selectionStart: i, selectionEnd: i } : { selectionStart: i, selectionEnd: i + n.slice(e, t).join("").length };
  }
  _updateTextarea() {
    if (this.cursorOffsetCache = {}, this.hiddenTextarea) {
      if (!this.inCompositionMode) {
        const e = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
        this.hiddenTextarea.selectionStart = e.selectionStart, this.hiddenTextarea.selectionEnd = e.selectionEnd;
      }
      this.updateTextareaPosition();
    }
  }
  updateFromTextArea() {
    if (!this.hiddenTextarea) return;
    this.cursorOffsetCache = {};
    const e = this.hiddenTextarea;
    this.text = e.value, this.set("dirty", !0), this.initDimensions(), this.setCoords();
    const t = this.fromStringToGraphemeSelection(e.selectionStart, e.selectionEnd, e.value);
    this.selectionEnd = this.selectionStart = t.selectionEnd, this.inCompositionMode || (this.selectionStart = t.selectionStart), this.updateTextareaPosition();
  }
  updateTextareaPosition() {
    if (this.selectionStart === this.selectionEnd) {
      const e = this._calcTextareaPosition();
      this.hiddenTextarea.style.left = e.left, this.hiddenTextarea.style.top = e.top;
    }
  }
  _calcTextareaPosition() {
    if (!this.canvas) return { left: "1px", top: "1px" };
    const e = this.inCompositionMode ? this.compositionStart : this.selectionStart, t = this._getCursorBoundaries(e), n = this.get2DCursorLocation(e), i = n.lineIndex, s = n.charIndex, a = this.getValueOfPropertyAt(i, s, "fontSize") * this.lineHeight, c = t.leftOffset, u = this.getCanvasRetinaScaling(), h = this.canvas.upperCanvasEl, d = h.width / u, p = h.height / u, g = d - a, v = p - a, b = new B(t.left + c, t.top + t.topOffset + a).transform(this.calcTransformMatrix()).transform(this.canvas.viewportTransform).multiply(new B(h.clientWidth / d, h.clientHeight / p));
    return b.x < 0 && (b.x = 0), b.x > g && (b.x = g), b.y < 0 && (b.y = 0), b.y > v && (b.y = v), b.x += this.canvas._offset.left, b.y += this.canvas._offset.top, { left: "".concat(b.x, "px"), top: "".concat(b.y, "px"), fontSize: "".concat(a, "px"), charHeight: a };
  }
  _saveEditingProps() {
    this._savedProps = { hasControls: this.hasControls, borderColor: this.borderColor, lockMovementX: this.lockMovementX, lockMovementY: this.lockMovementY, hoverCursor: this.hoverCursor, selectable: this.selectable, defaultCursor: this.canvas && this.canvas.defaultCursor, moveCursor: this.canvas && this.canvas.moveCursor };
  }
  _restoreEditingProps() {
    this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor || this.canvas.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor || this.canvas.moveCursor), delete this._savedProps);
  }
  _exitEditing() {
    const e = this.hiddenTextarea;
    this.selected = !1, this.isEditing = !1, e && (e.blur && e.blur(), e.parentNode && e.parentNode.removeChild(e)), this.hiddenTextarea = null, this.abortCursorAnimation(), this.selectionStart !== this.selectionEnd && this.clearContextTop();
  }
  exitEditingImpl() {
    this._exitEditing(), this.selectionEnd = this.selectionStart, this._restoreEditingProps(), this._forceClearCache && (this.initDimensions(), this.setCoords());
  }
  exitEditing() {
    const e = this._textBeforeEdit !== this.text;
    return this.exitEditingImpl(), this.fire("editing:exited"), e && this.fire(fl), this.canvas && (this.canvas.fire("text:editing:exited", { target: this }), e && this.canvas.fire("object:modified", { target: this })), this;
  }
  _removeExtraneousStyles() {
    for (const e in this.styles) this._textLines[e] || delete this.styles[e];
  }
  removeStyleFromTo(e, t) {
    const { lineIndex: n, charIndex: i } = this.get2DCursorLocation(e, !0), { lineIndex: s, charIndex: a } = this.get2DCursorLocation(t, !0);
    if (n !== s) {
      if (this.styles[n]) for (let c = i; c < this._unwrappedTextLines[n].length; c++) delete this.styles[n][c];
      if (this.styles[s]) for (let c = a; c < this._unwrappedTextLines[s].length; c++) {
        const u = this.styles[s][c];
        u && (this.styles[n] || (this.styles[n] = {}), this.styles[n][i + c - a] = u);
      }
      for (let c = n + 1; c <= s; c++) delete this.styles[c];
      this.shiftLineStyles(s, n - s);
    } else if (this.styles[n]) {
      const c = this.styles[n], u = a - i;
      for (let h = i; h < a; h++) delete c[h];
      for (const h in this.styles[n]) {
        const d = parseInt(h, 10);
        d >= a && (c[d - u] = c[h], delete c[h]);
      }
    }
  }
  shiftLineStyles(e, t) {
    const n = Object.assign({}, this.styles);
    for (const i in this.styles) {
      const s = parseInt(i, 10);
      s > e && (this.styles[s + t] = n[s], n[s - t] || delete this.styles[s]);
    }
  }
  insertNewlineStyleObject(e, t, n, i) {
    const s = {}, a = this._unwrappedTextLines[e].length, c = a === t;
    let u = !1;
    n || (n = 1), this.shiftLineStyles(e, n);
    const h = this.styles[e] ? this.styles[e][t === 0 ? t : t - 1] : void 0;
    for (const p in this.styles[e]) {
      const g = parseInt(p, 10);
      g >= t && (u = !0, s[g - t] = this.styles[e][p], c && t === 0 || delete this.styles[e][p]);
    }
    let d = !1;
    for (u && !c && (this.styles[e + n] = s, d = !0), (d || a > t) && n--; n > 0; ) i && i[n - 1] ? this.styles[e + n] = { 0: D({}, i[n - 1]) } : h ? this.styles[e + n] = { 0: D({}, h) } : delete this.styles[e + n], n--;
    this._forceClearCache = !0;
  }
  insertCharStyleObject(e, t, n, i) {
    this.styles || (this.styles = {});
    const s = this.styles[e], a = s ? D({}, s) : {};
    n || (n = 1);
    for (const u in a) {
      const h = parseInt(u, 10);
      h >= t && (s[h + n] = a[h], a[h - n] || delete s[h]);
    }
    if (this._forceClearCache = !0, i) {
      for (; n--; ) Object.keys(i[n]).length && (this.styles[e] || (this.styles[e] = {}), this.styles[e][t + n] = D({}, i[n]));
      return;
    }
    if (!s) return;
    const c = s[t ? t - 1 : 1];
    for (; c && n--; ) this.styles[e][t + n] = D({}, c);
  }
  insertNewStyleBlock(e, t, n) {
    const i = this.get2DCursorLocation(t, !0), s = [0];
    let a, c = 0;
    for (let u = 0; u < e.length; u++) e[u] === `
` ? (c++, s[c] = 0) : s[c]++;
    for (s[0] > 0 && (this.insertCharStyleObject(i.lineIndex, i.charIndex, s[0], n), n = n && n.slice(s[0] + 1)), c && this.insertNewlineStyleObject(i.lineIndex, i.charIndex + s[0], c), a = 1; a < c; a++) s[a] > 0 ? this.insertCharStyleObject(i.lineIndex + a, 0, s[a], n) : n && this.styles[i.lineIndex + a] && n[0] && (this.styles[i.lineIndex + a][0] = n[0]), n = n && n.slice(s[a] + 1);
    s[a] > 0 && this.insertCharStyleObject(i.lineIndex + a, 0, s[a], n);
  }
  removeChars(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e + 1;
    this.removeStyleFromTo(e, t), this._text.splice(e, t - e), this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  insertChars(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : n;
    i > n && this.removeStyleFromTo(n, i);
    const s = this.graphemeSplit(e);
    this.insertNewStyleBlock(s, n, t), this._text = [...this._text.slice(0, n), ...s, ...this._text.slice(i)], this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  setSelectionStartEndWithShift(e, t, n) {
    n <= e ? (t === e ? this._selectionDirection = Ke : this._selectionDirection === Tt && (this._selectionDirection = Ke, this.selectionEnd = e), this.selectionStart = n) : n > e && n < t ? this._selectionDirection === Tt ? this.selectionEnd = n : this.selectionStart = n : (t === e ? this._selectionDirection = Tt : this._selectionDirection === Ke && (this._selectionDirection = Tt, this.selectionStart = t), this.selectionEnd = n);
  }
}
class L6 extends F6 {
  initHiddenTextarea() {
    const e = this.canvas && an(this.canvas.getElement()) || lo(), t = e.createElement("textarea");
    Object.entries({ autocapitalize: "off", autocorrect: "off", autocomplete: "off", spellcheck: "false", "data-fabric": "textarea", wrap: "off" }).map((a) => {
      let [c, u] = a;
      return t.setAttribute(c, u);
    });
    const { top: n, left: i, fontSize: s } = this._calcTextareaPosition();
    t.style.cssText = "position: absolute; top: ".concat(n, "; left: ").concat(i, "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: ").concat(s, ";"), (this.hiddenTextareaContainer || e.body).appendChild(t), Object.entries({ blur: "blur", keydown: "onKeyDown", keyup: "onKeyUp", input: "onInput", copy: "copy", cut: "copy", paste: "paste", compositionstart: "onCompositionStart", compositionupdate: "onCompositionUpdate", compositionend: "onCompositionEnd" }).map((a) => {
      let [c, u] = a;
      return t.addEventListener(c, this[u].bind(this));
    }), this.hiddenTextarea = t;
  }
  blur() {
    this.abortCursorAnimation();
  }
  onKeyDown(e) {
    if (!this.isEditing) return;
    const t = this.direction === "rtl" ? this.keysMapRtl : this.keysMap;
    if (e.keyCode in t) this[t[e.keyCode]](e);
    else {
      if (!(e.keyCode in this.ctrlKeysMapDown) || !e.ctrlKey && !e.metaKey) return;
      this[this.ctrlKeysMapDown[e.keyCode]](e);
    }
    e.stopImmediatePropagation(), e.preventDefault(), e.keyCode >= 33 && e.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll();
  }
  onKeyUp(e) {
    !this.isEditing || this._copyDone || this.inCompositionMode ? this._copyDone = !1 : e.keyCode in this.ctrlKeysMapUp && (e.ctrlKey || e.metaKey) && (this[this.ctrlKeysMapUp[e.keyCode]](e), e.stopImmediatePropagation(), e.preventDefault(), this.canvas && this.canvas.requestRenderAll());
  }
  onInput(e) {
    const t = this.fromPaste;
    if (this.fromPaste = !1, e && e.stopPropagation(), !this.isEditing) return;
    const n = () => {
      this.updateFromTextArea(), this.fire(dl), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll());
    };
    if (this.hiddenTextarea.value === "") return this.styles = {}, void n();
    const i = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, s = this._text.length, a = i.length, c = this.selectionStart, u = this.selectionEnd, h = c !== u;
    let d, p, g, v, b = a - s;
    const x = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value), _ = c > x.selectionStart;
    h ? (p = this._text.slice(c, u), b += u - c) : a < s && (p = _ ? this._text.slice(u + b, u) : this._text.slice(c, c - b));
    const C = i.slice(x.selectionEnd - b, x.selectionEnd);
    if (p && p.length && (C.length && (d = this.getSelectionStyles(c, c + 1, !1), d = C.map(() => d[0])), h ? (g = c, v = u) : _ ? (g = u - p.length, v = u) : (g = u, v = u + p.length), this.removeStyleFromTo(g, v)), C.length) {
      const { copyPasteData: E } = kn();
      t && C.join("") === E.copiedText && !Ue.disableStyleCopyPaste && (d = E.copiedTextStyle), this.insertNewStyleBlock(C, c, d);
    }
    n();
  }
  onCompositionStart() {
    this.inCompositionMode = !0;
  }
  onCompositionEnd() {
    this.inCompositionMode = !1;
  }
  onCompositionUpdate(e) {
    let { target: t } = e;
    const { selectionStart: n, selectionEnd: i } = t;
    this.compositionStart = n, this.compositionEnd = i, this.updateTextareaPosition();
  }
  copy() {
    if (this.selectionStart === this.selectionEnd) return;
    const { copyPasteData: e } = kn();
    e.copiedText = this.getSelectedText(), Ue.disableStyleCopyPaste ? e.copiedTextStyle = void 0 : e.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0;
  }
  paste() {
    this.fromPaste = !0;
  }
  _getWidthBeforeCursor(e, t) {
    let n, i = this._getLineLeftOffset(e);
    return t > 0 && (n = this.__charBounds[e][t - 1], i += n.left + n.width), i;
  }
  getDownCursorOffset(e, t) {
    const n = this._getSelectionForOffset(e, t), i = this.get2DCursorLocation(n), s = i.lineIndex;
    if (s === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) return this._text.length - n;
    const a = i.charIndex, c = this._getWidthBeforeCursor(s, a), u = this._getIndexOnLine(s + 1, c);
    return this._textLines[s].slice(a).length + u + 1 + this.missingNewlineOffset(s);
  }
  _getSelectionForOffset(e, t) {
    return e.shiftKey && this.selectionStart !== this.selectionEnd && t ? this.selectionEnd : this.selectionStart;
  }
  getUpCursorOffset(e, t) {
    const n = this._getSelectionForOffset(e, t), i = this.get2DCursorLocation(n), s = i.lineIndex;
    if (s === 0 || e.metaKey || e.keyCode === 33) return -n;
    const a = i.charIndex, c = this._getWidthBeforeCursor(s, a), u = this._getIndexOnLine(s - 1, c), h = this._textLines[s].slice(0, a), d = this.missingNewlineOffset(s - 1);
    return -this._textLines[s - 1].length + u - h.length + (1 - d);
  }
  _getIndexOnLine(e, t) {
    const n = this._textLines[e];
    let i, s, a = this._getLineLeftOffset(e), c = 0;
    for (let u = 0, h = n.length; u < h; u++) if (i = this.__charBounds[e][u].width, a += i, a > t) {
      s = !0;
      const d = a - i, p = a, g = Math.abs(d - t);
      c = Math.abs(p - t) < g ? u : u - 1;
      break;
    }
    return s || (c = n.length - 1), c;
  }
  moveCursorDown(e) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", e);
  }
  moveCursorUp(e) {
    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorUpOrDown("Up", e);
  }
  _moveCursorUpOrDown(e, t) {
    const n = this["get".concat(e, "CursorOffset")](t, this._selectionDirection === Tt);
    if (t.shiftKey ? this.moveCursorWithShift(n) : this.moveCursorWithoutShift(n), n !== 0) {
      const i = this.text.length;
      this.selectionStart = ns(0, this.selectionStart, i), this.selectionEnd = ns(0, this.selectionEnd, i), this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea();
    }
  }
  moveCursorWithShift(e) {
    const t = this._selectionDirection === Ke ? this.selectionStart + e : this.selectionEnd + e;
    return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, t), e !== 0;
  }
  moveCursorWithoutShift(e) {
    return e < 0 ? (this.selectionStart += e, this.selectionEnd = this.selectionStart) : (this.selectionEnd += e, this.selectionStart = this.selectionEnd), e !== 0;
  }
  moveCursorLeft(e) {
    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorLeftOrRight("Left", e);
  }
  _move(e, t, n) {
    let i;
    if (e.altKey) i = this["findWordBoundary".concat(n)](this[t]);
    else {
      if (!e.metaKey && e.keyCode !== 35 && e.keyCode !== 36) return this[t] += n === "Left" ? -1 : 1, !0;
      i = this["findLineBoundary".concat(n)](this[t]);
    }
    return i !== void 0 && this[t] !== i && (this[t] = i, !0);
  }
  _moveLeft(e, t) {
    return this._move(e, t, "Left");
  }
  _moveRight(e, t) {
    return this._move(e, t, "Right");
  }
  moveCursorLeftWithoutShift(e) {
    let t = !0;
    return this._selectionDirection = Ke, this.selectionEnd === this.selectionStart && this.selectionStart !== 0 && (t = this._moveLeft(e, "selectionStart")), this.selectionEnd = this.selectionStart, t;
  }
  moveCursorLeftWithShift(e) {
    return this._selectionDirection === Tt && this.selectionStart !== this.selectionEnd ? this._moveLeft(e, "selectionEnd") : this.selectionStart !== 0 ? (this._selectionDirection = Ke, this._moveLeft(e, "selectionStart")) : void 0;
  }
  moveCursorRight(e) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", e);
  }
  _moveCursorLeftOrRight(e, t) {
    const n = "moveCursor".concat(e).concat(t.shiftKey ? "WithShift" : "WithoutShift");
    this._currentCursorOpacity = 1, this[n](t) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());
  }
  moveCursorRightWithShift(e) {
    return this._selectionDirection === Ke && this.selectionStart !== this.selectionEnd ? this._moveRight(e, "selectionStart") : this.selectionEnd !== this._text.length ? (this._selectionDirection = Tt, this._moveRight(e, "selectionEnd")) : void 0;
  }
  moveCursorRightWithoutShift(e) {
    let t = !0;
    return this._selectionDirection = Tt, this.selectionStart === this.selectionEnd ? (t = this._moveRight(e, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, t;
  }
}
const td = (r) => !!r.button;
class N6 extends L6 {
  constructor() {
    super(...arguments), j(this, "draggableTextDelegate", void 0);
  }
  initBehavior() {
    this.on("mousedown", this._mouseDownHandler), this.on("mousedown:before", this._mouseDownHandlerBefore), this.on("mouseup", this.mouseUpHandler), this.on("mousedblclick", this.doubleClickHandler), this.on("tripleclick", this.tripleClickHandler), this.__lastClickTime = +/* @__PURE__ */ new Date(), this.__lastLastClickTime = +/* @__PURE__ */ new Date(), this.__lastPointer = {}, this.on("mousedown", this.onMouseDown), this.draggableTextDelegate = new R6(this), super.initBehavior();
  }
  shouldStartDragging() {
    return this.draggableTextDelegate.isActive();
  }
  onDragStart(e) {
    return this.draggableTextDelegate.onDragStart(e);
  }
  canDrop(e) {
    return this.draggableTextDelegate.canDrop(e);
  }
  onMouseDown(e) {
    if (!this.canvas) return;
    this.__newClickTime = +/* @__PURE__ */ new Date();
    const t = e.pointer;
    this.isTripleClick(t) && (this.fire("tripleclick", e), Yd(e.e)), this.__lastLastClickTime = this.__lastClickTime, this.__lastClickTime = this.__newClickTime, this.__lastPointer = t, this.__lastSelected = this.selected && !this.getActiveControl();
  }
  isTripleClick(e) {
    return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === e.x && this.__lastPointer.y === e.y;
  }
  doubleClickHandler(e) {
    this.isEditing && this.selectWord(this.getSelectionStartFromPointer(e.e));
  }
  tripleClickHandler(e) {
    this.isEditing && this.selectLine(this.getSelectionStartFromPointer(e.e));
  }
  _mouseDownHandler(e) {
    let { e: t } = e;
    this.canvas && this.editable && !td(t) && !this.getActiveControl() && (this.draggableTextDelegate.start(t) || (this.canvas.textEditingManager.register(this), this.selected && (this.inCompositionMode = !1, this.setCursorByClick(t)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection())));
  }
  _mouseDownHandlerBefore(e) {
    let { e: t } = e;
    this.canvas && this.editable && !td(t) && (this.selected = this === this.canvas._activeObject);
  }
  mouseUpHandler(e) {
    let { e: t, transform: n } = e;
    const i = this.draggableTextDelegate.end(t);
    if (this.canvas) {
      this.canvas.textEditingManager.unregister(this);
      const s = this.canvas._activeObject;
      if (s && s !== this) return;
    }
    !this.editable || this.group && !this.group.interactive || n && n.actionPerformed || td(t) || i || (this.__lastSelected && !this.getActiveControl() ? (this.selected = !1, this.__lastSelected = !1, this.enterEditing(t), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection()) : this.selected = !0);
  }
  setCursorByClick(e) {
    const t = this.getSelectionStartFromPointer(e), n = this.selectionStart, i = this.selectionEnd;
    e.shiftKey ? this.setSelectionStartEndWithShift(n, i, t) : (this.selectionStart = t, this.selectionEnd = t), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea());
  }
  getSelectionStartFromPointer(e) {
    const t = this.canvas.getScenePoint(e).transform(jr(this.calcTransformMatrix())).add(new B(-this._getLeftOffset(), -this._getTopOffset()));
    let n = 0, i = 0, s = 0;
    for (let h = 0; h < this._textLines.length && n <= t.y; h++) n += this.getHeightOfLine(h), s = h, h > 0 && (i += this._textLines[h - 1].length + this.missingNewlineOffset(h - 1));
    let a = Math.abs(this._getLineLeftOffset(s));
    const c = this._textLines[s].length, u = this.__charBounds[s];
    for (let h = 0; h < c; h++) {
      const d = a + u[h].kernedWidth;
      if (t.x <= d) {
        Math.abs(t.x - d) <= Math.abs(t.x - a) && i++;
        break;
      }
      a = d, i++;
    }
    return Math.min(this.flipX ? c - i : i, this._text.length);
  }
}
const Ic = "moveCursorUp", Ac = "moveCursorDown", Mc = "moveCursorLeft", Pc = "moveCursorRight", Dc = "exitEditing", B6 = D({ selectionStart: 0, selectionEnd: 0, selectionColor: "rgba(17,119,255,0.3)", isEditing: !1, editable: !0, editingBorderColor: "rgba(102,153,255,0.25)", cursorWidth: 2, cursorColor: "", cursorDelay: 1e3, cursorDuration: 600, caching: !0, hiddenTextareaContainer: null, keysMap: { 9: Dc, 27: Dc, 33: Ic, 34: Ac, 35: Pc, 36: Mc, 37: Mc, 38: Ic, 39: Pc, 40: Ac }, keysMapRtl: { 9: Dc, 27: Dc, 33: Ic, 34: Ac, 35: Mc, 36: Pc, 37: Pc, 38: Ic, 39: Mc, 40: Ac }, ctrlKeysMapDown: { 65: "selectAll" }, ctrlKeysMapUp: { 67: "copy", 88: "cut" } }, { _selectionDirection: null, _reSpace: /\s|\r?\n/, inCompositionMode: !1 });
class Xn extends N6 {
  static getDefaults() {
    return D(D({}, super.getDefaults()), Xn.ownDefaults);
  }
  get type() {
    const e = super.type;
    return e === "itext" ? "i-text" : e;
  }
  constructor(e, t) {
    super(e, D(D({}, Xn.ownDefaults), t)), this.initBehavior();
  }
  _set(e, t) {
    return this.isEditing && this._savedProps && e in this._savedProps ? (this._savedProps[e] = t, this) : (e === "canvas" && (this.canvas instanceof nf && this.canvas.textEditingManager.remove(this), t instanceof nf && t.textEditingManager.add(this)), super._set(e, t));
  }
  setSelectionStart(e) {
    e = Math.max(e, 0), this._updateAndFire("selectionStart", e);
  }
  setSelectionEnd(e) {
    e = Math.min(e, this.text.length), this._updateAndFire("selectionEnd", e);
  }
  _updateAndFire(e, t) {
    this[e] !== t && (this._fireSelectionChanged(), this[e] = t), this._updateTextarea();
  }
  _fireSelectionChanged() {
    this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this });
  }
  initDimensions() {
    this.isEditing && this.initDelayedCursor(), super.initDimensions();
  }
  getSelectionStyles() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart || 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionEnd, n = arguments.length > 2 ? arguments[2] : void 0;
    return super.getSelectionStyles(e, t, n);
  }
  setSelectionStyles(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionStart || 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.selectionEnd;
    return super.setSelectionStyles(e, t, n);
  }
  get2DCursorLocation() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, t = arguments.length > 1 ? arguments[1] : void 0;
    return super.get2DCursorLocation(e, t);
  }
  render(e) {
    super.render(e), this.cursorOffsetCache = {}, this.renderCursorOrSelection();
  }
  toCanvasElement(e) {
    const t = this.isEditing;
    this.isEditing = !1;
    const n = super.toCanvasElement(e);
    return this.isEditing = t, n;
  }
  renderCursorOrSelection() {
    if (!this.isEditing) return;
    const e = this.clearContextTop(!0);
    if (!e) return;
    const t = this._getCursorBoundaries();
    this.selectionStart !== this.selectionEnd || this.inCompositionMode ? this.renderSelection(e, t) : this.renderCursor(e, t), this.canvas.contextTopDirty = !0, e.restore();
  }
  _getCursorBoundaries() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, t = arguments.length > 1 ? arguments[1] : void 0;
    const n = this._getLeftOffset(), i = this._getTopOffset(), s = this._getCursorBoundariesOffsets(e, t);
    return { left: n, top: i, leftOffset: s.left, topOffset: s.top };
  }
  _getCursorBoundariesOffsets(e, t) {
    return t ? this.__getCursorBoundariesOffsets(e) : this.cursorOffsetCache && "top" in this.cursorOffsetCache ? this.cursorOffsetCache : this.cursorOffsetCache = this.__getCursorBoundariesOffsets(e);
  }
  __getCursorBoundariesOffsets(e) {
    let t = 0, n = 0;
    const { charIndex: i, lineIndex: s } = this.get2DCursorLocation(e);
    for (let h = 0; h < s; h++) t += this.getHeightOfLine(h);
    const a = this._getLineLeftOffset(s), c = this.__charBounds[s][i];
    c && (n = c.left), this.charSpacing !== 0 && i === this._textLines[s].length && (n -= this._getWidthOfCharSpacing());
    const u = { top: t, left: a + (n > 0 ? n : 0) };
    return this.direction === "rtl" && (this.textAlign === Tt || this.textAlign === wn || this.textAlign === Jo ? u.left *= -1 : this.textAlign === Ke || this.textAlign === Cl ? u.left = a - (n > 0 ? n : 0) : this.textAlign !== Pe && this.textAlign !== Qo || (u.left = a - (n > 0 ? n : 0))), u;
  }
  renderCursorAt(e) {
    this._renderCursor(this.canvas.contextTop, this._getCursorBoundaries(e, !0), e);
  }
  renderCursor(e, t) {
    this._renderCursor(e, t, this.selectionStart);
  }
  getCursorRenderingData() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getCursorBoundaries(e);
    const n = this.get2DCursorLocation(e), i = n.lineIndex, s = n.charIndex > 0 ? n.charIndex - 1 : 0, a = this.getValueOfPropertyAt(i, s, "fontSize"), c = this.getObjectScaling().x * this.canvas.getZoom(), u = this.cursorWidth / c, h = this.getValueOfPropertyAt(i, s, "deltaY"), d = t.topOffset + (1 - this._fontSizeFraction) * this.getHeightOfLine(i) / this.lineHeight - a * (1 - this._fontSizeFraction);
    return { color: this.cursorColor || this.getValueOfPropertyAt(i, s, "fill"), opacity: this._currentCursorOpacity, left: t.left + t.leftOffset - u / 2, top: d + t.top + h, width: u, height: a };
  }
  _renderCursor(e, t, n) {
    const { color: i, opacity: s, left: a, top: c, width: u, height: h } = this.getCursorRenderingData(n, t);
    e.fillStyle = i, e.globalAlpha = s, e.fillRect(a, c, u, h);
  }
  renderSelection(e, t) {
    const n = { selectionStart: this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd: this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd };
    this._renderSelection(e, n, t);
  }
  renderDragSourceEffect() {
    const e = this.draggableTextDelegate.getDragStartSelection();
    this._renderSelection(this.canvas.contextTop, e, this._getCursorBoundaries(e.selectionStart, !0));
  }
  renderDropTargetEffect(e) {
    const t = this.getSelectionStartFromPointer(e);
    this.renderCursorAt(t);
  }
  _renderSelection(e, t, n) {
    const i = t.selectionStart, s = t.selectionEnd, a = this.textAlign.includes(wn), c = this.get2DCursorLocation(i), u = this.get2DCursorLocation(s), h = c.lineIndex, d = u.lineIndex, p = c.charIndex < 0 ? 0 : c.charIndex, g = u.charIndex < 0 ? 0 : u.charIndex;
    for (let v = h; v <= d; v++) {
      const b = this._getLineLeftOffset(v) || 0;
      let x = this.getHeightOfLine(v), _ = 0, C = 0, E = 0;
      if (v === h && (C = this.__charBounds[h][p].left), v >= h && v < d) E = a && !this.isEndOfWrapping(v) ? this.width : this.getLineWidth(v) || 5;
      else if (v === d) if (g === 0) E = this.__charBounds[d][g].left;
      else {
        const V = this._getWidthOfCharSpacing();
        E = this.__charBounds[d][g - 1].left + this.__charBounds[d][g - 1].width - V;
      }
      _ = x, (this.lineHeight < 1 || v === d && this.lineHeight > 1) && (x /= this.lineHeight);
      let k = n.left + b + C, O = x, P = 0;
      const R = E - C;
      this.inCompositionMode ? (e.fillStyle = this.compositionColor || "black", O = 1, P = x) : e.fillStyle = this.selectionColor, this.direction === "rtl" && (this.textAlign === Tt || this.textAlign === wn || this.textAlign === Jo ? k = this.width - k - R : this.textAlign === Ke || this.textAlign === Cl ? k = n.left + b - E : this.textAlign !== Pe && this.textAlign !== Qo || (k = n.left + b - E)), e.fillRect(k, n.top + n.topOffset + P, R, O), n.topOffset += _;
    }
  }
  getCurrentCharFontSize() {
    const e = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(e.l, e.c, "fontSize");
  }
  getCurrentCharColor() {
    const e = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(e.l, e.c, Nt);
  }
  _getCurrentCharIndex() {
    const e = this.get2DCursorLocation(this.selectionStart, !0), t = e.charIndex > 0 ? e.charIndex - 1 : 0;
    return { l: e.lineIndex, c: t };
  }
  dispose() {
    this.exitEditingImpl(), this.draggableTextDelegate.dispose(), super.dispose();
  }
}
j(Xn, "ownDefaults", B6), j(Xn, "type", "IText"), ne.setClass(Xn), ne.setClass(Xn, "i-text");
class Ji extends Xn {
  static getDefaults() {
    return D(D({}, super.getDefaults()), Ji.ownDefaults);
  }
  constructor(e, t) {
    super(e, D(D({}, Ji.ownDefaults), t));
  }
  static createControls() {
    return { controls: Mw() };
  }
  initDimensions() {
    this.initialized && (this.isEditing && this.initDelayedCursor(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), this.textAlign.includes(wn) && this.enlargeSpaces(), this.height = this.calcTextHeight());
  }
  _generateStyleMap(e) {
    let t = 0, n = 0, i = 0;
    const s = {};
    for (let a = 0; a < e.graphemeLines.length; a++) e.graphemeText[i] === `
` && a > 0 ? (n = 0, i++, t++) : !this.splitByGrapheme && this._reSpaceAndTab.test(e.graphemeText[i]) && a > 0 && (n++, i++), s[a] = { line: t, offset: n }, i += e.graphemeLines[a].length, n += e.graphemeLines[a].length;
    return s;
  }
  styleHas(e, t) {
    if (this._styleMap && !this.isWrapping) {
      const n = this._styleMap[t];
      n && (t = n.line);
    }
    return super.styleHas(e, t);
  }
  isEmptyStyles(e) {
    if (!this.styles) return !0;
    let t, n = 0, i = e + 1, s = !1;
    const a = this._styleMap[e], c = this._styleMap[e + 1];
    a && (e = a.line, n = a.offset), c && (i = c.line, s = i === e, t = c.offset);
    const u = e === void 0 ? this.styles : { line: this.styles[e] };
    for (const h in u) for (const d in u[h]) {
      const p = parseInt(d, 10);
      if (p >= n && (!s || p < t)) for (const g in u[h][d]) return !1;
    }
    return !0;
  }
  _getStyleDeclaration(e, t) {
    if (this._styleMap && !this.isWrapping) {
      const n = this._styleMap[e];
      if (!n) return {};
      e = n.line, t = n.offset + t;
    }
    return super._getStyleDeclaration(e, t);
  }
  _setStyleDeclaration(e, t, n) {
    const i = this._styleMap[e];
    super._setStyleDeclaration(i.line, i.offset + t, n);
  }
  _deleteStyleDeclaration(e, t) {
    const n = this._styleMap[e];
    super._deleteStyleDeclaration(n.line, n.offset + t);
  }
  _getLineStyle(e) {
    const t = this._styleMap[e];
    return !!this.styles[t.line];
  }
  _setLineStyle(e) {
    const t = this._styleMap[e];
    super._setLineStyle(t.line);
  }
  _wrapText(e, t) {
    this.isWrapping = !0;
    const n = this.getGraphemeDataForRender(e), i = [];
    for (let s = 0; s < n.wordsData.length; s++) i.push(...this._wrapLine(s, t, n));
    return this.isWrapping = !1, i;
  }
  getGraphemeDataForRender(e) {
    const t = this.splitByGrapheme, n = t ? "" : " ";
    let i = 0;
    return { wordsData: e.map((s, a) => {
      let c = 0;
      const u = t ? this.graphemeSplit(s) : this.wordSplit(s);
      return u.length === 0 ? [{ word: [], width: 0 }] : u.map((h) => {
        const d = t ? [h] : this.graphemeSplit(h), p = this._measureWord(d, a, c);
        return i = Math.max(p, i), c += d.length + n.length, { word: d, width: p };
      });
    }), largestWordWidth: i };
  }
  _measureWord(e, t) {
    let n, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, s = 0;
    for (let a = 0, c = e.length; a < c; a++)
      s += this._getGraphemeBox(e[a], t, a + i, n, !0).kernedWidth, n = e[a];
    return s;
  }
  wordSplit(e) {
    return e.split(this._wordJoiners);
  }
  _wrapLine(e, t, n) {
    let { largestWordWidth: i, wordsData: s } = n, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    const c = this._getWidthOfCharSpacing(), u = this.splitByGrapheme, h = [], d = u ? "" : " ";
    let p = 0, g = [], v = 0, b = 0, x = !0;
    t -= a;
    const _ = Math.max(t, i, this.dynamicMinWidth), C = s[e];
    let E;
    for (v = 0, E = 0; E < C.length; E++) {
      const { word: k, width: O } = C[E];
      v += k.length, p += b + O - c, p > _ && !x ? (h.push(g), g = [], p = O, x = !0) : p += c, x || u || g.push(d), g = g.concat(k), b = u ? 0 : this._measureWord([d], e, v), v++, x = !1;
    }
    return E && h.push(g), i + a > this.dynamicMinWidth && (this.dynamicMinWidth = i - c + a), h;
  }
  isEndOfWrapping(e) {
    return !this._styleMap[e + 1] || this._styleMap[e + 1].line !== this._styleMap[e].line;
  }
  missingNewlineOffset(e, t) {
    return this.splitByGrapheme && !t ? this.isEndOfWrapping(e) ? 1 : 0 : 1;
  }
  _splitTextIntoLines(e) {
    const t = super._splitTextIntoLines(e), n = this._wrapText(t.lines, this.width), i = new Array(n.length);
    for (let s = 0; s < n.length; s++) i[s] = n[s].join("");
    return t.lines = i, t.graphemeLines = n, t;
  }
  getMinWidth() {
    return Math.max(this.minWidth, this.dynamicMinWidth);
  }
  _removeExtraneousStyles() {
    const e = /* @__PURE__ */ new Map();
    for (const t in this._styleMap) {
      const n = parseInt(t, 10);
      if (this._textLines[n]) {
        const i = this._styleMap[t].line;
        e.set("".concat(i), !0);
      }
    }
    for (const t in this.styles) e.has(t) || delete this.styles[t];
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject(["minWidth", "splitByGrapheme", ...e]);
  }
}
j(Ji, "type", "Textbox"), j(Ji, "textLayoutProperties", [...Xn.textLayoutProperties, "width"]), j(Ji, "ownDefaults", { minWidth: 20, dynamicMinWidth: 2, lockScalingFlip: !0, noScaleCache: !1, _wordJoiners: /[ \t\r]/, splitByGrapheme: !1 }), ne.setClass(Ji);
class L0 extends du {
  shouldPerformLayout(e) {
    return !!e.target.clipPath && super.shouldPerformLayout(e);
  }
  shouldLayoutClipPath() {
    return !1;
  }
  calcLayoutResult(e, t) {
    const { target: n } = e, { clipPath: i, group: s } = n;
    if (!i || !this.shouldPerformLayout(e)) return;
    const { width: a, height: c } = Tn(Vw(n, i)), u = new B(a, c);
    if (i.absolutePositioned)
      return { center: Gn(i.getRelativeCenterPoint(), void 0, s ? s.calcTransformMatrix() : void 0), size: u };
    {
      const h = i.getRelativeCenterPoint().transform(n.calcOwnMatrix(), !0);
      if (this.shouldPerformLayout(e)) {
        const { center: d = new B(), correction: p = new B() } = this.calcBoundingBox(t, e) || {};
        return { center: d.add(h), correction: p.subtract(h), size: u };
      }
      return { center: n.getRelativeCenterPoint().add(h), size: u };
    }
  }
}
j(L0, "type", "clip-path"), ne.setClass(L0);
class N0 extends du {
  getInitialSize(e, t) {
    let { target: n } = e, { size: i } = t;
    return new B(n.width || i.x, n.height || i.y);
  }
}
j(N0, "type", "fixed"), ne.setClass(N0);
class V6 extends ca {
  subscribeTargets(e) {
    const t = e.target;
    e.targets.reduce((n, i) => (i.parent && n.add(i.parent), n), /* @__PURE__ */ new Set()).forEach((n) => {
      n.layoutManager.subscribeTargets({ target: n, targets: [t] });
    });
  }
  unsubscribeTargets(e) {
    const t = e.target, n = t.getObjects();
    e.targets.reduce((i, s) => (s.parent && i.add(s.parent), i), /* @__PURE__ */ new Set()).forEach((i) => {
      !n.some((s) => s.parent === i) && i.layoutManager.unsubscribeTargets({ target: i, targets: [t] });
    });
  }
}
class Sn extends qr {
  static getDefaults() {
    return D(D({}, super.getDefaults()), Sn.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, Sn.ownDefaults), this.setOptions(t);
    const { left: n, top: i, layoutManager: s } = t;
    this.groupInit(e, { left: n, top: i, layoutManager: s ?? new V6() });
  }
  _shouldSetNestedCoords() {
    return !0;
  }
  __objectSelectionMonitor() {
  }
  multiSelectAdd() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    this.multiSelectionStacking === "selection-order" ? this.add(...t) : t.forEach((i) => {
      const s = this._objects.findIndex((c) => c.isInFrontOf(i)), a = s === -1 ? this.size() : s;
      this.insertAt(a, i);
    });
  }
  canEnterGroup(e) {
    return this.getObjects().some((t) => t.isDescendantOf(e) || e.isDescendantOf(t)) ? (yi("error", "ActiveSelection: circular object trees are not supported, this call has no effect"), !1) : super.canEnterGroup(e);
  }
  enterGroup(e, t) {
    e.parent && e.parent === e.group ? e.parent._exitGroup(e) : e.group && e.parent !== e.group && e.group.remove(e), this._enterGroup(e, t);
  }
  exitGroup(e, t) {
    this._exitGroup(e, t), e.parent && e.parent._enterGroup(e, !0);
  }
  _onAfterObjectsChange(e, t) {
    super._onAfterObjectsChange(e, t);
    const n = /* @__PURE__ */ new Set();
    t.forEach((i) => {
      const { parent: s } = i;
      s && n.add(s);
    }), e === yp ? n.forEach((i) => {
      i._onAfterObjectsChange(wl, t);
    }) : n.forEach((i) => {
      i._set("dirty", !0);
    });
  }
  onDeselect() {
    return this.removeAll(), !1;
  }
  toString() {
    return "#<ActiveSelection: (".concat(this.complexity(), ")>");
  }
  shouldCache() {
    return !1;
  }
  isOnACache() {
    return !1;
  }
  _renderControls(e, t, n) {
    e.save(), e.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
    const i = D(D({ hasControls: !1 }, n), {}, { forActiveSelection: !0 });
    for (let s = 0; s < this._objects.length; s++) this._objects[s]._renderControls(e, i);
    super._renderControls(e, t), e.restore();
  }
}
j(Sn, "type", "ActiveSelection"), j(Sn, "ownDefaults", { multiSelectionStacking: "canvas-stacking" }), ne.setClass(Sn), ne.setClass(Sn, "activeSelection");
class z6 {
  constructor() {
    j(this, "resources", {});
  }
  applyFilters(e, t, n, i, s) {
    const a = s.getContext("2d");
    if (!a) return;
    a.drawImage(t, 0, 0, n, i);
    const c = { sourceWidth: n, sourceHeight: i, imageData: a.getImageData(0, 0, n, i), originalEl: t, originalImageData: a.getImageData(0, 0, n, i), canvasEl: s, ctx: a, filterBackend: this };
    e.forEach((h) => {
      h.applyTo(c);
    });
    const { imageData: u } = c;
    return u.width === n && u.height === i || (s.width = u.width, s.height = u.height), a.putImageData(u, 0, 0), c;
  }
}
class dx {
  constructor() {
    let { tileSize: e = Ue.textureSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    j(this, "aPosition", new Float32Array([0, 0, 0, 1, 1, 0, 1, 1])), j(this, "resources", {}), this.tileSize = e, this.setupGLContext(e, e), this.captureGPUInfo();
  }
  setupGLContext(e, t) {
    this.dispose(), this.createWebGLCanvas(e, t);
  }
  createWebGLCanvas(e, t) {
    const n = dn({ width: e, height: t }), i = n.getContext("webgl", { alpha: !0, premultipliedAlpha: !1, depth: !1, stencil: !1, antialias: !1 });
    i && (i.clearColor(0, 0, 0, 0), this.canvas = n, this.gl = i);
  }
  applyFilters(e, t, n, i, s, a) {
    const c = this.gl, u = s.getContext("2d");
    if (!c || !u) return;
    let h;
    a && (h = this.getCachedTexture(a, t));
    const d = { originalWidth: t.width || t.naturalWidth || 0, originalHeight: t.height || t.naturalHeight || 0, sourceWidth: n, sourceHeight: i, destinationWidth: n, destinationHeight: i, context: c, sourceTexture: this.createTexture(c, n, i, h ? void 0 : t), targetTexture: this.createTexture(c, n, i), originalTexture: h || this.createTexture(c, n, i, h ? void 0 : t), passes: e.length, webgl: !0, aPosition: this.aPosition, programCache: this.programCache, pass: 0, filterBackend: this, targetCanvas: s }, p = c.createFramebuffer();
    return c.bindFramebuffer(c.FRAMEBUFFER, p), e.forEach((g) => {
      g && g.applyTo(d);
    }), function(g) {
      const v = g.targetCanvas, b = v.width, x = v.height, _ = g.destinationWidth, C = g.destinationHeight;
      b === _ && x === C || (v.width = _, v.height = C);
    }(d), this.copyGLTo2D(c, d), c.bindTexture(c.TEXTURE_2D, null), c.deleteTexture(d.sourceTexture), c.deleteTexture(d.targetTexture), c.deleteFramebuffer(p), u.setTransform(1, 0, 0, 1, 0, 0), d;
  }
  dispose() {
    this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches();
  }
  clearWebGLCaches() {
    this.programCache = {}, this.textureCache = {};
  }
  createTexture(e, t, n, i, s) {
    const { NEAREST: a, TEXTURE_2D: c, RGBA: u, UNSIGNED_BYTE: h, CLAMP_TO_EDGE: d, TEXTURE_MAG_FILTER: p, TEXTURE_MIN_FILTER: g, TEXTURE_WRAP_S: v, TEXTURE_WRAP_T: b } = e, x = e.createTexture();
    return e.bindTexture(c, x), e.texParameteri(c, p, s || a), e.texParameteri(c, g, s || a), e.texParameteri(c, v, d), e.texParameteri(c, b, d), i ? e.texImage2D(c, 0, u, u, h, i) : e.texImage2D(c, 0, u, t, n, 0, u, h, null), x;
  }
  getCachedTexture(e, t, n) {
    const { textureCache: i } = this;
    if (i[e]) return i[e];
    {
      const s = this.createTexture(this.gl, t.width, t.height, t, n);
      return s && (i[e] = s), s;
    }
  }
  evictCachesForKey(e) {
    this.textureCache[e] && (this.gl.deleteTexture(this.textureCache[e]), delete this.textureCache[e]);
  }
  copyGLTo2D(e, t) {
    const n = e.canvas, i = t.targetCanvas, s = i.getContext("2d");
    if (!s) return;
    s.translate(0, i.height), s.scale(1, -1);
    const a = n.height - i.height;
    s.drawImage(n, 0, a, i.width, i.height, 0, 0, i.width, i.height);
  }
  copyGLTo2DPutImageData(e, t) {
    const n = t.targetCanvas.getContext("2d"), i = t.destinationWidth, s = t.destinationHeight, a = i * s * 4;
    if (!n) return;
    const c = new Uint8Array(this.imageBuffer, 0, a), u = new Uint8ClampedArray(this.imageBuffer, 0, a);
    e.readPixels(0, 0, i, s, e.RGBA, e.UNSIGNED_BYTE, c);
    const h = new ImageData(u, i, s);
    n.putImageData(h, 0, 0);
  }
  captureGPUInfo() {
    if (this.gpuInfo) return this.gpuInfo;
    const e = this.gl, t = { renderer: "", vendor: "" };
    if (!e) return t;
    const n = e.getExtension("WEBGL_debug_renderer_info");
    if (n) {
      const i = e.getParameter(n.UNMASKED_RENDERER_WEBGL), s = e.getParameter(n.UNMASKED_VENDOR_WEBGL);
      i && (t.renderer = i.toLowerCase()), s && (t.vendor = s.toLowerCase());
    }
    return this.gpuInfo = t, t;
  }
}
let rd;
function W6() {
  const { WebGLProbe: r } = kn();
  return r.queryWebGL(Kr()), Ue.enableGLFiltering && r.isSupported(Ue.textureSize) ? new dx({ tileSize: Ue.textureSize }) : new z6();
}
function nd() {
  return !rd && (!(arguments.length > 0 && arguments[0] !== void 0) || arguments[0]) && (rd = W6()), rd;
}
const H6 = ["filters", "resizeFilter", "src", "crossOrigin", "type"], fx = ["cropX", "cropY"];
class Xr extends rt {
  static getDefaults() {
    return D(D({}, super.getDefaults()), Xr.ownDefaults);
  }
  constructor(e, t) {
    super(), j(this, "_lastScaleX", 1), j(this, "_lastScaleY", 1), j(this, "_filterScalingX", 1), j(this, "_filterScalingY", 1), this.filters = [], Object.assign(this, Xr.ownDefaults), this.setOptions(t), this.cacheKey = "texture".concat(wi()), this.setElement(typeof e == "string" ? (this.canvas && an(this.canvas.getElement()) || lo()).getElementById(e) : e, t);
  }
  getElement() {
    return this._element;
  }
  setElement(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._element = e, this._originalElement = e, this._setWidthHeight(t), e.classList.add(Xr.CSS_CANVAS), this.filters.length !== 0 && this.applyFilters(), this.resizeFilter && this.applyResizeFilters();
  }
  removeTexture(e) {
    const t = nd(!1);
    t instanceof dx && t.evictCachesForKey(e);
  }
  dispose() {
    super.dispose(), this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._cacheContext = null, ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach((e) => {
      const t = this[e];
      t && kn().dispose(t), this[e] = void 0;
    });
  }
  getCrossOrigin() {
    return this._originalElement && (this._originalElement.crossOrigin || null);
  }
  getOriginalSize() {
    const e = this.getElement();
    return e ? { width: e.naturalWidth || e.width, height: e.naturalHeight || e.height } : { width: 0, height: 0 };
  }
  _stroke(e) {
    if (!this.stroke || this.strokeWidth === 0) return;
    const t = this.width / 2, n = this.height / 2;
    e.beginPath(), e.moveTo(-t, -n), e.lineTo(t, -n), e.lineTo(t, n), e.lineTo(-t, n), e.lineTo(-t, -n), e.closePath();
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = [];
    return this.filters.forEach((n) => {
      n && t.push(n.toObject());
    }), D(D({}, super.toObject([...fx, ...e])), {}, { src: this.getSrc(), crossOrigin: this.getCrossOrigin(), filters: t }, this.resizeFilter ? { resizeFilter: this.resizeFilter.toObject() } : {});
  }
  hasCrop() {
    return !!this.cropX || !!this.cropY || this.width < this._element.width || this.height < this._element.height;
  }
  _toSVG() {
    const e = [], t = this._element, n = -this.width / 2, i = -this.height / 2;
    let s = [], a = [], c = "", u = "";
    if (!t) return [];
    if (this.hasCrop()) {
      const h = wi();
      s.push('<clipPath id="imageCrop_' + h + `">
`, '	<rect x="' + n + '" y="' + i + '" width="' + this.width + '" height="' + this.height + `" />
`, `</clipPath>
`), c = ' clip-path="url(#imageCrop_' + h + ')" ';
    }
    if (this.imageSmoothing || (u = ' image-rendering="optimizeSpeed"'), e.push("	<image ", "COMMON_PARTS", 'xlink:href="'.concat(this.getSvgSrc(!0), '" x="').concat(n - this.cropX, '" y="').concat(i - this.cropY, '" width="').concat(t.width || t.naturalWidth, '" height="').concat(t.height || t.naturalHeight, '"').concat(u).concat(c, `></image>
`)), this.stroke || this.strokeDashArray) {
      const h = this.fill;
      this.fill = null, a = ['	<rect x="'.concat(n, '" y="').concat(i, '" width="').concat(this.width, '" height="').concat(this.height, '" style="').concat(this.getSvgStyles(), `" />
`)], this.fill = h;
    }
    return s = this.paintFirst !== Nt ? s.concat(a, e) : s.concat(e, a), s;
  }
  getSrc(e) {
    const t = e ? this._element : this._originalElement;
    return t ? t.toDataURL ? t.toDataURL() : this.srcFromAttribute ? t.getAttribute("src") || "" : t.src : this.src || "";
  }
  getSvgSrc(e) {
    return this.getSrc(e);
  }
  setSrc(e) {
    let { crossOrigin: t, signal: n } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Zo(e, { crossOrigin: t, signal: n }).then((i) => {
      t !== void 0 && this.set({ crossOrigin: t }), this.setElement(i);
    });
  }
  toString() {
    return '#<Image: { src: "'.concat(this.getSrc(), '" }>');
  }
  applyResizeFilters() {
    const e = this.resizeFilter, t = this.minimumScaleTrigger, n = this.getTotalObjectScaling(), i = n.x, s = n.y, a = this._filteredEl || this._originalElement;
    if (this.group && this.set("dirty", !0), !e || i > t && s > t) return this._element = a, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = i, void (this._lastScaleY = s);
    const c = dn(a), { width: u, height: h } = a;
    this._element = c, this._lastScaleX = e.scaleX = i, this._lastScaleY = e.scaleY = s, nd().applyFilters([e], a, u, h, this._element), this._filterScalingX = c.width / this._originalElement.width, this._filterScalingY = c.height / this._originalElement.height;
  }
  applyFilters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.filters || [];
    if (e = e.filter((s) => s && !s.isNeutralState()), this.set("dirty", !0), this.removeTexture("".concat(this.cacheKey, "_filtered")), e.length === 0) return this._element = this._originalElement, this._filteredEl = void 0, this._filterScalingX = 1, void (this._filterScalingY = 1);
    const t = this._originalElement, n = t.naturalWidth || t.width, i = t.naturalHeight || t.height;
    if (this._element === this._originalElement) {
      const s = dn({ width: n, height: i });
      this._element = s, this._filteredEl = s;
    } else this._filteredEl && (this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, n, i), this._lastScaleX = 1, this._lastScaleY = 1);
    nd().applyFilters(e, this._originalElement, n, i, this._element), this._originalElement.width === this._element.width && this._originalElement.height === this._element.height || (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height);
  }
  _render(e) {
    e.imageSmoothingEnabled = this.imageSmoothing, this.isMoving !== !0 && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(e), this._renderPaintInOrder(e);
  }
  drawCacheOnCanvas(e) {
    e.imageSmoothingEnabled = this.imageSmoothing, super.drawCacheOnCanvas(e);
  }
  shouldCache() {
    return this.needsItsOwnCache();
  }
  _renderFill(e) {
    const t = this._element;
    if (!t) return;
    const n = this._filterScalingX, i = this._filterScalingY, s = this.width, a = this.height, c = Math.max(this.cropX, 0), u = Math.max(this.cropY, 0), h = t.naturalWidth || t.width, d = t.naturalHeight || t.height, p = c * n, g = u * i, v = Math.min(s * n, h - p), b = Math.min(a * i, d - g), x = -s / 2, _ = -a / 2, C = Math.min(s, h / n - c), E = Math.min(a, d / i - u);
    t && e.drawImage(t, p, g, v, b, x, _, C, E);
  }
  _needsResize() {
    const e = this.getTotalObjectScaling();
    return e.x !== this._lastScaleX || e.y !== this._lastScaleY;
  }
  _resetWidthHeight() {
    this.set(this.getOriginalSize());
  }
  _setWidthHeight() {
    let { width: e, height: t } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = this.getOriginalSize();
    this.width = e || n.width, this.height = t || n.height;
  }
  parsePreserveAspectRatioAttribute() {
    const e = ew(this.preserveAspectRatio || ""), t = this.width, n = this.height, i = { width: t, height: n };
    let s, a = this._element.width, c = this._element.height, u = 1, h = 1, d = 0, p = 0, g = 0, v = 0;
    return !e || e.alignX === wr && e.alignY === wr ? (u = t / a, h = n / c) : (e.meetOrSlice === "meet" && (u = h = Ww(this._element, i), s = (t - a * u) / 2, e.alignX === "Min" && (d = -s), e.alignX === "Max" && (d = s), s = (n - c * h) / 2, e.alignY === "Min" && (p = -s), e.alignY === "Max" && (p = s)), e.meetOrSlice === "slice" && (u = h = Hw(this._element, i), s = a - t / u, e.alignX === "Mid" && (g = s / 2), e.alignX === "Max" && (g = s), s = c - n / h, e.alignY === "Mid" && (v = s / 2), e.alignY === "Max" && (v = s), a = t / u, c = n / h)), { width: a, height: c, scaleX: u, scaleY: h, offsetLeft: d, offsetTop: p, cropX: g, cropY: v };
  }
  static fromObject(e, t) {
    let { filters: n, resizeFilter: i, src: s, crossOrigin: a, type: c } = e, u = ht(e, H6);
    return Promise.all([Zo(s, D(D({}, t), {}, { crossOrigin: a })), n && Gs(n, t), i && Gs([i], t), Sa(u, t)]).then((h) => {
      let [d, p = [], [g] = [], v = {}] = h;
      return new this(d, D(D({}, u), {}, { src: s, filters: p, resizeFilter: g }, v));
    });
  }
  static fromURL(e) {
    let { crossOrigin: t = null, signal: n } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = arguments.length > 2 ? arguments[2] : void 0;
    return Zo(e, { crossOrigin: t, signal: n }).then((s) => new this(s, i));
  }
  static async fromElement(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;
    const i = ti(e, this.ATTRIBUTE_NAMES, n);
    return this.fromURL(i["xlink:href"], t, i).catch((s) => (yi("log", "Unable to parse Image", s), null));
  }
}
j(Xr, "type", "Image"), j(Xr, "cacheProperties", [...ei, ...fx]), j(Xr, "ownDefaults", { strokeWidth: 0, srcFromAttribute: !1, minimumScaleTrigger: 0.5, cropX: 0, cropY: 0, imageSmoothing: !0 }), j(Xr, "CSS_CANVAS", "canvas-img"), j(Xr, "ATTRIBUTE_NAMES", [...Ai, "x", "y", "width", "height", "preserveAspectRatio", "xlink:href", "crossOrigin", "image-rendering"]), ne.setClass(Xr), ne.setSVGClass(Xr);
au(["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"]);
const px = $b, B0 = (r) => function(e, t, n) {
  const { points: i, pathOffset: s } = n;
  return new B(i[r]).subtract(s).transform(xt(n.getViewportTransform(), n.calcTransformMatrix()));
}, gx = (r, e, t, n) => {
  const { target: i, pointIndex: s } = e, a = i, c = Gn(new B(t, n), void 0, a.calcOwnMatrix());
  return a.points[s] = c.add(a.pathOffset), a.setDimensions(), !0;
}, mx = (r, e) => function(t, n, i, s) {
  const a = n.target, c = new B(a.points[(r > 0 ? r : a.points.length) - 1]), u = c.subtract(a.pathOffset).transform(a.calcOwnMatrix()), h = e(t, D(D({}, n), {}, { pointIndex: r }), i, s), d = c.subtract(a.pathOffset).transform(a.calcOwnMatrix()).subtract(u);
  return a.left -= d.x, a.top -= d.y, h;
}, V0 = (r) => Ii(px, mx(r, gx)), of = (r, e, t) => {
  const { path: n, pathOffset: i } = r, s = n[e];
  return new B(s[t] - i.x, s[t + 1] - i.y).transform(xt(r.getViewportTransform(), r.calcTransformMatrix()));
};
function U6(r, e, t) {
  const { commandIndex: n, pointIndex: i } = this;
  return of(t, n, i);
}
function $6(r, e, t, n) {
  const { target: i } = e, { commandIndex: s, pointIndex: a } = this, c = ((u, h, d, p, g) => {
    const { path: v, pathOffset: b } = u, x = v[(p > 0 ? p : v.length) - 1], _ = new B(x[g], x[g + 1]), C = _.subtract(b).transform(u.calcOwnMatrix()), E = Gn(new B(h, d), void 0, u.calcOwnMatrix());
    v[p][g] = E.x + b.x, v[p][g + 1] = E.y + b.y, u.setDimensions();
    const k = _.subtract(u.pathOffset).transform(u.calcOwnMatrix()).subtract(C);
    return u.left -= k.x, u.top -= k.y, u.set("dirty", !0), !0;
  })(i, t, n, s, a);
  return cp(this.actionName, D(D({}, lp(r, e, t, n)), {}, { commandIndex: s, pointIndex: a })), c;
}
class vx extends gt {
  constructor(e) {
    super(e);
  }
  render(e, t, n, i, s) {
    const a = D(D({}, i), {}, { cornerColor: this.controlFill, cornerStrokeColor: this.controlStroke, transparentCorners: !this.controlFill });
    super.render(e, t, n, a, s);
  }
}
class Y6 extends vx {
  constructor(e) {
    super(e);
  }
  render(e, t, n, i, s) {
    const { path: a } = s, { commandIndex: c, pointIndex: u, connectToCommandIndex: h, connectToPointIndex: d } = this;
    e.save(), e.strokeStyle = this.controlStroke, this.connectionDashArray && e.setLineDash(this.connectionDashArray);
    const [p] = a[c], g = of(s, h, d);
    if (p === "Q") {
      const v = of(s, c, u + 2);
      e.moveTo(v.x, v.y), e.lineTo(t, n);
    } else e.moveTo(t, n);
    e.lineTo(g.x, g.y), e.stroke(), e.restore(), super.render(e, t, n, i, s);
  }
}
const jc = (r, e, t, n, i, s) => new (t ? Y6 : vx)(D(D({ commandIndex: r, pointIndex: e, actionName: "modifyPath", positionHandler: U6, actionHandler: $6, connectToCommandIndex: i, connectToPointIndex: s }, n), t ? n.controlPointStyle : n.pointStyle));
var Zt = Object.freeze({ __proto__: null, changeWidth: Kd, createObjectDefaultControls: gp, createPathControls: function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = {};
  let n = "M";
  return r.path.forEach((i, s) => {
    const a = i[0];
    switch (a !== "Z" && (t["c_".concat(s, "_").concat(a)] = jc(s, i.length - 2, !1, e)), a) {
      case "C":
        t["c_".concat(s, "_C_CP_1")] = jc(s, 1, !0, e, s - 1, /* @__PURE__ */ ((c) => c === "C" ? 5 : c === "Q" ? 3 : 1)(n)), t["c_".concat(s, "_C_CP_2")] = jc(s, 3, !0, e, s, 5);
        break;
      case "Q":
        t["c_".concat(s, "_Q_CP_1")] = jc(s, 1, !0, e, s, 3);
    }
    n = a;
  }), t;
}, createPolyActionHandler: V0, createPolyControls: function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = {};
  for (let n = 0; n < (typeof r == "number" ? r : r.points.length); n++) t["p".concat(n)] = new gt(D({ actionName: px, positionHandler: B0(n), actionHandler: V0(n) }, e));
  return t;
}, createPolyPositionHandler: B0, createResizeControls: Aw, createTextboxDefaultControls: Mw, dragHandler: hw, factoryPolyActionHandler: mx, getLocalPoint: ou, polyActionHandler: gx, renderCircleControl: yw, renderSquareControl: bw, rotationStyleHandler: ww, rotationWithSnapping: xw, scaleCursorStyleHandler: Bs, scaleOrSkewActionName: $o, scaleSkewCursorStyleHandler: Ki, scalingEqually: Uo, scalingX: Cw, scalingXOrSkewingY: Zd, scalingY: Tw, scalingYOrSkewingX: Jd, skewCursorStyleHandler: Ew, skewHandlerX: Ow, skewHandlerY: Iw, wrapWithFireEvent: Ii, wrapWithFixedAnchor: gs });
const pu = (r) => r.webgl !== void 0, wp = "precision highp float", X6 = `
    `.concat(wp, `;
    varying vec2 vTexCoord;
    uniform sampler2D uTexture;
    void main() {
      gl_FragColor = texture2D(uTexture, vTexCoord);
    }`), G6 = ["type"], q6 = ["type"], K6 = new RegExp(wp, "g");
class Bt {
  get type() {
    return this.constructor.type;
  }
  constructor() {
    let e = ht(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, G6);
    Object.assign(this, this.constructor.defaults, e);
  }
  getFragmentSource() {
    return X6;
  }
  getVertexSource() {
    return `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    void main() {
      vTexCoord = aPosition;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }`;
  }
  createProgram(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getFragmentSource(), n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.getVertexSource();
    const { WebGLProbe: { GLPrecision: i = "highp" } } = kn();
    i !== "highp" && (t = t.replace(K6, wp.replace("highp", i)));
    const s = e.createShader(e.VERTEX_SHADER), a = e.createShader(e.FRAGMENT_SHADER), c = e.createProgram();
    if (!s || !a || !c) throw new _n("Vertex, fragment shader or program creation error");
    if (e.shaderSource(s, n), e.compileShader(s), !e.getShaderParameter(s, e.COMPILE_STATUS)) throw new _n("Vertex shader compile error for ".concat(this.type, ": ").concat(e.getShaderInfoLog(s)));
    if (e.shaderSource(a, t), e.compileShader(a), !e.getShaderParameter(a, e.COMPILE_STATUS)) throw new _n("Fragment shader compile error for ".concat(this.type, ": ").concat(e.getShaderInfoLog(a)));
    if (e.attachShader(c, s), e.attachShader(c, a), e.linkProgram(c), !e.getProgramParameter(c, e.LINK_STATUS)) throw new _n('Shader link error for "'.concat(this.type, '" ').concat(e.getProgramInfoLog(c)));
    const u = this.getUniformLocations(e, c) || {};
    return u.uStepW = e.getUniformLocation(c, "uStepW"), u.uStepH = e.getUniformLocation(c, "uStepH"), { program: c, attributeLocations: this.getAttributeLocations(e, c), uniformLocations: u };
  }
  getAttributeLocations(e, t) {
    return { aPosition: e.getAttribLocation(t, "aPosition") };
  }
  getUniformLocations(e, t) {
    const n = this.constructor.uniformLocations, i = {};
    for (let s = 0; s < n.length; s++) i[n[s]] = e.getUniformLocation(t, n[s]);
    return i;
  }
  sendAttributeData(e, t, n) {
    const i = t.aPosition, s = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, s), e.enableVertexAttribArray(i), e.vertexAttribPointer(i, 2, e.FLOAT, !1, 0, 0), e.bufferData(e.ARRAY_BUFFER, n, e.STATIC_DRAW);
  }
  _setupFrameBuffer(e) {
    const t = e.context;
    if (e.passes > 1) {
      const n = e.destinationWidth, i = e.destinationHeight;
      e.sourceWidth === n && e.sourceHeight === i || (t.deleteTexture(e.targetTexture), e.targetTexture = e.filterBackend.createTexture(t, n, i)), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e.targetTexture, 0);
    } else t.bindFramebuffer(t.FRAMEBUFFER, null), t.finish();
  }
  _swapTextures(e) {
    e.passes--, e.pass++;
    const t = e.targetTexture;
    e.targetTexture = e.sourceTexture, e.sourceTexture = t;
  }
  isNeutralState(e) {
    return !1;
  }
  applyTo(e) {
    pu(e) ? (this._setupFrameBuffer(e), this.applyToWebGL(e), this._swapTextures(e)) : this.applyTo2d(e);
  }
  applyTo2d(e) {
  }
  getCacheKey() {
    return this.type;
  }
  retrieveShader(e) {
    const t = this.getCacheKey();
    return e.programCache[t] || (e.programCache[t] = this.createProgram(e.context)), e.programCache[t];
  }
  applyToWebGL(e) {
    const t = e.context, n = this.retrieveShader(e);
    e.pass === 0 && e.originalTexture ? t.bindTexture(t.TEXTURE_2D, e.originalTexture) : t.bindTexture(t.TEXTURE_2D, e.sourceTexture), t.useProgram(n.program), this.sendAttributeData(t, n.attributeLocations, e.aPosition), t.uniform1f(n.uniformLocations.uStepW, 1 / e.sourceWidth), t.uniform1f(n.uniformLocations.uStepH, 1 / e.sourceHeight), this.sendUniformData(t, n.uniformLocations), t.viewport(0, 0, e.destinationWidth, e.destinationHeight), t.drawArrays(t.TRIANGLE_STRIP, 0, 4);
  }
  bindAdditionalTexture(e, t, n) {
    e.activeTexture(n), e.bindTexture(e.TEXTURE_2D, t), e.activeTexture(e.TEXTURE0);
  }
  unbindAdditionalTexture(e, t) {
    e.activeTexture(t), e.bindTexture(e.TEXTURE_2D, null), e.activeTexture(e.TEXTURE0);
  }
  sendUniformData(e, t) {
  }
  createHelpLayer(e) {
    if (!e.helpLayer) {
      const { sourceWidth: t, sourceHeight: n } = e, i = dn({ width: t, height: n });
      e.helpLayer = i;
    }
  }
  toObject() {
    const e = Object.keys(this.constructor.defaults || {});
    return D({ type: this.type }, e.reduce((t, n) => (t[n] = this[n], t), {}));
  }
  toJSON() {
    return this.toObject();
  }
  static async fromObject(e, t) {
    return new this(ht(e, q6));
  }
}
j(Bt, "type", "BaseFilter"), j(Bt, "uniformLocations", []);
const Z6 = { multiply: `gl_FragColor.rgb *= uColor.rgb;
`, screen: `gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);
`, add: `gl_FragColor.rgb += uColor.rgb;
`, difference: `gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);
`, subtract: `gl_FragColor.rgb -= uColor.rgb;
`, lighten: `gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);
`, darken: `gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);
`, exclusion: `gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);
`, overlay: `
    if (uColor.r < 0.5) {
      gl_FragColor.r *= 2.0 * uColor.r;
    } else {
      gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);
    }
    if (uColor.g < 0.5) {
      gl_FragColor.g *= 2.0 * uColor.g;
    } else {
      gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);
    }
    if (uColor.b < 0.5) {
      gl_FragColor.b *= 2.0 * uColor.b;
    } else {
      gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);
    }
    `, tint: `
    gl_FragColor.rgb *= (1.0 - uColor.a);
    gl_FragColor.rgb += uColor.rgb;
    ` };
class Rc extends Bt {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return `
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec4 uColor;
      varying vec2 vTexCoord;
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        gl_FragColor = color;
        if (color.a > 0.0) {
          `.concat(Z6[this.mode], `
        }
      }
      `);
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = new Qe(this.color).getSource(), i = this.alpha, s = n[0] * i, a = n[1] * i, c = n[2] * i, u = 1 - i;
    for (let h = 0; h < t.length; h += 4) {
      const d = t[h], p = t[h + 1], g = t[h + 2];
      let v, b, x;
      switch (this.mode) {
        case "multiply":
          v = d * s / 255, b = p * a / 255, x = g * c / 255;
          break;
        case "screen":
          v = 255 - (255 - d) * (255 - s) / 255, b = 255 - (255 - p) * (255 - a) / 255, x = 255 - (255 - g) * (255 - c) / 255;
          break;
        case "add":
          v = d + s, b = p + a, x = g + c;
          break;
        case "difference":
          v = Math.abs(d - s), b = Math.abs(p - a), x = Math.abs(g - c);
          break;
        case "subtract":
          v = d - s, b = p - a, x = g - c;
          break;
        case "darken":
          v = Math.min(d, s), b = Math.min(p, a), x = Math.min(g, c);
          break;
        case "lighten":
          v = Math.max(d, s), b = Math.max(p, a), x = Math.max(g, c);
          break;
        case "overlay":
          v = s < 128 ? 2 * d * s / 255 : 255 - 2 * (255 - d) * (255 - s) / 255, b = a < 128 ? 2 * p * a / 255 : 255 - 2 * (255 - p) * (255 - a) / 255, x = c < 128 ? 2 * g * c / 255 : 255 - 2 * (255 - g) * (255 - c) / 255;
          break;
        case "exclusion":
          v = s + d - 2 * s * d / 255, b = a + p - 2 * a * p / 255, x = c + g - 2 * c * g / 255;
          break;
        case "tint":
          v = s + d * u, b = a + p * u, x = c + g * u;
      }
      t[h] = v, t[h + 1] = b, t[h + 2] = x;
    }
  }
  sendUniformData(e, t) {
    const n = new Qe(this.color).getSource();
    n[0] = this.alpha * n[0] / 255, n[1] = this.alpha * n[1] / 255, n[2] = this.alpha * n[2] / 255, n[3] = this.alpha, e.uniform4fv(t.uColor, n);
  }
}
j(Rc, "defaults", { color: "#F95C63", mode: "multiply", alpha: 1 }), j(Rc, "type", "BlendColor"), j(Rc, "uniformLocations", ["uColor"]), ne.setClass(Rc);
const J6 = { multiply: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.rgba *= color2.rgba;
      gl_FragColor = color;
    }
    `, mask: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.a = color2.a;
      gl_FragColor = color;
    }
    ` }, Q6 = ["type", "image"];
class Fc extends Bt {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return J6[this.mode];
  }
  getVertexSource() {
    return `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    uniform mat3 uTransformMatrix;
    void main() {
      vTexCoord = aPosition;
      vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }
    `;
  }
  applyToWebGL(e) {
    const t = e.context, n = this.createTexture(e.filterBackend, this.image);
    this.bindAdditionalTexture(t, n, t.TEXTURE1), super.applyToWebGL(e), this.unbindAdditionalTexture(t, t.TEXTURE1);
  }
  createTexture(e, t) {
    return e.getCachedTexture(t.cacheKey, t.getElement());
  }
  calculateMatrix() {
    const e = this.image, { width: t, height: n } = e.getElement();
    return [1 / e.scaleX, 0, 0, 0, 1 / e.scaleY, 0, -e.left / t, -e.top / n, 1];
  }
  applyTo2d(e) {
    let { imageData: { data: t, width: n, height: i }, filterBackend: { resources: s } } = e;
    const a = this.image;
    s.blendImage || (s.blendImage = Kr());
    const c = s.blendImage, u = c.getContext("2d");
    c.width !== n || c.height !== i ? (c.width = n, c.height = i) : u.clearRect(0, 0, n, i), u.setTransform(a.scaleX, 0, 0, a.scaleY, a.left, a.top), u.drawImage(a.getElement(), 0, 0, n, i);
    const h = u.getImageData(0, 0, n, i).data;
    for (let d = 0; d < t.length; d += 4) {
      const p = t[d], g = t[d + 1], v = t[d + 2], b = t[d + 3], x = h[d], _ = h[d + 1], C = h[d + 2], E = h[d + 3];
      switch (this.mode) {
        case "multiply":
          t[d] = p * x / 255, t[d + 1] = g * _ / 255, t[d + 2] = v * C / 255, t[d + 3] = b * E / 255;
          break;
        case "mask":
          t[d + 3] = E;
      }
    }
  }
  sendUniformData(e, t) {
    const n = this.calculateMatrix();
    e.uniform1i(t.uImage, 1), e.uniformMatrix3fv(t.uTransformMatrix, !1, n);
  }
  toObject() {
    return D(D({}, super.toObject()), {}, { image: this.image && this.image.toObject() });
  }
  static async fromObject(e, t) {
    let { type: n, image: i } = e, s = ht(e, Q6);
    return Xr.fromObject(i, t).then((a) => new this(D(D({}, s), {}, { image: a })));
  }
}
j(Fc, "type", "BlendImage"), j(Fc, "defaults", { mode: "multiply", alpha: 1 }), j(Fc, "uniformLocations", ["uTransformMatrix", "uImage"]), ne.setClass(Fc);
class Lc extends Bt {
  getFragmentSource() {
    return `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uDelta;
    varying vec2 vTexCoord;
    const float nSamples = 15.0;
    vec3 v3offset = vec3(12.9898, 78.233, 151.7182);
    float random(vec3 scale) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);
    }
    void main() {
      vec4 color = vec4(0.0);
      float total = 0.0;
      float offset = random(v3offset);
      for (float t = -nSamples; t <= nSamples; t++) {
        float percent = (t + offset - 0.5) / nSamples;
        float weight = 1.0 - abs(percent);
        color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;
        total += weight;
      }
      gl_FragColor = color / total;
    }
  `;
  }
  applyTo(e) {
    pu(e) ? (this.aspectRatio = e.sourceWidth / e.sourceHeight, e.passes++, this._setupFrameBuffer(e), this.horizontal = !0, this.applyToWebGL(e), this._swapTextures(e), this._setupFrameBuffer(e), this.horizontal = !1, this.applyToWebGL(e), this._swapTextures(e)) : this.applyTo2d(e);
  }
  applyTo2d(e) {
    e.imageData = this.simpleBlur(e);
  }
  simpleBlur(e) {
    let { ctx: t, imageData: n, filterBackend: { resources: i } } = e;
    const { width: s, height: a } = n;
    i.blurLayer1 || (i.blurLayer1 = Kr(), i.blurLayer2 = Kr());
    const c = i.blurLayer1, u = i.blurLayer2;
    c.width === s && c.height === a || (u.width = c.width = s, u.height = c.height = a);
    const h = c.getContext("2d"), d = u.getContext("2d"), p = 15, g = 0.06 * this.blur * 0.5;
    let v, b, x, _;
    for (h.putImageData(n, 0, 0), d.clearRect(0, 0, s, a), _ = -15; _ <= p; _++) v = (Math.random() - 0.5) / 4, b = _ / p, x = g * b * s + v, d.globalAlpha = 1 - Math.abs(b), d.drawImage(c, x, v), h.drawImage(u, 0, 0), d.globalAlpha = 1, d.clearRect(0, 0, u.width, u.height);
    for (_ = -15; _ <= p; _++) v = (Math.random() - 0.5) / 4, b = _ / p, x = g * b * a + v, d.globalAlpha = 1 - Math.abs(b), d.drawImage(c, v, x), h.drawImage(u, 0, 0), d.globalAlpha = 1, d.clearRect(0, 0, u.width, u.height);
    t.drawImage(c, 0, 0);
    const C = t.getImageData(0, 0, c.width, c.height);
    return h.globalAlpha = 1, h.clearRect(0, 0, c.width, c.height), C;
  }
  sendUniformData(e, t) {
    const n = this.chooseRightDelta();
    e.uniform2fv(t.uDelta, n);
  }
  isNeutralState() {
    return this.blur === 0;
  }
  chooseRightDelta() {
    let e = 1;
    const t = [0, 0];
    this.horizontal ? this.aspectRatio > 1 && (e = 1 / this.aspectRatio) : this.aspectRatio < 1 && (e = this.aspectRatio);
    const n = e * this.blur * 0.12;
    return this.horizontal ? t[0] = n : t[1] = n, t;
  }
}
j(Lc, "type", "Blur"), j(Lc, "defaults", { blur: 0 }), j(Lc, "uniformLocations", ["uDelta"]), ne.setClass(Lc);
class Nc extends Bt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBrightness;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += uBrightness;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = Math.round(255 * this.brightness);
    for (let i = 0; i < t.length; i += 4) t[i] += n, t[i + 1] += n, t[i + 2] += n;
  }
  isNeutralState() {
    return this.brightness === 0;
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uBrightness, this.brightness);
  }
}
j(Nc, "type", "Brightness"), j(Nc, "defaults", { brightness: 0 }), j(Nc, "uniformLocations", ["uBrightness"]), ne.setClass(Nc);
const yx = { matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], colorsOnly: !0 };
class zs extends Bt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  varying vec2 vTexCoord;
  uniform mat4 uColorMatrix;
  uniform vec4 uConstants;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color *= uColorMatrix;
    color += uConstants;
    gl_FragColor = color;
  }`;
  }
  applyTo2d(e) {
    const t = e.imageData.data, n = this.matrix, i = this.colorsOnly;
    for (let s = 0; s < t.length; s += 4) {
      const a = t[s], c = t[s + 1], u = t[s + 2];
      if (t[s] = a * n[0] + c * n[1] + u * n[2] + 255 * n[4], t[s + 1] = a * n[5] + c * n[6] + u * n[7] + 255 * n[9], t[s + 2] = a * n[10] + c * n[11] + u * n[12] + 255 * n[14], !i) {
        const h = t[s + 3];
        t[s] += h * n[3], t[s + 1] += h * n[8], t[s + 2] += h * n[13], t[s + 3] = a * n[15] + c * n[16] + u * n[17] + h * n[18] + 255 * n[19];
      }
    }
  }
  sendUniformData(e, t) {
    const n = this.matrix, i = [n[0], n[1], n[2], n[3], n[5], n[6], n[7], n[8], n[10], n[11], n[12], n[13], n[15], n[16], n[17], n[18]], s = [n[4], n[9], n[14], n[19]];
    e.uniformMatrix4fv(t.uColorMatrix, !1, i), e.uniform4fv(t.uConstants, s);
  }
  toObject() {
    return D(D({}, super.toObject()), {}, { matrix: [...this.matrix] });
  }
}
function ms(r, e) {
  var t;
  const n = (j(t = class extends zs {
    toObject() {
      return { type: this.type, colorsOnly: this.colorsOnly };
    }
  }, "type", r), j(t, "defaults", { colorsOnly: !1, matrix: e }), t);
  return ne.setClass(n, r), n;
}
j(zs, "type", "ColorMatrix"), j(zs, "defaults", yx), j(zs, "uniformLocations", ["uColorMatrix", "uConstants"]), ne.setClass(zs);
ms("Brownie", [0.5997, 0.34553, -0.27082, 0, 0.186, -0.0377, 0.86095, 0.15059, 0, -0.1449, 0.24113, -0.07441, 0.44972, 0, -0.02965, 0, 0, 0, 1, 0]);
ms("Vintage", [0.62793, 0.32021, -0.03965, 0, 0.03784, 0.02578, 0.64411, 0.03259, 0, 0.02926, 0.0466, -0.08512, 0.52416, 0, 0.02023, 0, 0, 0, 1, 0]);
ms("Kodachrome", [1.12855, -0.39673, -0.03992, 0, 0.24991, -0.16404, 1.08352, -0.05498, 0, 0.09698, -0.16786, -0.56034, 1.60148, 0, 0.13972, 0, 0, 0, 1, 0]);
ms("Technicolor", [1.91252, -0.85453, -0.09155, 0, 0.04624, -0.30878, 1.76589, -0.10601, 0, -0.27589, -0.2311, -0.75018, 1.84759, 0, 0.12137, 0, 0, 0, 1, 0]);
ms("Polaroid", [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0]);
ms("Sepia", [0.393, 0.769, 0.189, 0, 0, 0.349, 0.686, 0.168, 0, 0, 0.272, 0.534, 0.131, 0, 0, 0, 0, 0, 1, 0]);
ms("BlackWhite", [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0]);
class z0 extends Bt {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e), this.subFilters = e.subFilters || [];
  }
  applyTo(e) {
    pu(e) && (e.passes += this.subFilters.length - 1), this.subFilters.forEach((t) => {
      t.applyTo(e);
    });
  }
  toObject() {
    return { type: this.type, subFilters: this.subFilters.map((e) => e.toObject()) };
  }
  isNeutralState() {
    return !this.subFilters.some((e) => !e.isNeutralState());
  }
  static fromObject(e, t) {
    return Promise.all((e.subFilters || []).map((n) => ne.getClass(n.type).fromObject(n, t))).then((n) => new this({ subFilters: n }));
  }
}
j(z0, "type", "Composed"), ne.setClass(z0);
class Bc extends Bt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uContrast;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));
    color.rgb = contrastF * (color.rgb - 0.5) + 0.5;
    gl_FragColor = color;
  }`;
  }
  isNeutralState() {
    return this.contrast === 0;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = Math.floor(255 * this.contrast), i = 259 * (n + 255) / (255 * (259 - n));
    for (let s = 0; s < t.length; s += 4) t[s] = i * (t[s] - 128) + 128, t[s + 1] = i * (t[s + 1] - 128) + 128, t[s + 2] = i * (t[s + 2] - 128) + 128;
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uContrast, this.contrast);
  }
}
j(Bc, "type", "Contrast"), j(Bc, "defaults", { contrast: 0 }), j(Bc, "uniformLocations", ["uContrast"]), ne.setClass(Bc);
const e8 = { Convolute_3_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_3_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_5_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_5_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_7_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_7_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_9_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_9_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    ` };
class Vc extends Bt {
  getCacheKey() {
    return "".concat(this.type, "_").concat(Math.sqrt(this.matrix.length), "_").concat(this.opaque ? 1 : 0);
  }
  getFragmentSource() {
    return e8[this.getCacheKey()];
  }
  applyTo2d(e) {
    const t = e.imageData, n = t.data, i = this.matrix, s = Math.round(Math.sqrt(i.length)), a = Math.floor(s / 2), c = t.width, u = t.height, h = e.ctx.createImageData(c, u), d = h.data, p = this.opaque ? 1 : 0;
    let g, v, b, x, _, C, E, k, O, P, R, V, F;
    for (R = 0; R < u; R++) for (P = 0; P < c; P++) {
      for (_ = 4 * (R * c + P), g = 0, v = 0, b = 0, x = 0, F = 0; F < s; F++) for (V = 0; V < s; V++) E = R + F - a, C = P + V - a, E < 0 || E >= u || C < 0 || C >= c || (k = 4 * (E * c + C), O = i[F * s + V], g += n[k] * O, v += n[k + 1] * O, b += n[k + 2] * O, p || (x += n[k + 3] * O));
      d[_] = g, d[_ + 1] = v, d[_ + 2] = b, d[_ + 3] = p ? n[_ + 3] : x;
    }
    e.imageData = h;
  }
  sendUniformData(e, t) {
    e.uniform1fv(t.uMatrix, this.matrix);
  }
  toObject() {
    return D(D({}, super.toObject()), {}, { opaque: this.opaque, matrix: [...this.matrix] });
  }
}
j(Vc, "type", "Convolute"), j(Vc, "defaults", { opaque: !1, matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0] }), j(Vc, "uniformLocations", ["uMatrix", "uOpaque", "uHalfSize", "uSize"]), ne.setClass(Vc);
const bx = "Gamma";
class zc extends Bt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform vec3 uGamma;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    vec3 correction = (1.0 / uGamma);
    color.r = pow(color.r, correction.r);
    color.g = pow(color.g, correction.g);
    color.b = pow(color.b, correction.b);
    gl_FragColor = color;
    gl_FragColor.rgb *= color.a;
  }
`;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e), this.gamma = e.gamma || this.constructor.defaults.gamma.concat();
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = this.gamma, i = 1 / n[0], s = 1 / n[1], a = 1 / n[2];
    this.rgbValues || (this.rgbValues = { r: new Uint8Array(256), g: new Uint8Array(256), b: new Uint8Array(256) });
    const c = this.rgbValues;
    for (let u = 0; u < 256; u++) c.r[u] = 255 * Math.pow(u / 255, i), c.g[u] = 255 * Math.pow(u / 255, s), c.b[u] = 255 * Math.pow(u / 255, a);
    for (let u = 0; u < t.length; u += 4) t[u] = c.r[t[u]], t[u + 1] = c.g[t[u + 1]], t[u + 2] = c.b[t[u + 2]];
  }
  sendUniformData(e, t) {
    e.uniform3fv(t.uGamma, this.gamma);
  }
  isNeutralState() {
    const { gamma: e } = this;
    return e[0] === 1 && e[1] === 1 && e[2] === 1;
  }
  toObject() {
    return { type: bx, gamma: this.gamma.concat() };
  }
}
j(zc, "type", bx), j(zc, "defaults", { gamma: [1, 1, 1] }), j(zc, "uniformLocations", ["uGamma"]), ne.setClass(zc);
const t8 = { average: `
    precision highp float;
    uniform sampler2D uTexture;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      float average = (color.r + color.b + color.g) / 3.0;
      gl_FragColor = vec4(average, average, average, color.a);
    }
    `, lightness: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    `, luminosity: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    ` };
class Wc extends Bt {
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    for (let n, i = 0; i < t.length; i += 4) {
      const s = t[i], a = t[i + 1], c = t[i + 2];
      switch (this.mode) {
        case "average":
          n = (s + a + c) / 3;
          break;
        case "lightness":
          n = (Math.min(s, a, c) + Math.max(s, a, c)) / 2;
          break;
        case "luminosity":
          n = 0.21 * s + 0.72 * a + 0.07 * c;
      }
      t[i + 2] = t[i + 1] = t[i] = n;
    }
  }
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return t8[this.mode];
  }
  sendUniformData(e, t) {
    e.uniform1i(t.uMode, 1);
  }
  isNeutralState() {
    return !1;
  }
}
j(Wc, "type", "Grayscale"), j(Wc, "defaults", { mode: "average" }), j(Wc, "uniformLocations", ["uMode"]), ne.setClass(Wc);
const r8 = D(D({}, yx), {}, { rotation: 0 });
class id extends zs {
  calculateMatrix() {
    const e = this.rotation * Math.PI, t = un(e), n = hn(e), i = 1 / 3, s = Math.sqrt(i) * n, a = 1 - t;
    this.matrix = [t + a / 3, i * a - s, i * a + s, 0, 0, i * a + s, t + i * a, i * a - s, 0, 0, i * a - s, i * a + s, t + i * a, 0, 0, 0, 0, 0, 1, 0];
  }
  isNeutralState() {
    return this.rotation === 0;
  }
  applyTo(e) {
    this.calculateMatrix(), super.applyTo(e);
  }
  toObject() {
    return { type: this.type, rotation: this.rotation };
  }
}
j(id, "type", "HueRotation"), j(id, "defaults", r8), ne.setClass(id);
class Hc extends Bt {
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    for (let n = 0; n < t.length; n += 4) t[n] = 255 - t[n], t[n + 1] = 255 - t[n + 1], t[n + 2] = 255 - t[n + 2], this.alpha && (t[n + 3] = 255 - t[n + 3]);
  }
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform int uInvert;
  uniform int uAlpha;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    if (uInvert == 1) {
      if (uAlpha == 1) {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,1.0 -color.a);
      } else {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);
      }
    } else {
      gl_FragColor = color;
    }
  }
`;
  }
  isNeutralState() {
    return !this.invert;
  }
  sendUniformData(e, t) {
    e.uniform1i(t.uInvert, Number(this.invert)), e.uniform1i(t.uAlpha, Number(this.alpha));
  }
}
j(Hc, "type", "Invert"), j(Hc, "defaults", { alpha: !1, invert: !0 }), j(Hc, "uniformLocations", ["uInvert", "uAlpha"]), ne.setClass(Hc);
class Uc extends Bt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uStepH;
  uniform float uNoise;
  uniform float uSeed;
  varying vec2 vTexCoord;
  float rand(vec2 co, float seed, float vScale) {
    return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);
  }
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = this.noise;
    for (let i = 0; i < t.length; i += 4) {
      const s = (0.5 - Math.random()) * n;
      t[i] += s, t[i + 1] += s, t[i + 2] += s;
    }
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uNoise, this.noise / 255), e.uniform1f(t.uSeed, Math.random());
  }
  isNeutralState() {
    return this.noise === 0;
  }
}
j(Uc, "type", "Noise"), j(Uc, "defaults", { noise: 0 }), j(Uc, "uniformLocations", ["uNoise", "uSeed"]), ne.setClass(Uc);
class $c extends Bt {
  applyTo2d(e) {
    let { imageData: { data: t, width: n, height: i } } = e;
    for (let s = 0; s < i; s += this.blocksize) for (let a = 0; a < n; a += this.blocksize) {
      const c = 4 * s * n + 4 * a, u = t[c], h = t[c + 1], d = t[c + 2], p = t[c + 3];
      for (let g = s; g < Math.min(s + this.blocksize, i); g++) for (let v = a; v < Math.min(a + this.blocksize, n); v++) {
        const b = 4 * g * n + 4 * v;
        t[b] = u, t[b + 1] = h, t[b + 2] = d, t[b + 3] = p;
      }
    }
  }
  isNeutralState() {
    return this.blocksize === 1;
  }
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBlocksize;
  uniform float uStepW;
  uniform float uStepH;
  varying vec2 vTexCoord;
  void main() {
    float blockW = uBlocksize * uStepW;
    float blockH = uBlocksize * uStepH;
    int posX = int(vTexCoord.x / blockW);
    int posY = int(vTexCoord.y / blockH);
    float fposX = float(posX);
    float fposY = float(posY);
    vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);
    vec4 color = texture2D(uTexture, squareCoords);
    gl_FragColor = color;
  }
`;
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uBlocksize, this.blocksize);
  }
}
j($c, "type", "Pixelate"), j($c, "defaults", { blocksize: 4 }), j($c, "uniformLocations", ["uBlocksize"]), ne.setClass($c);
class Yc extends Bt {
  getFragmentSource() {
    return `
precision highp float;
uniform sampler2D uTexture;
uniform vec4 uLow;
uniform vec4 uHigh;
varying vec2 vTexCoord;
void main() {
  gl_FragColor = texture2D(uTexture, vTexCoord);
  if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {
    gl_FragColor.a = 0.0;
  }
}
`;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = 255 * this.distance, i = new Qe(this.color).getSource(), s = [i[0] - n, i[1] - n, i[2] - n], a = [i[0] + n, i[1] + n, i[2] + n];
    for (let c = 0; c < t.length; c += 4) {
      const u = t[c], h = t[c + 1], d = t[c + 2];
      u > s[0] && h > s[1] && d > s[2] && u < a[0] && h < a[1] && d < a[2] && (t[c + 3] = 0);
    }
  }
  sendUniformData(e, t) {
    const n = new Qe(this.color).getSource(), i = this.distance, s = [0 + n[0] / 255 - i, 0 + n[1] / 255 - i, 0 + n[2] / 255 - i, 1], a = [n[0] / 255 + i, n[1] / 255 + i, n[2] / 255 + i, 1];
    e.uniform4fv(t.uLow, s), e.uniform4fv(t.uHigh, a);
  }
}
j(Yc, "type", "RemoveColor"), j(Yc, "defaults", { color: "#FFFFFF", distance: 0.02, useAlpha: !1 }), j(Yc, "uniformLocations", ["uLow", "uHigh"]), ne.setClass(Yc);
class Xc extends Bt {
  sendUniformData(e, t) {
    e.uniform2fv(t.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), e.uniform1fv(t.uTaps, this.taps);
  }
  getFilterWindow() {
    const e = this.tempScale;
    return Math.ceil(this.lanczosLobes / e);
  }
  getCacheKey() {
    const e = this.getFilterWindow();
    return "".concat(this.type, "_").concat(e);
  }
  getFragmentSource() {
    const e = this.getFilterWindow();
    return this.generateShader(e);
  }
  getTaps() {
    const e = this.lanczosCreate(this.lanczosLobes), t = this.tempScale, n = this.getFilterWindow(), i = new Array(n);
    for (let s = 1; s <= n; s++) i[s - 1] = e(s * t);
    return i;
  }
  generateShader(e) {
    const t = new Array(e);
    for (let n = 1; n <= e; n++) t[n - 1] = "".concat(n, ".0 * uDelta");
    return `
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec2 uDelta;
      varying vec2 vTexCoord;
      uniform float uTaps[`.concat(e, `];
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        float sum = 1.0;
        `).concat(t.map((n, i) => `
              color += texture2D(uTexture, vTexCoord + `.concat(n, ") * uTaps[").concat(i, "] + texture2D(uTexture, vTexCoord - ").concat(n, ") * uTaps[").concat(i, `];
              sum += 2.0 * uTaps[`).concat(i, `];
            `)).join(`
`), `
        gl_FragColor = color / sum;
      }
    `);
  }
  applyToForWebgl(e) {
    e.passes++, this.width = e.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = e.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), e.destinationWidth = this.dW, super.applyTo(e), e.sourceWidth = e.destinationWidth, this.height = e.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), e.destinationHeight = this.dH, super.applyTo(e), e.sourceHeight = e.destinationHeight;
  }
  applyTo(e) {
    pu(e) ? this.applyToForWebgl(e) : this.applyTo2d(e);
  }
  isNeutralState() {
    return this.scaleX === 1 && this.scaleY === 1;
  }
  lanczosCreate(e) {
    return (t) => {
      if (t >= e || t <= -e) return 0;
      if (t < 11920929e-14 && t > -11920929e-14) return 1;
      const n = (t *= Math.PI) / e;
      return Math.sin(t) / t * Math.sin(n) / n;
    };
  }
  applyTo2d(e) {
    const t = e.imageData, n = this.scaleX, i = this.scaleY;
    this.rcpScaleX = 1 / n, this.rcpScaleY = 1 / i;
    const s = t.width, a = t.height, c = Math.round(s * n), u = Math.round(a * i);
    let h;
    h = this.resizeType === "sliceHack" ? this.sliceByTwo(e, s, a, c, u) : this.resizeType === "hermite" ? this.hermiteFastResize(e, s, a, c, u) : this.resizeType === "bilinear" ? this.bilinearFiltering(e, s, a, c, u) : this.resizeType === "lanczos" ? this.lanczosResize(e, s, a, c, u) : new ImageData(c, u), e.imageData = h;
  }
  sliceByTwo(e, t, n, i, s) {
    const a = e.imageData, c = 0.5;
    let u = !1, h = !1, d = t * c, p = n * c;
    const g = e.filterBackend.resources;
    let v = 0, b = 0;
    const x = t;
    let _ = 0;
    g.sliceByTwo || (g.sliceByTwo = Kr());
    const C = g.sliceByTwo;
    (C.width < 1.5 * t || C.height < n) && (C.width = 1.5 * t, C.height = n);
    const E = C.getContext("2d");
    for (E.clearRect(0, 0, 1.5 * t, n), E.putImageData(a, 0, 0), i = Math.floor(i), s = Math.floor(s); !u || !h; ) t = d, n = p, i < Math.floor(d * c) ? d = Math.floor(d * c) : (d = i, u = !0), s < Math.floor(p * c) ? p = Math.floor(p * c) : (p = s, h = !0), E.drawImage(C, v, b, t, n, x, _, d, p), v = x, b = _, _ += p;
    return E.getImageData(v, b, i, s);
  }
  lanczosResize(e, t, n, i, s) {
    const a = e.imageData.data, c = e.ctx.createImageData(i, s), u = c.data, h = this.lanczosCreate(this.lanczosLobes), d = this.rcpScaleX, p = this.rcpScaleY, g = 2 / this.rcpScaleX, v = 2 / this.rcpScaleY, b = Math.ceil(d * this.lanczosLobes / 2), x = Math.ceil(p * this.lanczosLobes / 2), _ = {}, C = { x: 0, y: 0 }, E = { x: 0, y: 0 };
    return function k(O) {
      let P, R, V, F, $, z, G, H, Y, te, ge;
      for (C.x = (O + 0.5) * d, E.x = Math.floor(C.x), P = 0; P < s; P++) {
        for (C.y = (P + 0.5) * p, E.y = Math.floor(C.y), $ = 0, z = 0, G = 0, H = 0, Y = 0, R = E.x - b; R <= E.x + b; R++) if (!(R < 0 || R >= t)) {
          te = Math.floor(1e3 * Math.abs(R - C.x)), _[te] || (_[te] = {});
          for (let Z = E.y - x; Z <= E.y + x; Z++) Z < 0 || Z >= n || (ge = Math.floor(1e3 * Math.abs(Z - C.y)), _[te][ge] || (_[te][ge] = h(Math.sqrt(Math.pow(te * g, 2) + Math.pow(ge * v, 2)) / 1e3)), V = _[te][ge], V > 0 && (F = 4 * (Z * t + R), $ += V, z += V * a[F], G += V * a[F + 1], H += V * a[F + 2], Y += V * a[F + 3]));
        }
        F = 4 * (P * i + O), u[F] = z / $, u[F + 1] = G / $, u[F + 2] = H / $, u[F + 3] = Y / $;
      }
      return ++O < i ? k(O) : c;
    }(0);
  }
  bilinearFiltering(e, t, n, i, s) {
    let a, c, u, h, d, p, g, v, b, x, _, C, E, k = 0;
    const O = this.rcpScaleX, P = this.rcpScaleY, R = 4 * (t - 1), V = e.imageData.data, F = e.ctx.createImageData(i, s), $ = F.data;
    for (g = 0; g < s; g++) for (v = 0; v < i; v++) for (d = Math.floor(O * v), p = Math.floor(P * g), b = O * v - d, x = P * g - p, E = 4 * (p * t + d), _ = 0; _ < 4; _++) a = V[E + _], c = V[E + 4 + _], u = V[E + R + _], h = V[E + R + 4 + _], C = a * (1 - b) * (1 - x) + c * b * (1 - x) + u * x * (1 - b) + h * b * x, $[k++] = C;
    return F;
  }
  hermiteFastResize(e, t, n, i, s) {
    const a = this.rcpScaleX, c = this.rcpScaleY, u = Math.ceil(a / 2), h = Math.ceil(c / 2), d = e.imageData.data, p = e.ctx.createImageData(i, s), g = p.data;
    for (let v = 0; v < s; v++) for (let b = 0; b < i; b++) {
      const x = 4 * (b + v * i);
      let _ = 0, C = 0, E = 0, k = 0, O = 0, P = 0, R = 0;
      const V = (v + 0.5) * c;
      for (let F = Math.floor(v * c); F < (v + 1) * c; F++) {
        const $ = Math.abs(V - (F + 0.5)) / h, z = (b + 0.5) * a, G = $ * $;
        for (let H = Math.floor(b * a); H < (b + 1) * a; H++) {
          let Y = Math.abs(z - (H + 0.5)) / u;
          const te = Math.sqrt(G + Y * Y);
          te > 1 && te < -1 || (_ = 2 * te * te * te - 3 * te * te + 1, _ > 0 && (Y = 4 * (H + F * t), R += _ * d[Y + 3], E += _, d[Y + 3] < 255 && (_ = _ * d[Y + 3] / 250), k += _ * d[Y], O += _ * d[Y + 1], P += _ * d[Y + 2], C += _));
        }
      }
      g[x] = k / C, g[x + 1] = O / C, g[x + 2] = P / C, g[x + 3] = R / E;
    }
    return p;
  }
}
j(Xc, "type", "Resize"), j(Xc, "defaults", { resizeType: "hermite", scaleX: 1, scaleY: 1, lanczosLobes: 3 }), j(Xc, "uniformLocations", ["uDelta", "uTaps"]), ne.setClass(Xc);
class Gc extends Bt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uSaturation;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float rgMax = max(color.r, color.g);
    float rgbMax = max(rgMax, color.b);
    color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;
    color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;
    color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = -this.saturation;
    for (let i = 0; i < t.length; i += 4) {
      const s = t[i], a = t[i + 1], c = t[i + 2], u = Math.max(s, a, c);
      t[i] += u !== s ? (u - s) * n : 0, t[i + 1] += u !== a ? (u - a) * n : 0, t[i + 2] += u !== c ? (u - c) * n : 0;
    }
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uSaturation, -this.saturation);
  }
  isNeutralState() {
    return this.saturation === 0;
  }
}
j(Gc, "type", "Saturation"), j(Gc, "defaults", { saturation: 0 }), j(Gc, "uniformLocations", ["uSaturation"]), ne.setClass(Gc);
class qc extends Bt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uVibrance;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float max = max(color.r, max(color.g, color.b));
    float avg = (color.r + color.g + color.b) / 3.0;
    float amt = (abs(max - avg) * 2.0) * uVibrance;
    color.r += max != color.r ? (max - color.r) * amt : 0.00;
    color.g += max != color.g ? (max - color.g) * amt : 0.00;
    color.b += max != color.b ? (max - color.b) * amt : 0.00;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = -this.vibrance;
    for (let i = 0; i < t.length; i += 4) {
      const s = t[i], a = t[i + 1], c = t[i + 2], u = Math.max(s, a, c), h = (s + a + c) / 3, d = 2 * Math.abs(u - h) / 255 * n;
      t[i] += u !== s ? (u - s) * d : 0, t[i + 1] += u !== a ? (u - a) * d : 0, t[i + 2] += u !== c ? (u - c) * d : 0;
    }
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uVibrance, -this.vibrance);
  }
  isNeutralState() {
    return this.vibrance === 0;
  }
}
j(qc, "type", "Vibrance"), j(qc, "defaults", { vibrance: 0 }), j(qc, "uniformLocations", ["uVibrance"]), ne.setClass(qc);
class n8 {
  ___eventListeners;
  ___activeObjects;
  constructor() {
    this.___activeObjects = [], this.___eventListeners = {};
  }
  pauseEventListeners() {
    this.___eventListeners = this.__eventListeners, this.__eventListeners = {};
    const e = this.getActiveObjects();
    this.discardActiveObject(), this.___activeObjects = e;
  }
  resumeEventListeners() {
    this.__eventListeners = this.___eventListeners, this.___eventListeners = {};
    const e = this.___activeObjects;
    if (!e.length)
      return this.requestRenderAll(), !1;
    if (e.length === 1)
      this.setActiveObject(e[0]);
    else {
      const t = new Sn(e);
      this.setActiveObject(t);
    }
    this.requestRenderAll();
  }
}
class Ks extends Ot {
  isSelected = !1;
  text;
  tScale;
  display;
  id;
  backgroundColor;
  static ownDefaults = {
    rx: 6,
    ry: 6,
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 0,
    fill: "#27272a",
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    fontSize: 16,
    fontFamily: "Arial",
    fontColor: "#ffffff",
    textAlign: "center"
  };
  static type = "Text";
  constructor(e) {
    super(e), Object.assign(this, Ks.ownDefaults), this.id = e.id, this.tScale = e.tScale, this.display = e.display, this.text = e.text || "", this.backgroundColor = e.backgroundColor || "transparent";
  }
  static createControls() {
    return {
      controls: wx()
    };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...Ks.ownDefaults
    };
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      6
    ), e.lineWidth = 2, e.strokeStyle = "rgba(0, 216, 214,1.0)", e.stroke(), e.restore());
  }
}
function _i(r, e, t, n, i) {
  r.save(), r.translate(e, t), r.rotate(Jw.degreesToRadians(90 + i.angle)), r.beginPath(), r.lineWidth = 4, r.lineCap = "round", r.strokeStyle = "#dfe2e8", r.moveTo(-6, 0), r.lineTo(6, 0), r.stroke(), r.restore();
}
function wx() {
  return {
    mr: new gt({
      x: 0.5,
      y: 0,
      actionHandler: Tl,
      cursorStyleHandler: Zt.scaleSkewCursorStyleHandler,
      actionName: "resizing",
      render: _i
    }),
    ml: new gt({
      x: -0.5,
      y: 0,
      actionHandler: Tl,
      cursorStyleHandler: Zt.scaleSkewCursorStyleHandler,
      actionName: "resizing",
      render: _i
    })
  };
}
const Tl = Zt.wrapWithFireEvent(
  "resizing",
  Zt.wrapWithFixedAnchor((r, e, t, n) => {
    const i = Zt.getLocalPoint(
      e,
      e.originX,
      e.originY,
      t,
      n
    );
    if (s8(e.originX) || a8(e.originX) && i.x < 0 || o8(e.originX) && i.x > 0) {
      const s = e.target, a = s.strokeWidth / (s.strokeUniform ? s.scaleX : 1), c = c8(e) ? 2 : 1, u = s.width, h = Math.ceil(
        Math.abs(i.x * c / s.scaleX) - a
      );
      if (e.corner === "ml") {
        const p = u - h;
        if (s.left + p < 0)
          return s.set("width", s.width + s.left), !0;
      }
      return s.set("width", Math.max(h, 0)), u !== s.width;
    }
    return !1;
  })
), i8 = {
  left: -0.5,
  top: -0.5,
  center: 0,
  bottom: 0.5,
  right: 0.5
}, Be = (r) => typeof r == "string" ? i8[r] : r - 0.5, s8 = (r) => Be(r) === Be("center"), o8 = (r) => Be(r) === Be("left"), a8 = (r) => Be(r) === Be("right");
function c8(r) {
  return Be(r.originX) === Be("center") && Be(r.originY) === Be("center");
}
ne.setClass(Ks, "Text");
class fn extends Ot {
  static type = "Transition";
  id;
  duration;
  fromId;
  toId;
  static ownDefaults = {
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 1.5,
    fill: "rgba(0, 0, 0, 0.5)",
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    lockMovementX: !0,
    lockMovementY: !0,
    duration: 1500,
    rx: 8,
    ry: 8
  };
  isSelected = !1;
  constructor(e) {
    super(e), this.id = e.id, this.fromId = e.fromId, this.toId = e.toId, Object.assign(this, {
      duration: e.duration,
      fromId: e.fromId,
      toId: e.toId,
      kind: e.kind,
      tScale: e.tScale,
      strokeDashArray: e.strokeDashArray || [],
      isSelected: !1,
      centeredScaling: !0,
      strokeWidth: 0
    }), Object.assign(this, fn.ownDefaults);
  }
  static createControls() {
    return {
      controls: l8()
    };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...fn.ownDefaults
    };
  }
  updateCoords() {
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  updateSelected(e) {
    e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = 2, this.strokeDashArray && e.setLineDash(this.strokeDashArray), e.strokeStyle = this.isSelected ? "rgba(255, 255, 255,1.0)" : "rgba(255, 255, 255,0.15)", e.stroke(), e.restore();
  }
}
ne.setClass(fn, "Transition");
const l8 = () => ({
  mr: new gt({
    x: 0.5,
    y: 0,
    actionHandler: W0,
    cursorStyleHandler: Zt.scaleSkewCursorStyleHandler,
    actionName: "resizing",
    render: _i
  }),
  ml: new gt({
    x: -0.5,
    y: 0,
    actionHandler: W0,
    cursorStyleHandler: Zt.scaleSkewCursorStyleHandler,
    actionName: "resizing",
    render: _i
  })
});
ne.setClass(fn, "Transition");
const { wrapWithFireEvent: u8, getLocalPoint: h8 } = Zt, af = "center", d8 = "left", f8 = "right";
function p8(r) {
  return (e, t, n, i) => {
    const { target: s, originX: a, originY: c } = t, u = s.getRelativeCenterPoint(), h = s.translateToOriginPoint(
      u,
      a,
      c
    ), d = r(e, t, n, i);
    return s.setPositionByOrigin(h, a, c), d;
  };
}
const g8 = (r, e, t, n) => {
  const i = h8(
    e,
    e.originX,
    e.originY,
    t,
    n
  );
  if (Be(e.originX) === Be(af) || Be(e.originX) === Be(f8) && i.x < 0 || Be(e.originX) === Be(d8) && i.x > 0) {
    const { target: s } = e, a = s.strokeWidth / (s.strokeUniform ? s.scaleX : 1), c = m8(e) ? 2 : 1, u = s.width, h = Math.ceil(
      Math.abs(i.x * c / s.scaleX) - a
    ), d = ts(h, s.tScale);
    return d >= 1500 || d < 500 ? !1 : (s.set("width", Math.max(h, 0)), s.set("duration", d), s.setCoords(), s.canvas && s.canvas.renderAll(), u !== s.width);
  }
  return !1;
};
function m8(r) {
  return Be(r.originX) === Be(af) && Be(r.originY) === Be(af);
}
const W0 = u8(
  "resizing",
  p8(g8)
);
class la extends Ot {
  static type = "Placeholder";
  guideItemId;
  distXToActCenter;
  trackItemType;
  defaultPos;
  draggedObject = null;
  for;
  id;
  static ownDefaults = {
    rx: 6,
    ry: 6,
    objectCaching: !1,
    borderColor: "transparent",
    strokeWidth: 0,
    fill: "rgba(255, 211, 42, 0.1)",
    stroke: "rgba(255, 211, 42, 1.0)",
    selectable: !1,
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    strokeDashArray: [5, 1],
    evented: !1
  };
  constructor(e) {
    super(e), this.id = e.id, this.for = e.for, Object.assign(this, la.ownDefaults);
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...la.ownDefaults
    };
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = 2, this.strokeDashArray && e.setLineDash(this.strokeDashArray), e.strokeStyle = "rgba(0, 216, 214,1.0)", e.stroke(), e.restore();
  }
}
ne.setClass(la, "Placeholder");
const v8 = {
  top: { top: 35, guideHeight: 2, bottom: 3 },
  center: { top: 3, guideHeight: 2, bottom: 3 },
  bottom: { top: 3, guideHeight: 2, bottom: 35 }
}, gu = "rgba(0, 216, 214, 1.0)", sd = (r, e, t) => new Ot({
  top: r,
  left: 0,
  strokeWidth: 0,
  fill: "transparent",
  selectable: !0,
  height: t,
  width: e
});
class ea extends qr {
  static type = "Helper";
  static defaultSettings = {
    selectable: !1,
    evented: !1
  };
  static ownDefaults = { ...ea.defaultSettings };
  guide;
  topGuide;
  bottomGuide;
  id;
  metadata = {};
  tScale;
  kind;
  constructor(e) {
    const t = v8[e.kind], n = sd(0, e.width, t.top), i = sd(t.top, e.width, t.guideHeight), s = sd(
      t.top + t.guideHeight,
      e.width,
      t.bottom
    );
    super([n, i, s], {
      ...ea.defaultSettings,
      ...e
    }), this.topGuide = n, this.guide = i, this.bottomGuide = s, this.id = e.id, this.metadata = e.metadata ?? {}, this.tScale = e.tScale, this.kind = e.kind;
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...ea.defaultSettings
    };
  }
  updateCoords(e) {
    this.scaleToWidth(e), this.set("scaleY", 1);
  }
  setSelected(e) {
    this.guide.set("fill", e ? gu : "transparent");
  }
}
const Ea = ea;
ne.setClass(Ea, "Helper");
class is extends Ot {
  static ownDefaults = {
    selectable: !1,
    evented: !1,
    strokeWidth: 0,
    stroke: "transparent"
  };
  static type = "Track";
  id;
  accepts;
  metadata;
  items;
  borderColor = "transparent";
  stroke = "transparent";
  strokeWidth = 0;
  constructor(e) {
    super(e), Object.assign(this, is.ownDefaults), this.id = e.id, this.accepts = e.accepts || ["audio", "video", "image", "text"], this.items = e.items || [], this.metadata = e.metadata;
  }
  static getDefaults() {
    return { ...super.getDefaults(), ...is.ownDefaults };
  }
  updateCoords(e) {
    this.width = e;
  }
}
ne.setClass(is, "Track");
class El extends Ot {
  isSelected;
  tScale;
  display;
  id;
  src;
  itemType;
  static ownDefaults = {
    rx: 8,
    ry: 8,
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 0,
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    fill: "#27272a"
  };
  static type = "Image";
  constructor(e) {
    super(e), this.itemType = "image", this.isSelected = !1, Object.assign(this, El.ownDefaults), this.id = e.id, this.src = e.src, this.display = e.display, this.tScale = e.tScale;
  }
  static createControls() {
    return {
      controls: wx()
    };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...El.ownDefaults
    };
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = 2, e.strokeStyle = gu, e.stroke(), e.restore());
  }
}
const xp = El;
ne.setClass(xp, "Image");
class go extends Ot {
  id;
  tScale;
  isSelected = !1;
  display;
  trim;
  static type = "Video";
  static defaultProps = {
    objectCaching: !1,
    rx: 8,
    ry: 8,
    fill: "#27272a"
  };
  constructor(e) {
    super(Object.assign({}, go.defaultProps, e)), this.id = e.id, this.tScale = e.tScale, this.display = e.display, this.trim = e.trim;
  }
  static createControls() {
    return { controls: y8() };
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = 2, e.strokeStyle = gu, e.stroke(), e.restore());
  }
}
ne.setClass(go, "Video");
const y8 = () => ({
  mr: new gt({
    x: 0.5,
    y: 0,
    render: _i,
    actionHandler: H0,
    cursorStyleHandler: Zt.scaleSkewCursorStyleHandler,
    actionName: "resizing"
  }),
  ml: new gt({
    x: -0.5,
    y: 0,
    render: _i,
    actionHandler: H0,
    cursorStyleHandler: Zt.scaleSkewCursorStyleHandler,
    actionName: "resizing"
  })
}), { wrapWithFireEvent: b8, getLocalPoint: w8 } = Zt, x8 = (r, e, t, n) => {
  const i = w8(
    e,
    e.originX,
    e.originY,
    t,
    n
  );
  if (Be(e.originX) === Be("center") || Be(e.originX) === Be("right") && i.x < 0 || Be(e.originX) === Be("left") && i.x > 0) {
    const { target: s } = e;
    return s.width !== s.width;
  }
  return !1;
};
function xx(r) {
  return (e, t, n, i) => {
    const { target: s, originX: a, originY: c } = t, u = s.getRelativeCenterPoint(), h = s.translateToOriginPoint(
      u,
      a,
      c
    ), d = r(e, t, n, i);
    return s.setPositionByOrigin(h, a, c), d;
  };
}
const H0 = b8(
  "resizing",
  xx(x8)
);
class mi extends Ot {
  id;
  itemType = "audio";
  isSelected = !1;
  trim;
  src;
  tScale;
  display;
  static ownDefaults = {
    rx: 6,
    ry: 6,
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 0,
    fill: "#27272a",
    borderOpacityWhenMoving: 1,
    hoverCursor: "default"
  };
  static type = "Audio";
  constructor(e) {
    super({
      ...mi.getDefaults(),
      ...e
    }), this.id = e.id, this.tScale = e.tScale, this.display = e.display, this.trim = e.trim, this.src = e.src;
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...mi.ownDefaults
    };
  }
  static createControls() {
    return { controls: _8() };
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      mi.ownDefaults.rx
    ), e.lineWidth = 2, e.strokeStyle = gu, e.stroke(), e.restore());
  }
}
ne.setClass(mi, "Audio");
const _8 = () => ({
  mr: new gt({
    x: 0.5,
    y: 0,
    render: _i,
    actionHandler: U0,
    cursorStyleHandler: Zt.scaleSkewCursorStyleHandler,
    actionName: "resizing"
  }),
  ml: new gt({
    x: -0.5,
    y: 0,
    render: _i,
    actionHandler: U0,
    cursorStyleHandler: Zt.scaleSkewCursorStyleHandler,
    actionName: "resizing"
  })
}), { wrapWithFireEvent: S8, getLocalPoint: C8 } = Zt, T8 = (r, e, t, n) => {
  const i = C8(
    e,
    e.originX,
    e.originY,
    t,
    n
  );
  if (Be(e.originX) === Be("center") || Be(e.originX) === Be("right") && i.x < 0 || Be(e.originX) === Be("left") && i.x > 0) {
    const { target: s } = e, a = s.strokeWidth / (s.strokeUniform ? s.scaleX : 1), c = E8(e) ? 2 : 1, u = s.width, h = Math.ceil(
      Math.abs(i.x * c / s.scaleX) - a
    );
    if (e.corner === "mr") {
      const d = s.trim.to, p = h - u, g = ts(p, s.tScale), v = d + g;
      if (v > s.duration) return !1;
      s.set("width", Math.max(h, 0)), s.trim.to = v;
    } else {
      if (s.left < 0) return !1;
      const d = u - h;
      if (s.left + d < 0)
        return s.set("width", s.width + s.left), !0;
      const p = h - u, g = s.trim.from, v = ts(p, s.tScale), b = g - v;
      if (b < 0) return !1;
      s.set("width", Math.max(h, 0)), s.trim.from = b;
    }
    return u !== s.width;
  }
  return !1;
};
function E8(r) {
  return Be(r.originX) === Be("center") && Be(r.originY) === Be("center");
}
const U0 = S8(
  "resizing",
  xx(T8)
);
class kl extends Ot {
  static type = "TransitionGuide";
  static ownDefaults = {
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 1.5,
    fill: "rgba(0,0,0,0.85)",
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    lockMovementX: !0,
    lockMovementY: !0,
    duration: 1500,
    rx: 8,
    ry: 8
  };
  tScale;
  duration = 0;
  fromId;
  toId;
  itemType = "none";
  isSelected = !1;
  id;
  constructor(e) {
    super(e), Object.assign(this, kl.ownDefaults), this.id = e.id;
  }
  static createControls() {
    return {
      controls: k8()
    };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...kl.ownDefaults
    };
  }
  updateCoords() {
    const e = this.canvas;
    if (!e) return;
    const t = e.getObjects().find((s) => s.id === this.fromId);
    if (!t) return;
    const n = It(this.duration, this.tScale), i = t.left + t.width - n / 2;
    this.set({
      width: n,
      left: i
    });
  }
  _render(e) {
    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);
  }
  drawTextIdentity(e) {
    const t = new Path2D(
      "M3 5.30359C3 3.93159 4.659 3.24359 5.629 4.21359L11.997 10.5826L10.583 11.9966L5 6.41359V17.5856L10.586 11.9996L10.583 11.9966L11.997 10.5826L12 10.5856L18.371 4.21459C19.341 3.24459 21 3.93159 21 5.30359V18.6956C21 20.0676 19.341 20.7556 18.371 19.7856L12 13.5L13.414 11.9996L19 17.5866V6.41359L13.414 11.9996L13.421 12.0056L12.006 13.4206L12 13.4136L5.629 19.7846C4.659 20.7546 3 20.0676 3 18.6956V5.30359Z"
    );
    e.save(), e.translate(-12, -12), e.fillStyle = "#ffffff", e.fill(t), e.restore();
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = 1, e.strokeStyle = "rgba(255, 255, 255,1.0)", e.stroke(), e.restore());
  }
}
function k8() {
  return {
    mr: new gt({
      x: 0.5,
      y: 0,
      actionHandler: Tl,
      cursorStyleHandler: Zt.scaleSkewCursorStyleHandler,
      actionName: "resizing",
      render: $0
    }),
    ml: new gt({
      x: -0.5,
      y: 0,
      actionHandler: Tl,
      cursorStyleHandler: Zt.scaleSkewCursorStyleHandler,
      actionName: "resizing",
      render: $0
    })
  };
}
function $0(r, e, t, n, i) {
  r.save(), r.translate(e, t), r.rotate(Jw.degreesToRadians(90 + i.angle)), r.lineWidth = 6, r.lineCap = "round", r.strokeStyle = "white", r.beginPath(), r.moveTo(-6, 0), r.lineTo(6, 0), r.stroke(), r.lineWidth = 4, r.strokeStyle = "black", r.beginPath(), r.moveTo(-6, 0), r.lineTo(6, 0), r.stroke(), r.restore();
}
class Ol extends Ot {
  static type = "PreviewTrackItem";
  static ownDefaults = {
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 0,
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    rx: 4,
    ry: 4
  };
  duration = 0;
  fromId = "";
  toId = "";
  isSelected = !1;
  name;
  durationString;
  id;
  constructor(e) {
    super(e), Object.assign(this, Ol.ownDefaults), this.id = e.id, this.name = e.name || "item", this.durationString = "00:05", this.fill = "#27272a";
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...Ol.ownDefaults
    };
  }
  _render(e) {
    e.save(), super._render(e), e.beginPath(), e.rect(-this.width / 2, -this.height / 2, this.width, this.height), e.clip(), this.drawTextIdentity(e), e.restore();
  }
  drawTextIdentity(e) {
    e.font = "600 12px 'Geist variable'", e.textAlign = "left";
    const u = e.measureText(this.name).width, h = e.measureText(this.durationString).width, d = -this.height / 2 + 4, p = -this.width / 2, g = p + u + 8 * 2 + 4, v = u + 8 * 2;
    this.drawRoundedRect(
      e,
      p,
      d,
      v,
      20,
      4
    ), e.fillStyle = "#f4f4f5", e.fillText(this.name, p + 8, d + 12 + 2);
    const b = h + 8 * 2;
    this.drawRoundedRect(
      e,
      g,
      d,
      b,
      20,
      4
    ), e.fillStyle = "#f4f4f5", e.fillText(
      this.durationString,
      g + 8,
      d + 12 + 2
    );
  }
  drawRoundedRect(e, t, n, i, s, a) {
    e.fillStyle = "rgba(0, 0, 0, 0.5)", e.roundRect ? (e.beginPath(), e.roundRect(t, n, i, s, a), e.fill()) : e.fillRect(t, n, i, s);
  }
}
function O8(r, e) {
  e.forEach((t) => {
    Object.getOwnPropertyNames(t.prototype).forEach((n) => {
      if (n !== "constructor") {
        const i = Object.getOwnPropertyDescriptor(
          t.prototype,
          n
        );
        i && Object.defineProperty(r.prototype, n, i);
      }
    });
  });
}
const _p = (r, e) => {
  const t = {
    x: r.size.width / 2,
    y: r.size.height / 2
  }, n = {
    x: e.width / 2,
    y: e.height / 2
  }, i = t.x - n.x, s = t.y - n.y, a = Math.min(
    r.size.width / e.width,
    r.size.height / e.height
  );
  return {
    top: `${s}px`,
    left: `${i}px`,
    transform: `scale(${a})`
  };
}, I8 = (r) => new Promise((e, t) => {
  const n = new Audio();
  n.preload = "auto", n.addEventListener("loadedmetadata", () => {
    const i = n.duration * 1e3;
    e({
      duration: i
    });
  }), n.addEventListener("error", (i) => {
    t(i);
  }), n.src = r, n.crossOrigin = "anonymous", n.load();
}), A8 = (r) => new Promise((e, t) => {
  const n = new Image();
  console.warn("Consider updating CDN config for CORS issues?"), n.onload = () => {
    const i = n.width, s = n.height;
    e({ width: i, height: s });
  }, n.onerror = (i) => {
    t(i);
  }, n.crossOrigin = "anonymous", n.src = r;
}), M8 = (r) => new Promise((e, t) => {
  const n = document.createElement("video");
  n.preload = "auto", n.addEventListener("loadedmetadata", () => {
    const i = n.duration * 1e3, s = n.videoWidth, a = n.videoHeight;
    e({
      duration: i,
      width: s,
      height: a
    });
  }), n.addEventListener("error", (i) => {
    t(i);
  }), n.src = r, n.load();
}), tl = (r, e) => {
  const t = document.createElement("div");
  Object.keys(e).forEach((i) => {
    i !== "height" && (t.style[i] = e[i]);
  }), document.body.appendChild(t), t.textContent = r, t.style.width = `${e.width}px`, t.style.fontSize = `${e.fontSize}px`;
  const n = getComputedStyle(t).height;
  return document.body.removeChild(t), parseFloat(n);
}, On = (r) => Object.keys(r).reduce((e, t) => {
  const {
    display: { to: n }
  } = r[t];
  return Math.max(e, n);
}, 0), P8 = (r, e) => {
  if (!r)
    return {
      from: 0,
      to: e.duration
    };
  const { from: t, to: n } = r;
  return {
    from: t ?? 0,
    to: n ?? e.duration
  };
}, D8 = (r, e) => {
  const { duration: t, trim: n } = e, i = n ? n.to - n.from : t || 5e3, s = {
    from: 0,
    to: i
  };
  if (!r)
    return s;
  if (r.from !== void 0 && r.from < 0)
    return console.error(
      "'from' must be a non-negative number. Returning default display."
    ), s;
  if (r.from !== void 0 && r.to === void 0)
    return {
      from: r.from,
      to: r.from + i
    };
  if (r.to !== void 0) {
    if (r.to < 0)
      return console.error(
        "'to' must be a non-negative number. Returning default display."
      ), s;
    if (r.to < r.from)
      return console.error(
        "'to' must be greater than or equal to 'from'. Returning default display."
      ), s;
  }
  return r;
};
function j8(r, e) {
  return r.map((t) => {
    const n = t.items.filter(
      (i) => !e.includes(i)
    );
    return { ...t, items: n };
  }).filter((t) => t.items.length > 0);
}
const R8 = async (r, e) => {
  const t = r.details, n = await A8(t.src), i = _p(e, n);
  return {
    id: r.id,
    type: "image",
    name: "",
    display: {
      from: e.origin || 0,
      to: (e.origin || 5e3) + 5e3
    },
    details: {
      src: t.src || "",
      width: t.width || n.width || 100,
      height: t.height || n.height || 100,
      opacity: t.opacity ?? 100,
      transform: i.transform,
      border: t.border || "none",
      borderRadius: t.borderRadius || "0",
      boxShadow: t.boxShadow || "none",
      top: i.top || "0px",
      left: i.left || "0px"
    },
    metadata: r.metadata || {}
  };
}, F8 = async (r, e) => {
  const t = r.details.src, n = await M8(t), i = _p(e, {
    ...n
  }), s = P8(r.trim, { duration: n.duration }), a = {
    width: n.width,
    height: n.height,
    duration: n.duration,
    src: t,
    volume: r.details.volume ?? 100,
    top: r.details.top || i.top || "0px",
    left: r.details.left || i.left || "0px",
    text: r.details.text
    // Default volume
  };
  return {
    ...r,
    trim: s,
    type: "video",
    details: a,
    display: D8(r?.display, {
      duration: n.duration,
      trim: s
    })
  };
}, L8 = async (r) => {
  const e = r.details, t = (await I8(e.src)).duration, n = r?.display?.from ?? 0;
  return {
    id: r.id,
    name: "",
    type: "audio",
    display: {
      from: n,
      to: n + t
    },
    trim: {
      from: 0,
      to: t
    },
    details: {
      src: e.src,
      duration: t,
      volume: e.volume ?? 100,
      text: e.text
      // Default volume
    },
    metadata: {
      ...r.metadata
    }
  };
}, N8 = 5e3, _x = async (r, e) => {
  const t = r.id;
  await m3([
    {
      fontFamily: r.details.fontFamily ?? "",
      fontUrl: r.details.fontUrl ?? ""
    }
  ]);
  const n = {
    fontFamily: r.details.fontFamily ?? "Arial",
    fontSize: r.details.fontSize ?? "16px",
    fontWeight: r.details.fontWeight ?? "normal",
    fontStyle: r.details.fontStyle ?? "normal",
    textDecoration: r.details.textDecoration ?? "none",
    textAlign: r.details.textAlign ?? "left",
    lineHeight: r.details.lineHeight ?? "normal",
    letterSpacing: r.details.letterSpacing ?? "normal",
    wordSpacing: r.details.wordSpacing ?? "normal",
    color: r.details.color ?? "#ffffff",
    backgroundColor: r.details.backgroundColor ?? "transparent",
    border: r.details.border ?? "none",
    textShadow: r.details.textShadow ?? "none",
    text: r.details.text ?? "",
    opacity: r.details.opacity ?? 100,
    width: r.details.width ?? 300,
    wordWrap: r.details.wordWrap ?? "normal",
    wordBreak: r.details.wordBreak ?? "normal",
    WebkitTextStrokeColor: r.details.WebkitTextStrokeColor ?? "#ffffff",
    WebkitTextStrokeWidth: r.details.WebkitTextStrokeWidth ?? "0px",
    top: r.details.top ?? "0px",
    left: r.details.left ?? "0px"
  }, i = tl(r.details.text ?? "", n), s = _p(e, {
    width: n.width ?? 0,
    height: i
  });
  return {
    id: t,
    name: "",
    type: "text",
    display: {
      from: 0,
      to: N8
    },
    details: {
      ...n,
      height: i,
      top: s.top,
      left: s.left,
      fontUrl: r.details.fontUrl,
      text: r.details.text ?? ""
    },
    metadata: {}
  };
}, B8 = (r, e) => {
  const t = r.display, n = It(t.from, e.tScale), i = It(t.to - t.from, e.tScale), s = ne.getClass("Audio") || mi;
  return new s({
    width: i,
    height: 42,
    top: 10,
    left: n,
    id: r.id,
    display: t,
    text: r.details.text,
    trim: r.trim || {
      from: 0,
      to: r.details.duration
    },
    duration: r.details.duration,
    src: r.details.src,
    tScale: e.tScale
  });
}, V8 = (r, e) => {
  const t = It(r.display.from, e.tScale), n = It(r.details.duration || 5e3, e.tScale), i = ne.getClass("Image") || xp;
  return new i({
    width: n,
    height: 42,
    id: r.id,
    src: r.details.src,
    tScale: e.tScale,
    top: 10,
    left: t,
    display: r.display
  });
}, z8 = (r, e) => {
  const t = It(r.trim.from, e.tScale), n = It(r.trim.to - r.trim.from, e.tScale), i = ne.getClass("Video") || go;
  return new i({
    width: n,
    height: 42,
    id: r.id,
    tScale: e.tScale,
    fill: "#333333",
    top: 10,
    left: t,
    display: r.trim,
    trim: r.trim,
    text: r.details.text
  });
}, W8 = (r, e) => {
  const t = r.display, n = It(t.from, e.tScale), i = It(t.to - t.from, e.tScale), s = ne.getClass("Text") || Ks;
  return new s({
    width: i,
    height: 42,
    id: r.id,
    display: t,
    top: 10,
    left: n,
    text: r.details.text,
    tScale: e.tScale
  });
}, H8 = {
  video: 42,
  image: 42,
  audio: 42,
  text: 42,
  caption: 42,
  template: 42
}, U8 = (r = {}) => {
  const e = { ...H8, ...r };
  return Object.fromEntries(
    Object.entries(e).filter(([, t]) => typeof t == "number")
  );
};
let $8 = class extends mi {
  static type = "Audio";
  text;
  constructor(e) {
    super(e), this.text = e.text ?? "Audio";
  }
  _render(e) {
    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);
  }
  drawTextIdentity(e) {
    const t = new Path2D(
      "M8.24092 0C8.24092 2.51565 10.2795 4.55419 12.7951 4.55419C12.9677 4.55419 13.1331 4.62274 13.2552 4.74475C13.3772 4.86676 13.4457 5.03224 13.4457 5.20479C13.4457 5.37734 13.3772 5.54282 13.2552 5.66483C13.1331 5.78685 12.9677 5.85539 12.7951 5.85539C11.9218 5.85605 11.0594 5.66105 10.2713 5.28471C9.48319 4.90838 8.78942 4.36027 8.24092 3.68066V13.8794C8.24094 14.8271 7.91431 15.7458 7.31606 16.4808C6.71781 17.2157 5.88451 17.722 4.95657 17.9143C4.02863 18.1066 3.06276 17.9731 2.22172 17.5364C1.38067 17.0997 0.715856 16.3865 0.339286 15.5169C-0.0372842 14.6473 -0.10259 13.6744 0.154372 12.7622C0.411334 11.8501 0.974857 11.0544 1.74999 10.5092C2.52512 9.96403 3.46449 9.7027 4.40981 9.76924C5.35512 9.83579 6.24861 10.2261 6.93972 10.8745V0H8.24092ZM6.93972 13.8794C6.93972 13.1317 6.6427 12.4146 6.11398 11.8859C5.58527 11.3572 4.86818 11.0602 4.12046 11.0602C3.37275 11.0602 2.65566 11.3572 2.12694 11.8859C1.59823 12.4146 1.3012 13.1317 1.3012 13.8794C1.3012 14.6272 1.59823 15.3443 2.12694 15.873C2.65566 16.4017 3.37275 16.6987 4.12046 16.6987C4.86818 16.6987 5.58527 16.4017 6.11398 15.873C6.6427 15.3443 6.93972 14.6272 6.93972 13.8794Z"
    );
    e.save(), e.translate(-this.width / 2, -this.height / 2), e.translate(0, 10), e.font = "600 12px 'Geist variable'", e.fillStyle = "#f4f4f5", e.textAlign = "left", e.clip(), e.fillText(this.text, 36, 14), e.translate(10, 1), e.fillStyle = "#f4f4f5", e.fill(t), e.restore();
  }
};
class Y8 extends go {
  static type = "Video";
  text;
  constructor(e) {
    super(e), this.text = e.text ?? "Video";
  }
  _render(e) {
    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);
  }
  drawTextIdentity(e) {
    const t = new Path2D(
      "M16.5625 0.925L12.5 3.275V0.625L11.875 0H0.625L0 0.625V9.375L0.625 10H11.875L12.5 9.375V6.875L16.5625 9.2125L17.5 8.625V1.475L16.5625 0.925ZM11.25 8.75H1.25V1.25H11.25V8.75ZM16.25 7.5L12.5 5.375V4.725L16.25 2.5V7.5Z"
    );
    e.save(), e.translate(-this.width / 2, -this.height / 2), e.translate(0, 14), e.font = "600 12px 'Geist variable'", e.fillStyle = "#f4f4f5", e.textAlign = "left", e.clip(), e.fillText(this.text, 36, 10), e.translate(8, 1), e.fillStyle = "#f4f4f5", e.fill(t), e.restore();
  }
}
class Sx extends Ks {
  static type = "Text";
  constructor(e) {
    super(e), this.fill = "#303030";
  }
  _render(e) {
    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);
  }
  drawTextIdentity(e) {
    const t = new Path2D(
      "M6.23982 0.361968C6.18894 0.253743 6.10832 0.162234 6.00736 0.0981357C5.9064 0.034038 5.78929 0 5.6697 0C5.55012 0 5.433 0.034038 5.33204 0.0981357C5.23109 0.162234 5.15046 0.253743 5.09959 0.361968L0.0599035 11.0713C0.0246926 11.1462 0.00457285 11.2272 0.000693114 11.3099C-0.00318662 11.3925 0.00924959 11.4751 0.0372917 11.553C0.0939253 11.7102 0.210687 11.8384 0.361891 11.9095C0.513095 11.9806 0.686354 11.9888 0.843555 11.9322C1.00076 11.8755 1.12902 11.7588 1.20013 11.6075L2.51202 8.81998H8.82738L10.1393 11.6075C10.1745 11.6824 10.2241 11.7496 10.2853 11.8053C10.3465 11.861 10.418 11.9041 10.4958 11.9322C10.5737 11.9602 10.6563 11.9726 10.7389 11.9687C10.8216 11.9649 10.9026 11.9447 10.9775 11.9095C11.0524 11.8743 11.1196 11.8247 11.1753 11.7635C11.231 11.7023 11.2741 11.6308 11.3021 11.553C11.3302 11.4751 11.3426 11.3925 11.3387 11.3099C11.3348 11.2272 11.3147 11.1462 11.2795 11.0713L6.23982 0.361968ZM3.10498 7.56005L5.6697 2.11011L8.23443 7.56005H3.10498ZM15.1191 3.78029C14.1143 3.78029 13.3292 4.05354 12.7859 4.59294C12.6721 4.71153 12.6092 4.86987 12.6106 5.03419C12.6119 5.19851 12.6774 5.3558 12.7931 5.4725C12.9088 5.58921 13.0655 5.6561 13.2298 5.6589C13.3941 5.6617 13.553 5.60018 13.6726 5.48748C13.9718 5.19062 14.46 5.04021 15.1191 5.04021C16.1609 5.04021 17.009 5.74892 17.009 6.61511V6.86867C16.45 6.49465 15.7917 6.29663 15.1191 6.30013C13.382 6.30013 11.9693 7.57187 11.9693 9.13495C11.9693 10.698 13.382 11.9698 15.1191 11.9698C15.792 11.9727 16.4503 11.7739 17.009 11.3989C17.0168 11.566 17.0907 11.7231 17.2144 11.8357C17.3381 11.9483 17.5014 12.0071 17.6685 11.9993C17.8356 11.9915 17.9927 11.9176 18.1053 11.7939C18.2179 11.6702 18.2767 11.5069 18.2689 11.3398V6.61511C18.2689 5.05202 16.8562 3.78029 15.1191 3.78029ZM15.1191 10.7099C14.0773 10.7099 13.2292 10.0012 13.2292 9.13495C13.2292 8.26876 14.0773 7.56005 15.1191 7.56005C16.1609 7.56005 17.009 8.26876 17.009 9.13495C17.009 10.0012 16.1609 10.7099 15.1191 10.7099Z"
    );
    e.save(), e.translate(-this.width / 2, -this.height / 2), e.translate(0, 12), e.font = "600 12px 'Geist variable'", e.fillStyle = "#f4f4f5", e.textAlign = "left", e.clip(), e.fillText(this.text, 36, 12), e.translate(8, 1), e.fillStyle = "#f4f4f5", e.fill(t), e.restore();
  }
}
let X8 = class extends xp {
  static type = "Image";
  text;
  constructor(e) {
    super(e), this.text = e.text ?? "Image";
  }
  _render(e) {
    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);
  }
  drawTextIdentity(e) {
    const t = new Path2D(
      "M1.55556 0H14.4444C15.3031 0 16 0.696889 16 1.55556V14.4444C16 14.857 15.8361 15.2527 15.5444 15.5444C15.2527 15.8361 14.857 16 14.4444 16H1.55556C1.143 16 0.747335 15.8361 0.455612 15.5444C0.163889 15.2527 0 14.857 0 14.4444V1.55556C0 0.696889 0.696889 0 1.55556 0ZM14.4444 1.33333H1.55556C1.49662 1.33333 1.4401 1.35675 1.39842 1.39842C1.35675 1.4401 1.33333 1.49662 1.33333 1.55556V14.4444C1.33333 14.5671 1.43289 14.6667 1.55556 14.6667H1.72444L10.456 5.93511C10.6004 5.79065 10.7719 5.67605 10.9607 5.59787C11.1494 5.51968 11.3517 5.47944 11.556 5.47944C11.7603 5.47944 11.9626 5.51968 12.1513 5.59787C12.3401 5.67605 12.5116 5.79065 12.656 5.93511L14.6667 7.94578V1.55556C14.6667 1.49662 14.6433 1.4401 14.6016 1.39842C14.5599 1.35675 14.5034 1.33333 14.4444 1.33333ZM14.6667 9.83111L11.7129 6.87733C11.6922 6.85664 11.6677 6.84022 11.6407 6.82902C11.6137 6.81781 11.5848 6.81205 11.5556 6.81205C11.5263 6.81205 11.4974 6.81781 11.4704 6.82902C11.4434 6.84022 11.4189 6.85664 11.3982 6.87733L3.60978 14.6667H14.4444C14.5034 14.6667 14.5599 14.6433 14.6016 14.6016C14.6433 14.5599 14.6667 14.5034 14.6667 14.4444V9.83111ZM4.88889 7.11111C4.29952 7.11111 3.73429 6.87699 3.31754 6.46024C2.90079 6.04349 2.66667 5.47826 2.66667 4.88889C2.66667 4.29952 2.90079 3.73429 3.31754 3.31754C3.73429 2.90079 4.29952 2.66667 4.88889 2.66667C5.47826 2.66667 6.04349 2.90079 6.46024 3.31754C6.87699 3.73429 7.11111 4.29952 7.11111 4.88889C7.11111 5.47826 6.87699 6.04349 6.46024 6.46024C6.04349 6.87699 5.47826 7.11111 4.88889 7.11111ZM4.88889 5.77778C5.12464 5.77778 5.35073 5.68413 5.51743 5.51743C5.68413 5.35073 5.77778 5.12464 5.77778 4.88889C5.77778 4.65314 5.68413 4.42705 5.51743 4.26035C5.35073 4.09365 5.12464 4 4.88889 4C4.65314 4 4.42705 4.09365 4.26035 4.26035C4.09365 4.42705 4 4.65314 4 4.88889C4 5.12464 4.09365 5.35073 4.26035 5.51743C4.42705 5.68413 4.65314 5.77778 4.88889 5.77778Z"
    );
    e.save(), e.translate(-this.width / 2, -this.height / 2), e.translate(0, 12), e.font = "600 12px 'Geist variable'", e.fillStyle = "#f4f4f5", e.textAlign = "left", e.clip(), e.fillText(this.text, 36, 12), e.translate(8, 1), e.fillStyle = "#f4f4f5", e.fill(t), e.restore();
  }
};
class G8 extends is {
  static type = "Track";
  constructor(e) {
    super(e), this.fill = "#18181b";
  }
  _render(e) {
    super._render(e);
    const t = new Path2D(
      "M14.4444 13.3263H11.0667C12.5384 12.3991 13.6259 10.9716 14.1289 9.30644C14.632 7.64131 14.5169 5.85051 13.8048 4.26348C13.0927 2.67645 11.8314 1.39993 10.2531 0.668736C8.67478 -0.0624548 6.8855 -0.199136 5.21442 0.283835C3.54334 0.766806 2.10285 1.83695 1.15794 3.2974C0.213035 4.75785 -0.172743 6.51038 0.0715766 8.23261C0.315896 9.95484 1.17388 11.5309 2.4877 12.671C3.80151 13.811 5.4828 14.4383 7.22227 14.4374H14.4444C14.5918 14.4374 14.7331 14.3789 14.8373 14.2747C14.9415 14.1705 15 14.0292 15 13.8819C15 13.7345 14.9415 13.5932 14.8373 13.489C14.7331 13.3848 14.5918 13.3263 14.4444 13.3263ZM1.1112 7.21523C1.1112 6.00658 1.46961 4.82506 2.14111 3.8201C2.8126 2.81514 3.76702 2.03187 4.88367 1.56934C6.00032 1.10681 7.22905 0.985789 8.41449 1.22159C9.59992 1.45738 10.6888 2.03941 11.5435 2.89405C12.3981 3.7487 12.9801 4.83759 13.2159 6.02302C13.4517 7.20845 13.3307 8.43719 12.8682 9.55384C12.4056 10.6705 11.6224 11.6249 10.6174 12.2964C9.61244 12.9679 8.43093 13.3263 7.22227 13.3263C5.60208 13.3245 4.04878 12.68 2.90313 11.5344C1.75748 10.3887 1.11304 8.83542 1.1112 7.21523ZM7.22227 5.54858C7.55191 5.54858 7.87414 5.45083 8.14822 5.2677C8.4223 5.08456 8.63592 4.82426 8.76206 4.51972C8.88821 4.21518 8.92121 3.88007 8.85691 3.55677C8.7926 3.23347 8.63386 2.9365 8.40078 2.70342C8.16769 2.47033 7.87072 2.3116 7.54742 2.24729C7.22412 2.18298 6.88901 2.21599 6.58447 2.34213C6.27993 2.46828 6.01964 2.6819 5.8365 2.95598C5.65337 3.23006 5.55562 3.55229 5.55562 3.88192C5.55562 4.32395 5.73121 4.74787 6.04377 5.06043C6.35633 5.37298 6.78025 5.54858 7.22227 5.54858ZM7.22227 3.32637C7.33215 3.32637 7.43956 3.35895 7.53092 3.42C7.62228 3.48104 7.69349 3.56781 7.73554 3.66932C7.77759 3.77084 7.78859 3.88254 7.76715 3.9903C7.74572 4.09807 7.6928 4.19706 7.61511 4.27476C7.53741 4.35245 7.43842 4.40536 7.33066 4.4268C7.22289 4.44824 7.11119 4.43723 7.00967 4.39519C6.90816 4.35314 6.82139 4.28193 6.76035 4.19057C6.69931 4.09921 6.66672 3.9918 6.66672 3.88192C6.66672 3.73458 6.72525 3.59327 6.82944 3.48909C6.93363 3.3849 7.07493 3.32637 7.22227 3.32637ZM8.88893 10.5485C8.88893 10.2189 8.79118 9.89668 8.60805 9.6226C8.42491 9.34852 8.16462 9.1349 7.86008 9.00875C7.55553 8.88261 7.22043 8.8496 6.89713 8.91391C6.57383 8.97822 6.27686 9.13695 6.04377 9.37004C5.81069 9.60313 5.65195 9.9001 5.58764 10.2234C5.52334 10.5467 5.55634 10.8818 5.68249 11.1863C5.80863 11.4909 6.02225 11.7512 6.29633 11.9343C6.57041 12.1175 6.89264 12.2152 7.22227 12.2152C7.6643 12.2152 8.08822 12.0396 8.40078 11.727C8.71334 11.4145 8.88893 10.9906 8.88893 10.5485ZM6.66672 10.5485C6.66672 10.4387 6.69931 10.3313 6.76035 10.2399C6.82139 10.1485 6.90816 10.0773 7.00967 10.0353C7.11119 9.99323 7.22289 9.98223 7.33066 10.0037C7.43842 10.0251 7.53741 10.078 7.61511 10.1557C7.6928 10.2334 7.74572 10.3324 7.76715 10.4402C7.78859 10.5479 7.77759 10.6596 7.73554 10.7611C7.69349 10.8627 7.62228 10.9494 7.53092 11.0105C7.43956 11.0715 7.33215 11.1041 7.22227 11.1041C7.07493 11.1041 6.93363 11.0456 6.82944 10.9414C6.72525 10.8372 6.66672 10.6959 6.66672 10.5485ZM10.5556 8.88189C10.8852 8.88189 11.2074 8.78414 11.4815 8.60101C11.7556 8.41787 11.9692 8.15758 12.0954 7.85303C12.2215 7.54849 12.2545 7.21338 12.1902 6.89008C12.1259 6.56678 11.9672 6.26982 11.7341 6.03673C11.501 5.80364 11.204 5.64491 10.8807 5.5806C10.5574 5.51629 10.2223 5.5493 9.91778 5.67544C9.61324 5.80159 9.35295 6.01521 9.16981 6.28929C8.98668 6.56337 8.88893 6.8856 8.88893 7.21523C8.88893 7.65726 9.06452 8.08118 9.37708 8.39374C9.68964 8.70629 10.1136 8.88189 10.5556 8.88189ZM10.5556 6.65968C10.6655 6.65968 10.7729 6.69226 10.8642 6.75331C10.9556 6.81435 11.0268 6.90112 11.0688 7.00263C11.1109 7.10415 11.1219 7.21585 11.1005 7.32362C11.079 7.43138 11.0261 7.53037 10.9484 7.60807C10.8707 7.68576 10.7717 7.73867 10.664 7.76011C10.5562 7.78155 10.4445 7.77054 10.343 7.7285C10.2415 7.68645 10.1547 7.61524 10.0937 7.52388C10.0326 7.43252 10 7.32511 10 7.21523C10 7.06789 10.0586 6.92658 10.1628 6.8224C10.2669 6.71821 10.4082 6.65968 10.5556 6.65968ZM3.88896 5.54858C3.55933 5.54858 3.2371 5.64633 2.96302 5.82946C2.68894 6.01259 2.47532 6.27289 2.34918 6.57743C2.22303 6.88197 2.19002 7.21708 2.25433 7.54038C2.31864 7.86368 2.47737 8.16065 2.71046 8.39374C2.94355 8.62682 3.24052 8.78556 3.56382 8.84986C3.88711 8.91417 4.22222 8.88117 4.52677 8.75502C4.83131 8.62888 5.0916 8.41526 5.27474 8.14118C5.45787 7.8671 5.55562 7.54487 5.55562 7.21523C5.55562 6.77321 5.38003 6.34929 5.06747 6.03673C4.75491 5.72417 4.33099 5.54858 3.88896 5.54858ZM3.88896 7.77078C3.77909 7.77078 3.67168 7.7382 3.58032 7.67716C3.48896 7.61611 3.41775 7.52935 3.3757 7.42783C3.33365 7.32632 3.32265 7.21462 3.34409 7.10685C3.36552 6.99908 3.41843 6.90009 3.49613 6.8224C3.57382 6.7447 3.67281 6.69179 3.78058 6.67036C3.88835 6.64892 4.00005 6.65992 4.10156 6.70197C4.20308 6.74402 4.28984 6.81522 4.35089 6.90658C4.41193 6.99794 4.44452 7.10535 4.44452 7.21523C4.44452 7.36257 4.38598 7.50388 4.2818 7.60807C4.17761 7.71225 4.03631 7.77078 3.88896 7.77078Z"
    );
    this.items.length || (e.save(), e.translate(-this.width / 2, -this.height / 2), e.translate(0, 12), e.font = "600 12px 'Geist variable'", e.fillStyle = "#A0A4A2", e.textAlign = "left", e.clip(), e.fillText("Drag and drop media here", 32, 12), e.translate(8, 1), e.fillStyle = "#A0A4A2", e.fill(t), e.restore());
  }
}
class q8 extends Ea {
  static type = "Helper";
  constructor(e) {
    e.activeGuideFill = "#ffffff", super(e);
  }
}
class K8 {
  addTrackItem(e) {
    const t = e.id, n = od(e, {
      tScale: this.tScale,
      sizesMap: this.sizesMap
    });
    this.add(n), this.trackItemIds.push(t), this.renderTracks(), this.alignItemsToTrack(), this.calcBounding(), this.duration = On(this.trackItemsMap);
  }
  alignItemsToTrack() {
    this.pauseEventListeners();
    const e = new Map(
      this.getObjects("Track").map((n) => [n.id, n])
    ), t = this.getObjects("Image", "Video", "Text", "Audio");
    this.trackItemIds.forEach((n) => {
      const i = this.tracks.find((c) => c.items.includes(n));
      if (!i) return;
      const s = e.get(i.id);
      this.duration;
      const a = this.getObjects().find((c) => c.id === n);
      a && s && (a.isMain = !1, this.trackItemsMap[n].isMain = !1, a.set({ top: s.top }), a.setCoords());
    }), e.forEach((n) => {
      n.items = t.filter((i) => i.top === n.top).map((i) => i.id);
    }), this.resumeEventListeners();
  }
  updateTrackItemsPosition() {
    const e = this.getObjects("Image", "Text", "Video", "Audio");
    e.sort((t, n) => t.top - n.top), this.trackItemIds = e.map((t) => t.id).reverse();
  }
  restoreTrackItemPositions() {
  }
  updateTrackItemsState() {
    this.pauseEventListeners();
    const e = this.getObjects("Image", "Video", "Text", "Audio"), t = {};
    e.forEach((n) => {
      const { id: i, left: s, width: a } = n, c = this.trackItemsMap[i], u = ts(s, this.tScale), h = u + ts(a, this.tScale), d = { from: u, to: h }, p = {
        ...c,
        display: d,
        trim: n instanceof go || n instanceof mi ? n.trim : void 0
      };
      n.display = d, t[i] = p;
    }), this.trackItemsMap = t, this.resumeEventListeners();
  }
  deleteActiveTrackItem() {
    const e = this.getActiveObjects();
    if (!e.length) return !1;
    const t = e.map((i) => i.id), n = al(this.tracks, t);
    this.trackItemsMap = Object.keys(this.trackItemsMap).reduce((i, s) => (t.includes(s) || (i[s] = this.trackItemsMap[s]), i), {}), this.trackItemIds = this.trackItemIds.filter(
      (i) => !t.includes(i)
    ), this.tracks = n, this.discardActiveObject(), this.remove(...e), this.setActiveIds([]), this.renderTracks(), this.alignItemsToTrack(), this.updateState({ updateHistory: !0, kind: "remove" });
  }
  updateTrackItemsToHistory() {
    this.pauseEventListeners();
    const e = this.getObjects();
    this.trackItemIds.forEach((t) => {
      const n = this.tracks.find(
        (h) => h.items.includes(t)
      ), i = e.find(
        (h) => h.id === n?.id
      )?.top;
      if (!i) {
        console.warn(`Track top not found for trackItemId: ${t}`);
        return;
      }
      const s = this.trackItemsMap[t], a = e.find((h) => h.id === t);
      if (!a) {
        console.warn(`Object not found for trackItemId: ${t}`);
        return;
      }
      const c = It(s.display.from, this.tScale), u = It(
        s.display.to - s.display.from,
        this.tScale
      );
      a.set({ left: c, width: u, top: i }), a.setCoords();
    }), this.requestRenderAll(), this.resumeEventListeners();
  }
  cloneActiveTrackItem(e) {
    const t = e?.trackItemId || this.activeIds[0];
    if (!t) return !1;
    const i = {
      ...this.trackItemsMap[t],
      id: Lt()
    }, s = this.tracks.find(
      (d) => d.items.includes(t)
    ), a = this.tracks.findIndex((d) => d.id === s?.id) + 1;
    this.findOrCreateTrack(i, { trackIndex: a });
    const c = od(i, {
      tScale: this.tScale
    });
    c && this.add(c);
    const { audioData: u, ...h } = i.metadata || {};
    i.metadata = h, this.trackItemsMap[i.id] = i, this.trackItemIds.push(i.id), this.alignItemsToTrack(), this.updateTransitions(), this.updateState();
  }
  splitActiveTrackItem(e) {
    const t = e.trackItemId ?? this.activeIds[0];
    if (!t || this.activeIds.length > 1) return !1;
    const n = this.trackItemsMap[t], i = e.time;
    if (n.display.from >= i || n.display.to <= i)
      return !1;
    const s = {
      ...n,
      display: { from: n.display.from, to: i }
    }, a = {
      ...n,
      display: { from: i, to: n.display.to },
      id: Lt()
    };
    if (n.type === "video" || n.type === "audio") {
      const d = i - s.display.from;
      s.trim = {
        from: n.trim.from,
        to: n.trim.from + d
      }, a.trim = {
        from: s.trim.to,
        to: n.trim.to
      };
    }
    const c = this.getObjects().find(
      (d) => d.id === t
    );
    c.display = s.display, this.tracks.find(
      (d) => d.items.includes(t)
    )?.items.push(a.id);
    const h = od(a, {
      tScale: this.tScale
    });
    h && this.add(h), this.trackItemsMap[a.id] = a, this.trackItemsMap[t] = s, this.trackItemIds.push(a.id), this.updateTrackItemCoords(s.id), this.alignItemsToTrack(), this.updateTransitions(), this.updateState();
  }
  updateTrackItemCoords(e) {
    const t = this.getObjects().find((a) => a.id === e), n = this.trackItemsMap[e], i = It(n.display.from, this.tScale), s = It(
      n.display.to - n.display.from,
      this.tScale
    );
    t?.set({ left: i, width: s }), t?.setCoords();
  }
  updateTrackItemDetails(e, t) {
    const n = t?.trackItemId;
    if (!n) return !1;
    const i = this.trackItemsMap[n], s = { ...i.details, ...e.details };
    ("fontSize" in s || "lineHeight" in s) && (s.height = tl(
      s.text,
      s
    )), this.trackItemsMap[n] = {
      ...i,
      ...e,
      details: s
    }, this.updateState();
  }
  updateTrackItem(e, t) {
    const n = t.trackItemId;
    if (!n) return !1;
    const i = this.trackItemsMap[n], s = { ...i.details, ...e.details };
    if (i.type === "text" && e.details.text) {
      const a = this.getObjects("Text").find(
        (c) => c.id === n
      );
      a instanceof Sx && (a.text = e.details.text, this.requestRenderAll());
    }
    ("fontSize" in s || "lineHeight" in s) && (s.height = tl(
      s.text,
      s
    )), this.trackItemsMap[n] = {
      ...i,
      ...e,
      details: s
    }, this.updateState();
  }
  updateTrackItemsDetails(e, t) {
    t?.trackItemIds?.forEach((n, i) => {
      const s = this.trackItemsMap[n], a = {
        ...s.details,
        ...e[i].details
      };
      ("fontSize" in a || "lineHeight" in a) && (a.height = tl(
        a.text,
        a
      )), this.trackItemsMap[n] = {
        ...s,
        ...e[i],
        details: a
      };
    }), this.updateState();
  }
  getTrackItems() {
    return this.getObjects(...Z8);
  }
  setActiveTrackItemCoords() {
    this.getActiveObjects().forEach((e) => e.setCoords());
  }
  deleteTrackItemById(e) {
    const t = this.getObjects().filter(
      (n) => e.includes(n.id)
    );
    this.tracks = al(this.tracks, e), this.trackItemsMap = Object.keys(this.trackItemsMap).filter((n) => !e.includes(n)).reduce((n, i) => (n[i] = this.trackItemsMap[i], n), {}), this.trackItemIds = this.trackItemIds.filter((n) => !e.includes(n)), this.discardActiveObject(), this.remove(...t), this.renderTracks(), this.alignItemsToTrack(), this.calcBounding(), this.duration = On(this.trackItemsMap);
  }
  selectTrackItemByIds(e) {
    const t = this.getActiveObjects().map((i) => i.id);
    if (Xe.isEqual(t, e)) return;
    const n = this.getTrackItems().filter(
      (i) => e.includes(i.id)
    );
    if (n.length === 0)
      this.discardActiveObject();
    else if (n.length === 1)
      this.setActiveObject(n[0]);
    else {
      const i = new Sn(n);
      this.setActiveObject(i);
    }
    this.requestRenderAll();
  }
}
const Z8 = ["Image", "Text", "Video", "Audio", "Caption", "Template"], od = (r, e) => {
  const n = {
    text: W8,
    video: z8,
    image: V8,
    audio: B8
  }[r.type];
  return n(r, e);
}, Ls = {
  text: 32,
  image: 40,
  video: 40,
  audio: 32,
  main: 40
}, Y0 = (r) => {
  switch (r) {
    case "text":
      return Ls.text;
    case "image":
      return Ls.image;
    case "video":
      return Ls.video;
    case "audio":
      return Ls.audio;
    case "helperTop":
      return 40;
    case "helperBottom":
      return 40;
    case "helperCenter":
      return 8;
    case "main":
      return Ls.main;
    default:
      return Ls.text;
  }
};
class J8 {
  // Метод для нахождения или создания нового трека
  findOrCreateTrack(e, { trackId: t, trackIndex: n }) {
    const i = t;
    if (i) {
      const a = this.tracks.find((c) => c.id === i);
      if (a)
        return a.items.push(e.id), i;
    }
    const s = {
      id: Lt(),
      // Генерация уникального ID
      items: [e.id],
      type: e.type,
      accepts: this.acceptsMap?.[e.type]
    };
    return n !== void 0 ? this.tracks.splice(n, 0, s) : this.tracks.push(s), this.renderTracks(), s.id;
  }
  // Метод для удаления всех треков и вспомогательных объектов
  removeTracks() {
    this.getObjects("Track", "Helper")?.forEach((e) => this.remove(e));
  }
  // Метод для отображения треков
  renderTracks() {
    this.updateTracksState(), this.removeTracks();
    const e = this.width, t = this.tracks.flatMap((c) => [
      c,
      {
        id: `after-${c.id}`,
        type: "helper",
        items: [],
        accepts: []
      }
    ]).slice(0, -1);
    let n = 0;
    const i = ne.getClass("Helper") || Ea, s = new i({
      id: "helperLineTop",
      top: n,
      selectable: !1,
      evented: !1,
      tScale: this.tScale,
      width: e,
      kind: "top",
      metadata: {}
    });
    n += Y0("helperTop"), this.insertAt(0, s), t.forEach((c, u) => {
      if (c.type === "helper") {
        const h = Y0("helperCenter"), d = new i({
          id: c.id,
          top: n,
          tScale: this.tScale,
          width: e,
          height: h,
          metadata: { order: (u + 1) / 2 },
          kind: "center"
        });
        n += h, this.insertAt(0, d);
      } else {
        const h = ne.getClass("Track") || is, d = new h({
          id: c.id,
          top: n,
          left: 0,
          fill: "#18181b",
          height: 42,
          width: e,
          tScale: this.tScale,
          accepts: this.acceptsMap?.[c.type] || [],
          items: c.items
        });
        n += 42, this.insertAt(0, d);
      }
    });
    const a = new i({
      id: "helperLineBottom",
      top: n,
      selectable: !1,
      evented: !1,
      tScale: this.tScale,
      width: e,
      kind: "bottom",
      metadata: {}
    });
    this.insertAt(0, a);
  }
  // Метод для обновления состояния треков
  updateTracksState() {
    const e = this.tracks.filter(
      (n) => n.items.length || n.type === "main"
    ), t = /* @__PURE__ */ new Map();
    e.forEach((n) => t.set(n.id, n)), this.tracks = Array.from(t.values());
  }
  // Метод для обновления координат треков
  updateTrackCoords() {
    const e = this.bounding.width + this.spacing.right;
    this.getObjects("Track", "Helper").forEach((t) => {
      t.updateCoords(e), t.setCoords();
    });
  }
}
const Q8 = 60, ej = 188;
function X0(r, e = 1, t = 1) {
  const n = ej * e;
  return r * (Q8 / 1e3) * n / t;
}
class tj {
  // Удаление всех переходов
  removeTransitions() {
    const e = this.getObjects("Transition");
    this.remove(...e);
  }
  // Рендеринг переходов
  renderTransitions() {
    this.removeTransitions(), this.transitionIds.forEach((e) => {
      const t = this.transitionsMap[e], n = t.fromId, i = t.toId, s = this.getObjects(), a = s.find((g) => g.id === n), c = s.find((g) => g.id === i);
      if (!a || !c) return;
      const u = X0(t.duration, this.tScale), h = a.left + a.width - u / 2, d = a.height, p = new fn({
        id: t.id,
        left: h,
        top: a.top,
        height: d,
        width: u,
        tScale: this.tScale,
        duration: t.duration,
        fromId: a.id,
        toId: c.id,
        kind: t.kind
      });
      t.kind === "none" && (p.visible = !1), this.add(p);
    });
  }
  // Обновление координат переходов
  updateTransitionCoordinates() {
    this.pauseEventListeners(), this.getObjects("Transition").forEach((e) => {
      e.tScale = this.tScale, e.updateCoords(), e.setCoords();
    }), this.resumeEventListeners();
  }
  // Выравнивание переходов по треку
  alignTransitionsToTrack() {
    this.pauseEventListeners(), this.transitionIds.forEach((e) => {
      const t = this.getObjects("Transition").find(
        (n) => n.id === e
      );
      if (t instanceof fn) {
        const n = this.getObjects().find(
          (a) => a.id === t.fromId
        );
        if (!n) return;
        const i = X0(t.duration, this.tScale), s = n.left + n.width - i / 2;
        t.set({ left: s, top: n.top }), t.setCoords();
      }
    }), this.resumeEventListeners();
  }
  // Обновление переходов
  updateTransitions(e = !0) {
    e && this.pauseEventListeners();
    const t = this.getObjects("Track"), n = this.getObjects("Video", "Image");
    this.removeTransitions();
    const i = {}, s = [];
    t.forEach((a) => {
      const c = n.filter((u) => a.items.includes(u.id)).sort((u, h) => u.left - h.left);
      for (let u = 0; u < c.length - 1; u++) {
        const h = c[u], d = c[u + 1];
        if (Math.abs(h.left + h.width - d.left) <= 1) {
          const p = `${h.id}-${d.id}`;
          if (this.transitionIds.includes(p))
            i[p] = this.transitionsMap[p];
          else {
            const g = {
              id: p,
              duration: 1500,
              fromId: h.id,
              toId: d.id,
              kind: "none",
              trackId: a.id,
              type: "transition"
            };
            i[p] = g;
          }
          s.push(p);
        }
      }
    }), this.transitionIds = s, this.transitionsMap = i, this.renderTransitions(), e && this.resumeEventListeners();
  }
}
const Q = {
  canvas: null,
  enableGuideRedraw: !0,
  isPointerOverHelperTrack: !1,
  draggingOverTrack: null,
  primaryMovingObjects: [],
  secondaryMovingObjects: [],
  placeholderMovingObjects: [],
  objectInitialPositions: {},
  originTrack: {},
  trackToItemsMap: {},
  activeTrackToItemsMap: {},
  trackTopToIdMap: {},
  trackTops: [],
  activeObjects: [],
  primaryTracks: {},
  secondaryTracks: {}
}, Et = {
  guide: null,
  object: null,
  objects: []
}, fL = () => Q, pL = (r) => {
  Object.assign(Q, r);
}, rj = (r) => {
  r.on("before:transform", Cx.bind(r));
}, nj = (r) => {
  r.off("before:transform", Cx.bind(r));
};
function Cx(r) {
  Q.canvas = this, Q.activeTrackToItemsMap = {}, Q.primaryTracks = {}, Q.secondaryTracks = {}, Q.trackTops = [], Q.trackToItemsMap = {}, Q.activeObjects = [], Q.trackTopToIdMap = {}, Q.canvas.trackIdAfterTransform = "", Q.canvas.positionAfterTransform = {};
  const e = Q.canvas.getActiveObject();
  if (!e) return;
  Q.activeObjects = e instanceof Sn ? e.getObjects() : [e];
  const t = Q.canvas.getScenePoint(r.e), n = Q.canvas.getObjects("Track");
  Q.originTrack = n.find((a) => {
    const c = a.getBoundingRect();
    return t.x >= c.left && t.x <= c.left + c.width && t.y >= c.top && t.y <= c.top + c.height;
  }) ?? {};
  const i = Q.canvas.getObjects(
    "Video",
    "Image",
    "Audio",
    "Text",
    "Element"
  );
  n.forEach((a) => {
    const c = i.filter(
      (u) => a.items.includes(u.id)
    );
    Q.trackToItemsMap[a.id] = c, Q.trackTopToIdMap[a.top] = a.id, Q.trackTops.push(a.top);
  }), Q.trackTops.sort((a, c) => a - c), Q.activeObjects.forEach((a) => {
    const c = n?.find(
      (h) => h.items.includes(a.id)
    );
    if (!c) return;
    const u = c.id;
    Q.activeTrackToItemsMap[u] ? Q.activeTrackToItemsMap[u].push(a) : Q.activeTrackToItemsMap[u] = [a];
  }), Q.primaryMovingObjects = Q.activeObjects.filter(
    (a) => {
      const c = a.getBoundingRect();
      return t.y >= c.top && t.y <= c.top + c.height && !(a instanceof fn);
    }
  ), Q.primaryMovingObjects.forEach((a) => {
    const c = a.getBoundingRect().top, u = Q.trackTopToIdMap[c];
    if (Q.primaryTracks[u])
      Q.primaryTracks[u].objects.push(a);
    else {
      const h = cf(
        Q.trackTops,
        Q.originTrack.top,
        c
      );
      if (typeof h != "number") return;
      Q.primaryTracks[u] = { objects: [a], index: h };
    }
  }), Q.primaryMovingObjects = Q.primaryMovingObjects.sort(
    (a, c) => a.left - c.left
  ), Q.secondaryMovingObjects = Q.activeObjects.filter(
    (a) => !Q.primaryMovingObjects.includes(a) && !(a instanceof fn)
  ), Q.secondaryMovingObjects.forEach((a) => {
    const c = a.getBoundingRect().top, u = Q.trackTopToIdMap[a.getBoundingRect().top];
    if (Q.secondaryTracks[u])
      Q.secondaryTracks[u].objects.push(a);
    else {
      const h = cf(
        Q.trackTops,
        Q.originTrack.top,
        c
      );
      if (typeof h != "number") return;
      Q.secondaryTracks[u] = { objects: [a], index: h };
    }
  }), Q.originTrack && (Q.canvas.trackOriginBeforeTransform = Q.originTrack.id), e && (Q.canvas.positionBeforeTransform = {
    top: e.top,
    left: e.left
  }), ("transform" in r ? r.transform : {}).action === "drag" && (Q.placeholderMovingObjects = Q.primaryMovingObjects.map(
    (a) => {
      const c = a.getBoundingRect();
      Q.objectInitialPositions[a.id] = {
        top: c.top,
        left: c.left
      };
      const u = new la({
        id: `${a.id}-placeholder`,
        left: c.left,
        top: c.top,
        width: c.width,
        height: c.height,
        for: ij[a.type]
      });
      return u.draggedObject = a, u;
    }
  ), Q.canvas.add(...Q.placeholderMovingObjects));
}
function cf(r, e, t) {
  const n = r.indexOf(e), i = r.indexOf(t);
  return n === -1 || i === -1 ? null : i - n;
}
const ij = {
  trackitemvideo: "video",
  trackitemimage: "image",
  trackitemaudio: "audio",
  trackitemtext: "text"
};
function Tx(r) {
  if (!Et.guide) return !1;
  r.e.preventDefault();
  const e = this, t = e.getViewportPoint(r.e);
  Et.guide.set({
    left: t.x - 16,
    top: t.y - Et.guide.height / 2
  });
  const n = sj(
    t,
    Et.objects
  );
  n && (Et.object = n, n.strokeDashArray = [5, 1], n.setSelected(!0)), Et.objects.forEach((i) => {
    i !== n && i.setSelected(!1);
  }), e.requestRenderAll();
}
function sj(r, e) {
  let t = 1 / 0, n = null;
  const i = new B(r.x, r.y);
  return e.forEach((s) => {
    const a = oj(s, i);
    a < t && (t = a, n = s);
  }), n;
}
function oj(r, e) {
  return Math.sqrt(
    Math.pow(r.left - e.x, 2) + Math.pow(r.top - e.y, 2)
  );
}
const aj = [
  "transition",
  "image",
  "video",
  "audio",
  "caption",
  "text"
];
function Ex(r) {
  const e = r.e.dataTransfer?.types[0];
  if (!e) return;
  const t = JSON.parse(e), { type: n, duration: i = 5e3 } = t;
  if (!aj.includes(n)) return;
  const s = this;
  s.discardActiveObject();
  const a = It(i, s.tScale);
  Et.guide = cj({
    width: a,
    height: 48,
    id: "TransitionGuide",
    left: 0,
    top: 0,
    type: n
  }), s.add(Et.guide), n === "transition" && (Et.objects = s.getObjects("Transition"), Et.objects.forEach((c) => {
    c.visible = !0;
  })), Ne.dispatch(Sy);
}
function cj({ width: r, height: e, id: t, left: n, top: i, type: s }) {
  return s === "transition" ? new kl({
    top: 0,
    left: 0,
    height: 48,
    width: 48,
    id: "TransitionGuide"
  }) : new Ol({
    top: i,
    left: n,
    height: e,
    width: r,
    id: t,
    name: "Rivers in the mountains"
  });
}
function kx() {
  if (!Et.guide) return;
  Ne.dispatch(ol);
  const r = this;
  lj(Et.objects), r.remove(Et.guide);
}
function lj(r) {
  r.forEach((e) => {
    e.strokeDashArray = [], e.setSelected(!1), e.kind === "none" && (e.visible = !1);
  });
}
var uj = typeof global == "object" && global && global.Object === Object && global, hj = typeof self == "object" && self && self.Object === Object && self, Sp = uj || hj || Function("return this")(), Si = Sp.Symbol, Ox = Object.prototype, dj = Ox.hasOwnProperty, fj = Ox.toString, Wo = Si ? Si.toStringTag : void 0;
function pj(r) {
  var e = dj.call(r, Wo), t = r[Wo];
  try {
    r[Wo] = void 0;
    var n = !0;
  } catch {
  }
  var i = fj.call(r);
  return n && (e ? r[Wo] = t : delete r[Wo]), i;
}
var gj = Object.prototype, mj = gj.toString;
function vj(r) {
  return mj.call(r);
}
var yj = "[object Null]", bj = "[object Undefined]", G0 = Si ? Si.toStringTag : void 0;
function Cp(r) {
  return r == null ? r === void 0 ? bj : yj : G0 && G0 in Object(r) ? pj(r) : vj(r);
}
function Tp(r) {
  return r != null && typeof r == "object";
}
var wj = "[object Symbol]";
function Ep(r) {
  return typeof r == "symbol" || Tp(r) && Cp(r) == wj;
}
function xj(r, e) {
  for (var t = -1, n = r == null ? 0 : r.length, i = Array(n); ++t < n; )
    i[t] = e(r[t], t, r);
  return i;
}
var ka = Array.isArray, q0 = Si ? Si.prototype : void 0, K0 = q0 ? q0.toString : void 0;
function Ix(r) {
  if (typeof r == "string")
    return r;
  if (ka(r))
    return xj(r, Ix) + "";
  if (Ep(r))
    return K0 ? K0.call(r) : "";
  var e = r + "";
  return e == "0" && 1 / r == -1 / 0 ? "-0" : e;
}
function Il(r) {
  var e = typeof r;
  return r != null && (e == "object" || e == "function");
}
function _j(r) {
  return r;
}
var Sj = "[object AsyncFunction]", Cj = "[object Function]", Tj = "[object GeneratorFunction]", Ej = "[object Proxy]";
function kj(r) {
  if (!Il(r))
    return !1;
  var e = Cp(r);
  return e == Cj || e == Tj || e == Sj || e == Ej;
}
var ad = Sp["__core-js_shared__"], Z0 = function() {
  var r = /[^.]+$/.exec(ad && ad.keys && ad.keys.IE_PROTO || "");
  return r ? "Symbol(src)_1." + r : "";
}();
function Oj(r) {
  return !!Z0 && Z0 in r;
}
var Ij = Function.prototype, Aj = Ij.toString;
function Mj(r) {
  if (r != null) {
    try {
      return Aj.call(r);
    } catch {
    }
    try {
      return r + "";
    } catch {
    }
  }
  return "";
}
var Pj = /[\\^$.*+?()[\]{}|]/g, Dj = /^\[object .+?Constructor\]$/, jj = Function.prototype, Rj = Object.prototype, Fj = jj.toString, Lj = Rj.hasOwnProperty, Nj = RegExp(
  "^" + Fj.call(Lj).replace(Pj, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Bj(r) {
  if (!Il(r) || Oj(r))
    return !1;
  var e = kj(r) ? Nj : Dj;
  return e.test(Mj(r));
}
function Vj(r, e) {
  return r?.[e];
}
function kp(r, e) {
  var t = Vj(r, e);
  return Bj(t) ? t : void 0;
}
function zj(r, e, t) {
  switch (t.length) {
    case 0:
      return r.call(e);
    case 1:
      return r.call(e, t[0]);
    case 2:
      return r.call(e, t[0], t[1]);
    case 3:
      return r.call(e, t[0], t[1], t[2]);
  }
  return r.apply(e, t);
}
var Wj = 800, Hj = 16, Uj = Date.now;
function $j(r) {
  var e = 0, t = 0;
  return function() {
    var n = Uj(), i = Hj - (n - t);
    if (t = n, i > 0) {
      if (++e >= Wj)
        return arguments[0];
    } else
      e = 0;
    return r.apply(void 0, arguments);
  };
}
function Yj(r) {
  return function() {
    return r;
  };
}
var Al = function() {
  try {
    var r = kp(Object, "defineProperty");
    return r({}, "", {}), r;
  } catch {
  }
}(), Xj = Al ? function(r, e) {
  return Al(r, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Yj(e),
    writable: !0
  });
} : _j, Gj = $j(Xj), qj = 9007199254740991, Kj = /^(?:0|[1-9]\d*)$/;
function Ax(r, e) {
  var t = typeof r;
  return e = e ?? qj, !!e && (t == "number" || t != "symbol" && Kj.test(r)) && r > -1 && r % 1 == 0 && r < e;
}
function Zj(r, e, t) {
  e == "__proto__" && Al ? Al(r, e, {
    configurable: !0,
    enumerable: !0,
    value: t,
    writable: !0
  }) : r[e] = t;
}
function Mx(r, e) {
  return r === e || r !== r && e !== e;
}
var Jj = Object.prototype, Qj = Jj.hasOwnProperty;
function e7(r, e, t) {
  var n = r[e];
  (!(Qj.call(r, e) && Mx(n, t)) || t === void 0 && !(e in r)) && Zj(r, e, t);
}
var J0 = Math.max;
function t7(r, e, t) {
  return e = J0(e === void 0 ? r.length - 1 : e, 0), function() {
    for (var n = arguments, i = -1, s = J0(n.length - e, 0), a = Array(s); ++i < s; )
      a[i] = n[e + i];
    i = -1;
    for (var c = Array(e + 1); ++i < e; )
      c[i] = n[i];
    return c[e] = t(a), zj(r, this, c);
  };
}
var r7 = 9007199254740991;
function n7(r) {
  return typeof r == "number" && r > -1 && r % 1 == 0 && r <= r7;
}
var i7 = "[object Arguments]";
function Q0(r) {
  return Tp(r) && Cp(r) == i7;
}
var Px = Object.prototype, s7 = Px.hasOwnProperty, o7 = Px.propertyIsEnumerable, Dx = Q0(/* @__PURE__ */ function() {
  return arguments;
}()) ? Q0 : function(r) {
  return Tp(r) && s7.call(r, "callee") && !o7.call(r, "callee");
}, a7 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, c7 = /^\w*$/;
function l7(r, e) {
  if (ka(r))
    return !1;
  var t = typeof r;
  return t == "number" || t == "symbol" || t == "boolean" || r == null || Ep(r) ? !0 : c7.test(r) || !a7.test(r) || e != null && r in Object(e);
}
var ua = kp(Object, "create");
function u7() {
  this.__data__ = ua ? ua(null) : {}, this.size = 0;
}
function h7(r) {
  var e = this.has(r) && delete this.__data__[r];
  return this.size -= e ? 1 : 0, e;
}
var d7 = "__lodash_hash_undefined__", f7 = Object.prototype, p7 = f7.hasOwnProperty;
function g7(r) {
  var e = this.__data__;
  if (ua) {
    var t = e[r];
    return t === d7 ? void 0 : t;
  }
  return p7.call(e, r) ? e[r] : void 0;
}
var m7 = Object.prototype, v7 = m7.hasOwnProperty;
function y7(r) {
  var e = this.__data__;
  return ua ? e[r] !== void 0 : v7.call(e, r);
}
var b7 = "__lodash_hash_undefined__";
function w7(r, e) {
  var t = this.__data__;
  return this.size += this.has(r) ? 0 : 1, t[r] = ua && e === void 0 ? b7 : e, this;
}
function ss(r) {
  var e = -1, t = r == null ? 0 : r.length;
  for (this.clear(); ++e < t; ) {
    var n = r[e];
    this.set(n[0], n[1]);
  }
}
ss.prototype.clear = u7;
ss.prototype.delete = h7;
ss.prototype.get = g7;
ss.prototype.has = y7;
ss.prototype.set = w7;
function x7() {
  this.__data__ = [], this.size = 0;
}
function mu(r, e) {
  for (var t = r.length; t--; )
    if (Mx(r[t][0], e))
      return t;
  return -1;
}
var _7 = Array.prototype, S7 = _7.splice;
function C7(r) {
  var e = this.__data__, t = mu(e, r);
  if (t < 0)
    return !1;
  var n = e.length - 1;
  return t == n ? e.pop() : S7.call(e, t, 1), --this.size, !0;
}
function T7(r) {
  var e = this.__data__, t = mu(e, r);
  return t < 0 ? void 0 : e[t][1];
}
function E7(r) {
  return mu(this.__data__, r) > -1;
}
function k7(r, e) {
  var t = this.__data__, n = mu(t, r);
  return n < 0 ? (++this.size, t.push([r, e])) : t[n][1] = e, this;
}
function mo(r) {
  var e = -1, t = r == null ? 0 : r.length;
  for (this.clear(); ++e < t; ) {
    var n = r[e];
    this.set(n[0], n[1]);
  }
}
mo.prototype.clear = x7;
mo.prototype.delete = C7;
mo.prototype.get = T7;
mo.prototype.has = E7;
mo.prototype.set = k7;
var O7 = kp(Sp, "Map");
function I7() {
  this.size = 0, this.__data__ = {
    hash: new ss(),
    map: new (O7 || mo)(),
    string: new ss()
  };
}
function A7(r) {
  var e = typeof r;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? r !== "__proto__" : r === null;
}
function vu(r, e) {
  var t = r.__data__;
  return A7(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
function M7(r) {
  var e = vu(this, r).delete(r);
  return this.size -= e ? 1 : 0, e;
}
function P7(r) {
  return vu(this, r).get(r);
}
function D7(r) {
  return vu(this, r).has(r);
}
function j7(r, e) {
  var t = vu(this, r), n = t.size;
  return t.set(r, e), this.size += t.size == n ? 0 : 1, this;
}
function vs(r) {
  var e = -1, t = r == null ? 0 : r.length;
  for (this.clear(); ++e < t; ) {
    var n = r[e];
    this.set(n[0], n[1]);
  }
}
vs.prototype.clear = I7;
vs.prototype.delete = M7;
vs.prototype.get = P7;
vs.prototype.has = D7;
vs.prototype.set = j7;
var R7 = "Expected a function";
function Op(r, e) {
  if (typeof r != "function" || e != null && typeof e != "function")
    throw new TypeError(R7);
  var t = function() {
    var n = arguments, i = e ? e.apply(this, n) : n[0], s = t.cache;
    if (s.has(i))
      return s.get(i);
    var a = r.apply(this, n);
    return t.cache = s.set(i, a) || s, a;
  };
  return t.cache = new (Op.Cache || vs)(), t;
}
Op.Cache = vs;
var F7 = 500;
function L7(r) {
  var e = Op(r, function(n) {
    return t.size === F7 && t.clear(), n;
  }), t = e.cache;
  return e;
}
var N7 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, B7 = /\\(\\)?/g, V7 = L7(function(r) {
  var e = [];
  return r.charCodeAt(0) === 46 && e.push(""), r.replace(N7, function(t, n, i, s) {
    e.push(i ? s.replace(B7, "$1") : n || t);
  }), e;
});
function z7(r) {
  return r == null ? "" : Ix(r);
}
function yu(r, e) {
  return ka(r) ? r : l7(r, e) ? [r] : V7(z7(r));
}
function Ip(r) {
  if (typeof r == "string" || Ep(r))
    return r;
  var e = r + "";
  return e == "0" && 1 / r == -1 / 0 ? "-0" : e;
}
function W7(r, e) {
  e = yu(e, r);
  for (var t = 0, n = e.length; r != null && t < n; )
    r = r[Ip(e[t++])];
  return t && t == n ? r : void 0;
}
function H7(r, e) {
  for (var t = -1, n = e.length, i = r.length; ++t < n; )
    r[i + t] = e[t];
  return r;
}
var e1 = Si ? Si.isConcatSpreadable : void 0;
function U7(r) {
  return ka(r) || Dx(r) || !!(e1 && r && r[e1]);
}
function $7(r, e, t, n, i) {
  var s = -1, a = r.length;
  for (t || (t = U7), i || (i = []); ++s < a; ) {
    var c = r[s];
    t(c) ? H7(i, c) : i[i.length] = c;
  }
  return i;
}
function Y7(r) {
  var e = r == null ? 0 : r.length;
  return e ? $7(r) : [];
}
function X7(r) {
  return Gj(t7(r, void 0, Y7), r + "");
}
function G7(r, e) {
  return r != null && e in Object(r);
}
function q7(r, e, t) {
  e = yu(e, r);
  for (var n = -1, i = e.length, s = !1; ++n < i; ) {
    var a = Ip(e[n]);
    if (!(s = r != null && t(r, a)))
      break;
    r = r[a];
  }
  return s || ++n != i ? s : (i = r == null ? 0 : r.length, !!i && n7(i) && Ax(a, i) && (ka(r) || Dx(r)));
}
function K7(r, e) {
  return r != null && q7(r, e, G7);
}
function Z7(r, e, t, n) {
  if (!Il(r))
    return r;
  e = yu(e, r);
  for (var i = -1, s = e.length, a = s - 1, c = r; c != null && ++i < s; ) {
    var u = Ip(e[i]), h = t;
    if (u === "__proto__" || u === "constructor" || u === "prototype")
      return r;
    if (i != a) {
      var d = c[u];
      h = void 0, h === void 0 && (h = Il(d) ? d : Ax(e[i + 1]) ? [] : {});
    }
    e7(c, u, h), c = c[u];
  }
  return r;
}
function J7(r, e, t) {
  for (var n = -1, i = e.length, s = {}; ++n < i; ) {
    var a = e[n], c = W7(r, a);
    t(c, a) && Z7(s, yu(a, r), c);
  }
  return s;
}
function Q7(r, e) {
  return J7(r, e, function(t, n) {
    return K7(r, n);
  });
}
var eR = X7(function(r, e) {
  return r == null ? {} : Q7(r, e);
});
function jx(r) {
  const e = r.e.dataTransfer?.types[0];
  if (!e) return;
  const t = JSON.parse(
    r.e.dataTransfer.getData(e)
  ), n = this;
  if (t.type !== "transition") {
    tR(t), n.remove(Et.guide), n.requestRenderAll(), Ne.dispatch(ol);
    return;
  }
  Et.guide && (Et.object && rR(t, n), Et.objects.forEach((i) => {
    i.strokeDashArray = [], i.setSelected(!1), i.kind === "none" && (i.visible = !1);
  }), n.remove(Et.guide), n.requestRenderAll(), Ne.dispatch(ol));
}
function tR(r) {
  const e = { ...r, id: Lt() };
  switch (r.type) {
    case "image":
      Ne.dispatch(ya, { payload: e });
      break;
    case "video":
      Ne.dispatch(ma, { payload: e });
      break;
    case "audio":
      Ne.dispatch(va, { payload: e });
      break;
  }
}
function rR(r, e) {
  const t = Et.object?.id, n = eR(r, ["kind", "direction"]);
  Object.entries(n).forEach(([i, s]) => {
    i === "kind" ? Et.object.kind = s : Et.object[i] = s;
  }), e.transitionsMap[t] = {
    ...e.transitionsMap[t],
    ...n
  }, e.updateState();
}
const nR = (r) => {
  r.on("dragover", Tx), r.on("dragenter", Ex), r.on("dragleave", kx), r.on("drop", jx);
}, iR = (r) => {
  r.off("dragover", Tx), r.off("dragenter", Ex), r.off("dragleave", kx), r.off("drop", jx);
}, Rx = (r) => {
  const e = r.target.canvas, t = r.target;
  if (r.action === "resizing" && t instanceof fn && e) {
    const n = t.id, i = e.getObjects("Transition").find((s) => s.id === n);
    if (i && i instanceof fn) {
      const s = Xe.cloneDeep(e.transitionsMap), a = {
        ...s,
        [n]: {
          ...s[n],
          width: i.width,
          duration: i.duration
        }
      };
      e.transitionsMap = a, e.updateState();
    }
  }
  e && (sR(e, e.getObjects()), oR(e.getObjects("Helper")), Q.isPointerOverHelperTrack = !1, Q.draggingOverTrack = null);
}, sR = (r, e) => {
  e.forEach((t) => {
    t.isAlignmentAuxiliary && r.remove(t);
  });
}, oR = (r) => {
  r.forEach((e) => e.setSelected(!1));
};
function Fx(r) {
  const e = r.target.canvas;
  if (!e) return;
  const t = e.getActiveObject();
  if (!t || !e.positionBeforeTransform) return;
  const n = e.getScenePoint(r.e), i = e.getObjects("Track", "Helper").find((s) => {
    const a = s.getBoundingRect();
    return n.x >= a.left && n.x <= a.left + a.width && n.y >= a.top && n.y <= a.top + a.height;
  });
  if (r.action === "resizing") {
    const s = (Q.trackToItemsMap[Q.originTrack.id] || []).filter((c) => c !== t);
    t.setCoords();
    const a = bu(
      s,
      t.getBoundingRect()
    );
    return e.fire("track-items:resized", {
      trackId: Q.originTrack.id,
      trackItemIds: [t.id],
      isOverlapped: !!a
    }), !1;
  }
  if (!i)
    return t && (t?.set(e.positionBeforeTransform), t?.setCoords()), !1;
  if (i instanceof Ea) {
    let s;
    switch (i.kind) {
      case "top":
        s = 0;
        break;
      case "center":
        s = i.metadata.order || 0;
        break;
      case "bottom":
        s = -1;
        break;
      default:
        return;
    }
    const a = {
      isSecondaryOverlapped: !1,
      secondaryTracks: Q.secondaryTracks,
      primaryTracks: Q.primaryTracks,
      primaryPositions: {
        trackIndex: s,
        trackId: e.trackIdAfterTransform,
        positions: e.positionAfterTransform
      }
    };
    uR(a);
  } else if (i instanceof is) {
    const s = {
      isSecondaryOverlapped: cR(),
      secondaryTracks: Q.secondaryTracks,
      primaryTracks: Q.primaryTracks,
      primaryPositions: {
        trackId: e.trackIdAfterTransform,
        positions: e.positionAfterTransform
      }
    };
    aR(s);
  }
}
const aR = (r) => {
  Q.canvas && Q.canvas.fire("track-items:moved", r);
};
function cR() {
  const r = lR();
  return Object.keys(r).some((e) => {
    const t = Q.trackToItemsMap[e], n = r[e].objects;
    return t?.length ? t.filter((i) => !n.includes(i)).some(
      (i) => bu(n, i.getBoundingRect())
    ) : !0;
  });
}
function lR() {
  const [r] = Q.primaryMovingObjects, e = r.id, n = Q.canvas.positionAfterTransform[e].top - r.getBoundingRect().top, i = {};
  return Q.secondaryMovingObjects.forEach((s) => {
    const a = s.getBoundingRect().top + n, c = Q.trackTopToIdMap[a], u = cf(
      Q.trackTops,
      Q.originTrack.top,
      a
    );
    i[c] ? i[c].objects.push(s) : i[c] = {
      objects: [s],
      index: u
    };
  }), i;
}
const uR = (r) => {
  Q.canvas && Q.canvas.fire("track:create", r);
};
function bu(r, e) {
  return r.find((t) => {
    const n = t.getBoundingRect();
    return e.left < n.left + n.width && e.left + e.width > n.left && e.top < n.top + n.height && e.top + e.height > n.top;
  });
}
const hR = (r) => {
  r.on("object:modified", Rx), r.on("object:modified", Fx);
}, dR = (r) => {
  r.off("object:modified", Rx), r.off("object:modified", Fx);
};
function fR(r, e) {
  r.remove(...e), e.length = 0;
}
function Lx() {
  fR(this, Q.placeholderMovingObjects);
}
function Nx(r) {
  const e = this.height < this.bounding.height, t = this.width < this.bounding.width;
  if (!e && !t) return;
  const n = this.viewportTransform;
  let i = n[4], s = n[5];
  const a = 2;
  r.e.shiftKey ? i = n[4] - r.e.deltaY * a : (e && (s = n[5] - r.e.deltaY * a), i = n[4] - r.e.deltaX * a), this.setViewportPos(i, s);
}
const pR = (r) => {
  r.on("mouse:wheel", Nx), r.on("mouse:up", Lx.bind(r));
}, gR = (r) => {
  r.off("mouse:wheel", Nx), r.off("mouse:up", Lx.bind(r));
};
function Bx(r) {
  const e = this;
  if (!e) return;
  const t = e.getScenePoint(r.e), n = e.getObjects("Helper", "Track");
  Q.draggingOverTrack = n.find((h) => {
    const d = h.getBoundingRect();
    return t.x >= d.left && t.x <= d.left + d.width && t.y >= d.top && t.y <= d.top + d.height;
  }) ?? null, n.forEach((h) => {
    if (r1(h)) {
      const d = Q.draggingOverTrack;
      h.setSelected(h === d);
    }
  }), Q.isPointerOverHelperTrack = r1(
    Q.draggingOverTrack
  ), e.getObjects();
  const i = r.target;
  i.getBoundingRect(), i.setCoords();
  const s = [
    i,
    ...e.getActiveObjects(),
    ...e.getObjects("Track", "Helper", "Transition", "Placeholder")
  ], a = mR(s, e), c = yR(i);
  vR(
    a,
    c
  ).forEach((h) => {
    h.orientation === "V" ? i.left = h.lineGuide + h.offset : i.top = h.lineGuide + h.offset;
  });
}
const mR = (r, e) => {
  const t = [], n = [];
  return e.getObjects().filter((i) => i.visible).forEach((i) => {
    if (r.some(
      (c) => c.id === i.id
    ) || i.isAlignmentAuxiliary) return;
    const a = i.getBoundingRect();
    t.push(
      t1(
        a.left,
        a.width,
        a.top,
        a.height
      )
    ), n.push(
      t1(
        a.top,
        a.height,
        a.left,
        a.width
      )
    );
  }), {
    vertical: t.flat(),
    horizontal: []
  };
}, t1 = (r, e, t, n) => [r, r + e].map((i) => ({
  val: i,
  start: t,
  end: t + n
})), vR = (r, e) => {
  const t = [], n = [];
  r.vertical.forEach((u) => {
    e.vertical.forEach((h) => {
      const d = Math.abs(u.val - h.guide);
      d < 10 && t.push({
        lineGuide: u.val,
        diff: d,
        orientation: "V",
        snap: h.snap,
        offset: h.offset,
        targetDim: {
          start: u.start,
          end: u.end
        }
      });
    });
  }), r.horizontal.forEach((u) => {
    e.horizontal.forEach((h) => {
      const d = Math.abs(u.val - h.guide);
      d < 10 && n.push({
        lineGuide: u.val,
        diff: d,
        orientation: "H",
        snap: h.snap,
        offset: h.offset,
        targetDim: {
          start: u.start,
          end: u.end
        }
      });
    });
  });
  const s = [], a = t.sort(
    (u, h) => u.diff - h.diff
  )[0], c = n.sort(
    (u, h) => u.diff - h.diff
  )[0];
  return a && s.push({
    lineGuide: a.lineGuide,
    offset: a.offset,
    orientation: "V",
    snap: a.snap,
    targetDim: a.targetDim
  }), c && s.push({
    lineGuide: c.lineGuide,
    offset: c.offset,
    orientation: "H",
    snap: c.snap,
    targetDim: c.targetDim
  }), s;
}, yR = (r) => {
  const e = r.getBoundingRect();
  return {
    vertical: [
      {
        guide: Math.round(e.left),
        offset: Math.round(r.left - e.left),
        snap: "start"
      },
      {
        guide: Math.round(e.left + e.width),
        offset: Math.round(
          r.left - e.left - e.width
        ),
        snap: "end"
      }
    ],
    horizontal: [
      {
        guide: Math.round(e.top),
        offset: Math.round(r.top - e.top),
        snap: "start"
      },
      {
        guide: Math.round(e.top + e.height),
        offset: Math.round(r.top - e.top - e.height),
        snap: "end"
      }
    ]
  };
}, r1 = (r) => r instanceof Ea;
function bR(r) {
  r.opacity = Q.isPointerOverHelperTrack ? 0 : 1;
}
const Vx = ER((r) => {
  const e = r.target.canvas;
  if (kR(r), !Q.draggingOverTrack) return;
  const t = Q.placeholderMovingObjects.map(
    (s) => s.draggedObject
  ), n = (Q.trackToItemsMap[Q.draggingOverTrack.id] || []).filter((s) => !t.includes(s)), i = n.find(
    (s) => bu(t, s.getBoundingRect())
  );
  Q.placeholderMovingObjects.forEach((s) => {
    const a = s.draggedObject;
    a?.setCoords(), bR(s);
    const c = wR(
      a,
      n,
      i,
      Q.placeholderMovingObjects.length > 1
    );
    e.trackIdAfterTransform = Q.trackTopToIdMap[c.top], e.positionAfterTransform[a?.id] = {
      top: c.top,
      left: c.left
    }, s.left = c.left, s.top = c.top;
  });
}, 5), wR = (r, e, t, n) => !xR(r) || n && t ? zx(r) : t ? _R(r, t, e) : TR(r), xR = (r) => Q.draggingOverTrack ? Q.draggingOverTrack.accepts?.includes(r.type) ?? !1 : !1, zx = (r) => ({
  top: Q.objectInitialPositions[r.id].top,
  left: Q.objectInitialPositions[r.id].left
}), _R = (r, e, t) => {
  const n = SR(r, e);
  return !CR(t, r, n) || Q.activeObjects.length !== 1 ? zx(r) : {
    left: n,
    top: e.top
  };
}, SR = (r, e) => {
  const t = r.left + r.width / 2, n = e.left + e.width / 2;
  return t < n ? e.left - r.width : e.left + e.width;
}, CR = (r, e, t) => !(t < 0 || bu(r, {
  ...e.getBoundingRect(),
  left: t
})), TR = (r) => ({
  left: r.getBoundingRect().left,
  top: Q.draggingOverTrack?.top ?? 0
});
function ER(r, e) {
  let t = null;
  return function(...n) {
    const i = Date.now();
    (t === null || i - t >= e) && (t = i, r(...n));
  };
}
function kR(r) {
  const e = r.target, t = e.canvas, n = e.top, i = -e.height * 0.75, s = t.height + e.height * 0.75;
  e.top = Math.min(Math.max(n, i), s - e.height);
  const a = e.left;
  e.left = Math.max(a, 0);
}
const OR = (r) => {
  r.on("object:moving", Bx.bind(r)), r.on("object:moving", Vx);
}, IR = (r) => {
  r.off("object:moving", Bx.bind(r)), r.off("object:moving", Vx);
};
function Wx() {
  const r = this, e = r.getActiveObject(), t = r.getActiveObjects().map((n) => n.id);
  e instanceof qr ? (e.borderColor = "rgba(0, 216, 214, 0.75)", e.hasControls = !1, e.hoverCursor = "default", e.borderScaleFactor = 1, e.padding = 0, e.getObjects().forEach((n) => {
    n.setSelected(!0);
  })) : e?.setSelected(!0), this.setActiveIds(t);
}
function Hx(r) {
  const e = this, t = e.getActiveObject();
  t instanceof qr && (t.borderColor = "transparent", t.hasControls = !1, t.hoverCursor = "default"), r.selected.forEach((i) => {
    i.setSelected(!0);
  }), r.deselected.forEach((i) => {
    i.setSelected(!1);
  });
  const n = e.getActiveObjects().map((i) => i.id);
  this.setActiveIds(n);
}
function Ux(r) {
  this.getObjects().forEach((t) => {
    t.isSelected && (t.isSelected = !1);
  }), r.deselected.forEach((t) => {
    t.setSelected(!1);
  });
  const e = this.getActiveObjects().map((t) => t.id);
  this.setActiveIds(e);
}
const AR = (r) => {
  r.on("selection:created", Wx), r.on("selection:updated", Hx), r.on("selection:cleared", Ux);
}, MR = (r) => {
  r.off("selection:created", Wx), r.off("selection:updated", Hx), r.off("selection:cleared", Ux);
};
let $x, Yx, Xx;
const PR = (r) => {
  const { state: e } = r;
  $x = e.subscribeToActiveIds(({ activeIds: t }) => {
    if (t.length === 1) {
      const n = t[0], { trackItemIds: i, trackItemsMap: s } = e.getState();
      i.forEach((a) => {
        s[a].type;
      }), r.selectTrackItemByIds([n]);
    } else
      r.selectTrackItemByIds(t);
  }), Yx = e.subscribeToHistory((t) => {
    const { tracks: n, trackItemsMap: i, trackItemIds: s, trackItemDetailsMap: a } = t;
    r.tracks = n, r.trackItemsMap = i, r.trackItemIds = s, r.trackItemDetailsMap = a, r.renderTracks(), r.updateTrackItemsToHistory(), r.alignItemsToTrack(), r.calcBounding(), r.updateTransitions(), r.duration = On(r.trackItemsMap);
  }), Xx = e.subscribeToAddOrRemoveItems(() => {
    const t = r.getTrackItems().map((c) => c.id), { trackItemIds: n, trackItemsMap: i, trackItemDetailsMap: s } = e.getState(), a = [];
    t.forEach((c) => {
      n.includes(c) || a.push(c);
    }), r.deleteTrackItemById(a), r.tracks = e.getState().tracks, r.trackItemsMap = i, r.trackItemDetailsMap = s, n.forEach((c) => {
      if (!t.includes(c)) {
        const u = {
          ...i[c],
          details: {
            ...s[c].details
          }
        };
        r.addTrackItem(u);
      }
    }), r.renderTracks(), r.alignItemsToTrack(), n.forEach((c) => {
      r.updateTrackItemCoords(c);
    }), r.updateTransitions(), r.updateTrackCoords();
  });
}, DR = (r) => {
  $x.unsubscribe(), Yx.unsubscribe(), Xx.unsubscribe();
};
function Gx(r) {
  const {
    isSecondaryOverlapped: e,
    secondaryTracks: t,
    primaryTracks: n,
    primaryPositions: i
  } = r, { trackId: s, positions: a } = i, c = this.tracks.findIndex((v) => v.id === s), u = Py(
    Object.keys(t).map(
      (v) => t[v].objects.map((b) => b.id)
    )
  ), h = al(this.tracks, [
    ...Object.keys(a),
    ...u
  ]);
  Object.keys(n).forEach((v) => {
    this.pauseEventListeners();
    const { objects: b } = n[v];
    b.forEach((_) => {
      const C = a[_.id];
      _.left = C.left;
    }), this.resumeEventListeners();
    const x = h.find((_) => _.id === s);
    x && x.items.push(...Object.keys(a)), this.tracks = h;
  });
  const d = this.tracks[c], p = [];
  Object.keys(t).forEach((v) => {
    const { objects: b, index: x } = t[v], _ = b.map((k) => k.id), [C] = _, E = this.trackItemsMap[C];
    if (e) {
      const k = {
        id: Lt(),
        items: _,
        type: E.type,
        accepts: this.acceptsMap?.[E.type],
        tempIndex: x
      };
      p.push(k);
    } else {
      const k = h[c + x];
      k && k.items.push(..._), this.tracks = h;
    }
  });
  const g = Dy(
    d,
    p
  );
  g.length && h.splice(c, 1, ...g), this.tracks = h, this.renderTracks(), this.alignItemsToTrack(), this.updateTrackItemsPosition(), this.updateTransitions(), this.updateState({ updateHistory: !0, kind: "update" });
}
function qx({
  trackItemIds: r,
  isOverlapped: e
}) {
  const [t] = r;
  if (t) {
    if (!this.getObjects("Transition").find(
      (n) => n.id === t
    )) {
      const n = this.tracks.find((i) => i.items.includes(t));
      if (e) {
        const i = jR(this.tracks, r), s = {
          id: Lt(),
          items: [t],
          type: n?.type,
          accepts: n?.accepts
        }, a = this.tracks.findIndex((c) => c.id === n?.id);
        i.splice(a, 0, s), this.tracks = i;
      }
    }
    this.renderTracks(), this.alignItemsToTrack(), this.alignTransitionsToTrack(), this.updateTransitions(), this.updateTrackItemsPosition(), this.updateState({ updateHistory: !0, kind: "update" });
  }
}
function jR(r, e) {
  return r.map((t) => ({
    ...t,
    items: t.items.filter(
      (n) => !e.includes(n)
    )
  }));
}
function Kx(r) {
  const {
    secondaryTracks: e,
    primaryTracks: t,
    primaryPositions: n
  } = r, { positions: i, trackIndex: s } = n, a = s === -1 ? this.tracks.length : s, [c] = Object.keys(t), u = this.tracks.find((x) => x.id == c), h = t[c], d = {
    id: Lt(),
    items: h.objects.map((x) => x.id),
    type: u?.type,
    accepts: u?.accepts
  }, p = Py(
    Object.keys(e).map(
      (x) => e[x].objects.map((_) => _.id)
    )
  ), g = al(this.tracks, [
    ...Object.keys(i),
    ...p
  ]), v = [];
  Object.keys(e).forEach((x) => {
    const { objects: _, index: C } = e[x], E = this.tracks.find(
      (P) => P.id == x
    ), k = _.map((P) => P.id), O = {
      id: Lt(),
      items: k,
      type: E?.type,
      accepts: E?.accepts,
      tempIndex: C
    };
    v.push(O);
  });
  const b = Dy(d, v);
  b.length && g.splice(a, 0, ...b), this.tracks = g, this.renderTracks(), this.alignItemsToTrack(), this.updateTrackItemsPosition(), this.updateTransitions(), this.updateState({ updateHistory: !0, kind: "update" });
}
const RR = (r) => {
  r.on("track:create", Kx.bind(r)), r.on("track-items:resized", qx.bind(r)), r.on("track-items:moved", Gx.bind(r));
}, FR = (r) => {
  r.off("track:create", Kx.bind(r)), r.off("track-items:resized", qx.bind(r)), r.off("track-items:moved", Gx.bind(r));
}, LR = (r) => {
  nR(r), hR(r), pR(r), OR(r), RR(r), AR(r), rj(r), PR(r);
}, NR = (r) => {
  iR(r), dR(r), gR(r), IR(r), FR(r), MR(r), nj(r), DR();
}, BR = {
  video: ["*"],
  image: ["*"],
  audio: ["*"],
  text: ["*"]
}, VR = ["video", "image", "audio", "text"];
let Ap = class extends nf {
  acceptsMap;
  tracks = [];
  trackItemsMap = {};
  trackItemIds = [];
  transitionIds = [];
  transitionsMap = {};
  trackItemDetailsMap = {};
  bounding;
  onScroll;
  tScale;
  store;
  state;
  activeIds = [];
  spacing;
  scale;
  sizesMap;
  duration;
  setupFabricDefaults() {
    rt.ownDefaults.borderColor = "transparent", rt.ownDefaults.cornerColor = "white", rt.ownDefaults.cornerStrokeColor = "transparent", rt.ownDefaults.strokeWidth = 0, rt.ownDefaults.borderOpacityWhenMoving = 1, rt.ownDefaults.borderScaleFactor = 1, rt.ownDefaults.cornerSize = 8, rt.ownDefaults.cornerStyle = "rect", rt.ownDefaults.centeredScaling = !1, rt.ownDefaults.centeredRotation = !0, rt.ownDefaults.transparentCorners = !1;
  }
  constructor(e, t) {
    super(e, t), this.bounding = t.bounding || {
      width: t.width || 0,
      height: t.height || 0
    }, this.spacing = {
      left: 16,
      right: 80,
      ...t.spacing
    };
    const n = this.viewportTransform;
    n[4] = this.spacing.left, this.tScale = t.tScale || 1 / 300, this.store = t.store, this.state = t.state, this.scale = t.scale, this.onScroll = t.onScroll, this.acceptsMap = this.createAcceptsItemMap(t.acceptsMap), this.sizesMap = U8(t.sizesMap), this.setupFabricDefaults(), this.initEventListeners();
  }
  createAcceptsItemMap(e = BR) {
    const t = {};
    return Object.keys(e).forEach((n) => {
      const i = e[n];
      t[n] = i.includes("*") ? VR : i;
    }), t;
  }
  // setActiveIds(e: any) {
  //   this.activeIds = e;
  //   eventBus.dispatch(LAYER_SELECTION, {
  //     payload: {
  //       activeIds: this.activeIds,
  //     },
  //   });
  // }
  setActiveIds(e) {
    this.activeIds = e, this.getObjects("Transition").some(
      (n) => e.includes(n.id)
    ) || (this.state?.updateState({
      activeIds: Xe.cloneDeep(this.activeIds)
    }), Ne.dispatch(by, {
      payload: {
        activeIds: this.activeIds
      }
    }));
  }
  purge() {
    NR(this), this.dispose();
  }
  static registerItems(e) {
    Object.keys(e).forEach((t) => {
      ne.setClass(e[t], t);
    });
  }
  initEventListeners() {
    LR(this);
  }
  getUpdatedState() {
    const e = On(this.trackItemsMap);
    return {
      tracks: this.tracks,
      trackItemIds: this.trackItemIds,
      trackItemsMap: this.trackItemsMap,
      transitionIds: this.transitionIds,
      transitionsMap: this.transitionsMap,
      // tScale: this.tScale,
      scale: this.scale,
      duration: e
    };
  }
  getState() {
    const e = On(this.trackItemsMap);
    return {
      tracks: this.tracks,
      trackItemIds: this.trackItemIds,
      trackItemsMap: this.trackItemsMap,
      transitionIds: this.transitionIds,
      transitionsMap: this.transitionsMap,
      trackItemDetailsMap: this.trackItemDetailsMap,
      // tScale: this.tScale,
      scale: this.scale,
      duration: e
    };
  }
  notify(e = { updateHistory: !1 }) {
    const t = this.getUpdatedState();
    this.state.updateState(t, e);
  }
  updateState(e) {
    this.updateTracksState(), this.updateTrackItemsState(), this.requestRenderAll(), this.calcBounding(), this.updateTrackCoords();
    const t = this.getUpdatedState();
    this.state.updateState(t, e);
  }
  scrollTo({
    scrollLeft: e,
    scrollTop: t
  }) {
    const n = [...this.viewportTransform];
    let i = !1;
    if (typeof e == "number" && (n[4] = -e + this.spacing.left, i = !0), typeof t == "number" && (n[5] = -t, i = !0), i) {
      this.viewportTransform = n;
      const s = this.getActiveObject();
      s && s.setCoords(), this.requestRenderAll();
    }
  }
  setBoundingBox(e) {
    this.bounding = e;
  }
  calcBounding() {
    const e = this.getTrackItems().reduce(
      (t, n) => {
        const { left: i, top: s, width: a, height: c } = n.getBoundingRect();
        return {
          left: Math.min(t.left, i),
          top: Math.min(t.top, s),
          width: Math.max(t.width, i + a),
          height: Math.max(t.height, s + c)
        };
      },
      { left: 1 / 0, top: 1 / 0, width: this.width, height: 0 }
    );
    this.bounding = e, Ne.dispatch(Cy, {
      payload: { bounding: e }
    });
  }
  setScale(e) {
    this.pauseEventListeners(), this.tScale = e.zoom, this.scale = e;
    const t = this.getState();
    this.getObjects("Video", "Image", "Text", "Audio").forEach(
      (n) => {
        const i = t.trackItemsMap[n.id], { from: s, to: a } = i.display, c = It(s, this.tScale), u = It(
          a - s,
          this.tScale,
          n.playbackRate
        );
        n.set({ left: c, width: u, tScale: e.zoom }), n.setCoords();
      }
    ), this.requestRenderAll(), this.calcBounding(), this.updateTrackCoords(), this.updateTransitions(!1), this.resumeEventListeners(), this.notify();
  }
  setViewportPos(e, t) {
    const n = this.getViewportPos(e, t), i = this.viewportTransform;
    i[4] = n.x, i[5] = n.y, this.requestRenderAll(), this.setActiveTrackItemCoords();
    const s = this.onScroll;
    s && s.call(this, {
      scrollTop: n.y,
      scrollLeft: n.x - this.spacing.left
    });
  }
  getViewportPos(e, t) {
    const n = this.bounding.width - 100 >= this.width ? this.spacing.right : 0, i = this.width - this.bounding.width - n, s = this.spacing.left, a = Math.max(i, Math.min(e, s));
    if (this.bounding.height < this.height) return { x: a, y: 0 };
    const c = this.height - this.bounding.height - 40, u = Math.max(c, Math.min(t, 0));
    return { x: a, y: u };
  }
};
O8(Ap, [
  n8,
  K8,
  J8,
  tj
]);
function zR(r) {
  const e = Ne.subject.pipe($n(({ key: t }) => t.startsWith(OI))).subscribe((t) => {
    if (t.key === _y) {
      const n = t.value;
      r.setScale(n?.payload.scale ?? void 0);
    }
  });
  return {
    unsubscribe: () => {
      e.unsubscribe();
    }
  };
}
Ap.registerItems({
  Text: Sx,
  Image: X8,
  Video: Y8,
  Audio: $8,
  Track: G8,
  Helper: q8
});
const WR = ({ stateManager: r }) => {
  const e = be(!1), [t, n] = ue(0), i = be(null), s = be(null), a = be(null), c = be(null), u = be(null), [h, d] = ue({
    width: 0,
    height: 0
  }), [p, g] = ue({
    width: 0,
    height: 0
  }), {
    scale: v,
    playerRef: b,
    fps: x,
    setState: _,
    timeline: C
  } = Zn(), { setTimeline: E } = Zn(), k = Of(b ?? void 0), O = (F) => {
    u.current && c.current && (c.current.scrollTop = -F.scrollTop, u.current.scrollLeft = -F.scrollLeft, n(-F.scrollLeft));
  };
  ce(() => {
    const F = It(k / x * 1e3, v.zoom), $ = s.current?.getBoundingClientRect().x + s.current?.clientWidth;
    if (F - t + 40 >= $) {
      const G = u.current?.clientWidth, H = u.current?.scrollWidth, Y = u.current?.scrollLeft, ge = (H - (G + Y)) / G;
      ge >= 0 && (ge > 1 ? u.current?.scrollTo({
        left: Y + G
      }) : u.current?.scrollTo({
        left: H - G
      }));
    }
  }, [k]), ce(() => {
    const F = s.current, $ = i.current;
    if (!F || !$) return;
    const z = $.clientWidth, G = $.clientHeight, H = new Ap(F, {
      width: z,
      height: G,
      bounding: {
        width: z,
        height: 0
      },
      selectionColor: "rgba(0, 216, 214,0.1)",
      selectionBorderColor: "rgba(0, 216, 214,1.0)",
      onScroll: O,
      // tScale: scale.zoom,
      // store,
      state: r,
      scale: v,
      spacing: {
        left: kf,
        right: kv
      }
    }), Y = zR(H);
    a.current = H, d({
      width: z,
      height: G
    }), g({
      width: z,
      height: 0
    }), E(H);
    const te = r.subscribeToSize(
      (re) => {
        _(re);
      }
    ), ge = r.subscribeToScale((re) => {
      _(re);
    }), Z = r.subscribeToTracks(
      (re) => {
        _(re);
      }
    ), de = r.subscribeToDuration(
      (re) => {
        _(re);
      }
    ), oe = r.subscribeToUpdateTrackItem(() => {
      const re = r.getState();
      _({
        duration: re.duration,
        trackItemsMap: re.trackItemsMap
      });
    }), ie = r.subscribeToAddOrRemoveItems(
      () => {
        const re = r.getState();
        _({
          trackItemDetailsMap: re.trackItemDetailsMap,
          trackItemsMap: re.trackItemsMap,
          trackItemIds: re.trackItemIds,
          tracks: re.tracks
        });
      }
    ), pe = r.subscribeToUpdateItemDetails(() => {
      const re = r.getState();
      _({
        trackItemDetailsMap: re.trackItemDetailsMap
      });
    });
    return () => {
      Y.unsubscribe(), H.purge(), ge.unsubscribe(), Z.unsubscribe(), de.unsubscribe(), ie.unsubscribe(), oe.unsubscribe(), pe.unsubscribe(), te.unsubscribe();
    };
  }, []), ce(() => {
    const $ = Ne.subject.pipe(
      $n(({ key: z }) => z.startsWith(AI))
    ).subscribe((z) => {
      if (z.key === Cy) {
        const G = z.value?.payload?.bounding;
        G && g({
          width: G.width,
          height: G.height
        });
      }
    });
    return () => {
      $.unsubscribe();
    };
  }, []);
  const P = (F) => {
    const $ = F.currentTarget.scrollLeft;
    e.current && a.current.scrollTo({ scrollLeft: $ }), n($);
  }, R = (F) => {
    const $ = F.currentTarget.scrollTop;
    e.current && a.current.scrollTo({ scrollTop: $ });
  };
  ce(() => {
    const F = u.current?.scrollWidth;
    if (!F || !C) return;
    const $ = C.width;
    F < $ + t && C.scrollTo({ scrollLeft: F - $ });
  }, [v]);
  const V = (F) => {
    if (!a.current) return;
    const z = ts(F, v.zoom);
    b?.current?.seekTo(z * x / 1e3);
  };
  return /* @__PURE__ */ y.jsxs("div", { className: "relative overflow-hidden h-80 w-full", children: [
    /* @__PURE__ */ y.jsx(R3, {}),
    /* @__PURE__ */ y.jsx(
      UP,
      {
        onClick: V,
        scrollLeft: t
      }
    ),
    /* @__PURE__ */ y.jsx(HP, { scrollLeft: t }),
    /* @__PURE__ */ y.jsxs("div", { className: "flex", children: [
      /* @__PURE__ */ y.jsx("div", { className: "relative w-10 flex-none" }),
      /* @__PURE__ */ y.jsxs("div", { className: "relative h-[230px] flex-1", children: [
        /* @__PURE__ */ y.jsx(
          "div",
          {
            ref: i,
            className: "absolute top-0 h-[230px] w-full text-sm text-white ",
            children: /* @__PURE__ */ y.jsx(
              "canvas",
              {
                ref: s,
                id: "designcombo-timeline-canvas"
              }
            )
          }
        ),
        /* @__PURE__ */ y.jsxs(
          sl,
          {
            type: "always",
            style: {
              position: "absolute",
              width: "calc(100vw - 40px)",
              height: "10px"
            },
            className: "ScrollAreaRootH",
            children: [
              /* @__PURE__ */ y.jsx(
                bd,
                {
                  onScroll: P,
                  className: "ScrollAreaViewport",
                  id: "viewportH",
                  ref: u,
                  children: /* @__PURE__ */ y.jsx(
                    "div",
                    {
                      style: {
                        width: p.width > h.width ? p.width + kv : p.width
                      },
                      className: "pointer-events-none h-[10px]"
                    }
                  )
                }
              ),
              /* @__PURE__ */ y.jsx(
                yv,
                {
                  className: "ScrollAreaScrollbar",
                  orientation: "horizontal",
                  children: /* @__PURE__ */ y.jsx(
                    bv,
                    {
                      className: "ScrollAreaThumb",
                      onMouseDown: () => {
                        e.current = !0;
                      },
                      onMouseUp: () => {
                        e.current = !1;
                      }
                    }
                  )
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ y.jsxs(
          sl,
          {
            type: "always",
            style: {
              position: "absolute",
              height: "230px",
              width: "10px"
            },
            className: "ScrollAreaRootV",
            children: [
              /* @__PURE__ */ y.jsx(
                bd,
                {
                  onScroll: R,
                  className: "ScrollAreaViewport",
                  ref: c,
                  children: /* @__PURE__ */ y.jsx(
                    "div",
                    {
                      style: {
                        height: p.height > h.height ? p.height + 40 : h.height
                      },
                      className: "pointer-events-none w-[10px]"
                    }
                  )
                }
              ),
              /* @__PURE__ */ y.jsx(
                yv,
                {
                  className: "ScrollAreaScrollbar",
                  orientation: "vertical",
                  children: /* @__PURE__ */ y.jsx(
                    bv,
                    {
                      className: "ScrollAreaThumb",
                      onMouseDown: () => {
                        e.current = !0;
                      },
                      onMouseUp: () => {
                        e.current = !1;
                      }
                    }
                  )
                }
              )
            ]
          }
        )
      ] })
    ] })
  ] });
}, HR = { Date: !0, RegExp: !0, String: !0, Number: !0 };
function Zx(r, e, t = { cyclesFix: !0 }, n = []) {
  let i = [];
  const s = Array.isArray(r);
  for (const c in r) {
    const u = r[c], h = s ? +c : c;
    if (!(c in e)) {
      i.push({
        type: "REMOVE",
        path: [h],
        oldValue: r[c]
      });
      continue;
    }
    const d = e[c], p = typeof u == "object" && typeof d == "object" && Array.isArray(u) === Array.isArray(d);
    u && d && p && !HR[Object.getPrototypeOf(u)?.constructor?.name] && (!t.cyclesFix || !n.includes(u)) ? i.push.apply(i, Zx(u, d, t, t.cyclesFix ? n.concat([u]) : []).map((g) => (g.path.unshift(h), g))) : u !== d && // treat NaN values as equivalent
    !(Number.isNaN(u) && Number.isNaN(d)) && !(p && (isNaN(u) ? u + "" == d + "" : +u == +d)) && i.push({
      path: [h],
      type: "CHANGE",
      value: d,
      oldValue: u
    });
  }
  const a = Array.isArray(e);
  for (const c in e)
    c in r || i.push({
      type: "CREATE",
      path: [a ? +c : c],
      value: e[c]
    });
  return i;
}
var Mp = Symbol.for("immer-nothing"), ta = Symbol.for("immer-draftable"), Fr = Symbol.for("immer-state"), Jx = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(r) {
    return `The plugin for '${r}' has not been loaded into Immer. To enable the plugin, import and call \`enable${r}()\` when initializing your application.`;
  },
  function(r) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${r}'`;
  },
  "This object has been frozen and should not be mutated",
  function(r) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + r;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(r) {
    return `'current' expects a draft, got: ${r}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(r) {
    return `'original' expects a draft, got: ${r}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Ft(r, ...e) {
  if (process.env.NODE_ENV !== "production") {
    const t = Jx[r], n = typeof t == "function" ? t.apply(null, e) : t;
    throw new Error(`[Immer] ${n}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${r}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var os = Object.getPrototypeOf;
function as(r) {
  return !!r && !!r[Fr];
}
function Ci(r) {
  return r ? Qx(r) || Array.isArray(r) || !!r[ta] || !!r.constructor?.[ta] || Oa(r) || Ia(r) : !1;
}
var UR = Object.prototype.constructor.toString();
function Qx(r) {
  if (!r || typeof r != "object")
    return !1;
  const e = os(r);
  if (e === null)
    return !0;
  const t = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return t === Object ? !0 : typeof t == "function" && Function.toString.call(t) === UR;
}
function ha(r, e) {
  cs(r) === 0 ? Reflect.ownKeys(r).forEach((t) => {
    e(t, r[t], r);
  }) : r.forEach((t, n) => e(n, t, r));
}
function cs(r) {
  const e = r[Fr];
  return e ? e.type_ : Array.isArray(r) ? 1 : Oa(r) ? 2 : Ia(r) ? 3 : 0;
}
function da(r, e) {
  return cs(r) === 2 ? r.has(e) : Object.prototype.hasOwnProperty.call(r, e);
}
function cd(r, e) {
  return cs(r) === 2 ? r.get(e) : r[e];
}
function e_(r, e, t) {
  const n = cs(r);
  n === 2 ? r.set(e, t) : n === 3 ? r.add(t) : r[e] = t;
}
function $R(r, e) {
  return r === e ? r !== 0 || 1 / r === 1 / e : r !== r && e !== e;
}
function Oa(r) {
  return r instanceof Map;
}
function Ia(r) {
  return r instanceof Set;
}
function Ui(r) {
  return r.copy_ || r.base_;
}
function lf(r, e) {
  if (Oa(r))
    return new Map(r);
  if (Ia(r))
    return new Set(r);
  if (Array.isArray(r))
    return Array.prototype.slice.call(r);
  const t = Qx(r);
  if (e === !0 || e === "class_only" && !t) {
    const n = Object.getOwnPropertyDescriptors(r);
    delete n[Fr];
    let i = Reflect.ownKeys(n);
    for (let s = 0; s < i.length; s++) {
      const a = i[s], c = n[a];
      c.writable === !1 && (c.writable = !0, c.configurable = !0), (c.get || c.set) && (n[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: c.enumerable,
        value: r[a]
      });
    }
    return Object.create(os(r), n);
  } else {
    const n = os(r);
    if (n !== null && t)
      return { ...r };
    const i = Object.create(n);
    return Object.assign(i, r);
  }
}
function Pp(r, e = !1) {
  return wu(r) || as(r) || !Ci(r) || (cs(r) > 1 && (r.set = r.add = r.clear = r.delete = YR), Object.freeze(r), e && Object.entries(r).forEach(([t, n]) => Pp(n, !0))), r;
}
function YR() {
  Ft(2);
}
function wu(r) {
  return Object.isFrozen(r);
}
var uf = {};
function ls(r) {
  const e = uf[r];
  return e || Ft(0, r), e;
}
function XR(r, e) {
  uf[r] || (uf[r] = e);
}
var fa;
function t_() {
  return fa;
}
function GR(r, e) {
  return {
    drafts_: [],
    parent_: r,
    immer_: e,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function n1(r, e) {
  e && (ls("Patches"), r.patches_ = [], r.inversePatches_ = [], r.patchListener_ = e);
}
function hf(r) {
  df(r), r.drafts_.forEach(qR), r.drafts_ = null;
}
function df(r) {
  r === fa && (fa = r.parent_);
}
function i1(r) {
  return fa = GR(fa, r);
}
function qR(r) {
  const e = r[Fr];
  e.type_ === 0 || e.type_ === 1 ? e.revoke_() : e.revoked_ = !0;
}
function s1(r, e) {
  e.unfinalizedDrafts_ = e.drafts_.length;
  const t = e.drafts_[0];
  return r !== void 0 && r !== t ? (t[Fr].modified_ && (hf(e), Ft(4)), Ci(r) && (r = Ml(e, r), e.parent_ || Pl(e, r)), e.patches_ && ls("Patches").generateReplacementPatches_(
    t[Fr].base_,
    r,
    e.patches_,
    e.inversePatches_
  )) : r = Ml(e, t, []), hf(e), e.patches_ && e.patchListener_(e.patches_, e.inversePatches_), r !== Mp ? r : void 0;
}
function Ml(r, e, t) {
  if (wu(e))
    return e;
  const n = e[Fr];
  if (!n)
    return ha(
      e,
      (i, s) => o1(r, n, e, i, s, t)
    ), e;
  if (n.scope_ !== r)
    return e;
  if (!n.modified_)
    return Pl(r, n.base_, !0), n.base_;
  if (!n.finalized_) {
    n.finalized_ = !0, n.scope_.unfinalizedDrafts_--;
    const i = n.copy_;
    let s = i, a = !1;
    n.type_ === 3 && (s = new Set(i), i.clear(), a = !0), ha(
      s,
      (c, u) => o1(r, n, i, c, u, t, a)
    ), Pl(r, i, !1), t && r.patches_ && ls("Patches").generatePatches_(
      n,
      t,
      r.patches_,
      r.inversePatches_
    );
  }
  return n.copy_;
}
function o1(r, e, t, n, i, s, a) {
  if (process.env.NODE_ENV !== "production" && i === t && Ft(5), as(i)) {
    const c = s && e && e.type_ !== 3 && // Set objects are atomic since they have no keys.
    !da(e.assigned_, n) ? s.concat(n) : void 0, u = Ml(r, i, c);
    if (e_(t, n, u), as(u))
      r.canAutoFreeze_ = !1;
    else
      return;
  } else a && t.add(i);
  if (Ci(i) && !wu(i)) {
    if (!r.immer_.autoFreeze_ && r.unfinalizedDrafts_ < 1)
      return;
    Ml(r, i), (!e || !e.scope_.parent_) && typeof n != "symbol" && Object.prototype.propertyIsEnumerable.call(t, n) && Pl(r, i);
  }
}
function Pl(r, e, t = !1) {
  !r.parent_ && r.immer_.autoFreeze_ && r.canAutoFreeze_ && Pp(e, t);
}
function KR(r, e) {
  const t = Array.isArray(r), n = {
    type_: t ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: e ? e.scope_ : t_(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: e,
    // The base state.
    base_: r,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let i = n, s = Dp;
  t && (i = [n], s = pa);
  const { revoke: a, proxy: c } = Proxy.revocable(i, s);
  return n.draft_ = c, n.revoke_ = a, c;
}
var Dp = {
  get(r, e) {
    if (e === Fr)
      return r;
    const t = Ui(r);
    if (!da(t, e))
      return ZR(r, t, e);
    const n = t[e];
    return r.finalized_ || !Ci(n) ? n : n === ld(r.base_, e) ? (ud(r), r.copy_[e] = pf(n, r)) : n;
  },
  has(r, e) {
    return e in Ui(r);
  },
  ownKeys(r) {
    return Reflect.ownKeys(Ui(r));
  },
  set(r, e, t) {
    const n = r_(Ui(r), e);
    if (n?.set)
      return n.set.call(r.draft_, t), !0;
    if (!r.modified_) {
      const i = ld(Ui(r), e), s = i?.[Fr];
      if (s && s.base_ === t)
        return r.copy_[e] = t, r.assigned_[e] = !1, !0;
      if ($R(t, i) && (t !== void 0 || da(r.base_, e)))
        return !0;
      ud(r), ff(r);
    }
    return r.copy_[e] === t && // special case: handle new props with value 'undefined'
    (t !== void 0 || e in r.copy_) || // special case: NaN
    Number.isNaN(t) && Number.isNaN(r.copy_[e]) || (r.copy_[e] = t, r.assigned_[e] = !0), !0;
  },
  deleteProperty(r, e) {
    return ld(r.base_, e) !== void 0 || e in r.base_ ? (r.assigned_[e] = !1, ud(r), ff(r)) : delete r.assigned_[e], r.copy_ && delete r.copy_[e], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(r, e) {
    const t = Ui(r), n = Reflect.getOwnPropertyDescriptor(t, e);
    return n && {
      writable: !0,
      configurable: r.type_ !== 1 || e !== "length",
      enumerable: n.enumerable,
      value: t[e]
    };
  },
  defineProperty() {
    Ft(11);
  },
  getPrototypeOf(r) {
    return os(r.base_);
  },
  setPrototypeOf() {
    Ft(12);
  }
}, pa = {};
ha(Dp, (r, e) => {
  pa[r] = function() {
    return arguments[0] = arguments[0][0], e.apply(this, arguments);
  };
});
pa.deleteProperty = function(r, e) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(e)) && Ft(13), pa.set.call(this, r, e, void 0);
};
pa.set = function(r, e, t) {
  return process.env.NODE_ENV !== "production" && e !== "length" && isNaN(parseInt(e)) && Ft(14), Dp.set.call(this, r[0], e, t, r[0]);
};
function ld(r, e) {
  const t = r[Fr];
  return (t ? Ui(t) : r)[e];
}
function ZR(r, e, t) {
  const n = r_(e, t);
  return n ? "value" in n ? n.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    n.get?.call(r.draft_)
  ) : void 0;
}
function r_(r, e) {
  if (!(e in r))
    return;
  let t = os(r);
  for (; t; ) {
    const n = Object.getOwnPropertyDescriptor(t, e);
    if (n)
      return n;
    t = os(t);
  }
}
function ff(r) {
  r.modified_ || (r.modified_ = !0, r.parent_ && ff(r.parent_));
}
function ud(r) {
  r.copy_ || (r.copy_ = lf(
    r.base_,
    r.scope_.immer_.useStrictShallowCopy_
  ));
}
var JR = class {
  constructor(r) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (e, t, n) => {
      if (typeof e == "function" && typeof t != "function") {
        const s = t;
        t = e;
        const a = this;
        return function(u = s, ...h) {
          return a.produce(u, (d) => t.call(this, d, ...h));
        };
      }
      typeof t != "function" && Ft(6), n !== void 0 && typeof n != "function" && Ft(7);
      let i;
      if (Ci(e)) {
        const s = i1(this), a = pf(e, void 0);
        let c = !0;
        try {
          i = t(a), c = !1;
        } finally {
          c ? hf(s) : df(s);
        }
        return n1(s, n), s1(i, s);
      } else if (!e || typeof e != "object") {
        if (i = t(e), i === void 0 && (i = e), i === Mp && (i = void 0), this.autoFreeze_ && Pp(i, !0), n) {
          const s = [], a = [];
          ls("Patches").generateReplacementPatches_(e, i, s, a), n(s, a);
        }
        return i;
      } else
        Ft(1, e);
    }, this.produceWithPatches = (e, t) => {
      if (typeof e == "function")
        return (a, ...c) => this.produceWithPatches(a, (u) => e(u, ...c));
      let n, i;
      return [this.produce(e, t, (a, c) => {
        n = a, i = c;
      }), n, i];
    }, typeof r?.autoFreeze == "boolean" && this.setAutoFreeze(r.autoFreeze), typeof r?.useStrictShallowCopy == "boolean" && this.setUseStrictShallowCopy(r.useStrictShallowCopy);
  }
  createDraft(r) {
    Ci(r) || Ft(8), as(r) && (r = QR(r));
    const e = i1(this), t = pf(r, void 0);
    return t[Fr].isManual_ = !0, df(e), t;
  }
  finishDraft(r, e) {
    const t = r && r[Fr];
    (!t || !t.isManual_) && Ft(9);
    const { scope_: n } = t;
    return n1(n, e), s1(void 0, n);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(r) {
    this.autoFreeze_ = r;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(r) {
    this.useStrictShallowCopy_ = r;
  }
  applyPatches(r, e) {
    let t;
    for (t = e.length - 1; t >= 0; t--) {
      const i = e[t];
      if (i.path.length === 0 && i.op === "replace") {
        r = i.value;
        break;
      }
    }
    t > -1 && (e = e.slice(t + 1));
    const n = ls("Patches").applyPatches_;
    return as(r) ? n(r, e) : this.produce(
      r,
      (i) => n(i, e)
    );
  }
};
function pf(r, e) {
  const t = Oa(r) ? ls("MapSet").proxyMap_(r, e) : Ia(r) ? ls("MapSet").proxySet_(r, e) : KR(r, e);
  return (e ? e.scope_ : t_()).drafts_.push(t), t;
}
function QR(r) {
  return as(r) || Ft(10, r), n_(r);
}
function n_(r) {
  if (!Ci(r) || wu(r))
    return r;
  const e = r[Fr];
  let t;
  if (e) {
    if (!e.modified_)
      return e.base_;
    e.finalized_ = !0, t = lf(r, e.scope_.immer_.useStrictShallowCopy_);
  } else
    t = lf(r, !0);
  return ha(t, (n, i) => {
    e_(t, n, n_(i));
  }), e && (e.finalized_ = !1), t;
}
function a1() {
  process.env.NODE_ENV !== "production" && Jx.push(
    'Sets cannot have "replace" patches.',
    function(g) {
      return "Unsupported patch operation: " + g;
    },
    function(g) {
      return "Cannot apply patch, path doesn't resolve: " + g;
    },
    "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
  );
  const e = "replace", t = "add", n = "remove";
  function i(g, v, b, x) {
    switch (g.type_) {
      case 0:
      case 2:
        return a(
          g,
          v,
          b,
          x
        );
      case 1:
        return s(g, v, b, x);
      case 3:
        return c(
          g,
          v,
          b,
          x
        );
    }
  }
  function s(g, v, b, x) {
    let { base_: _, assigned_: C } = g, E = g.copy_;
    E.length < _.length && ([_, E] = [E, _], [b, x] = [x, b]);
    for (let k = 0; k < _.length; k++)
      if (C[k] && E[k] !== _[k]) {
        const O = v.concat([k]);
        b.push({
          op: e,
          path: O,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: p(E[k])
        }), x.push({
          op: e,
          path: O,
          value: p(_[k])
        });
      }
    for (let k = _.length; k < E.length; k++) {
      const O = v.concat([k]);
      b.push({
        op: t,
        path: O,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: p(E[k])
      });
    }
    for (let k = E.length - 1; _.length <= k; --k) {
      const O = v.concat([k]);
      x.push({
        op: n,
        path: O
      });
    }
  }
  function a(g, v, b, x) {
    const { base_: _, copy_: C } = g;
    ha(g.assigned_, (E, k) => {
      const O = cd(_, E), P = cd(C, E), R = k ? da(_, E) ? e : t : n;
      if (O === P && R === e)
        return;
      const V = v.concat(E);
      b.push(R === n ? { op: R, path: V } : { op: R, path: V, value: P }), x.push(
        R === t ? { op: n, path: V } : R === n ? { op: t, path: V, value: p(O) } : { op: e, path: V, value: p(O) }
      );
    });
  }
  function c(g, v, b, x) {
    let { base_: _, copy_: C } = g, E = 0;
    _.forEach((k) => {
      if (!C.has(k)) {
        const O = v.concat([E]);
        b.push({
          op: n,
          path: O,
          value: k
        }), x.unshift({
          op: t,
          path: O,
          value: k
        });
      }
      E++;
    }), E = 0, C.forEach((k) => {
      if (!_.has(k)) {
        const O = v.concat([E]);
        b.push({
          op: t,
          path: O,
          value: k
        }), x.unshift({
          op: n,
          path: O,
          value: k
        });
      }
      E++;
    });
  }
  function u(g, v, b, x) {
    b.push({
      op: e,
      path: [],
      value: v === Mp ? void 0 : v
    }), x.push({
      op: e,
      path: [],
      value: g
    });
  }
  function h(g, v) {
    return v.forEach((b) => {
      const { path: x, op: _ } = b;
      let C = g;
      for (let P = 0; P < x.length - 1; P++) {
        const R = cs(C);
        let V = x[P];
        typeof V != "string" && typeof V != "number" && (V = "" + V), (R === 0 || R === 1) && (V === "__proto__" || V === "constructor") && Ft(19), typeof C == "function" && V === "prototype" && Ft(19), C = cd(C, V), typeof C != "object" && Ft(18, x.join("/"));
      }
      const E = cs(C), k = d(b.value), O = x[x.length - 1];
      switch (_) {
        case e:
          switch (E) {
            case 2:
              return C.set(O, k);
            case 3:
              Ft(16);
            default:
              return C[O] = k;
          }
        case t:
          switch (E) {
            case 1:
              return O === "-" ? C.push(k) : C.splice(O, 0, k);
            case 2:
              return C.set(O, k);
            case 3:
              return C.add(k);
            default:
              return C[O] = k;
          }
        case n:
          switch (E) {
            case 1:
              return C.splice(O, 1);
            case 2:
              return C.delete(O);
            case 3:
              return C.delete(b.value);
            default:
              return delete C[O];
          }
        default:
          Ft(17, _);
      }
    }), g;
  }
  function d(g) {
    if (!Ci(g))
      return g;
    if (Array.isArray(g))
      return g.map(d);
    if (Oa(g))
      return new Map(
        Array.from(g.entries()).map(([b, x]) => [b, d(x)])
      );
    if (Ia(g))
      return new Set(Array.from(g).map(d));
    const v = Object.create(os(g));
    for (const b in g)
      v[b] = d(g[b]);
    return da(g, ta) && (v[ta] = g[ta]), v;
  }
  function p(g) {
    return as(g) ? d(g) : g;
  }
  XR("Patches", {
    applyPatches_: h,
    generatePatches_: i,
    generateReplacementPatches_: u
  });
}
var Lr = new JR(), e9 = Lr.produce;
Lr.produceWithPatches.bind(
  Lr
);
Lr.setAutoFreeze.bind(Lr);
Lr.setUseStrictShallowCopy.bind(Lr);
var t9 = Lr.applyPatches.bind(Lr);
Lr.createDraft.bind(Lr);
Lr.finishDraft.bind(Lr);
function r9(r) {
  const e = r.value, t = [];
  if (e?.payload?.trackItemIds) {
    const n = e.payload.trackItemIds;
    t.push(n), this.updateState({ activeIds: t });
  }
  if (r.key === my) {
    const n = r.value?.payload.trackItemIds, i = Xe.cloneDeep(this.getState()), s = n?.length ? n : i.activeIds, a = i.trackItemIds.filter(
      (p) => !s.includes(p)
    ), c = Object.fromEntries(
      Object.entries(i.trackItemDetailsMap).filter(
        ([p]) => !s.includes(p)
      )
    ), u = j8(i.tracks, s), h = Object.fromEntries(
      Object.entries(i.trackItemsMap).filter(
        ([p]) => !s.includes(p)
      )
    ), d = On(h);
    this.updateState(
      {
        trackItemIds: a,
        trackItemDetailsMap: c,
        activeIds: [],
        trackItemsMap: h,
        tracks: u,
        duration: d
      },
      { updateHistory: !0, kind: "remove" }
    );
  }
  if (r.key === vy) {
    const n = Xe.cloneDeep(this.getState()), i = [], s = r.value?.payload.trackItemIds || n.activeIds;
    if (s.length === 0) return;
    s.forEach((c) => {
      const u = n.trackItemsMap[c], h = n.trackItemDetailsMap[c], d = Lt();
      i.push(d), n.trackItemsMap = {
        ...n.trackItemsMap,
        [d]: { ...Xe.cloneDeep(u), id: d }
      }, n.trackItemDetailsMap = {
        ...n.trackItemDetailsMap,
        [d]: { ...Xe.cloneDeep(h) }
      }, n.trackItemIds.push(d);
    });
    const a = n.tracks.map((c) => {
      const u = {
        ...c,
        id: Lt(),
        items: c.items.filter((h) => s.includes(h)).map((h) => {
          const d = s.indexOf(h);
          return i[d];
        })
      };
      return u.items.length ? u : null;
    }).filter(Boolean);
    n.tracks.unshift(...a), this.updateState(
      {
        trackItemDetailsMap: n.trackItemDetailsMap,
        tracks: n.tracks,
        trackItemIds: n.trackItemIds,
        trackItemsMap: n.trackItemsMap
      },
      {
        updateHistory: !0,
        kind: "update"
      }
    );
  }
  if (r.key === yy) {
    const n = Xe.cloneDeep(this.getState()), i = r.value?.options.time;
    if (n.activeIds.length !== 1) return;
    const s = n.activeIds[0], a = n.trackItemsMap[s];
    if (i <= a.display.from || i >= a.display.to)
      return;
    const c = Lt(), u = {
      ...a,
      id: c,
      display: { from: i, to: a.display.to },
      trim: { from: i, to: a.display.to }
    };
    n.trackItemsMap[s].display.to = i, n.trackItemsMap[c] = u, n.trackItemDetailsMap[c] = n.trackItemDetailsMap[s], n.trackItemIds.push(c), n.tracks.forEach((h) => {
      h.items.includes(s) && h.items.push(c);
    }), this.updateState(
      {
        trackItemsMap: n.trackItemsMap,
        trackItemDetailsMap: n.trackItemDetailsMap,
        trackItemIds: n.trackItemIds,
        tracks: n.tracks
      },
      { updateHistory: !0, kind: "update" }
    );
  }
}
async function n9(r) {
  if (r.key === "scene:load") {
    const e = r.value?.payload, t = e.size, n = e.trackItemIds, i = e.trackItemsMap, s = e.trackItemDetailsMap;
    if (!n) return;
    const a = n?.map(async (u) => {
      try {
        const h = s[u], d = i[u];
        if (h.type === "text") {
          const p = await _x(
            { id: u, details: h.details, ...d },
            {
              size: t
            }
          ), { details: g, ...v } = p;
          s[u] = { type: "text", details: g }, i[u] = v;
        }
        return !0;
      } catch {
        return !1;
      }
    });
    await Promise.all(a);
    const c = On(i);
    this.updateState({
      ...e,
      trackItemsMap: i,
      duration: c
    });
  }
}
async function i9(r) {
  const e = Xe.cloneDeep(this.getState()), t = r.value?.options?.trackId, n = r.value?.options?.trackIndex;
  let i = [], s;
  if (r.key === ma) {
    s = "video";
    const c = await F8(r.value?.payload, {
      size: e.size
    }), { details: u, ...h } = c;
    e.trackItemDetailsMap[h.id] = {
      type: s,
      details: u
    }, e.trackItemsMap[h.id] = h, e.trackItemIds.push(h.id), i = [h.id];
  }
  if (r.key === ya) {
    s = "image";
    const c = await R8(r.value?.payload, {
      size: e.size
    }), { details: u, ...h } = c;
    e.trackItemDetailsMap[h.id] = {
      type: s,
      details: u
    }, e.trackItemsMap[h.id] = h, e.trackItemIds.push(h.id), i = [h.id];
  }
  if (r.key === va) {
    s = "audio";
    const c = await L8(r.value?.payload), { details: u, ...h } = c;
    e.trackItemDetailsMap[h.id] = {
      type: s,
      details: u
    }, e.trackItemsMap[h.id] = h, e.trackItemIds.push(h.id), i = [h.id];
  }
  if (r.key === fy) {
    s = "text";
    const { details: c, ...u } = await _x(
      r.value?.payload ?? void 0,
      {
        size: e.size
      }
    );
    e.trackItemDetailsMap[u.id] = { type: s, details: c }, e.trackItemsMap[u.id] = u, e.trackItemIds.push(u.id), i.push(u.id);
  }
  const a = s9(
    i,
    e.tracks,
    e.trackItemsMap,
    t,
    n
  );
  if (a.trackId)
    e.tracks.find((u) => u.id === a.trackId)?.items.push(...i);
  else if (a.trackIndex !== void 0) {
    const c = c1(s, i);
    e.tracks.splice(a.trackIndex, 0, c);
  } else {
    const c = c1(s, i);
    e.tracks.unshift(c);
  }
  e.duration = On(e.trackItemsMap), this.updateState(
    {
      trackItemIds: e.trackItemIds,
      trackItemDetailsMap: e.trackItemDetailsMap,
      trackItemsMap: e.trackItemsMap,
      tracks: e.tracks,
      duration: e.duration,
      structure: e.structure
    },
    {
      updateHistory: !0,
      kind: "add"
    }
  );
}
function c1(r, e) {
  return {
    id: Lt(),
    accepts: ["text", "audio", "helper", "video", "image"],
    type: r,
    items: e,
    magnetic: !1,
    static: !1
  };
}
const s9 = (r, e, t, n, i) => {
  if (n === void 0 && i === void 0)
    return { trackId: void 0, trackIndex: void 0 };
  const s = i !== void 0 ? e[Math.max(0, Math.min(i, e.length - 1))] : e.find((u) => u.id === n);
  if (!s)
    return {
      trackId: void 0,
      trackIndex: i !== void 0 ? Math.max(0, Math.min(i, e.length - 1)) : void 0
    };
  const a = s.items.map((u) => t[u]), c = r.map((u) => t[u]);
  for (const u of a) {
    const h = u.display.from, d = u.display.to;
    for (const p of c) {
      const g = p.display.from;
      if (!(p.display.to <= h || g >= d))
        return {
          trackId: void 0,
          trackIndex: e.indexOf(s)
        };
    }
  }
  return {
    trackId: s.id,
    trackIndex: e.indexOf(s)
  };
}, l1 = [
  "tracks",
  "trackItemsMap",
  "trackItemDetailsMap",
  "transitionIds",
  "transitionsMap",
  "trackItemIds"
], o9 = {
  size: {
    width: 1080,
    height: 1920
  },
  tracks: [],
  trackItemIds: [],
  trackItemsMap: {},
  transitionIds: [],
  transitionsMap: {},
  scale: {
    unit: 1,
    zoom: 1,
    segments: 1,
    index: 1
  },
  duration: 0,
  activeIds: [],
  trackItemDetailsMap: {},
  structure: []
};
class a9 {
  stateSubject;
  stateHistorySubject;
  prevState;
  undos;
  redos;
  listener;
  constructor(e) {
    this.stateSubject = null, this.stateHistorySubject = null, this.prevState = null, this.undos = [], this.redos = [], this.listener = null;
    const t = e || o9;
    this.stateSubject = new Tv(t), this.stateHistorySubject = new Tv({
      handleRedo: !1,
      handleUndo: !1
    }), this.prevState = t, this.initListeners();
  }
  initListeners() {
    c9(this);
  }
  destroyListeners() {
    this.listener && this.listener.unsubscribe();
  }
  purge() {
    this.destroyListeners();
  }
  updateHistory(e, t) {
    const n = Xe.pick(e, l1), i = Xe.pick(this.getState(), l1), s = Zx(i, n);
    s.length && (this.undos.push({ undos: s, type: t }), this.redos = []);
  }
  getStateHistory() {
    return this.stateHistorySubject.getValue();
  }
  subscribeHistory(e) {
    return this.stateHistorySubject.subscribe(e);
  }
  getState() {
    return this.stateSubject.getValue();
  }
  subscribe(e) {
    return this.stateSubject.subscribe(e);
  }
  updateState(e, t = { updateHistory: !1, kind: void 0 }) {
    const n = this.getState(), i = { ...n, ...e };
    if (!Xe.isEqual(n, i)) {
      t.updateHistory && this.updateHistory(i, t.kind);
      const { duration: s, trackItemsMap: a, ...c } = n;
      this.prevState = {
        ...c,
        duration: this.prevState.duration,
        trackItemsMap: this.prevState.trackItemsMap
      }, this.stateSubject.next(i);
    }
  }
  subscribeToSize(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      Xe.isEqual(t.size, this.prevState.size) || e({ size: t.size });
    });
  }
  subscribeToScale(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      Xe.isEqual(t.scale, this.prevState.scale) || e({ scale: t.scale });
    });
  }
  subscribeToUpdateTrackItem(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      Xe.isEqual(t.trackItemsMap, this.prevState.trackItemsMap) || e({ trackItemsMap: t.trackItemsMap });
    });
  }
  subscribeToUpdateItemDetails(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      Xe.isEqual(
        t.trackItemDetailsMap,
        this.prevState.trackItemDetailsMap
      ) || e({ trackItemDetailsMap: t.trackItemDetailsMap });
    });
  }
  subscribeToDuration(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      t.duration !== this.prevState.duration && e({ duration: t.duration });
    });
  }
  subscribeToHistory(e) {
    return this.stateHistorySubject.asObservable().subscribe((t) => {
      if (t.handleRedo) {
        const n = this.undos[this.undos.length - 1]?.type;
        n === "update" && e({ ...this.getState(), type: n }), this.stateHistorySubject.next({
          handleRedo: !1,
          handleUndo: !1
        });
      }
      if (t.handleUndo) {
        const n = this.redos[this.redos.length - 1]?.type;
        n === "update" && e({ ...this.getState(), type: n }), this.stateHistorySubject.next({
          handleRedo: !1,
          handleUndo: !1
        });
      }
    });
  }
  subscribeToAddOrRemoveItems(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      (!t.trackItemIds?.every(
        (n) => this.prevState.trackItemIds?.includes(n)
      ) || !Xe.isEqual(t.tracks, this.prevState.tracks)) && e({ trackItemIds: t.trackItemIds });
    });
  }
  subscribeToActiveIds(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      Xe.isEqual(t.activeIds, this.prevState.activeIds) || e({ activeIds: t.activeIds });
    });
  }
  subscribeToTracks(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      (!Xe.isEqual(t.tracks, this.prevState.tracks) || !Xe.isEqual(t.trackItemIds, this.prevState.trackItemIds) || !Xe.isEqual(t.trackItemsMap, this.prevState.trackItemsMap) || !Xe.isEqual(t.transitionIds, this.prevState.transitionIds) || !Xe.isEqual(t.transitionsMap, this.prevState.transitionsMap) || !Xe.isEqual(
        t.trackItemDetailsMap,
        this.prevState.trackItemDetailsMap
      )) && e({
        tracks: t.tracks,
        trackItemIds: t.trackItemIds,
        trackItemsMap: t.trackItemsMap,
        transitionIds: t.transitionIds,
        transitionsMap: t.transitionsMap,
        trackItemDetailsMap: t.trackItemDetailsMap
        // structure: currentState.structure,
      });
    });
  }
  undo() {
    const e = this.undos.pop(), t = e?.undos, n = e?.type;
    if (!t || !n) return;
    a1();
    const {
      trackItemDetailsMap: i,
      trackItemIds: s,
      tracks: a,
      transitionIds: c,
      transitionsMap: u,
      trackItemsMap: h
    } = this.getState(), d = Xe.cloneDeep({
      trackItemDetailsMap: i,
      trackItemIds: s,
      tracks: a,
      transitionIds: c,
      transitionsMap: u,
      trackItemsMap: h
    }), p = [], g = [], v = [], b = [], x = [], _ = [];
    t.forEach((H) => {
      let Y;
      const te = H.path.slice(1);
      H.type === "CREATE" ? Y = {
        path: te,
        op: "remove",
        value: H.value
      } : H.type === "CHANGE" ? Y = {
        path: te,
        op: "replace",
        value: H.oldValue
      } : Y = {
        path: te,
        op: "add",
        value: H.oldValue
      }, H.path.includes("trackItemIds") ? v.push(Y) : H.path.includes("transitionIds") ? g.push(Y) : H.path.includes("trackItemsMap") ? x.push(Y) : H.path.includes("transitionsMap") ? b.push(Y) : H.path.includes("tracks") ? p.push(Y) : H.path.includes("trackItemDetailsMap") && _.push(Y);
    });
    const C = this.applyPatch(d.tracks, p), E = this.applyPatch(
      d.transitionIds,
      g
    ), k = this.applyPatch(
      d.trackItemIds,
      v
    ), O = this.applyPatch(
      d.transitionsMap,
      b
    ), P = this.applyPatch(
      d.trackItemsMap,
      x
    ), R = this.applyPatch(
      d.trackItemDetailsMap,
      _
    ), V = Xe.cloneDeep({
      tracks: C,
      transitionIds: E,
      trackItemIds: k,
      transitionsMap: O,
      trackItemsMap: P,
      trackItemDetailsMap: R
    }), F = Xe.cloneDeep(this.getState()), $ = { ...F, ...V };
    this.prevState = F;
    const z = { redos: t, type: n };
    this.redos.push(z);
    const G = On($.trackItemsMap);
    this.stateSubject.next({ ...$, duration: G }), this.stateHistorySubject.next({ handleRedo: !1, handleUndo: !0 });
  }
  redo() {
    const e = this.redos.pop();
    if (!e?.redos || !e?.type) return;
    a1();
    const t = this.getState(), {
      trackItemDetailsMap: n,
      trackItemIds: i,
      tracks: s,
      transitionIds: a,
      transitionsMap: c,
      trackItemsMap: u
    } = t, h = Xe.cloneDeep({
      trackItemDetailsMap: n,
      trackItemIds: i,
      tracks: s,
      transitionIds: a,
      transitionsMap: c,
      trackItemsMap: u
    }), d = [], p = [], g = [], v = [], b = [], x = [];
    e.redos.forEach((O) => {
      const P = O.path.slice(1);
      let R = {};
      switch (O.type) {
        case "CREATE":
          R = {
            path: P,
            op: "add",
            value: O.value
          };
          break;
        case "CHANGE":
          R = {
            path: P,
            op: "replace",
            value: O.value
          };
          break;
        case "REMOVE":
          R = {
            path: P,
            op: "remove",
            value: O.oldValue
          };
          break;
        default:
          return null;
      }
      O.path.includes("trackItemIds") ? g.push(R) : O.path.includes("transitionIds") ? p.push(R) : O.path.includes("trackItemsMap") ? b.push(R) : O.path.includes("transitionsMap") ? v.push(R) : O.path.includes("trackItemDetailsMap") ? x.push(R) : d.push(R);
    });
    const _ = {
      tracks: this.applyPatch(h.tracks, d),
      transitionIds: this.applyPatch(h.transitionIds, p),
      trackItemIds: this.applyPatch(h.trackItemIds, g),
      transitionsMap: this.applyPatch(h.transitionsMap, v),
      trackItemsMap: this.applyPatch(h.trackItemsMap, b),
      trackItemDetailsMap: this.applyPatch(h.trackItemDetailsMap, x)
    }, C = Xe.cloneDeep(_), E = { ...Xe.cloneDeep(t), ...C };
    this.prevState = t, this.undos.push({ undos: e.redos, type: e.type });
    const k = On(E.trackItemsMap);
    this.stateSubject.next({ ...E, duration: k }), this.stateHistorySubject.next({ handleRedo: !0, handleUndo: !1 });
  }
  applyPatch(e, t) {
    return t.reverse().reduce(
      (n, i) => e9(n, (s) => {
        t9(s, [i]);
      }),
      e
    );
  }
}
function c9(r) {
  const e = Ne.subject.pipe($n(({ key: s }) => s.startsWith(kI))).subscribe((s) => {
    s.key === wy && r.undo(), s.key === xy && r.redo();
  }), t = Ne.subject.pipe($n(({ key: s, value: a }) => s.startsWith(wI))).subscribe((s) => {
    i9.bind(r)(s);
  }), n = Ne.subject.pipe(
    $n(({ key: s, value: a }) => s.startsWith("scene"))
  ).subscribe(async (s) => {
    await n9.bind(r)(s);
  }), i = Ne.subject.pipe($n(({ key: s }) => s.startsWith(TI))).subscribe(async (s) => {
    r9.bind(r)(s);
  });
  return () => {
    e.unsubscribe(), t.unsubscribe(), i.unsubscribe(), n.unsubscribe();
  };
}
const l9 = () => {
  const { playerRef: r, fps: e, timeline: t, setState: n } = Zn();
  ce(() => {
    const s = Ne.subject.pipe(
      $n(({ key: a }) => a.startsWith(xI))
    ).subscribe((a) => {
      if (a.key === _I) {
        const { time: c } = a.value?.payload;
        r?.current?.seekTo(c / 1e3 * e);
      } else if (a.key === py)
        r?.current?.play();
      else if (a.key === gy)
        r?.current?.pause();
      else if (a.key === CI)
        r?.current?.isPlaying() ? r.current.pause() : r?.current?.play();
      else if (a.key === SI) {
        const { frames: c } = a.value?.payload;
        r?.current?.seekTo(
          Math.round(r.current.getCurrentFrame()) + c
        );
      }
    });
    return () => {
      s.unsubscribe();
    };
  }, [r, e]), ce(() => {
    const s = Ne.subject.pipe(
      $n(({ key: a }) => a.startsWith(EI))
    ).subscribe((a) => {
      a.key === by && n({
        activeIds: a.value?.payload.activeIds
      });
    });
    return () => {
      s.unsubscribe();
    };
  }, [t]);
}, u9 = new a9(), mL = () => {
  const { playerRef: r } = Zn();
  l9();
  const [e, t] = ue([]);
  return /* @__PURE__ */ y.jsxs("div", { className: "relative flex h-screen w-screen flex-col bg-background ", children: [
    /* @__PURE__ */ y.jsx(t4, {}),
    /* @__PURE__ */ y.jsxs(
      "div",
      {
        style: {
          width: "100%",
          height: "100%",
          position: "relative",
          flex: 1,
          overflow: "hidden"
        },
        children: [
          /* @__PURE__ */ y.jsx(e4, {}),
          /* @__PURE__ */ y.jsx(Q3, {}),
          /* @__PURE__ */ y.jsx($P, {})
        ]
      }
    ),
    /* @__PURE__ */ y.jsx("div", { className: "h-70 w-full ", children: r && /* @__PURE__ */ y.jsx(WR, { stateManager: u9 }) })
  ] });
};
export {
  vy as ACTIVE_CLONE,
  my as ACTIVE_DELETE,
  R9 as ACTIVE_PASTE,
  TI as ACTIVE_PREFIX,
  j9 as ACTIVE_SET,
  yy as ACTIVE_SPLIT,
  k9 as ADD_ANIMATION,
  va as ADD_AUDIO,
  ya as ADD_IMAGE,
  T9 as ADD_MASK,
  C9 as ADD_PLACEHOLDER,
  wI as ADD_PREFIX,
  v9 as ADD_SUFFIX,
  fy as ADD_TEXT,
  E9 as ADD_TRANSITION,
  ma as ADD_VIDEO,
  L3 as AUDIOS,
  mL as AppComponent,
  $8 as Audio,
  mi as AudioObject,
  sF as BASE_TIMELINE_ELEMENT_DURATION_MS,
  mt as Button,
  n8 as CanvasMixin,
  lF as DEFAULT_AUDIO_BITRATE,
  cF as DEFAULT_AUDIO_SAMPLE_RATE,
  KF as DEFAULT_BLUR,
  qF as DEFAULT_BLUR_STEP,
  AF as DEFAULT_BRIGHTNESS,
  IF as DEFAULT_BRIGHTNESS_STEP,
  WF as DEFAULT_CONTRAST,
  zF as DEFAULT_CONTRAST_STEP,
  bF as DEFAULT_FADE_IN,
  wF as DEFAULT_FADE_OUT,
  yF as DEFAULT_FADE_STEP,
  TF as DEFAULT_FLIP_X,
  EF as DEFAULT_FLIP_Y,
  Ov as DEFAULT_FONT,
  i3 as DEFAULT_FRAMERATE,
  GF as DEFAULT_MAX_BLUR,
  OF as DEFAULT_MAX_BRIGHTNESS,
  VF as DEFAULT_MAX_CONTRAST,
  vF as DEFAULT_MAX_FADE,
  UF as DEFAULT_MAX_OPACITY,
  _F as DEFAULT_MAX_ROTATION,
  PF as DEFAULT_MAX_SATURATION,
  JF as DEFAULT_MAX_SPEED,
  FF as DEFAULT_MAX_TEMPERATURE,
  rL as DEFAULT_MAX_VOLUME,
  fF as DEFAULT_MEDIA_PANEL_WIDTH,
  XF as DEFAULT_MIN_BLUR,
  kF as DEFAULT_MIN_BRIGHTNESS,
  BF as DEFAULT_MIN_CONTRAST,
  mF as DEFAULT_MIN_FADE,
  HF as DEFAULT_MIN_OPACITY,
  xF as DEFAULT_MIN_ROTATION,
  MF as DEFAULT_MIN_SATURATION,
  ZF as DEFAULT_MIN_SPEED,
  RF as DEFAULT_MIN_TEMPERATURE,
  tL as DEFAULT_MIN_VOLUME,
  YF as DEFAULT_OPACITY,
  $F as DEFAULT_OPACITY_STEP,
  hF as DEFAULT_PREVIEW_HEIGHT,
  Ay as DEFAULT_PREVIEW_SCALE,
  uF as DEFAULT_PREVIEW_WIDTH,
  CF as DEFAULT_ROTATION,
  SF as DEFAULT_ROTATION_STEP,
  jF as DEFAULT_SATURATION,
  DF as DEFAULT_SATURATION_STEP,
  gF as DEFAULT_SETTINGS_PANEL_WIDTH,
  eL as DEFAULT_SPEED,
  QF as DEFAULT_SPEED_STEP,
  NF as DEFAULT_TEMPERATURE,
  LF as DEFAULT_TEMPERATURE_STEP,
  n3 as DEFAULT_VIDEO_HEIGHT,
  aF as DEFAULT_VIDEO_MAX_BITRATE,
  oF as DEFAULT_VIDEO_MIN_BITRATE,
  r3 as DEFAULT_VIDEO_WIDTH,
  iL as DEFAULT_VOLUME,
  nL as DEFAULT_VOLUME_STEP,
  iF as DEFAULT_WEIGHT,
  ol as DRAG_END,
  II as DRAG_PREFIX,
  Sy as DRAG_START,
  Nl as Draggable,
  QI as DroppableArea,
  I9 as EDIT_OBJECT,
  O9 as EDIT_PREFIX,
  M9 as EDIT_SHAPE,
  A9 as EDIT_TEXT,
  P9 as ENTER_EDIT_MODE,
  s3 as FRAME_INTERVAL,
  Z9 as GIANT_ICON_SIZE,
  kI as HISTORY_PREFIX,
  xy as HISTORY_REDO,
  q9 as HISTORY_RESET,
  wy as HISTORY_UNDO,
  R3 as Header,
  q8 as Helper,
  Ea as HelperObject,
  N3 as IMAGES,
  X8 as Image,
  xp as ImageObject,
  tF as LARGER_FONT_SIZE,
  rF as LARGE_FONT_SIZE,
  J9 as LARGE_ICON_SIZE,
  $9 as LAYER_CLONE,
  H9 as LAYER_COPY,
  X9 as LAYER_CUT,
  G9 as LAYER_DELETE,
  W9 as LAYER_EDITING_NAME,
  L9 as LAYER_HIDDEN,
  F9 as LAYER_LOCKED,
  N9 as LAYER_MOVE,
  U9 as LAYER_PASTE,
  EI as LAYER_PREFIX,
  z9 as LAYER_RENAME,
  B9 as LAYER_SELECT,
  by as LAYER_SELECTION,
  V9 as LAYER_SEND_TO,
  Y9 as LAYER_SPLIT,
  pF as MAX_MEDIA_PANEL_WIDTH,
  dF as MIN_MEDIA_PANEL_WIDTH,
  Q3 as MenuItem,
  nF as NORMAL_FONT_SIZE,
  Q9 as NORMAL_ICON_SIZE,
  t4 as NavbarComponent,
  gy as PLAYER_PAUSE,
  py as PLAYER_PLAY,
  xI as PLAYER_PREFIX,
  _I as PLAYER_SEEK,
  SI as PLAYER_SEEK_BY,
  D9 as PLAYER_SEEK_TO,
  CI as PLAYER_TOGGLE_PLAY,
  zl as PREVIEW_FRAME_WIDTH,
  la as Placeholder,
  WP as Player,
  HP as PlayheadComponent,
  Ol as PreviewTrackItem,
  UP as RulerComponent,
  t3 as SECONDARY_FONT,
  e3 as SMALL_FONT_SIZE,
  eF as SMALL_ICON_SIZE,
  S9 as STATE_CHANGED,
  _9 as STATE_PREFIX,
  $P as Scene,
  K9 as SceneBoard,
  eo as ScrollArea,
  $1 as ScrollBar,
  mP as SequenceItem,
  VO as Slider,
  a9 as StateManager,
  Cy as TIMELINE_BOUNDING_CHANGED,
  kf as TIMELINE_OFFSET_CANVAS_LEFT,
  kv as TIMELINE_OFFSET_CANVAS_RIGHT,
  Id as TIMELINE_OFFSET_X,
  AI as TIMELINE_PREFIX,
  _y as TIMELINE_SCALE_CHANGED,
  OI as TIMELINE_SCALE_PREFIX,
  En as TIMELINE_ZOOM_LEVELS,
  w9 as TRACKS_CHANGED,
  x9 as TRACK_ITEMS_CHANGED,
  b9 as TRACK_ITEMS_PREFIX,
  y9 as TRACK_PREFIX,
  V3 as TRANSITIONS,
  bI as Tabs,
  _d as TabsContent,
  dy as TabsList,
  xd as TabsTrigger,
  Sx as Text,
  Ks as TextObject,
  Ap as Timeline,
  WR as TimelineComponent,
  G8 as Track,
  K8 as TrackItemsMixin,
  is as TrackObject,
  J8 as TracksMixin,
  fn as Transition,
  kl as TransitionGuide,
  tj as TransitionsMixin,
  uL as UPLOADS,
  B3 as VIDEOS,
  Y8 as Video,
  go as VideoObject,
  LR as addEventListeners,
  O8 as applyMixins,
  gO as buttonVariants,
  D8 as calculateDisplayRange,
  On as calculateDuration,
  _p as calculatePosition,
  g3 as calculateTimelineWidth,
  P8 as calculateTrim,
  ir as cn,
  _8 as createAudioControls,
  k8 as createControls,
  y8 as createMediaControls,
  wx as createResizeControls,
  gu as defaultColor,
  H8 as defaultSizes,
  j8 as filterAndCleanTracks,
  My as findIndex,
  f9 as formatBytes,
  sL as formatTimeToHumanReadable,
  o3 as formatTimelineUnit,
  a3 as frameToTimeString,
  l3 as getCurrentTime,
  oL as getFitZoomLevel,
  fL as getMovingState,
  d3 as getNextZoom,
  p3 as getNextZoomIndex,
  f3 as getNextZoomLevel,
  Be as getOffset,
  h3 as getPreviousZoom,
  cL as getPreviousZoomIndex,
  u3 as getPreviousZoomLevel,
  tl as getTextHeight,
  aL as getZoomByIndex,
  zR as handleEvents,
  Tl as handleResize,
  I8 as loadAudio,
  L8 as loadAudioItem,
  B8 as loadAudioObject,
  m3 as loadFonts,
  A8 as loadImage,
  R8 as loadImageItem,
  V8 as loadImageObject,
  _x as loadTextItem,
  W8 as loadTextObject,
  M8 as loadVideo,
  F8 as loadVideoItem,
  z8 as loadVideoObject,
  U8 as mergeSizes,
  Py as mergeTrackObjects,
  Q as movingState,
  i8 as positionOffsets,
  lL as randomInt,
  NR as removeEventListeners,
  al as removeItemsFromTrack,
  _i as renderControl,
  Dy as reorderTracksByIndex,
  c9 as setupHistoryListeners,
  It as timeMsToUnits,
  c3 as timeToString,
  Et as transitionStore,
  ts as unitsToTimeMs,
  pL as updateMovingState,
  Of as useCurrentPlayerFrame,
  Wl as useIsDraggingOverTimeline,
  If as useLayoutStore,
  Zn as useStore,
  l9 as useTimelineEvents,
  xx as wrapResizeWithAnchorPosition
};
