import * as W from "react";
import Ce, { useState as he, useRef as be, cloneElement as x5, useCallback as se, forwardRef as Bt, createElement as ud, useSyncExternalStore as _5, useEffect as ue, createContext as It, createRef as ly, useMemo as ee, useContext as me, useImperativeHandle as qr, useLayoutEffect as Xn, Suspense as tl, useReducer as S5 } from "react";
import { createPortal as hd } from "react-dom";
var Do = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function C5(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var dd = { exports: {} }, Ro = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cv;
function T5() {
  if (cv) return Ro;
  cv = 1;
  var r = Symbol.for("react.transitional.element"), e = Symbol.for("react.fragment");
  function t(n, i, s) {
    var a = null;
    if (s !== void 0 && (a = "" + s), i.key !== void 0 && (a = "" + i.key), "key" in i) {
      s = {};
      for (var c in i)
        c !== "key" && (s[c] = i[c]);
    } else s = i;
    return i = s.ref, {
      $$typeof: r,
      type: n,
      key: a,
      ref: i !== void 0 ? i : null,
      props: s
    };
  }
  return Ro.Fragment = e, Ro.jsx = t, Ro.jsxs = t, Ro;
}
var jo = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lv;
function E5() {
  return lv || (lv = 1, process.env.NODE_ENV !== "production" && function() {
    function r(A) {
      if (A == null) return null;
      if (typeof A == "function")
        return A.$$typeof === oe ? null : A.displayName || A.name || null;
      if (typeof A == "string") return A;
      switch (A) {
        case j:
          return "Fragment";
        case P:
          return "Portal";
        case F:
          return "Profiler";
        case V:
          return "StrictMode";
        case H:
          return "Suspense";
        case Y:
          return "SuspenseList";
      }
      if (typeof A == "object")
        switch (typeof A.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), A.$$typeof) {
          case z:
            return (A.displayName || "Context") + ".Provider";
          case $:
            return (A._context.displayName || "Context") + ".Consumer";
          case G:
            var le = A.render;
            return A = A.displayName, A || (A = le.displayName || le.name || "", A = A !== "" ? "ForwardRef(" + A + ")" : "ForwardRef"), A;
          case te:
            return le = A.displayName || null, le !== null ? le : r(A.type) || "Memo";
          case ge:
            le = A._payload, A = A._init;
            try {
              return r(A(le));
            } catch {
            }
        }
      return null;
    }
    function e(A) {
      return "" + A;
    }
    function t(A) {
      try {
        e(A);
        var le = !1;
      } catch {
        le = !0;
      }
      if (le) {
        le = console;
        var ce = le.error, je = typeof Symbol == "function" && Symbol.toStringTag && A[Symbol.toStringTag] || A.constructor.name || "Object";
        return ce.call(
          le,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          je
        ), e(A);
      }
    }
    function n() {
    }
    function i() {
      if (ze === 0) {
        Ee = console.log, Ie = console.info, dt = console.warn, lr = console.error, Wt = console.group, Mt = console.groupCollapsed, ur = console.groupEnd;
        var A = {
          configurable: !0,
          enumerable: !0,
          value: n,
          writable: !0
        };
        Object.defineProperties(console, {
          info: A,
          log: A,
          warn: A,
          error: A,
          group: A,
          groupCollapsed: A,
          groupEnd: A
        });
      }
      ze++;
    }
    function s() {
      if (ze--, ze === 0) {
        var A = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: re({}, A, { value: Ee }),
          info: re({}, A, { value: Ie }),
          warn: re({}, A, { value: dt }),
          error: re({}, A, { value: lr }),
          group: re({}, A, { value: Wt }),
          groupCollapsed: re({}, A, { value: Mt }),
          groupEnd: re({}, A, { value: ur })
        });
      }
      0 > ze && console.error(
        "disabledDepth fell below zero. This is a bug in React. Please file an issue."
      );
    }
    function a(A) {
      if (ye === void 0)
        try {
          throw Error();
        } catch (ce) {
          var le = ce.stack.trim().match(/\n( *(at )?)/);
          ye = le && le[1] || "", wr = -1 < ce.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < ce.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + ye + A + wr;
    }
    function c(A, le) {
      if (!A || st) return "";
      var ce = Vt.get(A);
      if (ce !== void 0) return ce;
      st = !0, ce = Error.prepareStackTrace, Error.prepareStackTrace = void 0;
      var je = null;
      je = ie.H, ie.H = null, i();
      try {
        var et = {
          DetermineComponentFrameRoot: function() {
            try {
              if (le) {
                var dr = function() {
                  throw Error();
                };
                if (Object.defineProperty(dr.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(dr, []);
                  } catch (Jt) {
                    var fn = Jt;
                  }
                  Reflect.construct(A, [], dr);
                } else {
                  try {
                    dr.call();
                  } catch (Jt) {
                    fn = Jt;
                  }
                  A.call(dr.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (Jt) {
                  fn = Jt;
                }
                (dr = A()) && typeof dr.catch == "function" && dr.catch(function() {
                });
              }
            } catch (Jt) {
              if (Jt && fn && typeof Jt.stack == "string")
                return [Jt.stack, fn.stack];
            }
            return [null, null];
          }
        };
        et.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var Ge = Object.getOwnPropertyDescriptor(
          et.DetermineComponentFrameRoot,
          "name"
        );
        Ge && Ge.configurable && Object.defineProperty(
          et.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var Se = et.DetermineComponentFrameRoot(), ot = Se[0], hr = Se[1];
        if (ot && hr) {
          var xt = ot.split(`
`), _r = hr.split(`
`);
          for (Se = Ge = 0; Ge < xt.length && !xt[Ge].includes(
            "DetermineComponentFrameRoot"
          ); )
            Ge++;
          for (; Se < _r.length && !_r[Se].includes(
            "DetermineComponentFrameRoot"
          ); )
            Se++;
          if (Ge === xt.length || Se === _r.length)
            for (Ge = xt.length - 1, Se = _r.length - 1; 1 <= Ge && 0 <= Se && xt[Ge] !== _r[Se]; )
              Se--;
          for (; 1 <= Ge && 0 <= Se; Ge--, Se--)
            if (xt[Ge] !== _r[Se]) {
              if (Ge !== 1 || Se !== 1)
                do
                  if (Ge--, Se--, 0 > Se || xt[Ge] !== _r[Se]) {
                    var Zr = `
` + xt[Ge].replace(
                      " at new ",
                      " at "
                    );
                    return A.displayName && Zr.includes("<anonymous>") && (Zr = Zr.replace("<anonymous>", A.displayName)), typeof A == "function" && Vt.set(A, Zr), Zr;
                  }
                while (1 <= Ge && 0 <= Se);
              break;
            }
        }
      } finally {
        st = !1, ie.H = je, s(), Error.prepareStackTrace = ce;
      }
      return xt = (xt = A ? A.displayName || A.name : "") ? a(xt) : "", typeof A == "function" && Vt.set(A, xt), xt;
    }
    function u(A) {
      if (A == null) return "";
      if (typeof A == "function") {
        var le = A.prototype;
        return c(
          A,
          !(!le || !le.isReactComponent)
        );
      }
      if (typeof A == "string") return a(A);
      switch (A) {
        case H:
          return a("Suspense");
        case Y:
          return a("SuspenseList");
      }
      if (typeof A == "object")
        switch (A.$$typeof) {
          case G:
            return A = c(A.render, !1), A;
          case te:
            return u(A.type);
          case ge:
            le = A._payload, A = A._init;
            try {
              return u(A(le));
            } catch {
            }
        }
      return "";
    }
    function h() {
      var A = ie.A;
      return A === null ? null : A.getOwner();
    }
    function d(A) {
      if (pe.call(A, "key")) {
        var le = Object.getOwnPropertyDescriptor(A, "key").get;
        if (le && le.isReactWarning) return !1;
      }
      return A.key !== void 0;
    }
    function p(A, le) {
      function ce() {
        nt || (nt = !0, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          le
        ));
      }
      ce.isReactWarning = !0, Object.defineProperty(A, "key", {
        get: ce,
        configurable: !0
      });
    }
    function g() {
      var A = r(this.type);
      return Pt[A] || (Pt[A] = !0, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      )), A = this.props.ref, A !== void 0 ? A : null;
    }
    function v(A, le, ce, je, et, Ge) {
      return ce = Ge.ref, A = {
        $$typeof: O,
        type: A,
        key: le,
        props: Ge,
        _owner: et
      }, (ce !== void 0 ? ce : null) !== null ? Object.defineProperty(A, "ref", {
        enumerable: !1,
        get: g
      }) : Object.defineProperty(A, "ref", { enumerable: !1, value: null }), A._store = {}, Object.defineProperty(A._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      }), Object.defineProperty(A, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      }), Object.freeze && (Object.freeze(A.props), Object.freeze(A)), A;
    }
    function y(A, le, ce, je, et, Ge) {
      if (typeof A == "string" || typeof A == "function" || A === j || A === F || A === V || A === H || A === Y || A === Z || typeof A == "object" && A !== null && (A.$$typeof === ge || A.$$typeof === te || A.$$typeof === z || A.$$typeof === $ || A.$$typeof === G || A.$$typeof === Be || A.getModuleId !== void 0)) {
        var Se = le.children;
        if (Se !== void 0)
          if (je)
            if (Ze(Se)) {
              for (je = 0; je < Se.length; je++)
                x(Se[je], A);
              Object.freeze && Object.freeze(Se);
            } else
              console.error(
                "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
              );
          else x(Se, A);
      } else
        Se = "", (A === void 0 || typeof A == "object" && A !== null && Object.keys(A).length === 0) && (Se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), A === null ? je = "null" : Ze(A) ? je = "array" : A !== void 0 && A.$$typeof === O ? (je = "<" + (r(A.type) || "Unknown") + " />", Se = " Did you accidentally export a JSX literal instead of a component?") : je = typeof A, console.error(
          "React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",
          je,
          Se
        );
      if (pe.call(le, "key")) {
        Se = r(A);
        var ot = Object.keys(le).filter(function(xt) {
          return xt !== "key";
        });
        je = 0 < ot.length ? "{key: someKey, " + ot.join(": ..., ") + ": ...}" : "{key: someKey}", In[Se + je] || (ot = 0 < ot.length ? "{" + ot.join(": ..., ") + ": ...}" : "{}", console.error(
          `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
          je,
          Se,
          ot,
          Se
        ), In[Se + je] = !0);
      }
      if (Se = null, ce !== void 0 && (t(ce), Se = "" + ce), d(le) && (t(le.key), Se = "" + le.key), "key" in le) {
        ce = {};
        for (var hr in le)
          hr !== "key" && (ce[hr] = le[hr]);
      } else ce = le;
      return Se && p(
        ce,
        typeof A == "function" ? A.displayName || A.name || "Unknown" : A
      ), v(A, Se, Ge, et, h(), ce);
    }
    function x(A, le) {
      if (typeof A == "object" && A && A.$$typeof !== Jn) {
        if (Ze(A))
          for (var ce = 0; ce < A.length; ce++) {
            var je = A[ce];
            _(je) && C(je, le);
          }
        else if (_(A))
          A._store && (A._store.validated = 1);
        else if (A === null || typeof A != "object" ? ce = null : (ce = de && A[de] || A["@@iterator"], ce = typeof ce == "function" ? ce : null), typeof ce == "function" && ce !== A.entries && (ce = ce.call(A), ce !== A))
          for (; !(A = ce.next()).done; )
            _(A.value) && C(A.value, le);
      }
    }
    function _(A) {
      return typeof A == "object" && A !== null && A.$$typeof === O;
    }
    function C(A, le) {
      if (A._store && !A._store.validated && A.key == null && (A._store.validated = 1, le = E(le), !xr[le])) {
        xr[le] = !0;
        var ce = "";
        A && A._owner != null && A._owner !== h() && (ce = null, typeof A._owner.tag == "number" ? ce = r(A._owner.type) : typeof A._owner.name == "string" && (ce = A._owner.name), ce = " It was passed a child from " + ce + ".");
        var je = ie.getCurrentStack;
        ie.getCurrentStack = function() {
          var et = u(A.type);
          return je && (et += je() || ""), et;
        }, console.error(
          'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
          le,
          ce
        ), ie.getCurrentStack = je;
      }
    }
    function E(A) {
      var le = "", ce = h();
      return ce && (ce = r(ce.type)) && (le = `

Check the render method of \`` + ce + "`."), le || (A = r(A)) && (le = `

Check the top-level render call using <` + A + ">."), le;
    }
    var k = Ce, O = Symbol.for("react.transitional.element"), P = Symbol.for("react.portal"), j = Symbol.for("react.fragment"), V = Symbol.for("react.strict_mode"), F = Symbol.for("react.profiler"), $ = Symbol.for("react.consumer"), z = Symbol.for("react.context"), G = Symbol.for("react.forward_ref"), H = Symbol.for("react.suspense"), Y = Symbol.for("react.suspense_list"), te = Symbol.for("react.memo"), ge = Symbol.for("react.lazy"), Z = Symbol.for("react.offscreen"), de = Symbol.iterator, oe = Symbol.for("react.client.reference"), ie = k.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, pe = Object.prototype.hasOwnProperty, re = Object.assign, Be = Symbol.for("react.client.reference"), Ze = Array.isArray, ze = 0, Ee, Ie, dt, lr, Wt, Mt, ur;
    n.__reactDisabledLog = !0;
    var ye, wr, st = !1, Vt = new (typeof WeakMap == "function" ? WeakMap : Map)(), Jn = Symbol.for("react.client.reference"), nt, Pt = {}, In = {}, xr = {};
    jo.Fragment = j, jo.jsx = function(A, le, ce, je, et) {
      return y(A, le, ce, !1, je, et);
    }, jo.jsxs = function(A, le, ce, je, et) {
      return y(A, le, ce, !0, je, et);
    };
  }()), jo;
}
process.env.NODE_ENV === "production" ? dd.exports = T5() : dd.exports = E5();
var b = dd.exports;
function uv(r, e) {
  if (typeof r == "function")
    return r(e);
  r != null && (r.current = e);
}
function uy(...r) {
  return (e) => {
    let t = !1;
    const n = r.map((i) => {
      const s = uv(i, e);
      return !t && typeof s == "function" && (t = !0), s;
    });
    if (t)
      return () => {
        for (let i = 0; i < n.length; i++) {
          const s = n[i];
          typeof s == "function" ? s() : uv(r[i], null);
        }
      };
  };
}
function sr(...r) {
  return W.useCallback(uy(...r), r);
}
var Us = W.forwardRef((r, e) => {
  const { children: t, ...n } = r, i = W.Children.toArray(t), s = i.find(O5);
  if (s) {
    const a = s.props.children, c = i.map((u) => u === s ? W.Children.count(a) > 1 ? W.Children.only(null) : W.isValidElement(a) ? a.props.children : null : u);
    return /* @__PURE__ */ b.jsx(fd, { ...n, ref: e, children: W.isValidElement(a) ? W.cloneElement(a, void 0, c) : null });
  }
  return /* @__PURE__ */ b.jsx(fd, { ...n, ref: e, children: t });
});
Us.displayName = "Slot";
var fd = W.forwardRef((r, e) => {
  const { children: t, ...n } = r;
  if (W.isValidElement(t)) {
    const i = A5(t), s = I5(n, t.props);
    return t.type !== W.Fragment && (s.ref = e ? uy(e, i) : i), W.cloneElement(t, s);
  }
  return W.Children.count(t) > 1 ? W.Children.only(null) : null;
});
fd.displayName = "SlotClone";
var k5 = ({ children: r }) => /* @__PURE__ */ b.jsx(b.Fragment, { children: r });
function O5(r) {
  return W.isValidElement(r) && r.type === k5;
}
function I5(r, e) {
  const t = { ...e };
  for (const n in e) {
    const i = r[n], s = e[n];
    /^on[A-Z]/.test(n) ? i && s ? t[n] = (...c) => {
      s(...c), i(...c);
    } : i && (t[n] = i) : n === "style" ? t[n] = { ...i, ...s } : n === "className" && (t[n] = [i, s].filter(Boolean).join(" "));
  }
  return { ...r, ...t };
}
function A5(r) {
  let e = Object.getOwnPropertyDescriptor(r.props, "ref")?.get, t = e && "isReactWarning" in e && e.isReactWarning;
  return t ? r.ref : (e = Object.getOwnPropertyDescriptor(r, "ref")?.get, t = e && "isReactWarning" in e && e.isReactWarning, t ? r.props.ref : r.props.ref || r.ref);
}
var M5 = Us;
function hy(r) {
  var e, t, n = "";
  if (typeof r == "string" || typeof r == "number") n += r;
  else if (typeof r == "object") if (Array.isArray(r)) {
    var i = r.length;
    for (e = 0; e < i; e++) r[e] && (t = hy(r[e])) && (n && (n += " "), n += t);
  } else for (t in r) r[t] && (n && (n += " "), n += t);
  return n;
}
function dy() {
  for (var r, e, t = 0, n = "", i = arguments.length; t < i; t++) (r = arguments[t]) && (e = hy(r)) && (n && (n += " "), n += e);
  return n;
}
const hv = (r) => typeof r == "boolean" ? `${r}` : r === 0 ? "0" : r, dv = dy, P5 = (r, e) => (t) => {
  var n;
  if (e?.variants == null) return dv(r, t?.class, t?.className);
  const { variants: i, defaultVariants: s } = e, a = Object.keys(i).map((h) => {
    const d = t?.[h], p = s?.[h];
    if (d === null) return null;
    const g = hv(d) || hv(p);
    return i[h][g];
  }), c = t && Object.entries(t).reduce((h, d) => {
    let [p, g] = d;
    return g === void 0 || (h[p] = g), h;
  }, {}), u = e == null || (n = e.compoundVariants) === null || n === void 0 ? void 0 : n.reduce((h, d) => {
    let { class: p, className: g, ...v } = d;
    return Object.entries(v).every((y) => {
      let [x, _] = y;
      return Array.isArray(_) ? _.includes({
        ...s,
        ...c
      }[x]) : {
        ...s,
        ...c
      }[x] === _;
    }) ? [
      ...h,
      p,
      g
    ] : h;
  }, []);
  return dv(r, a, u, t?.class, t?.className);
}, pf = "-", D5 = (r) => {
  const e = j5(r), {
    conflictingClassGroups: t,
    conflictingClassGroupModifiers: n
  } = r;
  return {
    getClassGroupId: (a) => {
      const c = a.split(pf);
      return c[0] === "" && c.length !== 1 && c.shift(), fy(c, e) || R5(a);
    },
    getConflictingClassGroupIds: (a, c) => {
      const u = t[a] || [];
      return c && n[a] ? [...u, ...n[a]] : u;
    }
  };
}, fy = (r, e) => {
  if (r.length === 0)
    return e.classGroupId;
  const t = r[0], n = e.nextPart.get(t), i = n ? fy(r.slice(1), n) : void 0;
  if (i)
    return i;
  if (e.validators.length === 0)
    return;
  const s = r.join(pf);
  return e.validators.find(({
    validator: a
  }) => a(s))?.classGroupId;
}, fv = /^\[(.+)\]$/, R5 = (r) => {
  if (fv.test(r)) {
    const e = fv.exec(r)[1], t = e?.substring(0, e.indexOf(":"));
    if (t)
      return "arbitrary.." + t;
  }
}, j5 = (r) => {
  const {
    theme: e,
    prefix: t
  } = r, n = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return L5(Object.entries(r.classGroups), t).forEach(([s, a]) => {
    pd(a, n, s, e);
  }), n;
}, pd = (r, e, t, n) => {
  r.forEach((i) => {
    if (typeof i == "string") {
      const s = i === "" ? e : pv(e, i);
      s.classGroupId = t;
      return;
    }
    if (typeof i == "function") {
      if (F5(i)) {
        pd(i(n), e, t, n);
        return;
      }
      e.validators.push({
        validator: i,
        classGroupId: t
      });
      return;
    }
    Object.entries(i).forEach(([s, a]) => {
      pd(a, pv(e, s), t, n);
    });
  });
}, pv = (r, e) => {
  let t = r;
  return e.split(pf).forEach((n) => {
    t.nextPart.has(n) || t.nextPart.set(n, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), t = t.nextPart.get(n);
  }), t;
}, F5 = (r) => r.isThemeGetter, L5 = (r, e) => e ? r.map(([t, n]) => {
  const i = n.map((s) => typeof s == "string" ? e + s : typeof s == "object" ? Object.fromEntries(Object.entries(s).map(([a, c]) => [e + a, c])) : s);
  return [t, i];
}) : r, N5 = (r) => {
  if (r < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  const i = (s, a) => {
    t.set(s, a), e++, e > r && (e = 0, n = t, t = /* @__PURE__ */ new Map());
  };
  return {
    get(s) {
      let a = t.get(s);
      if (a !== void 0)
        return a;
      if ((a = n.get(s)) !== void 0)
        return i(s, a), a;
    },
    set(s, a) {
      t.has(s) ? t.set(s, a) : i(s, a);
    }
  };
}, py = "!", B5 = (r) => {
  const {
    separator: e,
    experimentalParseClassName: t
  } = r, n = e.length === 1, i = e[0], s = e.length, a = (c) => {
    const u = [];
    let h = 0, d = 0, p;
    for (let _ = 0; _ < c.length; _++) {
      let C = c[_];
      if (h === 0) {
        if (C === i && (n || c.slice(_, _ + s) === e)) {
          u.push(c.slice(d, _)), d = _ + s;
          continue;
        }
        if (C === "/") {
          p = _;
          continue;
        }
      }
      C === "[" ? h++ : C === "]" && h--;
    }
    const g = u.length === 0 ? c : c.substring(d), v = g.startsWith(py), y = v ? g.substring(1) : g, x = p && p > d ? p - d : void 0;
    return {
      modifiers: u,
      hasImportantModifier: v,
      baseClassName: y,
      maybePostfixModifierPosition: x
    };
  };
  return t ? (c) => t({
    className: c,
    parseClassName: a
  }) : a;
}, V5 = (r) => {
  if (r.length <= 1)
    return r;
  const e = [];
  let t = [];
  return r.forEach((n) => {
    n[0] === "[" ? (e.push(...t.sort(), n), t = []) : t.push(n);
  }), e.push(...t.sort()), e;
}, z5 = (r) => ({
  cache: N5(r.cacheSize),
  parseClassName: B5(r),
  ...D5(r)
}), W5 = /\s+/, H5 = (r, e) => {
  const {
    parseClassName: t,
    getClassGroupId: n,
    getConflictingClassGroupIds: i
  } = e, s = [], a = r.trim().split(W5);
  let c = "";
  for (let u = a.length - 1; u >= 0; u -= 1) {
    const h = a[u], {
      modifiers: d,
      hasImportantModifier: p,
      baseClassName: g,
      maybePostfixModifierPosition: v
    } = t(h);
    let y = !!v, x = n(y ? g.substring(0, v) : g);
    if (!x) {
      if (!y) {
        c = h + (c.length > 0 ? " " + c : c);
        continue;
      }
      if (x = n(g), !x) {
        c = h + (c.length > 0 ? " " + c : c);
        continue;
      }
      y = !1;
    }
    const _ = V5(d).join(":"), C = p ? _ + py : _, E = C + x;
    if (s.includes(E))
      continue;
    s.push(E);
    const k = i(x, y);
    for (let O = 0; O < k.length; ++O) {
      const P = k[O];
      s.push(C + P);
    }
    c = h + (c.length > 0 ? " " + c : c);
  }
  return c;
};
function U5() {
  let r = 0, e, t, n = "";
  for (; r < arguments.length; )
    (e = arguments[r++]) && (t = gy(e)) && (n && (n += " "), n += t);
  return n;
}
const gy = (r) => {
  if (typeof r == "string")
    return r;
  let e, t = "";
  for (let n = 0; n < r.length; n++)
    r[n] && (e = gy(r[n])) && (t && (t += " "), t += e);
  return t;
};
function $5(r, ...e) {
  let t, n, i, s = a;
  function a(u) {
    const h = e.reduce((d, p) => p(d), r());
    return t = z5(h), n = t.cache.get, i = t.cache.set, s = c, c(u);
  }
  function c(u) {
    const h = n(u);
    if (h)
      return h;
    const d = H5(u, t);
    return i(u, d), d;
  }
  return function() {
    return s(U5.apply(null, arguments));
  };
}
const ct = (r) => {
  const e = (t) => t[r] || [];
  return e.isThemeGetter = !0, e;
}, my = /^\[(?:([a-z-]+):)?(.+)\]$/i, Y5 = /^\d+\/\d+$/, X5 = /* @__PURE__ */ new Set(["px", "full", "screen"]), G5 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, q5 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, K5 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, Z5 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, J5 = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Bn = (r) => zs(r) || X5.has(r) || Y5.test(r), ci = (r) => Ks(r, "length", oO), zs = (r) => !!r && !Number.isNaN(Number(r)), Dh = (r) => Ks(r, "number", zs), Fo = (r) => !!r && Number.isInteger(Number(r)), Q5 = (r) => r.endsWith("%") && zs(r.slice(0, -1)), Me = (r) => my.test(r), li = (r) => G5.test(r), eO = /* @__PURE__ */ new Set(["length", "size", "percentage"]), tO = (r) => Ks(r, eO, vy), rO = (r) => Ks(r, "position", vy), nO = /* @__PURE__ */ new Set(["image", "url"]), iO = (r) => Ks(r, nO, cO), sO = (r) => Ks(r, "", aO), Lo = () => !0, Ks = (r, e, t) => {
  const n = my.exec(r);
  return n ? n[1] ? typeof e == "string" ? n[1] === e : e.has(n[1]) : t(n[2]) : !1;
}, oO = (r) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  q5.test(r) && !K5.test(r)
), vy = () => !1, aO = (r) => Z5.test(r), cO = (r) => J5.test(r), lO = () => {
  const r = ct("colors"), e = ct("spacing"), t = ct("blur"), n = ct("brightness"), i = ct("borderColor"), s = ct("borderRadius"), a = ct("borderSpacing"), c = ct("borderWidth"), u = ct("contrast"), h = ct("grayscale"), d = ct("hueRotate"), p = ct("invert"), g = ct("gap"), v = ct("gradientColorStops"), y = ct("gradientColorStopPositions"), x = ct("inset"), _ = ct("margin"), C = ct("opacity"), E = ct("padding"), k = ct("saturate"), O = ct("scale"), P = ct("sepia"), j = ct("skew"), V = ct("space"), F = ct("translate"), $ = () => ["auto", "contain", "none"], z = () => ["auto", "hidden", "clip", "visible", "scroll"], G = () => ["auto", Me, e], H = () => [Me, e], Y = () => ["", Bn, ci], te = () => ["auto", zs, Me], ge = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], Z = () => ["solid", "dashed", "dotted", "double", "none"], de = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], oe = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], ie = () => ["", "0", Me], pe = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], re = () => [zs, Me];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Lo],
      spacing: [Bn, ci],
      blur: ["none", "", li, Me],
      brightness: re(),
      borderColor: [r],
      borderRadius: ["none", "", "full", li, Me],
      borderSpacing: H(),
      borderWidth: Y(),
      contrast: re(),
      grayscale: ie(),
      hueRotate: re(),
      invert: ie(),
      gap: H(),
      gradientColorStops: [r],
      gradientColorStopPositions: [Q5, ci],
      inset: G(),
      margin: G(),
      opacity: re(),
      padding: H(),
      saturate: re(),
      scale: re(),
      sepia: ie(),
      skew: re(),
      space: H(),
      translate: H()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", Me]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [li]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": pe()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": pe()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...ge(), Me]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: z()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": z()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": z()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: $()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": $()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": $()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [x]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [x]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [x]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [x]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [x]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [x]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [x]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [x]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [x]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Fo, Me]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: G()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", Me]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ie()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ie()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Fo, Me]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Lo]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Fo, Me]
        }, Me]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": te()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": te()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Lo]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Fo, Me]
        }, Me]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": te()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": te()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", Me]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", Me]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [g]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [g]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [g]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...oe()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...oe(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...oe(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [E]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [E]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [E]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [E]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [E]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [E]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [E]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [E]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [E]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [_]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [_]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [_]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [_]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [_]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [_]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [_]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [_]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [_]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [V]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [V]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Me, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [Me, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [Me, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [li]
        }, li]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [Me, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [Me, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [Me, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [Me, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", li, ci]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Dh]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Lo]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Me]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", zs, Dh]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Bn, Me]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Me]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", Me]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [r]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [C]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [r]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [C]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...Z(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", Bn, ci]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", Bn, Me]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [r]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: H()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Me]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Me]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [C]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...ge(), rO]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", tO]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, iO]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [r]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [y]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [y]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [y]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [v]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [v]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [v]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [s]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [s]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [s]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [s]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [s]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [s]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [s]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [s]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [s]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [s]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [s]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [s]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [s]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [s]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [s]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [c]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [c]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [c]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [c]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [c]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [c]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [c]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [c]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [c]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [C]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...Z(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [c]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [c]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [C]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: Z()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [i]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...Z()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Bn, Me]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [Bn, ci]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [r]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: Y()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [r]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [C]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [Bn, ci]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [r]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", li, sO]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Lo]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [C]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...de(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": de()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [t]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [n]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [u]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", li, Me]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [h]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [d]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [p]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [k]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [P]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [t]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [n]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [u]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [h]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [d]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [p]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [C]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [k]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [P]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [a]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [a]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [a]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Me]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: re()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", Me]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: re()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", Me]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [O]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [O]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [O]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Fo, Me]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [F]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [F]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [j]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [j]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Me]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", r]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Me]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [r]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": H()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": H()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": H()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": H()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": H()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": H()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": H()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": H()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": H()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": H()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": H()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": H()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": H()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": H()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": H()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": H()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": H()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": H()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Me]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [r, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Bn, ci, Dh]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [r, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, uO = /* @__PURE__ */ $5(lO);
function cs(...r) {
  return uO(dy(r));
}
function K8(r, e = {}) {
  const { decimals: t = 0, sizeType: n = "normal" } = e, i = ["Bytes", "KB", "MB", "GB", "TB"], s = ["Bytes", "KiB", "MiB", "GiB", "TiB"];
  if (r === 0) return "0 Byte";
  const a = Math.floor(Math.log(r) / Math.log(1024));
  return `${(r / Math.pow(1024, a)).toFixed(t)} ${n === "accurate" ? s[a] ?? "Bytest" : i[a] ?? "Bytes"}`;
}
const hO = P5(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), nr = W.forwardRef(
  ({ className: r, variant: e, size: t, asChild: n = !1, ...i }, s) => {
    const a = n ? Us : "button";
    return /* @__PURE__ */ b.jsx(
      a,
      {
        className: cs(hO({ variant: e, size: t, className: r })),
        ref: s,
        ...i
      }
    );
  }
);
nr.displayName = "Button";
function gf(r, [e, t]) {
  return Math.min(t, Math.max(e, r));
}
function yt(r, e, { checkForDefaultPrevented: t = !0 } = {}) {
  return function(i) {
    if (r?.(i), t === !1 || !i.defaultPrevented)
      return e?.(i);
  };
}
function pa(r, e = []) {
  let t = [];
  function n(s, a) {
    const c = W.createContext(a), u = t.length;
    t = [...t, a];
    const h = (p) => {
      const { scope: g, children: v, ...y } = p, x = g?.[r]?.[u] || c, _ = W.useMemo(() => y, Object.values(y));
      return /* @__PURE__ */ b.jsx(x.Provider, { value: _, children: v });
    };
    h.displayName = s + "Provider";
    function d(p, g) {
      const v = g?.[r]?.[u] || c, y = W.useContext(v);
      if (y) return y;
      if (a !== void 0) return a;
      throw new Error(`\`${p}\` must be used within \`${s}\``);
    }
    return [h, d];
  }
  const i = () => {
    const s = t.map((a) => W.createContext(a));
    return function(c) {
      const u = c?.[r] || s;
      return W.useMemo(
        () => ({ [`__scope${r}`]: { ...c, [r]: u } }),
        [c, u]
      );
    };
  };
  return i.scopeName = r, [n, dO(i, ...e)];
}
function dO(...r) {
  const e = r[0];
  if (r.length === 1) return e;
  const t = () => {
    const n = r.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(s) {
      const a = n.reduce((c, { useScope: u, scopeName: h }) => {
        const p = u(s)[`__scope${h}`];
        return { ...c, ...p };
      }, {});
      return W.useMemo(() => ({ [`__scope${e.scopeName}`]: a }), [a]);
    };
  };
  return t.scopeName = e.scopeName, t;
}
function yn(r) {
  const e = W.useRef(r);
  return W.useEffect(() => {
    e.current = r;
  }), W.useMemo(() => (...t) => e.current?.(...t), []);
}
function mf({
  prop: r,
  defaultProp: e,
  onChange: t = () => {
  }
}) {
  const [n, i] = fO({ defaultProp: e, onChange: t }), s = r !== void 0, a = s ? r : n, c = yn(t), u = W.useCallback(
    (h) => {
      if (s) {
        const p = typeof h == "function" ? h(r) : h;
        p !== r && c(p);
      } else
        i(h);
    },
    [s, r, i, c]
  );
  return [a, u];
}
function fO({
  defaultProp: r,
  onChange: e
}) {
  const t = W.useState(r), [n] = t, i = W.useRef(n), s = yn(e);
  return W.useEffect(() => {
    i.current !== n && (s(n), i.current = n);
  }, [n, i, s]), t;
}
var pO = W.createContext(void 0);
function Pl(r) {
  const e = W.useContext(pO);
  return r || e || "ltr";
}
function gO(r) {
  const e = W.useRef({ value: r, previous: r });
  return W.useMemo(() => (e.current.value !== r && (e.current.previous = e.current.value, e.current.value = r), e.current.previous), [r]);
}
var ta = globalThis?.document ? W.useLayoutEffect : () => {
};
function mO(r) {
  const [e, t] = W.useState(void 0);
  return ta(() => {
    if (r) {
      t({ width: r.offsetWidth, height: r.offsetHeight });
      const n = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const s = i[0];
        let a, c;
        if ("borderBoxSize" in s) {
          const u = s.borderBoxSize, h = Array.isArray(u) ? u[0] : u;
          a = h.inlineSize, c = h.blockSize;
        } else
          a = r.offsetWidth, c = r.offsetHeight;
        t({ width: a, height: c });
      });
      return n.observe(r, { box: "border-box" }), () => n.unobserve(r);
    } else
      t(void 0);
  }, [r]), e;
}
var vO = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], cr = vO.reduce((r, e) => {
  const t = W.forwardRef((n, i) => {
    const { asChild: s, ...a } = n, c = s ? Us : e;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ b.jsx(c, { ...a, ref: i });
  });
  return t.displayName = `Primitive.${e}`, { ...r, [e]: t };
}, {});
function yy(r) {
  const e = r + "CollectionProvider", [t, n] = pa(e), [i, s] = t(
    e,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), a = (v) => {
    const { scope: y, children: x } = v, _ = Ce.useRef(null), C = Ce.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ b.jsx(i, { scope: y, itemMap: C, collectionRef: _, children: x });
  };
  a.displayName = e;
  const c = r + "CollectionSlot", u = Ce.forwardRef(
    (v, y) => {
      const { scope: x, children: _ } = v, C = s(c, x), E = sr(y, C.collectionRef);
      return /* @__PURE__ */ b.jsx(Us, { ref: E, children: _ });
    }
  );
  u.displayName = c;
  const h = r + "CollectionItemSlot", d = "data-radix-collection-item", p = Ce.forwardRef(
    (v, y) => {
      const { scope: x, children: _, ...C } = v, E = Ce.useRef(null), k = sr(y, E), O = s(h, x);
      return Ce.useEffect(() => (O.itemMap.set(E, { ref: E, ...C }), () => void O.itemMap.delete(E))), /* @__PURE__ */ b.jsx(Us, { [d]: "", ref: k, children: _ });
    }
  );
  p.displayName = h;
  function g(v) {
    const y = s(r + "CollectionConsumer", v);
    return Ce.useCallback(() => {
      const _ = y.collectionRef.current;
      if (!_) return [];
      const C = Array.from(_.querySelectorAll(`[${d}]`));
      return Array.from(y.itemMap.values()).sort(
        (O, P) => C.indexOf(O.ref.current) - C.indexOf(P.ref.current)
      );
    }, [y.collectionRef, y.itemMap]);
  }
  return [
    { Provider: a, Slot: u, ItemSlot: p },
    g,
    n
  ];
}
var by = ["PageUp", "PageDown"], wy = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], xy = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, Zs = "Slider", [gd, yO, bO] = yy(Zs), [_y, Z8] = pa(Zs, [
  bO
]), [wO, Dl] = _y(Zs), Sy = W.forwardRef(
  (r, e) => {
    const {
      name: t,
      min: n = 0,
      max: i = 100,
      step: s = 1,
      orientation: a = "horizontal",
      disabled: c = !1,
      minStepsBetweenThumbs: u = 0,
      defaultValue: h = [n],
      value: d,
      onValueChange: p = () => {
      },
      onValueCommit: g = () => {
      },
      inverted: v = !1,
      form: y,
      ...x
    } = r, _ = W.useRef(/* @__PURE__ */ new Set()), C = W.useRef(0), k = a === "horizontal" ? xO : _O, [O = [], P] = mf({
      prop: d,
      defaultProp: h,
      onChange: (G) => {
        [..._.current][C.current]?.focus(), p(G);
      }
    }), j = W.useRef(O);
    function V(G) {
      const H = kO(O, G);
      z(G, H);
    }
    function F(G) {
      z(G, C.current);
    }
    function $() {
      const G = j.current[C.current];
      O[C.current] !== G && g(O);
    }
    function z(G, H, { commit: Y } = { commit: !1 }) {
      const te = MO(s), ge = PO(Math.round((G - n) / s) * s + n, te), Z = gf(ge, [n, i]);
      P((de = []) => {
        const oe = TO(de, Z, H);
        if (AO(oe, u * s)) {
          C.current = oe.indexOf(Z);
          const ie = String(oe) !== String(de);
          return ie && Y && g(oe), ie ? oe : de;
        } else
          return de;
      });
    }
    return /* @__PURE__ */ b.jsx(
      wO,
      {
        scope: r.__scopeSlider,
        name: t,
        disabled: c,
        min: n,
        max: i,
        valueIndexToChangeRef: C,
        thumbs: _.current,
        values: O,
        orientation: a,
        form: y,
        children: /* @__PURE__ */ b.jsx(gd.Provider, { scope: r.__scopeSlider, children: /* @__PURE__ */ b.jsx(gd.Slot, { scope: r.__scopeSlider, children: /* @__PURE__ */ b.jsx(
          k,
          {
            "aria-disabled": c,
            "data-disabled": c ? "" : void 0,
            ...x,
            ref: e,
            onPointerDown: yt(x.onPointerDown, () => {
              c || (j.current = O);
            }),
            min: n,
            max: i,
            inverted: v,
            onSlideStart: c ? void 0 : V,
            onSlideMove: c ? void 0 : F,
            onSlideEnd: c ? void 0 : $,
            onHomeKeyDown: () => !c && z(n, 0, { commit: !0 }),
            onEndKeyDown: () => !c && z(i, O.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: G, direction: H }) => {
              if (!c) {
                const ge = by.includes(G.key) || G.shiftKey && wy.includes(G.key) ? 10 : 1, Z = C.current, de = O[Z], oe = s * ge * H;
                z(de + oe, Z, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
Sy.displayName = Zs;
var [Cy, Ty] = _y(Zs, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), xO = W.forwardRef(
  (r, e) => {
    const {
      min: t,
      max: n,
      dir: i,
      inverted: s,
      onSlideStart: a,
      onSlideMove: c,
      onSlideEnd: u,
      onStepKeyDown: h,
      ...d
    } = r, [p, g] = W.useState(null), v = sr(e, (k) => g(k)), y = W.useRef(void 0), x = Pl(i), _ = x === "ltr", C = _ && !s || !_ && s;
    function E(k) {
      const O = y.current || p.getBoundingClientRect(), P = [0, O.width], V = vf(P, C ? [t, n] : [n, t]);
      return y.current = O, V(k - O.left);
    }
    return /* @__PURE__ */ b.jsx(
      Cy,
      {
        scope: r.__scopeSlider,
        startEdge: C ? "left" : "right",
        endEdge: C ? "right" : "left",
        direction: C ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ b.jsx(
          Ey,
          {
            dir: x,
            "data-orientation": "horizontal",
            ...d,
            ref: v,
            style: {
              ...d.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (k) => {
              const O = E(k.clientX);
              a?.(O);
            },
            onSlideMove: (k) => {
              const O = E(k.clientX);
              c?.(O);
            },
            onSlideEnd: () => {
              y.current = void 0, u?.();
            },
            onStepKeyDown: (k) => {
              const P = xy[C ? "from-left" : "from-right"].includes(k.key);
              h?.({ event: k, direction: P ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), _O = W.forwardRef(
  (r, e) => {
    const {
      min: t,
      max: n,
      inverted: i,
      onSlideStart: s,
      onSlideMove: a,
      onSlideEnd: c,
      onStepKeyDown: u,
      ...h
    } = r, d = W.useRef(null), p = sr(e, d), g = W.useRef(void 0), v = !i;
    function y(x) {
      const _ = g.current || d.current.getBoundingClientRect(), C = [0, _.height], k = vf(C, v ? [n, t] : [t, n]);
      return g.current = _, k(x - _.top);
    }
    return /* @__PURE__ */ b.jsx(
      Cy,
      {
        scope: r.__scopeSlider,
        startEdge: v ? "bottom" : "top",
        endEdge: v ? "top" : "bottom",
        size: "height",
        direction: v ? 1 : -1,
        children: /* @__PURE__ */ b.jsx(
          Ey,
          {
            "data-orientation": "vertical",
            ...h,
            ref: p,
            style: {
              ...h.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (x) => {
              const _ = y(x.clientY);
              s?.(_);
            },
            onSlideMove: (x) => {
              const _ = y(x.clientY);
              a?.(_);
            },
            onSlideEnd: () => {
              g.current = void 0, c?.();
            },
            onStepKeyDown: (x) => {
              const C = xy[v ? "from-bottom" : "from-top"].includes(x.key);
              u?.({ event: x, direction: C ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), Ey = W.forwardRef(
  (r, e) => {
    const {
      __scopeSlider: t,
      onSlideStart: n,
      onSlideMove: i,
      onSlideEnd: s,
      onHomeKeyDown: a,
      onEndKeyDown: c,
      onStepKeyDown: u,
      ...h
    } = r, d = Dl(Zs, t);
    return /* @__PURE__ */ b.jsx(
      cr.span,
      {
        ...h,
        ref: e,
        onKeyDown: yt(r.onKeyDown, (p) => {
          p.key === "Home" ? (a(p), p.preventDefault()) : p.key === "End" ? (c(p), p.preventDefault()) : by.concat(wy).includes(p.key) && (u(p), p.preventDefault());
        }),
        onPointerDown: yt(r.onPointerDown, (p) => {
          const g = p.target;
          g.setPointerCapture(p.pointerId), p.preventDefault(), d.thumbs.has(g) ? g.focus() : n(p);
        }),
        onPointerMove: yt(r.onPointerMove, (p) => {
          p.target.hasPointerCapture(p.pointerId) && i(p);
        }),
        onPointerUp: yt(r.onPointerUp, (p) => {
          const g = p.target;
          g.hasPointerCapture(p.pointerId) && (g.releasePointerCapture(p.pointerId), s(p));
        })
      }
    );
  }
), ky = "SliderTrack", Oy = W.forwardRef(
  (r, e) => {
    const { __scopeSlider: t, ...n } = r, i = Dl(ky, t);
    return /* @__PURE__ */ b.jsx(
      cr.span,
      {
        "data-disabled": i.disabled ? "" : void 0,
        "data-orientation": i.orientation,
        ...n,
        ref: e
      }
    );
  }
);
Oy.displayName = ky;
var md = "SliderRange", Iy = W.forwardRef(
  (r, e) => {
    const { __scopeSlider: t, ...n } = r, i = Dl(md, t), s = Ty(md, t), a = W.useRef(null), c = sr(e, a), u = i.values.length, h = i.values.map(
      (g) => My(g, i.min, i.max)
    ), d = u > 1 ? Math.min(...h) : 0, p = 100 - Math.max(...h);
    return /* @__PURE__ */ b.jsx(
      cr.span,
      {
        "data-orientation": i.orientation,
        "data-disabled": i.disabled ? "" : void 0,
        ...n,
        ref: c,
        style: {
          ...r.style,
          [s.startEdge]: d + "%",
          [s.endEdge]: p + "%"
        }
      }
    );
  }
);
Iy.displayName = md;
var vd = "SliderThumb", Ay = W.forwardRef(
  (r, e) => {
    const t = yO(r.__scopeSlider), [n, i] = W.useState(null), s = sr(e, (c) => i(c)), a = W.useMemo(
      () => n ? t().findIndex((c) => c.ref.current === n) : -1,
      [t, n]
    );
    return /* @__PURE__ */ b.jsx(SO, { ...r, ref: s, index: a });
  }
), SO = W.forwardRef(
  (r, e) => {
    const { __scopeSlider: t, index: n, name: i, ...s } = r, a = Dl(vd, t), c = Ty(vd, t), [u, h] = W.useState(null), d = sr(e, (E) => h(E)), p = u ? a.form || !!u.closest("form") : !0, g = mO(u), v = a.values[n], y = v === void 0 ? 0 : My(v, a.min, a.max), x = EO(n, a.values.length), _ = g?.[c.size], C = _ ? OO(_, y, c.direction) : 0;
    return W.useEffect(() => {
      if (u)
        return a.thumbs.add(u), () => {
          a.thumbs.delete(u);
        };
    }, [u, a.thumbs]), /* @__PURE__ */ b.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [c.startEdge]: `calc(${y}% + ${C}px)`
        },
        children: [
          /* @__PURE__ */ b.jsx(gd.ItemSlot, { scope: r.__scopeSlider, children: /* @__PURE__ */ b.jsx(
            cr.span,
            {
              role: "slider",
              "aria-label": r["aria-label"] || x,
              "aria-valuemin": a.min,
              "aria-valuenow": v,
              "aria-valuemax": a.max,
              "aria-orientation": a.orientation,
              "data-orientation": a.orientation,
              "data-disabled": a.disabled ? "" : void 0,
              tabIndex: a.disabled ? void 0 : 0,
              ...s,
              ref: d,
              style: v === void 0 ? { display: "none" } : r.style,
              onFocus: yt(r.onFocus, () => {
                a.valueIndexToChangeRef.current = n;
              })
            }
          ) }),
          p && /* @__PURE__ */ b.jsx(
            CO,
            {
              name: i ?? (a.name ? a.name + (a.values.length > 1 ? "[]" : "") : void 0),
              form: a.form,
              value: v
            },
            n
          )
        ]
      }
    );
  }
);
Ay.displayName = vd;
var CO = (r) => {
  const { value: e, ...t } = r, n = W.useRef(null), i = gO(e);
  return W.useEffect(() => {
    const s = n.current, a = window.HTMLInputElement.prototype, u = Object.getOwnPropertyDescriptor(a, "value").set;
    if (i !== e && u) {
      const h = new Event("input", { bubbles: !0 });
      u.call(s, e), s.dispatchEvent(h);
    }
  }, [i, e]), /* @__PURE__ */ b.jsx("input", { style: { display: "none" }, ...t, ref: n, defaultValue: e });
};
function TO(r = [], e, t) {
  const n = [...r];
  return n[t] = e, n.sort((i, s) => i - s);
}
function My(r, e, t) {
  const s = 100 / (t - e) * (r - e);
  return gf(s, [0, 100]);
}
function EO(r, e) {
  return e > 2 ? `Value ${r + 1} of ${e}` : e === 2 ? ["Minimum", "Maximum"][r] : void 0;
}
function kO(r, e) {
  if (r.length === 1) return 0;
  const t = r.map((i) => Math.abs(i - e)), n = Math.min(...t);
  return t.indexOf(n);
}
function OO(r, e, t) {
  const n = r / 2, s = vf([0, 50], [0, n]);
  return (n - s(e) * t) * t;
}
function IO(r) {
  return r.slice(0, -1).map((e, t) => r[t + 1] - e);
}
function AO(r, e) {
  if (e > 0) {
    const t = IO(r);
    return Math.min(...t) >= e;
  }
  return !0;
}
function vf(r, e) {
  return (t) => {
    if (r[0] === r[1] || e[0] === e[1]) return e[0];
    const n = (e[1] - e[0]) / (r[1] - r[0]);
    return e[0] + n * (t - r[0]);
  };
}
function MO(r) {
  return (String(r).split(".")[1] || "").length;
}
function PO(r, e) {
  const t = Math.pow(10, e);
  return Math.round(r * t) / t;
}
var Py = Sy, DO = Oy, RO = Iy, jO = Ay;
const FO = W.forwardRef(({ className: r, ...e }, t) => /* @__PURE__ */ b.jsxs(
  Py,
  {
    ref: t,
    className: cs(
      "relative flex w-full touch-none select-none items-center",
      r
    ),
    ...e,
    children: [
      /* @__PURE__ */ b.jsx(DO, { className: "relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20", children: /* @__PURE__ */ b.jsx(RO, { className: "absolute h-full bg-primary" }) }),
      /* @__PURE__ */ b.jsx(jO, { className: "block h-4 w-4 cursor-pointer rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-0 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50" })
    ]
  }
));
FO.displayName = Py.displayName;
function LO(r, e) {
  return W.useReducer((t, n) => e[t][n] ?? t, r);
}
var Js = (r) => {
  const { present: e, children: t } = r, n = NO(e), i = typeof t == "function" ? t({ present: n.isPresent }) : W.Children.only(t), s = sr(n.ref, BO(i));
  return typeof t == "function" || n.isPresent ? W.cloneElement(i, { ref: s }) : null;
};
Js.displayName = "Presence";
function NO(r) {
  const [e, t] = W.useState(), n = W.useRef({}), i = W.useRef(r), s = W.useRef("none"), a = r ? "mounted" : "unmounted", [c, u] = LO(a, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return W.useEffect(() => {
    const h = wc(n.current);
    s.current = c === "mounted" ? h : "none";
  }, [c]), ta(() => {
    const h = n.current, d = i.current;
    if (d !== r) {
      const g = s.current, v = wc(h);
      r ? u("MOUNT") : v === "none" || h?.display === "none" ? u("UNMOUNT") : u(d && g !== v ? "ANIMATION_OUT" : "UNMOUNT"), i.current = r;
    }
  }, [r, u]), ta(() => {
    if (e) {
      let h;
      const d = e.ownerDocument.defaultView ?? window, p = (v) => {
        const x = wc(n.current).includes(v.animationName);
        if (v.target === e && x && (u("ANIMATION_END"), !i.current)) {
          const _ = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", h = d.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = _);
          });
        }
      }, g = (v) => {
        v.target === e && (s.current = wc(n.current));
      };
      return e.addEventListener("animationstart", g), e.addEventListener("animationcancel", p), e.addEventListener("animationend", p), () => {
        d.clearTimeout(h), e.removeEventListener("animationstart", g), e.removeEventListener("animationcancel", p), e.removeEventListener("animationend", p);
      };
    } else
      u("ANIMATION_END");
  }, [e, u]), {
    isPresent: ["mounted", "unmountSuspended"].includes(c),
    ref: W.useCallback((h) => {
      h && (n.current = getComputedStyle(h)), t(h);
    }, [])
  };
}
function wc(r) {
  return r?.animationName || "none";
}
function BO(r) {
  let e = Object.getOwnPropertyDescriptor(r.props, "ref")?.get, t = e && "isReactWarning" in e && e.isReactWarning;
  return t ? r.ref : (e = Object.getOwnPropertyDescriptor(r, "ref")?.get, t = e && "isReactWarning" in e && e.isReactWarning, t ? r.props.ref : r.props.ref || r.ref);
}
function VO(r, e) {
  return W.useReducer((t, n) => e[t][n] ?? t, r);
}
var yf = "ScrollArea", [Dy, J8] = pa(yf), [zO, Kr] = Dy(yf), Ry = W.forwardRef(
  (r, e) => {
    const {
      __scopeScrollArea: t,
      type: n = "hover",
      dir: i,
      scrollHideDelay: s = 600,
      ...a
    } = r, [c, u] = W.useState(null), [h, d] = W.useState(null), [p, g] = W.useState(null), [v, y] = W.useState(null), [x, _] = W.useState(null), [C, E] = W.useState(0), [k, O] = W.useState(0), [P, j] = W.useState(!1), [V, F] = W.useState(!1), $ = sr(e, (G) => u(G)), z = Pl(i);
    return /* @__PURE__ */ b.jsx(
      zO,
      {
        scope: t,
        type: n,
        dir: z,
        scrollHideDelay: s,
        scrollArea: c,
        viewport: h,
        onViewportChange: d,
        content: p,
        onContentChange: g,
        scrollbarX: v,
        onScrollbarXChange: y,
        scrollbarXEnabled: P,
        onScrollbarXEnabledChange: j,
        scrollbarY: x,
        onScrollbarYChange: _,
        scrollbarYEnabled: V,
        onScrollbarYEnabledChange: F,
        onCornerWidthChange: E,
        onCornerHeightChange: O,
        children: /* @__PURE__ */ b.jsx(
          cr.div,
          {
            dir: z,
            ...a,
            ref: $,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": C + "px",
              "--radix-scroll-area-corner-height": k + "px",
              ...r.style
            }
          }
        )
      }
    );
  }
);
Ry.displayName = yf;
var jy = "ScrollAreaViewport", Fy = W.forwardRef(
  (r, e) => {
    const { __scopeScrollArea: t, children: n, nonce: i, ...s } = r, a = Kr(jy, t), c = W.useRef(null), u = sr(e, c, a.onViewportChange);
    return /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
      /* @__PURE__ */ b.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: i
        }
      ),
      /* @__PURE__ */ b.jsx(
        cr.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...s,
          ref: u,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: a.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: a.scrollbarYEnabled ? "scroll" : "hidden",
            ...r.style
          },
          children: /* @__PURE__ */ b.jsx("div", { ref: a.onContentChange, style: { minWidth: "100%", display: "table" }, children: n })
        }
      )
    ] });
  }
);
Fy.displayName = jy;
var On = "ScrollAreaScrollbar", Rl = W.forwardRef(
  (r, e) => {
    const { forceMount: t, ...n } = r, i = Kr(On, r.__scopeScrollArea), { onScrollbarXEnabledChange: s, onScrollbarYEnabledChange: a } = i, c = r.orientation === "horizontal";
    return W.useEffect(() => (c ? s(!0) : a(!0), () => {
      c ? s(!1) : a(!1);
    }), [c, s, a]), i.type === "hover" ? /* @__PURE__ */ b.jsx(WO, { ...n, ref: e, forceMount: t }) : i.type === "scroll" ? /* @__PURE__ */ b.jsx(HO, { ...n, ref: e, forceMount: t }) : i.type === "auto" ? /* @__PURE__ */ b.jsx(Ly, { ...n, ref: e, forceMount: t }) : i.type === "always" ? /* @__PURE__ */ b.jsx(bf, { ...n, ref: e }) : null;
  }
);
Rl.displayName = On;
var WO = W.forwardRef((r, e) => {
  const { forceMount: t, ...n } = r, i = Kr(On, r.__scopeScrollArea), [s, a] = W.useState(!1);
  return W.useEffect(() => {
    const c = i.scrollArea;
    let u = 0;
    if (c) {
      const h = () => {
        window.clearTimeout(u), a(!0);
      }, d = () => {
        u = window.setTimeout(() => a(!1), i.scrollHideDelay);
      };
      return c.addEventListener("pointerenter", h), c.addEventListener("pointerleave", d), () => {
        window.clearTimeout(u), c.removeEventListener("pointerenter", h), c.removeEventListener("pointerleave", d);
      };
    }
  }, [i.scrollArea, i.scrollHideDelay]), /* @__PURE__ */ b.jsx(Js, { present: t || s, children: /* @__PURE__ */ b.jsx(
    Ly,
    {
      "data-state": s ? "visible" : "hidden",
      ...n,
      ref: e
    }
  ) });
}), HO = W.forwardRef((r, e) => {
  const { forceMount: t, ...n } = r, i = Kr(On, r.__scopeScrollArea), s = r.orientation === "horizontal", a = Fl(() => u("SCROLL_END"), 100), [c, u] = VO("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return W.useEffect(() => {
    if (c === "idle") {
      const h = window.setTimeout(() => u("HIDE"), i.scrollHideDelay);
      return () => window.clearTimeout(h);
    }
  }, [c, i.scrollHideDelay, u]), W.useEffect(() => {
    const h = i.viewport, d = s ? "scrollLeft" : "scrollTop";
    if (h) {
      let p = h[d];
      const g = () => {
        const v = h[d];
        p !== v && (u("SCROLL"), a()), p = v;
      };
      return h.addEventListener("scroll", g), () => h.removeEventListener("scroll", g);
    }
  }, [i.viewport, s, u, a]), /* @__PURE__ */ b.jsx(Js, { present: t || c !== "hidden", children: /* @__PURE__ */ b.jsx(
    bf,
    {
      "data-state": c === "hidden" ? "hidden" : "visible",
      ...n,
      ref: e,
      onPointerEnter: yt(r.onPointerEnter, () => u("POINTER_ENTER")),
      onPointerLeave: yt(r.onPointerLeave, () => u("POINTER_LEAVE"))
    }
  ) });
}), Ly = W.forwardRef((r, e) => {
  const t = Kr(On, r.__scopeScrollArea), { forceMount: n, ...i } = r, [s, a] = W.useState(!1), c = r.orientation === "horizontal", u = Fl(() => {
    if (t.viewport) {
      const h = t.viewport.offsetWidth < t.viewport.scrollWidth, d = t.viewport.offsetHeight < t.viewport.scrollHeight;
      a(c ? h : d);
    }
  }, 10);
  return $s(t.viewport, u), $s(t.content, u), /* @__PURE__ */ b.jsx(Js, { present: n || s, children: /* @__PURE__ */ b.jsx(
    bf,
    {
      "data-state": s ? "visible" : "hidden",
      ...i,
      ref: e
    }
  ) });
}), bf = W.forwardRef((r, e) => {
  const { orientation: t = "vertical", ...n } = r, i = Kr(On, r.__scopeScrollArea), s = W.useRef(null), a = W.useRef(0), [c, u] = W.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), h = zy(c.viewport, c.content), d = {
    ...n,
    sizes: c,
    onSizesChange: u,
    hasThumb: h > 0 && h < 1,
    onThumbChange: (g) => s.current = g,
    onThumbPointerUp: () => a.current = 0,
    onThumbPointerDown: (g) => a.current = g
  };
  function p(g, v) {
    return qO(g, a.current, c, v);
  }
  return t === "horizontal" ? /* @__PURE__ */ b.jsx(
    UO,
    {
      ...d,
      ref: e,
      onThumbPositionChange: () => {
        if (i.viewport && s.current) {
          const g = i.viewport.scrollLeft, v = gv(g, c, i.dir);
          s.current.style.transform = `translate3d(${v}px, 0, 0)`;
        }
      },
      onWheelScroll: (g) => {
        i.viewport && (i.viewport.scrollLeft = g);
      },
      onDragScroll: (g) => {
        i.viewport && (i.viewport.scrollLeft = p(g, i.dir));
      }
    }
  ) : t === "vertical" ? /* @__PURE__ */ b.jsx(
    $O,
    {
      ...d,
      ref: e,
      onThumbPositionChange: () => {
        if (i.viewport && s.current) {
          const g = i.viewport.scrollTop, v = gv(g, c);
          s.current.style.transform = `translate3d(0, ${v}px, 0)`;
        }
      },
      onWheelScroll: (g) => {
        i.viewport && (i.viewport.scrollTop = g);
      },
      onDragScroll: (g) => {
        i.viewport && (i.viewport.scrollTop = p(g));
      }
    }
  ) : null;
}), UO = W.forwardRef((r, e) => {
  const { sizes: t, onSizesChange: n, ...i } = r, s = Kr(On, r.__scopeScrollArea), [a, c] = W.useState(), u = W.useRef(null), h = sr(e, u, s.onScrollbarXChange);
  return W.useEffect(() => {
    u.current && c(getComputedStyle(u.current));
  }, [u]), /* @__PURE__ */ b.jsx(
    By,
    {
      "data-orientation": "horizontal",
      ...i,
      ref: h,
      sizes: t,
      style: {
        bottom: 0,
        left: s.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: s.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": jl(t) + "px",
        ...r.style
      },
      onThumbPointerDown: (d) => r.onThumbPointerDown(d.x),
      onDragScroll: (d) => r.onDragScroll(d.x),
      onWheelScroll: (d, p) => {
        if (s.viewport) {
          const g = s.viewport.scrollLeft + d.deltaX;
          r.onWheelScroll(g), Hy(g, p) && d.preventDefault();
        }
      },
      onResize: () => {
        u.current && s.viewport && a && n({
          content: s.viewport.scrollWidth,
          viewport: s.viewport.offsetWidth,
          scrollbar: {
            size: u.current.clientWidth,
            paddingStart: nl(a.paddingLeft),
            paddingEnd: nl(a.paddingRight)
          }
        });
      }
    }
  );
}), $O = W.forwardRef((r, e) => {
  const { sizes: t, onSizesChange: n, ...i } = r, s = Kr(On, r.__scopeScrollArea), [a, c] = W.useState(), u = W.useRef(null), h = sr(e, u, s.onScrollbarYChange);
  return W.useEffect(() => {
    u.current && c(getComputedStyle(u.current));
  }, [u]), /* @__PURE__ */ b.jsx(
    By,
    {
      "data-orientation": "vertical",
      ...i,
      ref: h,
      sizes: t,
      style: {
        top: 0,
        right: s.dir === "ltr" ? 0 : void 0,
        left: s.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": jl(t) + "px",
        ...r.style
      },
      onThumbPointerDown: (d) => r.onThumbPointerDown(d.y),
      onDragScroll: (d) => r.onDragScroll(d.y),
      onWheelScroll: (d, p) => {
        if (s.viewport) {
          const g = s.viewport.scrollTop + d.deltaY;
          r.onWheelScroll(g), Hy(g, p) && d.preventDefault();
        }
      },
      onResize: () => {
        u.current && s.viewport && a && n({
          content: s.viewport.scrollHeight,
          viewport: s.viewport.offsetHeight,
          scrollbar: {
            size: u.current.clientHeight,
            paddingStart: nl(a.paddingTop),
            paddingEnd: nl(a.paddingBottom)
          }
        });
      }
    }
  );
}), [YO, Ny] = Dy(On), By = W.forwardRef((r, e) => {
  const {
    __scopeScrollArea: t,
    sizes: n,
    hasThumb: i,
    onThumbChange: s,
    onThumbPointerUp: a,
    onThumbPointerDown: c,
    onThumbPositionChange: u,
    onDragScroll: h,
    onWheelScroll: d,
    onResize: p,
    ...g
  } = r, v = Kr(On, t), [y, x] = W.useState(null), _ = sr(e, ($) => x($)), C = W.useRef(null), E = W.useRef(""), k = v.viewport, O = n.content - n.viewport, P = yn(d), j = yn(u), V = Fl(p, 10);
  function F($) {
    if (C.current) {
      const z = $.clientX - C.current.left, G = $.clientY - C.current.top;
      h({ x: z, y: G });
    }
  }
  return W.useEffect(() => {
    const $ = (z) => {
      const G = z.target;
      y?.contains(G) && P(z, O);
    };
    return document.addEventListener("wheel", $, { passive: !1 }), () => document.removeEventListener("wheel", $, { passive: !1 });
  }, [k, y, O, P]), W.useEffect(j, [n, j]), $s(y, V), $s(v.content, V), /* @__PURE__ */ b.jsx(
    YO,
    {
      scope: t,
      scrollbar: y,
      hasThumb: i,
      onThumbChange: yn(s),
      onThumbPointerUp: yn(a),
      onThumbPositionChange: j,
      onThumbPointerDown: yn(c),
      children: /* @__PURE__ */ b.jsx(
        cr.div,
        {
          ...g,
          ref: _,
          style: { position: "absolute", ...g.style },
          onPointerDown: yt(r.onPointerDown, ($) => {
            $.button === 0 && ($.target.setPointerCapture($.pointerId), C.current = y.getBoundingClientRect(), E.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", v.viewport && (v.viewport.style.scrollBehavior = "auto"), F($));
          }),
          onPointerMove: yt(r.onPointerMove, F),
          onPointerUp: yt(r.onPointerUp, ($) => {
            const z = $.target;
            z.hasPointerCapture($.pointerId) && z.releasePointerCapture($.pointerId), document.body.style.webkitUserSelect = E.current, v.viewport && (v.viewport.style.scrollBehavior = ""), C.current = null;
          })
        }
      )
    }
  );
}), rl = "ScrollAreaThumb", wf = W.forwardRef(
  (r, e) => {
    const { forceMount: t, ...n } = r, i = Ny(rl, r.__scopeScrollArea);
    return /* @__PURE__ */ b.jsx(Js, { present: t || i.hasThumb, children: /* @__PURE__ */ b.jsx(XO, { ref: e, ...n }) });
  }
), XO = W.forwardRef(
  (r, e) => {
    const { __scopeScrollArea: t, style: n, ...i } = r, s = Kr(rl, t), a = Ny(rl, t), { onThumbPositionChange: c } = a, u = sr(
      e,
      (p) => a.onThumbChange(p)
    ), h = W.useRef(void 0), d = Fl(() => {
      h.current && (h.current(), h.current = void 0);
    }, 100);
    return W.useEffect(() => {
      const p = s.viewport;
      if (p) {
        const g = () => {
          if (d(), !h.current) {
            const v = KO(p, c);
            h.current = v, c();
          }
        };
        return c(), p.addEventListener("scroll", g), () => p.removeEventListener("scroll", g);
      }
    }, [s.viewport, d, c]), /* @__PURE__ */ b.jsx(
      cr.div,
      {
        "data-state": a.hasThumb ? "visible" : "hidden",
        ...i,
        ref: u,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...n
        },
        onPointerDownCapture: yt(r.onPointerDownCapture, (p) => {
          const v = p.target.getBoundingClientRect(), y = p.clientX - v.left, x = p.clientY - v.top;
          a.onThumbPointerDown({ x: y, y: x });
        }),
        onPointerUp: yt(r.onPointerUp, a.onThumbPointerUp)
      }
    );
  }
);
wf.displayName = rl;
var xf = "ScrollAreaCorner", Vy = W.forwardRef(
  (r, e) => {
    const t = Kr(xf, r.__scopeScrollArea), n = !!(t.scrollbarX && t.scrollbarY);
    return t.type !== "scroll" && n ? /* @__PURE__ */ b.jsx(GO, { ...r, ref: e }) : null;
  }
);
Vy.displayName = xf;
var GO = W.forwardRef((r, e) => {
  const { __scopeScrollArea: t, ...n } = r, i = Kr(xf, t), [s, a] = W.useState(0), [c, u] = W.useState(0), h = !!(s && c);
  return $s(i.scrollbarX, () => {
    const d = i.scrollbarX?.offsetHeight || 0;
    i.onCornerHeightChange(d), u(d);
  }), $s(i.scrollbarY, () => {
    const d = i.scrollbarY?.offsetWidth || 0;
    i.onCornerWidthChange(d), a(d);
  }), h ? /* @__PURE__ */ b.jsx(
    cr.div,
    {
      ...n,
      ref: e,
      style: {
        width: s,
        height: c,
        position: "absolute",
        right: i.dir === "ltr" ? 0 : void 0,
        left: i.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...r.style
      }
    }
  ) : null;
});
function nl(r) {
  return r ? parseInt(r, 10) : 0;
}
function zy(r, e) {
  const t = r / e;
  return isNaN(t) ? 0 : t;
}
function jl(r) {
  const e = zy(r.viewport, r.content), t = r.scrollbar.paddingStart + r.scrollbar.paddingEnd, n = (r.scrollbar.size - t) * e;
  return Math.max(n, 18);
}
function qO(r, e, t, n = "ltr") {
  const i = jl(t), s = i / 2, a = e || s, c = i - a, u = t.scrollbar.paddingStart + a, h = t.scrollbar.size - t.scrollbar.paddingEnd - c, d = t.content - t.viewport, p = n === "ltr" ? [0, d] : [d * -1, 0];
  return Wy([u, h], p)(r);
}
function gv(r, e, t = "ltr") {
  const n = jl(e), i = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, s = e.scrollbar.size - i, a = e.content - e.viewport, c = s - n, u = t === "ltr" ? [0, a] : [a * -1, 0], h = gf(r, u);
  return Wy([0, a], [0, c])(h);
}
function Wy(r, e) {
  return (t) => {
    if (r[0] === r[1] || e[0] === e[1]) return e[0];
    const n = (e[1] - e[0]) / (r[1] - r[0]);
    return e[0] + n * (t - r[0]);
  };
}
function Hy(r, e) {
  return r > 0 && r < e;
}
var KO = (r, e = () => {
}) => {
  let t = { left: r.scrollLeft, top: r.scrollTop }, n = 0;
  return function i() {
    const s = { left: r.scrollLeft, top: r.scrollTop }, a = t.left !== s.left, c = t.top !== s.top;
    (a || c) && e(), t = s, n = window.requestAnimationFrame(i);
  }(), () => window.cancelAnimationFrame(n);
};
function Fl(r, e) {
  const t = yn(r), n = W.useRef(0);
  return W.useEffect(() => () => window.clearTimeout(n.current), []), W.useCallback(() => {
    window.clearTimeout(n.current), n.current = window.setTimeout(t, e);
  }, [t, e]);
}
function $s(r, e) {
  const t = yn(e);
  ta(() => {
    let n = 0;
    if (r) {
      const i = new ResizeObserver(() => {
        cancelAnimationFrame(n), n = window.requestAnimationFrame(t);
      });
      return i.observe(r), () => {
        window.cancelAnimationFrame(n), i.unobserve(r);
      };
    }
  }, [r, t]);
}
var il = Ry, yd = Fy, mv = Rl, vv = wf, ZO = Vy;
const Qs = W.forwardRef(({ className: r, children: e, ...t }, n) => /* @__PURE__ */ b.jsxs(
  il,
  {
    ref: n,
    className: cs("relative overflow-hidden", r),
    ...t,
    children: [
      /* @__PURE__ */ b.jsx(yd, { className: "h-full w-full rounded-[inherit]", children: e }),
      /* @__PURE__ */ b.jsx(Uy, {}),
      /* @__PURE__ */ b.jsx(ZO, {})
    ]
  }
));
Qs.displayName = il.displayName;
const Uy = W.forwardRef(({ className: r, orientation: e = "vertical", ...t }, n) => /* @__PURE__ */ b.jsx(
  Rl,
  {
    ref: n,
    orientation: e,
    className: cs(
      "flex touch-none select-none transition-colors",
      e === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      e === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      r
    ),
    ...t,
    children: /* @__PURE__ */ b.jsx(wf, { className: "relative flex-1 rounded-full bg-border" })
  }
));
Uy.displayName = Rl.displayName;
const Ll = ({
  children: r,
  renderCustomPreview: e,
  data: t = {},
  shouldDisplayPreview: n = !0
}) => {
  const [i, s] = he(!1), [a, c] = he({ x: 0, y: 0 }), u = be(null), g = x5(r, {
    draggable: !0,
    onDragStart: (v) => {
      s(!0), v.dataTransfer.setDragImage(new Image(), 0, 0), v.dataTransfer.setData(JSON.stringify(t), JSON.stringify(t)), c({
        x: v.clientX,
        y: v.clientY
      });
    },
    onDragEnd: () => {
      s(!1);
    },
    onDrag: (v) => {
      i && c({
        x: v.clientX,
        y: v.clientY
      });
    },
    style: {
      ...r.props.style
    }
  });
  return /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
    g,
    i && n && e ? hd(
      /* @__PURE__ */ b.jsx(
        "div",
        {
          ref: u,
          style: {
            position: "fixed",
            left: a.x,
            top: a.y,
            pointerEvents: "none",
            zIndex: 9999,
            transform: "translate(-50%, -50%)"
            // Center the preview
          },
          children: e
        }
      ),
      document.body
    ) : null
  ] });
};
var JO = W.useId || (() => {
}), QO = 0;
function $y(r) {
  const [e, t] = W.useState(JO());
  return ta(() => {
    t((n) => n ?? String(QO++));
  }, [r]), e ? `radix-${e}` : "";
}
var Rh = "rovingFocusGroup.onEntryFocus", eI = { bubbles: !1, cancelable: !0 }, Nl = "RovingFocusGroup", [bd, Yy, tI] = yy(Nl), [rI, Xy] = pa(
  Nl,
  [tI]
), [nI, iI] = rI(Nl), Gy = W.forwardRef(
  (r, e) => /* @__PURE__ */ b.jsx(bd.Provider, { scope: r.__scopeRovingFocusGroup, children: /* @__PURE__ */ b.jsx(bd.Slot, { scope: r.__scopeRovingFocusGroup, children: /* @__PURE__ */ b.jsx(sI, { ...r, ref: e }) }) })
);
Gy.displayName = Nl;
var sI = W.forwardRef((r, e) => {
  const {
    __scopeRovingFocusGroup: t,
    orientation: n,
    loop: i = !1,
    dir: s,
    currentTabStopId: a,
    defaultCurrentTabStopId: c,
    onCurrentTabStopIdChange: u,
    onEntryFocus: h,
    preventScrollOnEntryFocus: d = !1,
    ...p
  } = r, g = W.useRef(null), v = sr(e, g), y = Pl(s), [x = null, _] = mf({
    prop: a,
    defaultProp: c,
    onChange: u
  }), [C, E] = W.useState(!1), k = yn(h), O = Yy(t), P = W.useRef(!1), [j, V] = W.useState(0);
  return W.useEffect(() => {
    const F = g.current;
    if (F)
      return F.addEventListener(Rh, k), () => F.removeEventListener(Rh, k);
  }, [k]), /* @__PURE__ */ b.jsx(
    nI,
    {
      scope: t,
      orientation: n,
      dir: y,
      loop: i,
      currentTabStopId: x,
      onItemFocus: W.useCallback(
        (F) => _(F),
        [_]
      ),
      onItemShiftTab: W.useCallback(() => E(!0), []),
      onFocusableItemAdd: W.useCallback(
        () => V((F) => F + 1),
        []
      ),
      onFocusableItemRemove: W.useCallback(
        () => V((F) => F - 1),
        []
      ),
      children: /* @__PURE__ */ b.jsx(
        cr.div,
        {
          tabIndex: C || j === 0 ? -1 : 0,
          "data-orientation": n,
          ...p,
          ref: v,
          style: { outline: "none", ...r.style },
          onMouseDown: yt(r.onMouseDown, () => {
            P.current = !0;
          }),
          onFocus: yt(r.onFocus, (F) => {
            const $ = !P.current;
            if (F.target === F.currentTarget && $ && !C) {
              const z = new CustomEvent(Rh, eI);
              if (F.currentTarget.dispatchEvent(z), !z.defaultPrevented) {
                const G = O().filter((Z) => Z.focusable), H = G.find((Z) => Z.active), Y = G.find((Z) => Z.id === x), ge = [H, Y, ...G].filter(
                  Boolean
                ).map((Z) => Z.ref.current);
                Zy(ge, d);
              }
            }
            P.current = !1;
          }),
          onBlur: yt(r.onBlur, () => E(!1))
        }
      )
    }
  );
}), qy = "RovingFocusGroupItem", Ky = W.forwardRef(
  (r, e) => {
    const {
      __scopeRovingFocusGroup: t,
      focusable: n = !0,
      active: i = !1,
      tabStopId: s,
      ...a
    } = r, c = $y(), u = s || c, h = iI(qy, t), d = h.currentTabStopId === u, p = Yy(t), { onFocusableItemAdd: g, onFocusableItemRemove: v } = h;
    return W.useEffect(() => {
      if (n)
        return g(), () => v();
    }, [n, g, v]), /* @__PURE__ */ b.jsx(
      bd.ItemSlot,
      {
        scope: t,
        id: u,
        focusable: n,
        active: i,
        children: /* @__PURE__ */ b.jsx(
          cr.span,
          {
            tabIndex: d ? 0 : -1,
            "data-orientation": h.orientation,
            ...a,
            ref: e,
            onMouseDown: yt(r.onMouseDown, (y) => {
              n ? h.onItemFocus(u) : y.preventDefault();
            }),
            onFocus: yt(r.onFocus, () => h.onItemFocus(u)),
            onKeyDown: yt(r.onKeyDown, (y) => {
              if (y.key === "Tab" && y.shiftKey) {
                h.onItemShiftTab();
                return;
              }
              if (y.target !== y.currentTarget) return;
              const x = cI(y, h.orientation, h.dir);
              if (x !== void 0) {
                if (y.metaKey || y.ctrlKey || y.altKey || y.shiftKey) return;
                y.preventDefault();
                let C = p().filter((E) => E.focusable).map((E) => E.ref.current);
                if (x === "last") C.reverse();
                else if (x === "prev" || x === "next") {
                  x === "prev" && C.reverse();
                  const E = C.indexOf(y.currentTarget);
                  C = h.loop ? lI(C, E + 1) : C.slice(E + 1);
                }
                setTimeout(() => Zy(C));
              }
            })
          }
        )
      }
    );
  }
);
Ky.displayName = qy;
var oI = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function aI(r, e) {
  return e !== "rtl" ? r : r === "ArrowLeft" ? "ArrowRight" : r === "ArrowRight" ? "ArrowLeft" : r;
}
function cI(r, e, t) {
  const n = aI(r.key, t);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(n)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(n)))
    return oI[n];
}
function Zy(r, e = !1) {
  const t = document.activeElement;
  for (const n of r)
    if (n === t || (n.focus({ preventScroll: e }), document.activeElement !== t)) return;
}
function lI(r, e) {
  return r.map((t, n) => r[(e + n) % r.length]);
}
var uI = Gy, hI = Ky, _f = "Tabs", [dI, Q8] = pa(_f, [
  Xy
]), Jy = Xy(), [fI, Sf] = dI(_f), Qy = W.forwardRef(
  (r, e) => {
    const {
      __scopeTabs: t,
      value: n,
      onValueChange: i,
      defaultValue: s,
      orientation: a = "horizontal",
      dir: c,
      activationMode: u = "automatic",
      ...h
    } = r, d = Pl(c), [p, g] = mf({
      prop: n,
      onChange: i,
      defaultProp: s
    });
    return /* @__PURE__ */ b.jsx(
      fI,
      {
        scope: t,
        baseId: $y(),
        value: p,
        onValueChange: g,
        orientation: a,
        dir: d,
        activationMode: u,
        children: /* @__PURE__ */ b.jsx(
          cr.div,
          {
            dir: d,
            "data-orientation": a,
            ...h,
            ref: e
          }
        )
      }
    );
  }
);
Qy.displayName = _f;
var e1 = "TabsList", t1 = W.forwardRef(
  (r, e) => {
    const { __scopeTabs: t, loop: n = !0, ...i } = r, s = Sf(e1, t), a = Jy(t);
    return /* @__PURE__ */ b.jsx(
      uI,
      {
        asChild: !0,
        ...a,
        orientation: s.orientation,
        dir: s.dir,
        loop: n,
        children: /* @__PURE__ */ b.jsx(
          cr.div,
          {
            role: "tablist",
            "aria-orientation": s.orientation,
            ...i,
            ref: e
          }
        )
      }
    );
  }
);
t1.displayName = e1;
var r1 = "TabsTrigger", n1 = W.forwardRef(
  (r, e) => {
    const { __scopeTabs: t, value: n, disabled: i = !1, ...s } = r, a = Sf(r1, t), c = Jy(t), u = o1(a.baseId, n), h = a1(a.baseId, n), d = n === a.value;
    return /* @__PURE__ */ b.jsx(
      hI,
      {
        asChild: !0,
        ...c,
        focusable: !i,
        active: d,
        children: /* @__PURE__ */ b.jsx(
          cr.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": d,
            "aria-controls": h,
            "data-state": d ? "active" : "inactive",
            "data-disabled": i ? "" : void 0,
            disabled: i,
            id: u,
            ...s,
            ref: e,
            onMouseDown: yt(r.onMouseDown, (p) => {
              !i && p.button === 0 && p.ctrlKey === !1 ? a.onValueChange(n) : p.preventDefault();
            }),
            onKeyDown: yt(r.onKeyDown, (p) => {
              [" ", "Enter"].includes(p.key) && a.onValueChange(n);
            }),
            onFocus: yt(r.onFocus, () => {
              const p = a.activationMode !== "manual";
              !d && !i && p && a.onValueChange(n);
            })
          }
        )
      }
    );
  }
);
n1.displayName = r1;
var i1 = "TabsContent", s1 = W.forwardRef(
  (r, e) => {
    const { __scopeTabs: t, value: n, forceMount: i, children: s, ...a } = r, c = Sf(i1, t), u = o1(c.baseId, n), h = a1(c.baseId, n), d = n === c.value, p = W.useRef(d);
    return W.useEffect(() => {
      const g = requestAnimationFrame(() => p.current = !1);
      return () => cancelAnimationFrame(g);
    }, []), /* @__PURE__ */ b.jsx(Js, { present: i || d, children: ({ present: g }) => /* @__PURE__ */ b.jsx(
      cr.div,
      {
        "data-state": d ? "active" : "inactive",
        "data-orientation": c.orientation,
        role: "tabpanel",
        "aria-labelledby": u,
        hidden: !g,
        id: h,
        tabIndex: 0,
        ...a,
        ref: e,
        style: {
          ...r.style,
          animationDuration: p.current ? "0s" : void 0
        },
        children: g && s
      }
    ) });
  }
);
s1.displayName = i1;
function o1(r, e) {
  return `${r}-trigger-${e}`;
}
function a1(r, e) {
  return `${r}-content-${e}`;
}
var pI = Qy, c1 = t1, l1 = n1, u1 = s1;
const gI = pI, h1 = W.forwardRef(({ className: r, ...e }, t) => /* @__PURE__ */ b.jsx(
  c1,
  {
    ref: t,
    className: cs(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      r
    ),
    ...e
  }
));
h1.displayName = c1.displayName;
const wd = W.forwardRef(({ className: r, ...e }, t) => /* @__PURE__ */ b.jsx(
  l1,
  {
    ref: t,
    className: cs(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      r
    ),
    ...e
  }
));
wd.displayName = l1.displayName;
const xd = W.forwardRef(({ className: r, ...e }, t) => /* @__PURE__ */ b.jsx(
  u1,
  {
    ref: t,
    className: cs(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      r
    ),
    ...e
  }
));
xd.displayName = u1.displayName;
const eL = "add", tL = "track", rL = "trackItems", nL = "track:changed", iL = "trackItems:changed", sL = "state", oL = "state:changed", mI = "add", d1 = "add:text", ga = "add:video", ma = "add:audio", aL = "add:placeholder", va = "add:image", cL = "add:mask", lL = "add:transition", uL = "add:animation", hL = "edit", dL = "edit:object", fL = "edit:text", pL = "edit:shape", gL = "enterEditMode", mL = "player", vI = "player:play", yI = "player:pause", vL = "player:seek", yL = "player:seekTo", bL = "player:seekBy", wL = "player:togglePlay", bI = "active", xL = "active:set", f1 = "active:delete", _L = "active:paste", p1 = "active:clone", g1 = "active:split", SL = "layer", CL = "layer:locked", TL = "layer:hidden", EL = "layer:move", kL = "layer:select", wI = "layer:selection", OL = "layer:sendTo", IL = "layer:rename", AL = "layer:editingName", ML = "layer:copy", PL = "layer:paste", DL = "layer:clone", RL = "layer:split", jL = "layer:cut", FL = "layer:delete", xI = "history", m1 = "history:undo", v1 = "history:redo", LL = "history:reset", _I = "scale", y1 = "scale:changed", SI = "drag", b1 = "drag:start", sl = "drag:end", CI = "timeline", w1 = "timeline:boundingChanged";
var _d = function(r, e) {
  return _d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
  }, _d(r, e);
};
function eo(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  _d(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function Sd(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], n = 0;
  if (t) return t.call(r);
  if (r && typeof r.length == "number") return {
    next: function() {
      return r && n >= r.length && (r = void 0), { value: r && r[n++], done: !r };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Cd(r, e) {
  var t = typeof Symbol == "function" && r[Symbol.iterator];
  if (!t) return r;
  var n = t.call(r), i, s = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) s.push(i.value);
  } catch (c) {
    a = { error: c };
  } finally {
    try {
      i && !i.done && (t = n.return) && t.call(n);
    } finally {
      if (a) throw a.error;
    }
  }
  return s;
}
function Td(r, e, t) {
  if (t || arguments.length === 2) for (var n = 0, i = e.length, s; n < i; n++)
    (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return r.concat(s || Array.prototype.slice.call(e));
}
function Sn(r) {
  return typeof r == "function";
}
function x1(r) {
  var e = function(n) {
    Error.call(n), n.stack = new Error().stack;
  }, t = r(e);
  return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t;
}
var jh = x1(function(r) {
  return function(t) {
    r(this), this.message = t ? t.length + ` errors occurred during unsubscription:
` + t.map(function(n, i) {
      return i + 1 + ") " + n.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = t;
  };
});
function Ed(r, e) {
  if (r) {
    var t = r.indexOf(e);
    0 <= t && r.splice(t, 1);
  }
}
var Bl = function() {
  function r(e) {
    this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return r.prototype.unsubscribe = function() {
    var e, t, n, i, s;
    if (!this.closed) {
      this.closed = !0;
      var a = this._parentage;
      if (a)
        if (this._parentage = null, Array.isArray(a))
          try {
            for (var c = Sd(a), u = c.next(); !u.done; u = c.next()) {
              var h = u.value;
              h.remove(this);
            }
          } catch (x) {
            e = { error: x };
          } finally {
            try {
              u && !u.done && (t = c.return) && t.call(c);
            } finally {
              if (e) throw e.error;
            }
          }
        else
          a.remove(this);
      var d = this.initialTeardown;
      if (Sn(d))
        try {
          d();
        } catch (x) {
          s = x instanceof jh ? x.errors : [x];
        }
      var p = this._finalizers;
      if (p) {
        this._finalizers = null;
        try {
          for (var g = Sd(p), v = g.next(); !v.done; v = g.next()) {
            var y = v.value;
            try {
              yv(y);
            } catch (x) {
              s = s ?? [], x instanceof jh ? s = Td(Td([], Cd(s)), Cd(x.errors)) : s.push(x);
            }
          }
        } catch (x) {
          n = { error: x };
        } finally {
          try {
            v && !v.done && (i = g.return) && i.call(g);
          } finally {
            if (n) throw n.error;
          }
        }
      }
      if (s)
        throw new jh(s);
    }
  }, r.prototype.add = function(e) {
    var t;
    if (e && e !== this)
      if (this.closed)
        yv(e);
      else {
        if (e instanceof r) {
          if (e.closed || e._hasParent(this))
            return;
          e._addParent(this);
        }
        (this._finalizers = (t = this._finalizers) !== null && t !== void 0 ? t : []).push(e);
      }
  }, r.prototype._hasParent = function(e) {
    var t = this._parentage;
    return t === e || Array.isArray(t) && t.includes(e);
  }, r.prototype._addParent = function(e) {
    var t = this._parentage;
    this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e;
  }, r.prototype._removeParent = function(e) {
    var t = this._parentage;
    t === e ? this._parentage = null : Array.isArray(t) && Ed(t, e);
  }, r.prototype.remove = function(e) {
    var t = this._finalizers;
    t && Ed(t, e), e instanceof r && e._removeParent(this);
  }, r.EMPTY = function() {
    var e = new r();
    return e.closed = !0, e;
  }(), r;
}(), _1 = Bl.EMPTY;
function S1(r) {
  return r instanceof Bl || r && "closed" in r && Sn(r.remove) && Sn(r.add) && Sn(r.unsubscribe);
}
function yv(r) {
  Sn(r) ? r() : r.unsubscribe();
}
var TI = {
  Promise: void 0
}, EI = {
  setTimeout: function(r, e) {
    for (var t = [], n = 2; n < arguments.length; n++)
      t[n - 2] = arguments[n];
    return setTimeout.apply(void 0, Td([r, e], Cd(t)));
  },
  clearTimeout: function(r) {
    return clearTimeout(r);
  },
  delegate: void 0
};
function kI(r) {
  EI.setTimeout(function() {
    throw r;
  });
}
function bv() {
}
function qc(r) {
  r();
}
var Cf = function(r) {
  eo(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n.isStopped = !1, t ? (n.destination = t, S1(t) && t.add(n)) : n.destination = AI, n;
  }
  return e.create = function(t, n, i) {
    return new kd(t, n, i);
  }, e.prototype.next = function(t) {
    this.isStopped || this._next(t);
  }, e.prototype.error = function(t) {
    this.isStopped || (this.isStopped = !0, this._error(t));
  }, e.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, r.prototype.unsubscribe.call(this), this.destination = null);
  }, e.prototype._next = function(t) {
    this.destination.next(t);
  }, e.prototype._error = function(t) {
    try {
      this.destination.error(t);
    } finally {
      this.unsubscribe();
    }
  }, e.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, e;
}(Bl), OI = function() {
  function r(e) {
    this.partialObserver = e;
  }
  return r.prototype.next = function(e) {
    var t = this.partialObserver;
    if (t.next)
      try {
        t.next(e);
      } catch (n) {
        xc(n);
      }
  }, r.prototype.error = function(e) {
    var t = this.partialObserver;
    if (t.error)
      try {
        t.error(e);
      } catch (n) {
        xc(n);
      }
    else
      xc(e);
  }, r.prototype.complete = function() {
    var e = this.partialObserver;
    if (e.complete)
      try {
        e.complete();
      } catch (t) {
        xc(t);
      }
  }, r;
}(), kd = function(r) {
  eo(e, r);
  function e(t, n, i) {
    var s = r.call(this) || this, a;
    return Sn(t) || !t ? a = {
      next: t ?? void 0,
      error: n ?? void 0,
      complete: i ?? void 0
    } : a = t, s.destination = new OI(a), s;
  }
  return e;
}(Cf);
function xc(r) {
  kI(r);
}
function II(r) {
  throw r;
}
var AI = {
  closed: !0,
  next: bv,
  error: II,
  complete: bv
}, MI = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function PI(r) {
  return r;
}
function DI(r) {
  return r.length === 0 ? PI : r.length === 1 ? r[0] : function(t) {
    return r.reduce(function(n, i) {
      return i(n);
    }, t);
  };
}
var wv = function() {
  function r(e) {
    e && (this._subscribe = e);
  }
  return r.prototype.lift = function(e) {
    var t = new r();
    return t.source = this, t.operator = e, t;
  }, r.prototype.subscribe = function(e, t, n) {
    var i = this, s = jI(e) ? e : new kd(e, t, n);
    return qc(function() {
      var a = i, c = a.operator, u = a.source;
      s.add(c ? c.call(s, u) : u ? i._subscribe(s) : i._trySubscribe(s));
    }), s;
  }, r.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (t) {
      e.error(t);
    }
  }, r.prototype.forEach = function(e, t) {
    var n = this;
    return t = xv(t), new t(function(i, s) {
      var a = new kd({
        next: function(c) {
          try {
            e(c);
          } catch (u) {
            s(u), a.unsubscribe();
          }
        },
        error: s,
        complete: i
      });
      n.subscribe(a);
    });
  }, r.prototype._subscribe = function(e) {
    var t;
    return (t = this.source) === null || t === void 0 ? void 0 : t.subscribe(e);
  }, r.prototype[MI] = function() {
    return this;
  }, r.prototype.pipe = function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    return DI(e)(this);
  }, r.prototype.toPromise = function(e) {
    var t = this;
    return e = xv(e), new e(function(n, i) {
      var s;
      t.subscribe(function(a) {
        return s = a;
      }, function(a) {
        return i(a);
      }, function() {
        return n(s);
      });
    });
  }, r.create = function(e) {
    return new r(e);
  }, r;
}();
function xv(r) {
  var e;
  return (e = r ?? TI.Promise) !== null && e !== void 0 ? e : Promise;
}
function RI(r) {
  return r && Sn(r.next) && Sn(r.error) && Sn(r.complete);
}
function jI(r) {
  return r && r instanceof Cf || RI(r) && S1(r);
}
function FI(r) {
  return Sn(r?.lift);
}
function LI(r) {
  return function(e) {
    if (FI(e))
      return e.lift(function(t) {
        try {
          return r(t, this);
        } catch (n) {
          this.error(n);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function NI(r, e, t, n, i) {
  return new BI(r, e, t, n, i);
}
var BI = function(r) {
  eo(e, r);
  function e(t, n, i, s, a, c) {
    var u = r.call(this, t) || this;
    return u.onFinalize = a, u.shouldUnsubscribe = c, u._next = n ? function(h) {
      try {
        n(h);
      } catch (d) {
        t.error(d);
      }
    } : r.prototype._next, u._error = s ? function(h) {
      try {
        s(h);
      } catch (d) {
        t.error(d);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._error, u._complete = i ? function() {
      try {
        i();
      } catch (h) {
        t.error(h);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._complete, u;
  }
  return e.prototype.unsubscribe = function() {
    var t;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var n = this.closed;
      r.prototype.unsubscribe.call(this), !n && ((t = this.onFinalize) === null || t === void 0 || t.call(this));
    }
  }, e;
}(Cf), VI = x1(function(r) {
  return function() {
    r(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), Tf = function(r) {
  eo(e, r);
  function e() {
    var t = r.call(this) || this;
    return t.closed = !1, t.currentObservers = null, t.observers = [], t.isStopped = !1, t.hasError = !1, t.thrownError = null, t;
  }
  return e.prototype.lift = function(t) {
    var n = new _v(this, this);
    return n.operator = t, n;
  }, e.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new VI();
  }, e.prototype.next = function(t) {
    var n = this;
    qc(function() {
      var i, s;
      if (n._throwIfClosed(), !n.isStopped) {
        n.currentObservers || (n.currentObservers = Array.from(n.observers));
        try {
          for (var a = Sd(n.currentObservers), c = a.next(); !c.done; c = a.next()) {
            var u = c.value;
            u.next(t);
          }
        } catch (h) {
          i = { error: h };
        } finally {
          try {
            c && !c.done && (s = a.return) && s.call(a);
          } finally {
            if (i) throw i.error;
          }
        }
      }
    });
  }, e.prototype.error = function(t) {
    var n = this;
    qc(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.hasError = n.isStopped = !0, n.thrownError = t;
        for (var i = n.observers; i.length; )
          i.shift().error(t);
      }
    });
  }, e.prototype.complete = function() {
    var t = this;
    qc(function() {
      if (t._throwIfClosed(), !t.isStopped) {
        t.isStopped = !0;
        for (var n = t.observers; n.length; )
          n.shift().complete();
      }
    });
  }, e.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(e.prototype, "observed", {
    get: function() {
      var t;
      return ((t = this.observers) === null || t === void 0 ? void 0 : t.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._trySubscribe = function(t) {
    return this._throwIfClosed(), r.prototype._trySubscribe.call(this, t);
  }, e.prototype._subscribe = function(t) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(t), this._innerSubscribe(t);
  }, e.prototype._innerSubscribe = function(t) {
    var n = this, i = this, s = i.hasError, a = i.isStopped, c = i.observers;
    return s || a ? _1 : (this.currentObservers = null, c.push(t), new Bl(function() {
      n.currentObservers = null, Ed(c, t);
    }));
  }, e.prototype._checkFinalizedStatuses = function(t) {
    var n = this, i = n.hasError, s = n.thrownError, a = n.isStopped;
    i ? t.error(s) : a && t.complete();
  }, e.prototype.asObservable = function() {
    var t = new wv();
    return t.source = this, t;
  }, e.create = function(t, n) {
    return new _v(t, n);
  }, e;
}(wv), _v = function(r) {
  eo(e, r);
  function e(t, n) {
    var i = r.call(this) || this;
    return i.destination = t, i.source = n, i;
  }
  return e.prototype.next = function(t) {
    var n, i;
    (i = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null || i === void 0 || i.call(n, t);
  }, e.prototype.error = function(t) {
    var n, i;
    (i = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null || i === void 0 || i.call(n, t);
  }, e.prototype.complete = function() {
    var t, n;
    (n = (t = this.destination) === null || t === void 0 ? void 0 : t.complete) === null || n === void 0 || n.call(t);
  }, e.prototype._subscribe = function(t) {
    var n, i;
    return (i = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t)) !== null && i !== void 0 ? i : _1;
  }, e;
}(Tf), Sv = function(r) {
  eo(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n._value = t, n;
  }
  return Object.defineProperty(e.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._subscribe = function(t) {
    var n = r.prototype._subscribe.call(this, t);
    return !n.closed && t.next(this._value), n;
  }, e.prototype.getValue = function() {
    var t = this, n = t.hasError, i = t.thrownError, s = t._value;
    if (n)
      throw i;
    return this._throwIfClosed(), s;
  }, e.prototype.next = function(t) {
    r.prototype.next.call(this, this._value = t);
  }, e;
}(Tf);
function $i(r, e) {
  return LI(function(t, n) {
    var i = 0;
    t.subscribe(NI(n, function(s) {
      return r.call(e, s, i++) && n.next(s);
    }));
  });
}
const C1 = new Tf(), zI = (r, e) => {
  C1.next({ key: r, value: e });
}, We = {
  subject: C1,
  dispatch: zI
}, $t = [];
for (let r = 0; r < 256; ++r)
  $t.push((r + 256).toString(16).slice(1));
function WI(r, e = 0) {
  return ($t[r[e + 0]] + $t[r[e + 1]] + $t[r[e + 2]] + $t[r[e + 3]] + "-" + $t[r[e + 4]] + $t[r[e + 5]] + "-" + $t[r[e + 6]] + $t[r[e + 7]] + "-" + $t[r[e + 8]] + $t[r[e + 9]] + "-" + $t[r[e + 10]] + $t[r[e + 11]] + $t[r[e + 12]] + $t[r[e + 13]] + $t[r[e + 14]] + $t[r[e + 15]]).toLowerCase();
}
let Fh;
const HI = new Uint8Array(16);
function UI() {
  if (!Fh) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Fh = crypto.getRandomValues.bind(crypto);
  }
  return Fh(HI);
}
const $I = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Cv = { randomUUID: $I };
function Ft(r, e, t) {
  if (Cv.randomUUID && !r)
    return Cv.randomUUID();
  r = r || {};
  const n = r.random ?? r.rng?.() ?? UI();
  if (n.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, WI(n);
}
var T1 = /* @__PURE__ */ ((r) => (r.IMAGE = "image", r.VIDEO = "video", r.AUDIO = "audio", r))(T1 || {});
const YI = (r) => {
  const [e, t] = he(!1), [n, i] = he(!1), s = se((d) => {
    const p = { ...d, id: Ft() };
    switch (d.type) {
      case "image":
        We.dispatch(va, { payload: p });
        break;
      case "video":
        We.dispatch(ga, { payload: p });
        break;
      case "audio":
        We.dispatch(ma, { payload: p });
        break;
    }
  }, []), a = se(
    (d) => {
      d.preventDefault();
      try {
        const p = d.dataTransfer?.types[0], g = JSON.parse(p);
        if (!Object.values(T1).includes(g.type))
          return;
        i(!0), t(!0), r?.(!0);
      } catch (p) {
        console.error("Error parsing dragged data:", p);
      }
    },
    [r]
  ), c = se(
    (d) => {
      d.preventDefault(), e && (i(!0), r?.(!0));
    },
    [e, r]
  ), u = se(
    (d) => {
      if (n) {
        d.preventDefault(), i(!1), r?.(!1);
        try {
          const p = d.dataTransfer?.types[0], g = JSON.parse(
            d.dataTransfer.getData(p)
          );
          s(g);
        } catch (p) {
          console.error("Error parsing dropped data:", p);
        }
      }
    },
    [n, r, s]
  ), h = se(
    (d) => {
      d.preventDefault(), d.currentTarget.contains(d.relatedTarget) || (i(!1), t(!1), r?.(!1));
    },
    [r]
  );
  return { onDragEnter: a, onDragOver: c, onDrop: u, onDragLeave: h, isDraggingOver: n };
}, XI = ({
  children: r,
  className: e,
  style: t,
  onDragStateChange: n,
  id: i
}) => {
  const { onDragEnter: s, onDragOver: a, onDrop: c, onDragLeave: u } = YI(n);
  return /* @__PURE__ */ b.jsx(
    "div",
    {
      id: i,
      onDragEnter: s,
      onDrop: c,
      onDragOver: a,
      onDragLeave: u,
      className: e,
      style: t,
      role: "region",
      "aria-label": "Droppable area for images, videos, and audio",
      children: r
    }
  );
}, NL = ({
  size: r,
  children: e
}) => {
  const [t, n] = he(!1);
  return /* @__PURE__ */ b.jsxs(
    XI,
    {
      id: "artboard",
      onDragStateChange: n,
      style: {
        width: r.width,
        height: r.height
      },
      className: "designcombo_scene pointer-events-auto mt-3.5 bg-black",
      children: [
        /* @__PURE__ */ b.jsx(
          "div",
          {
            style: {
              width: r.width,
              height: r.height
            },
            className: `pointer-events-none absolute z-50 mt-3.5 transition-colors duration-200 ease-in-out ${t ? "border-4 border-dashed border-white bg-white/[0.075]" : "bg-transparent"} shadow-[0_0_0_5000px_#1D1D1F]`
          }
        ),
        e
      ]
    }
  );
}, BL = 100, VL = 30, zL = 18, WL = 14, HL = 30, UL = 24, $L = 16, GI = 12, YL = "Regular", qI = "sans-serif", Vl = 188, Od = 40, XL = 4e3, KI = 1920, ZI = 1080, JI = 60, QI = 1e3 / JI, GL = 2e6, qL = 1e7, KL = 48e3, ZL = 192e3, E1 = 2.3, JL = KI / E1, QL = ZI / E1, e7 = 184, t7 = 348, r7 = 512, n7 = 300, i7 = 0, s7 = 5e3, o7 = 1, a7 = 0, c7 = 0, l7 = 0, u7 = 359, h7 = 1, d7 = 0, f7 = !1, p7 = !1, g7 = 0, m7 = 2, v7 = 0.01, y7 = 1, b7 = 0, w7 = 3, x7 = 0.01, _7 = 1, S7 = 0, C7 = 1, T7 = 0.01, E7 = 0.5, k7 = -1e3, O7 = 1e3, I7 = 1, A7 = 1, M7 = 0, P7 = 1, D7 = 0.01, R7 = 1, j7 = 0, F7 = 1, L7 = 0.01, N7 = 0, B7 = 0.5, V7 = 10, z7 = 0.01, W7 = 1, H7 = 0, U7 = 1, $7 = 0.01, Y7 = 1, Ef = 16, Tv = 80;
function eA(r) {
  if (!r) return "0";
  const e = r / Vl, t = Math.trunc(e) % 60, n = Math.trunc(e / 60) % 60, i = Math.trunc(e / 3600) % 60, a = [
    Math.trunc(e / 216e3).toString(),
    i.toString(),
    n.toString(),
    t.toString()
  ];
  return e < 60 ? `${a[3].padStart(2, "0")}f` : e < 3600 ? `${a[2].padStart(1, "0")}s` : e < 216e3 ? `${a[1].padStart(2, "0")}:${a[2].padStart(
    2,
    "0"
  )}` : `${a[0].padStart(2, "0")}:${a[1].padStart(
    2,
    "0"
  )}:${a[2].padStart(2, "0")}`;
}
function X7(r, e = !1) {
  if (!r) return "00:00";
  const n = 1e3 / 60;
  if (r < 1e3)
    return e ? `${Math.floor(r / n)}f` : `${(r / 1e3).toFixed(1)}s`;
  const i = Math.floor(r / 1e3);
  if (i < 60)
    return `${i}s`;
  const s = Math.floor(i / 60);
  if (s < 60) {
    const h = i % 60;
    return `${s.toString().padStart(2, "0")}:${h.toString().padStart(2, "0")}`;
  }
  const a = Math.floor(s / 60), c = s % 60, u = i % 60;
  return `${a.toString().padStart(2, "0")}:${c.toString().padStart(2, "0")}:${u.toString().padStart(2, "0")}`;
}
function ol(r, e) {
  return r.map((t) => ({
    ...t,
    items: t.items.filter((n) => !e.includes(n))
  }));
}
const tA = ({ frame: r }, { fps: e }) => {
  const t = r / e, n = Math.floor(t / 3600), i = t % 3600, s = Math.floor(i / 60), a = Math.floor(i % 60), c = Math.floor(
    (i - Math.floor(i)) * 100
  );
  return n > 0 ? `${n}:${s.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}:${c.toString().padStart(2, "0")}` : `${s.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}:${c.toString().padStart(2, "0")}`;
}, rA = ({ time: r }) => {
  const e = r / 1e3, t = Math.floor(e / 3600), n = e % 3600, i = Math.floor(n / 60), s = Math.floor(n % 60), a = Math.floor(
    (n - Math.floor(n)) * 100
  );
  return t > 0 ? `${t}:${i.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}` : `${i.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}`;
}, nA = () => {
  const r = document.getElementById("video-current-time");
  return (r ? parseFloat(r.getAttribute("data-current-time") ?? "") : 0) * 1e3;
}, Tn = [
  {
    // 1x distance (minute 0 to minute 5, 5 segments).
    index: 0,
    unit: 18e3,
    zoom: 1 / 18e3,
    segments: 5
  },
  {
    // 1x distance (minute 0 to minute 3, 3 segments).
    index: 1,
    unit: 10800,
    zoom: 1 / 10800,
    segments: 3
  },
  {
    // 1x distance (minute 0 to minute 2, 2 segments).
    index: 2,
    unit: 7200,
    zoom: 1 / 7200,
    segments: 2
  },
  {
    // 1x distance (minute 0 to minute 1, 1 segment).
    index: 3,
    unit: 3600,
    zoom: 1 / 3600,
    segments: 1
  },
  {
    // 1x distance (second 0 to second 30, 2 segments).
    index: 4,
    unit: 1800,
    zoom: 1 / 1800,
    segments: 2
  },
  {
    // 1x distance (second 0 to second 15, 3 segments).
    index: 5,
    unit: 900,
    zoom: 1 / 900,
    segments: 3
  },
  {
    // 1x distance (second 0 to second 10, 2 segments).
    index: 6,
    unit: 600,
    zoom: 1 / 600,
    segments: 2
  },
  {
    // 1x distance (second 0 to second 5, 5 segments).
    index: 7,
    unit: 300,
    zoom: 1 / 300,
    segments: 5
  },
  {
    // 1x distance (second 0 to second 3, 3 segments).
    index: 8,
    unit: 180,
    zoom: 1 / 180,
    segments: 3
  },
  {
    // 1x distance (second 0 to second 2, 2 segments).
    index: 9,
    unit: 120,
    zoom: 1 / 120,
    segments: 10
  },
  {
    // 1x distance (second 0 to second 1, 1 segment).
    index: 10,
    unit: 60,
    zoom: 1 / 60,
    segments: 5
  },
  {
    // 1x distance (second 0 to second 1, 1 segment).
    index: 11,
    unit: 60,
    zoom: 1 / 60,
    segments: 5
  },
  {
    // 1x distance (frame 0 to frame 30, 2 segments).
    index: 12,
    unit: 30,
    zoom: 1 / 30,
    segments: 2
  },
  {
    // 1x distance (frame 0 to frame 15, 3 segments).
    index: 13,
    unit: 15,
    zoom: 1 / 15,
    segments: 3
  },
  {
    // 1x distance (frame 0 to frame 10, 2 segments).
    index: 14,
    unit: 10,
    zoom: 1 / 10,
    segments: 2
  },
  {
    // 1x distance (frame 0 to frame 5, 5 segments).
    index: 15,
    unit: 5,
    zoom: 1 / 5,
    segments: 5
  },
  {
    // 1x distance (frame 0 to frame 3, 3 segments).
    index: 16,
    unit: 3,
    zoom: 1 / 3,
    segments: 3
  },
  {
    // 1x distance (frame 0 to frame 2, 2 segments).
    index: 17,
    unit: 2,
    zoom: 1 / 2,
    segments: 5
  },
  {
    // 1x distance (frame 0 to frame 1, 1 segment).
    index: 18,
    unit: 1,
    zoom: 1,
    segments: 5
  },
  {
    // 2x distance (frame 0 to frame 1, 1 segment).
    index: 19,
    unit: 1,
    zoom: 2,
    segments: 5
  },
  {
    // 4x distance (frame 0 to frame 1, 1 segment).
    index: 20,
    unit: 1,
    zoom: 4,
    segments: 10
  }
];
function k1(r, e) {
  let t = -1, n = r.length - 1;
  for (; 1 + t < n; ) {
    const i = t + (n - t >> 1);
    e(r[i], i, r) ? n = i : t = i;
  }
  return n;
}
function G7(r, e = 1) {
  const t = () => {
    const u = Math.max(0, Od), d = document.getElementById(
      "designcombo-timeline-canvas"
    )?.offsetWidth ?? document.body.offsetWidth;
    return Math.max(1, d - u);
  }, n = () => typeof r == "number" ? Ot(r, e) : lA(r, e), i = t() / n(), s = e * i;
  return {
    segments: 5,
    index: k1(Tn, (c) => c.zoom > s),
    zoom: s,
    unit: 1 / s
  };
}
function q7(r) {
  return Tn[r];
}
function iA(r) {
  return sA(r) || Tn[0];
}
const sA = (r) => {
  const e = Tn.filter(
    (n) => n.zoom < r.zoom
  );
  return e.length === 0 ? null : e.reduce(
    (n, i) => i.zoom > n.zoom ? i : n
  );
}, oA = (r) => {
  const e = Tn.filter(
    (n) => n.zoom > r.zoom
  );
  return e.length === 0 ? null : e.reduce(
    (n, i) => i.zoom < n.zoom ? i : n
  );
};
function aA(r) {
  return oA(r) || Tn[Tn.length - 1];
}
function K7(r) {
  const e = Tn.at(-1), t = r === e, i = cA(r) - (t ? 1 : 2);
  return Math.max(0, i);
}
function cA(r) {
  const e = k1(Tn, (t) => t.zoom > r.zoom);
  return Math.min(Tn.length - 1, e);
}
function Ot(r, e = 1, t = 1) {
  const n = Vl * e;
  return r * (60 / 1e3) * n / t;
}
function Ji(r, e = 1) {
  const t = Vl * e;
  return r / t * QI;
}
function lA(r, e = 1) {
  return Ot(r, e);
}
const Z7 = Math.floor(Math.random() * 1e3) + 1;
function O1(r, e = 1) {
  const t = [], n = Math.floor(e), i = (s, a) => {
    for (const c of s)
      Array.isArray(c) && a < n ? i(c, a + 1) : t.push(c);
  };
  return i(r, 0), t;
}
function I1(r, e) {
  const t = e.sort((i, s) => i.tempIndex - s.tempIndex), n = [];
  for (const i of t)
    i.tempIndex < 0 && n.push(i);
  n.push(r);
  for (const i of t)
    i.tempIndex >= 0 && n.push(i);
  return n;
}
const Ev = {
  id: "font_UwdNKSyVq2iiMiuHSRRsUIOu",
  family: "Roboto",
  fullName: "Roboto Bold",
  postScriptName: "Roboto-Bold",
  preview: "https://ik.imagekit.io/lh/fonts/v2/5zQgS86djScKA0ri67BBCqW7.png",
  style: "Roboto-Bold",
  url: "https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmWUlvAx05IsDqlA.ttf",
  category: "sans-serif",
  createdAt: "2023-06-20T04:42:55.909Z",
  updatedAt: "2023-06-20T04:42:55.909Z",
  userId: null
}, uA = (r) => {
  const e = r.map(
    (t) => new FontFace(t.fontFamily, `url(${t.fontUrl})`).load()
    // .catch((error: unknown) => error),
  );
  return e.length === 0 ? Promise.resolve(!0) : new Promise((t, n) => {
    Promise.all(e).then((i) => {
      i.forEach((s) => {
        s instanceof FontFace && s.family && (document.fonts.add(s), t(!0));
      });
    }).catch((i) => {
      n(i);
    });
  });
}, kv = (r) => {
  let e;
  const t = /* @__PURE__ */ new Set(), n = (h, d) => {
    const p = typeof h == "function" ? h(e) : h;
    if (!Object.is(p, e)) {
      const g = e;
      e = d ?? (typeof p != "object" || p === null) ? p : Object.assign({}, e, p), t.forEach((v) => v(e, g));
    }
  }, i = () => e, c = { setState: n, getState: i, getInitialState: () => u, subscribe: (h) => (t.add(h), () => t.delete(h)) }, u = e = r(n, i, c);
  return c;
}, hA = (r) => r ? kv(r) : kv, dA = (r) => r;
function fA(r, e = dA) {
  const t = Ce.useSyncExternalStore(
    r.subscribe,
    () => e(r.getState()),
    () => e(r.getInitialState())
  );
  return Ce.useDebugValue(t), t;
}
const Ov = (r) => {
  const e = hA(r), t = (n) => fA(e, n);
  return Object.assign(t, e), t;
}, A1 = (r) => r ? Ov(r) : Ov, Qi = A1((r) => ({
  timeline: null,
  size: {
    width: 1080,
    height: 1920
  },
  duration: 5e3,
  fps: 30,
  scale: {
    // 1x distance (second 0 to second 5, 5 segments).
    index: 7,
    unit: 300,
    zoom: 1 / 300,
    segments: 5
  },
  scroll: {
    left: 0,
    top: 0
  },
  playerRef: null,
  activeIds: [],
  targetIds: [],
  tracks: [],
  trackItemIds: [],
  transitionIds: [],
  transitionsMap: {},
  trackItemDetailsMap: {},
  trackItemsMap: {},
  setTimeline: (e) => {
    r(() => ({
      timeline: e
    }));
  },
  setScale: (e) => {
    r(() => ({
      scale: e
    }));
  },
  setScroll: (e) => {
    r(() => ({
      scroll: e
    }));
  },
  setState: async (e) => {
    r({ ...e });
  },
  setPlayerRef: (e) => {
    r({ playerRef: e });
  }
}));
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const pA = (r) => r.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), M1 = (...r) => r.filter((e, t, n) => !!e && e.trim() !== "" && n.indexOf(e) === t).join(" ").trim();
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var gA = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const mA = Bt(
  ({
    color: r = "currentColor",
    size: e = 24,
    strokeWidth: t = 2,
    absoluteStrokeWidth: n,
    className: i = "",
    children: s,
    iconNode: a,
    ...c
  }, u) => ud(
    "svg",
    {
      ref: u,
      ...gA,
      width: e,
      height: e,
      stroke: r,
      strokeWidth: n ? Number(t) * 24 / Number(e) : t,
      className: M1("lucide", i),
      ...c
    },
    [
      ...a.map(([h, d]) => ud(h, d)),
      ...Array.isArray(s) ? s : [s]
    ]
  )
);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const dn = (r, e) => {
  const t = Bt(
    ({ className: n, ...i }, s) => ud(mA, {
      ref: s,
      iconNode: e,
      className: M1(`lucide-${pA(r)}`, n),
      ...i
    })
  );
  return t.displayName = `${r}`, t;
};
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const vA = dn("Music", [
  ["path", { d: "M9 18V5l12-2v13", key: "1jmyc2" }],
  ["circle", { cx: "6", cy: "18", r: "3", key: "fqmcym" }],
  ["circle", { cx: "18", cy: "16", r: "3", key: "1hluhg" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const yA = dn("Pause", [
  ["rect", { x: "14", y: "4", width: "4", height: "16", rx: "1", key: "zuxfzm" }],
  ["rect", { x: "6", y: "4", width: "4", height: "16", rx: "1", key: "1okwgv" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const bA = dn("Play", [
  ["polygon", { points: "6 3 20 12 6 21 6 3", key: "1oa8hb" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const wA = dn("SkipBack", [
  ["polygon", { points: "19 20 9 12 19 4 19 20", key: "o2sva" }],
  ["line", { x1: "5", x2: "5", y1: "19", y2: "5", key: "1ocqjk" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const xA = dn("SkipForward", [
  ["polygon", { points: "5 4 15 12 5 20 5 4", key: "16p6eg" }],
  ["line", { x1: "19", x2: "19", y1: "5", y2: "19", key: "futhcm" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Iv = dn("SquareSplitHorizontal", [
  ["path", { d: "M8 19H5c-1 0-2-1-2-2V7c0-1 1-2 2-2h3", key: "lubmu8" }],
  ["path", { d: "M16 5h3c1 0 2 1 2 2v10c0 1-1 2-2 2h-3", key: "1ag34g" }],
  ["line", { x1: "12", x2: "12", y1: "4", y2: "20", key: "1tx1rr" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const _A = dn("Trash", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Av = dn("Upload", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "17 8 12 3 7 8", key: "t8dd8p" }],
  ["line", { x1: "12", x2: "12", y1: "3", y2: "15", key: "widbto" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SA = dn("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CA = dn("ZoomIn", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "11", x2: "11", y1: "8", y2: "14", key: "1vmskp" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]);
/**
 * @license lucide-react v0.456.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const TA = dn("ZoomOut", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]), kf = (r) => {
  const e = se(
    (n) => {
      if (!r?.current)
        return () => {
        };
      const i = () => {
        n();
      };
      return r.current.addEventListener("frameupdate", i), () => {
        r.current && r.current.removeEventListener("frameupdate", i);
      };
    },
    [r]
  );
  return _5(
    e,
    () => r?.current?.getCurrentFrame() ?? 0,
    () => 0
  );
}, zl = () => {
  const [r, e] = he(!1);
  return ue(() => {
    const n = We.subject.pipe(
      $i(({ key: i }) => i.startsWith(SI))
    ).subscribe((i) => {
      i.key === b1 ? e(!0) : i.key === sl && e(!1);
    });
    return () => n.unsubscribe();
  }, []), r;
}, EA = () => {
  const [r, e] = he(!1), { duration: t, fps: n, scale: i, playerRef: s, activeIds: a } = Qi(), c = kf(s), u = () => {
    We.dispatch(f1);
  }, h = () => {
    We.dispatch(g1, {
      payload: {},
      options: {
        time: nA()
      }
    });
  }, d = (v) => {
    We.dispatch(y1, {
      payload: {
        scale: v
      }
    });
  }, p = () => {
    We.dispatch(vI);
  }, g = () => {
    We.dispatch(yI);
  };
  return ue(() => (s?.current?.addEventListener("play", () => {
    e(!0);
  }), s?.current?.addEventListener("pause", () => {
    e(!1);
  }), () => {
    s?.current?.removeEventListener("play", () => {
      e(!0);
    }), s?.current?.removeEventListener("pause", () => {
      e(!1);
    });
  }), [s]), /* @__PURE__ */ b.jsx(
    "div",
    {
      style: {
        position: "relative",
        height: "50px",
        boxShadow: "inset 0 1px 0 0 #27272a",
        flex: "none"
      },
      className: "bg-background",
      children: /* @__PURE__ */ b.jsx(
        "div",
        {
          style: {
            position: "absolute",
            height: 50,
            width: "100%",
            display: "flex",
            alignItems: "center"
          },
          children: /* @__PURE__ */ b.jsxs(
            "div",
            {
              style: {
                height: 36,
                width: "100%",
                display: "grid",
                gridTemplateColumns: "1fr 260px 1fr",
                alignItems: "center"
              },
              children: [
                /* @__PURE__ */ b.jsxs("div", { className: "flex px-2", children: [
                  /* @__PURE__ */ b.jsxs(
                    nr,
                    {
                      disabled: !a.length,
                      onClick: u,
                      variant: "ghost",
                      size: "sm",
                      className: "flex items-center gap-1 px-2",
                      children: [
                        /* @__PURE__ */ b.jsx(_A, { size: 14 }),
                        " Delete"
                      ]
                    }
                  ),
                  /* @__PURE__ */ b.jsxs(
                    nr,
                    {
                      disabled: !a.length,
                      onClick: h,
                      variant: "ghost",
                      size: "sm",
                      className: "flex items-center gap-1 px-2",
                      children: [
                        /* @__PURE__ */ b.jsx(Iv, { size: 15 }),
                        " Split"
                      ]
                    }
                  ),
                  /* @__PURE__ */ b.jsxs(
                    nr,
                    {
                      disabled: !a.length,
                      onClick: () => {
                        We.dispatch(p1);
                      },
                      variant: "ghost",
                      size: "sm",
                      className: "flex items-center gap-1 px-2",
                      children: [
                        /* @__PURE__ */ b.jsx(Iv, { size: 15 }),
                        " Clone"
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ b.jsxs("div", { className: "flex items-center justify-center", children: [
                  /* @__PURE__ */ b.jsxs("div", { children: [
                    /* @__PURE__ */ b.jsx(
                      nr,
                      {
                        onClick: u,
                        variant: "ghost",
                        size: "icon",
                        children: /* @__PURE__ */ b.jsx(wA, { size: 14 })
                      }
                    ),
                    /* @__PURE__ */ b.jsx(
                      nr,
                      {
                        onClick: () => {
                          if (r)
                            return g();
                          p();
                        },
                        variant: "ghost",
                        size: "icon",
                        children: r ? /* @__PURE__ */ b.jsx(yA, { size: 14 }) : /* @__PURE__ */ b.jsx(bA, { size: 14 })
                      }
                    ),
                    /* @__PURE__ */ b.jsx(
                      nr,
                      {
                        onClick: h,
                        variant: "ghost",
                        size: "icon",
                        children: /* @__PURE__ */ b.jsx(xA, { size: 14 })
                      }
                    )
                  ] }),
                  /* @__PURE__ */ b.jsxs(
                    "div",
                    {
                      className: "text-xs font-light",
                      style: {
                        display: "grid",
                        alignItems: "center",
                        gridTemplateColumns: "54px 4px 54px",
                        paddingTop: "2px",
                        justifyContent: "center"
                      },
                      children: [
                        /* @__PURE__ */ b.jsx(
                          "div",
                          {
                            className: "font-medium text-zinc-200",
                            style: {
                              display: "flex",
                              justifyContent: "center"
                            },
                            "data-current-time": c / n,
                            id: "video-current-time",
                            children: tA({ frame: c }, { fps: n })
                          }
                        ),
                        /* @__PURE__ */ b.jsx("span", { children: "/" }),
                        /* @__PURE__ */ b.jsx(
                          "div",
                          {
                            className: "text-muted-foreground",
                            style: {
                              display: "flex",
                              justifyContent: "center"
                            },
                            children: rA({ time: t })
                          }
                        )
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ b.jsx(
                  kA,
                  {
                    scale: i,
                    onChangeTimelineScale: d,
                    duration: t
                  }
                )
              ]
            }
          )
        }
      )
    }
  );
}, kA = ({
  scale: r,
  onChangeTimelineScale: e,
  duration: t
}) => {
  const n = () => {
    const s = iA(r);
    e(s);
  }, i = () => {
    const s = aA(r);
    e(s);
  };
  return /* @__PURE__ */ b.jsx("div", { className: "flex items-center justify-end", children: /* @__PURE__ */ b.jsxs("div", { className: "flex border-l border-border pl-4 pr-2", children: [
    /* @__PURE__ */ b.jsx(
      nr,
      {
        size: "icon",
        variant: "ghost",
        onClick: n,
        disabled: r.index === 0,
        children: /* @__PURE__ */ b.jsx(TA, { size: 16 })
      }
    ),
    /* @__PURE__ */ b.jsx(
      nr,
      {
        size: "icon",
        variant: "ghost",
        onClick: i,
        disabled: r.index === 20,
        children: /* @__PURE__ */ b.jsx(CA, { size: 16 })
      }
    )
  ] }) });
}, OA = [
  {
    id: "1",
    details: {
      src: "https://cdn.designcombo.dev/audio/Dawn%20of%20change.mp3",
      text: "Voiceover"
    },
    name: "Dawn of change",
    type: "audio",
    metadata: {
      author: "Roman Senyk"
    },
    display: { from: 3e3 }
  },
  {
    id: "2",
    details: {
      src: "https://cdn.designcombo.dev/audio/Hope.mp3"
    },
    name: "Hope",
    type: "audio",
    metadata: {
      author: "Hugo Dujardin"
    }
  },
  {
    id: "3",
    details: {
      src: "https://cdn.designcombo.dev/audio/Tenderness.mp3"
    },
    name: "Tenderness",
    type: "audio",
    metadata: {
      author: "Benjamin Tissot"
    }
  },
  {
    id: "4",
    details: {
      src: "https://cdn.designcombo.dev/audio/Piano%20Moment.mp3"
    },
    name: "Piano moment",
    type: "audio",
    metadata: {
      author: "Benjamin Tissot"
    }
  }
], IA = [
  {
    id: "1",
    details: { src: "https://ik.imagekit.io/wombo/images/img1.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img1.jpg?tr=w-190",
    type: "image"
  },
  {
    id: "2",
    details: { src: "https://ik.imagekit.io/wombo/images/img2.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img2.jpg?tr=w-190",
    type: "image"
  },
  {
    id: "3",
    details: { src: "https://ik.imagekit.io/wombo/images/img3.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img3.jpg?tr=w-190",
    type: "image"
  },
  {
    id: "4",
    details: { src: "https://ik.imagekit.io/wombo/images/img4.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img4.jpg?tr=w-190",
    type: "image"
  },
  {
    id: "5",
    details: { src: "https://ik.imagekit.io/wombo/images/img5.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img5.jpg?tr=w-190",
    type: "image"
  },
  ,
  {
    id: "6",
    details: { src: "https://ik.imagekit.io/wombo/images/img6.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img6.jpg?tr=w-190",
    type: "image"
  },
  {
    id: "7",
    details: { src: "https://ik.imagekit.io/wombo/images/img7.jpg" },
    preview: "https://ik.imagekit.io/wombo/images/img7.jpg?tr=w-190",
    type: "image"
  }
], AA = [
  {
    id: "1",
    details: {
      src: "https://cdn.designcombo.dev/videos/demo-video-1.mp4",
      text: "Scene"
    },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-1.png",
    duration: 17e3,
    display: { from: 3e3 }
  },
  {
    id: "2",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-2.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-2.png"
  },
  {
    id: "3",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-3.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-3.png",
    duration: 2e4
  },
  {
    id: "4",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-4.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-4.png",
    duration: 2e4
  },
  {
    id: "5",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-5.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-5.png",
    duration: 23e3
  },
  {
    id: "6",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-6.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-6.png",
    duration: 1e4
  },
  {
    id: "7",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-7.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-7.png",
    duration: 12e3
  },
  {
    id: "8",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-8.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-8.png",
    duration: 15e3
  },
  {
    id: "9",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-9.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-9.png",
    duration: 15e3
  },
  {
    id: "10",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-10.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-10.png",
    duration: 5e3
  },
  {
    id: "11",
    details: { src: "https://cdn.designcombo.dev/videos/demo-video-11.mp4" },
    type: "video",
    preview: "https://cdn.designcombo.dev/thumbnails/demo-video-s-11.png",
    duration: 5e3
  }
], MA = [
  {
    id: "1",
    kind: "none",
    duration: 0,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/transition-none.png",
    type: "transition"
  },
  {
    id: "2",
    kind: "fade",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/fade.webp",
    type: "transition"
  },
  {
    id: "3",
    kind: "slide",
    name: "slide up",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/slide-up.webp",
    type: "transition",
    direction: "from-bottom"
  },
  {
    id: "4",
    kind: "slide",
    name: "slide down",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/slide-down.webp",
    type: "transition",
    direction: "from-top"
  },
  {
    id: "5",
    kind: "slide",
    name: "slide left",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/slide-left.webp",
    type: "transition",
    direction: "from-right"
  },
  {
    id: "6",
    kind: "slide",
    name: "slide right",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/slide-right.webp",
    type: "transition",
    direction: "from-left"
  },
  {
    id: "7",
    kind: "wipe",
    name: "wipe up",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/wipe-up.webp",
    type: "transition",
    direction: "from-bottom"
  },
  {
    id: "8",
    kind: "wipe",
    name: "wipe down",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/wipe-down.webp",
    type: "transition",
    direction: "from-top"
  },
  {
    id: "9",
    kind: "wipe",
    name: "wipe left",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/wipe-left.webp",
    type: "transition",
    direction: "from-right"
  },
  {
    id: "10",
    kind: "wipe",
    name: "wipe right",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/wipe-right.webp",
    type: "transition",
    direction: "from-left"
  },
  {
    id: "11",
    kind: "flip",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/flip.webp",
    type: "transition"
  },
  {
    id: "12",
    kind: "clockWipe",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/clock-wipe.webp",
    type: "transition"
  },
  {
    id: "13",
    kind: "star",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/star.webp",
    type: "transition"
  },
  {
    id: "14",
    kind: "circle",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/circle.webp",
    type: "transition"
  },
  {
    id: "15",
    kind: "rectangle",
    duration: 0.5,
    preview: "https://ik.imagekit.io/wombo/transitions-v2/rectangle.webp",
    type: "transition"
  }
], J7 = [
  {
    id: "1",
    src: "https://ik.imagekit.io/snapmotion/upload-video-1.mp4",
    type: "video"
  },
  {
    id: "2",
    src: "https://ik.imagekit.io/snapmotion/upload-video-2.mp4",
    type: "video"
  },
  {
    id: "3",
    src: "https://ik.imagekit.io/snapmotion/upload-video-3.mp4",
    type: "video"
  }
], PA = () => {
  const r = zl();
  return /* @__PURE__ */ b.jsxs("div", { className: "flex flex-1 flex-col overflow-auto", children: [
    /* @__PURE__ */ b.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Transitions" }),
    /* @__PURE__ */ b.jsx(Qs, { children: /* @__PURE__ */ b.jsx("div", { className: "grid grid-cols-3 gap-2 px-4", children: MA.map((e, t) => /* @__PURE__ */ b.jsx(
      DA,
      {
        transition: e,
        shouldDisplayPreview: !r
      },
      t
    )) }) })
  ] });
}, DA = ({
  transition: r,
  shouldDisplayPreview: e
}) => {
  const t = Ce.useMemo(
    () => ({
      backgroundImage: `url(${r.preview})`,
      backgroundSize: "cover",
      width: "70px",
      height: "70px"
    }),
    [r.preview]
  );
  return /* @__PURE__ */ b.jsx(
    Ll,
    {
      data: r,
      renderCustomPreview: /* @__PURE__ */ b.jsx("div", { style: t }),
      shouldDisplayPreview: e,
      children: /* @__PURE__ */ b.jsxs("div", { children: [
        /* @__PURE__ */ b.jsx("div", { children: /* @__PURE__ */ b.jsx(
          "div",
          {
            style: t,
            draggable: !1
          }
        ) }),
        /* @__PURE__ */ b.jsx("div", { className: "flex h-6 items-center overflow-ellipsis text-nowrap text-[12px] capitalize text-muted-foreground", children: r.name || r.type })
      ] })
    }
  );
}, RA = () => {
  const r = () => {
    We.dispatch(d1, {
      payload: {
        id: Ft(),
        display: {
          from: 0,
          to: 5e3
        },
        details: {
          text: "Heading and some body",
          fontSize: 120,
          width: 600,
          fontUrl: Ev.url,
          fontFamily: Ev.postScriptName,
          color: "#ffffff",
          wordWrap: "break-word",
          textAlign: "center",
          borderWidth: 0,
          borderColor: "#000000",
          boxShadow: {
            color: "#ffffff",
            x: 0,
            y: 0,
            blur: 0
          }
        }
      },
      options: {}
    });
  };
  return /* @__PURE__ */ b.jsxs("div", { className: "flex flex-1 flex-col", children: [
    /* @__PURE__ */ b.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Text" }),
    /* @__PURE__ */ b.jsx("div", { className: "flex flex-col gap-2 px-4", children: /* @__PURE__ */ b.jsx(
      nr,
      {
        draggable: !1,
        onClick: r,
        variant: "secondary",
        className: "w-full",
        children: "Add text"
      }
    ) })
  ] });
}, jA = () => {
  const r = be(null), e = (n) => {
    t(n);
  }, t = async (n) => {
    const i = n[0].type;
    i.includes("audio") && We.dispatch(ma, {
      payload: {
        id: Ft(),
        details: {
          src: URL.createObjectURL(n[0]),
          volume: 50
        }
      }
    }), i.includes("video") && We.dispatch(ga, {
      payload: {
        id: Ft(),
        display: {
          from: 2e3,
          to: 7e3
        },
        details: {
          src: URL.createObjectURL(n[0]),
          name: n[0].name
        }
      }
    }), i.includes("image") && We.dispatch(va, {
      payload: {
        id: Ft(),
        details: {
          src: URL.createObjectURL(n[0])
        }
      }
    });
  };
  return /* @__PURE__ */ b.jsxs("div", { className: "flex flex-1 flex-col", children: [
    /* @__PURE__ */ b.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Your media" }),
    /* @__PURE__ */ b.jsx(
      "input",
      {
        ref: r,
        id: "file-upload-handle",
        type: "file",
        accept: "audio/*,video/*,image/*",
        onChange: (n) => e(Array.from(n.target.files || [])),
        className: "hidden"
      }
    ),
    /* @__PURE__ */ b.jsx("div", { className: "px-4 py-2", children: /* @__PURE__ */ b.jsx("div", { children: /* @__PURE__ */ b.jsxs(
      gI,
      {
        defaultValue: "projects",
        className: "w-full",
        children: [
          /* @__PURE__ */ b.jsxs(h1, { className: "grid w-full grid-cols-2", children: [
            /* @__PURE__ */ b.jsx(wd, { value: "projects", children: "Project" }),
            /* @__PURE__ */ b.jsx(wd, { value: "workspace", children: "Workspace" })
          ] }),
          /* @__PURE__ */ b.jsxs(xd, { value: "projects", children: [
            /* @__PURE__ */ b.jsxs(
              nr,
              {
                onClick: () => {
                  r.current?.click();
                },
                className: "flex w-full gap-2",
                variant: "secondary",
                children: [
                  /* @__PURE__ */ b.jsx(Av, { size: 16 }),
                  " Upload"
                ]
              }
            ),
            /* @__PURE__ */ b.jsx("div", {})
          ] }),
          /* @__PURE__ */ b.jsx(xd, { value: "workspace", children: /* @__PURE__ */ b.jsxs(
            nr,
            {
              onClick: () => {
                r.current?.click();
              },
              className: "flex w-full gap-2",
              variant: "secondary",
              children: [
                /* @__PURE__ */ b.jsx(Av, { size: 16 }),
                " Upload"
              ]
            }
          ) })
        ]
      }
    ) }) }),
    /* @__PURE__ */ b.jsx(Qs, { children: /* @__PURE__ */ b.jsx("div", { className: "masonry-sm px-4" }) })
  ] });
}, FA = () => {
  const r = zl(), e = (t) => {
    We.dispatch(ma, {
      payload: t,
      options: {}
    });
  };
  return /* @__PURE__ */ b.jsxs("div", { className: "flex flex-1 flex-col", children: [
    /* @__PURE__ */ b.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Audios" }),
    /* @__PURE__ */ b.jsx(Qs, { children: /* @__PURE__ */ b.jsx("div", { className: "flex flex-col px-2", children: OA.map((t, n) => /* @__PURE__ */ b.jsx(
      LA,
      {
        shouldDisplayPreview: !r,
        handleAddAudio: e,
        audio: t
      },
      n
    )) }) })
  ] });
}, LA = ({
  handleAddAudio: r,
  audio: e,
  shouldDisplayPreview: t
}) => {
  const n = Ce.useMemo(
    () => ({
      backgroundImage: "url(https://cdn.designcombo.dev/thumbnails/music-preview.png)",
      backgroundSize: "cover",
      width: "70px",
      height: "70px"
    }),
    []
  );
  return /* @__PURE__ */ b.jsx(
    Ll,
    {
      data: e,
      renderCustomPreview: /* @__PURE__ */ b.jsx("div", { style: n }),
      shouldDisplayPreview: t,
      children: /* @__PURE__ */ b.jsxs(
        "div",
        {
          draggable: !1,
          onClick: () => r(e),
          style: {
            display: "grid",
            gridTemplateColumns: "48px 1fr"
          },
          className: "flex cursor-pointer gap-4 px-2 py-1 text-sm hover:bg-zinc-800/70",
          children: [
            /* @__PURE__ */ b.jsx("div", { className: "flex h-12 items-center justify-center bg-zinc-800", children: /* @__PURE__ */ b.jsx(vA, { width: 16 }) }),
            /* @__PURE__ */ b.jsxs("div", { className: "flex flex-col justify-center", children: [
              /* @__PURE__ */ b.jsx("div", { children: e.name }),
              /* @__PURE__ */ b.jsx("div", { className: "text-zinc-400", children: e.metadata?.author })
            ] })
          ]
        }
      )
    }
  );
}, NA = () => {
  const r = zl(), e = (t) => {
    We.dispatch(va, {
      payload: t,
      options: {
        trackId: "main"
      }
    });
  };
  return /* @__PURE__ */ b.jsxs("div", { className: "flex flex-1 flex-col", children: [
    /* @__PURE__ */ b.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Photos" }),
    /* @__PURE__ */ b.jsx(Qs, { children: /* @__PURE__ */ b.jsx("div", { className: "masonry-sm px-4", children: IA.map((t, n) => /* @__PURE__ */ b.jsx(
      BA,
      {
        image: t,
        shouldDisplayPreview: !r,
        handleAddImage: e
      },
      n
    )) }) })
  ] });
}, BA = ({
  handleAddImage: r,
  image: e,
  shouldDisplayPreview: t
}) => {
  const n = Ce.useMemo(
    () => ({
      backgroundImage: `url(${e.preview})`,
      backgroundSize: "cover",
      width: "80px",
      height: "80px"
    }),
    [e.preview]
  );
  return /* @__PURE__ */ b.jsx(
    Ll,
    {
      data: e,
      renderCustomPreview: /* @__PURE__ */ b.jsx("div", { style: n }),
      shouldDisplayPreview: t,
      children: /* @__PURE__ */ b.jsx(
        "div",
        {
          onClick: () => r({
            id: Ft(),
            details: {
              src: e.details.src
            }
          }),
          className: "flex w-full items-center justify-center overflow-hidden bg-background pb-2",
          children: /* @__PURE__ */ b.jsx(
            "img",
            {
              draggable: !1,
              src: e.preview,
              className: "h-full w-full rounded-md object-cover",
              alt: "image"
            }
          )
        }
      )
    }
  );
}, VA = () => {
  const r = zl(), e = (t) => {
    We.dispatch(ga, {
      payload: t,
      options: {
        resourceId: "main"
      }
    });
  };
  return /* @__PURE__ */ b.jsxs("div", { className: "flex flex-1 flex-col", children: [
    /* @__PURE__ */ b.jsx("div", { className: "text-text-primary flex h-12 flex-none items-center px-4 text-sm font-medium", children: "Videos" }),
    /* @__PURE__ */ b.jsx(Qs, { children: /* @__PURE__ */ b.jsx("div", { className: "masonry-sm px-4", children: AA.map((t, n) => /* @__PURE__ */ b.jsx(
      zA,
      {
        video: t,
        shouldDisplayPreview: !r,
        handleAddVideo: e
      },
      n
    )) }) })
  ] });
}, zA = ({
  handleAddVideo: r,
  video: e,
  shouldDisplayPreview: t
}) => {
  const n = Ce.useMemo(
    () => ({
      backgroundImage: `url(${e.preview})`,
      backgroundSize: "cover",
      width: "80px",
      height: "80px"
    }),
    [e.preview]
  );
  return /* @__PURE__ */ b.jsx(
    Ll,
    {
      data: e,
      renderCustomPreview: /* @__PURE__ */ b.jsx(
        "div",
        {
          style: n,
          className: "draggable"
        }
      ),
      shouldDisplayPreview: t,
      children: /* @__PURE__ */ b.jsx(
        "div",
        {
          onClick: () => r({
            ...e,
            id: Ft(),
            details: {
              src: e.details.src,
              ...e.details
            }
          }),
          className: "flex w-full items-center justify-center overflow-hidden bg-background pb-2",
          children: /* @__PURE__ */ b.jsx(
            "img",
            {
              draggable: !1,
              src: e.preview,
              className: "h-full w-full rounded-md object-cover",
              alt: "image"
            }
          )
        }
      )
    }
  );
}, P1 = A1((r) => ({
  activeMenuItem: null,
  showMenuItem: !1,
  cropTarget: null,
  showControlItem: !1,
  showToolboxItem: !1,
  activeToolboxItem: null,
  setCropTarget: (e) => r({ cropTarget: e }),
  setActiveMenuItem: (e) => r({ activeMenuItem: e }),
  setShowMenuItem: (e) => r({ showMenuItem: e }),
  setShowControlItem: (e) => r({ showControlItem: e }),
  setShowToolboxItem: (e) => r({ showToolboxItem: e }),
  setActiveToolboxItem: (e) => r({ activeToolboxItem: e })
})), WA = ({ children: r }) => {
  const { showMenuItem: e, setShowMenuItem: t } = P1(), n = () => {
    t(!1);
  };
  return /* @__PURE__ */ b.jsxs(
    "div",
    {
      style: {
        left: e ? "0" : "-100%",
        transition: "left 0.25s ease-in-out",
        zIndex: 200
      },
      className: "absolute top-1/2 mt-6 flex h-[calc(100%-32px-64px)] w-[340px] -translate-y-1/2 rounded-lg shadow-lg",
      children: [
        /* @__PURE__ */ b.jsx("div", { className: "w-[74px]" }),
        /* @__PURE__ */ b.jsxs("div", { className: "relative flex flex-1 bg-background/80 backdrop-blur-lg backdrop-filter", children: [
          /* @__PURE__ */ b.jsx(
            nr,
            {
              variant: "ghost",
              className: "absolute right-2 top-2 h-8 w-8 text-muted-foreground",
              size: "icon",
              children: /* @__PURE__ */ b.jsx(
                SA,
                {
                  width: 16,
                  onClick: n
                }
              )
            }
          ),
          r
        ] })
      ]
    }
  );
}, HA = () => {
  const { activeMenuItem: r } = P1();
  return r === "transitions" ? /* @__PURE__ */ b.jsx(PA, {}) : r === "texts" ? /* @__PURE__ */ b.jsx(RA, {}) : r === "videos" ? /* @__PURE__ */ b.jsx(VA, {}) : r === "audios" ? /* @__PURE__ */ b.jsx(FA, {}) : r === "images" ? /* @__PURE__ */ b.jsx(NA, {}) : r === "uploads" ? /* @__PURE__ */ b.jsx(jA, {}) : null;
}, Q7 = () => /* @__PURE__ */ b.jsx(WA, { children: /* @__PURE__ */ b.jsx(HA, {}) }), Mv = {
  redo: ({ ...r }) => /* @__PURE__ */ b.jsx(
    "svg",
    {
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...r,
      children: /* @__PURE__ */ b.jsx(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M14.2957 4.15721C13.9052 3.76669 13.9052 3.13352 14.2957 2.743C14.6862 2.35247 15.3194 2.35247 15.7099 2.743L20.953 7.98603C21.1387 8.16758 21.2539 8.42087 21.2539 8.70108C21.2539 8.70111 21.2539 8.70114 21.2539 8.70117C21.2539 8.70431 21.2539 8.70744 21.2539 8.71057C21.2518 8.93273 21.1773 9.13757 21.0528 9.30262C21.0249 9.33973 20.9942 9.37505 20.961 9.40828L15.7099 14.6593C15.3194 15.0499 14.6862 15.0499 14.2957 14.6593C13.9052 14.2688 13.9052 13.6357 14.2957 13.2451L17.8398 9.70108H9.22665C8.59943 9.70108 7.97836 9.82462 7.39888 10.0646C6.81941 10.3047 6.29289 10.6565 5.84938 11.1C5.40587 11.5435 5.05406 12.07 4.81403 12.6495C4.57401 13.229 4.45047 13.85 4.45047 14.4773C4.45047 15.1045 4.57401 15.7256 4.81403 16.305C5.05406 16.8845 5.40587 17.411 5.84938 17.8545C6.29289 18.298 6.81941 18.6498 7.39888 18.8899C7.97836 19.1299 8.59943 19.2534 9.22665 19.2534H12.9024C13.4547 19.2534 13.9024 19.7012 13.9024 20.2534C13.9024 20.8057 13.4547 21.2534 12.9024 21.2534H9.22665C8.33679 21.2534 7.45564 21.0782 6.63352 20.7376C5.81139 20.3971 5.06439 19.898 4.43517 19.2687C3.80594 18.6395 3.30681 17.8925 2.96627 17.0704C2.62574 16.2483 2.45047 15.3671 2.45047 14.4773C2.45047 13.5874 2.62574 12.7063 2.96627 11.8841C3.30681 11.062 3.80594 10.315 4.43517 9.68578C5.06439 9.05655 5.81139 8.55742 6.63352 8.21689C7.45564 7.87635 8.33679 7.70108 9.22665 7.70108H17.8396L14.2957 4.15721Z",
          fill: "currentColor"
        }
      )
    }
  ),
  undo: ({ ...r }) => /* @__PURE__ */ b.jsx(
    "svg",
    {
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...r,
      children: /* @__PURE__ */ b.jsx(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M9.60387 4.30711C9.99439 3.91659 9.99439 3.28342 9.60387 2.8929C9.21334 2.50238 8.58018 2.50237 8.18965 2.8929L2.8925 8.19004C2.70497 8.37758 2.59961 8.63193 2.59961 8.89715C2.59961 9.16237 2.70497 9.41672 2.8925 9.60426L8.18965 14.9014C8.58018 15.2919 9.21334 15.2919 9.60387 14.9014C9.99439 14.5109 9.99439 13.8777 9.60387 13.4872L5.86478 9.7481H15.1044C15.7383 9.7481 16.366 9.87295 16.9516 10.1155C17.5372 10.3581 18.0693 10.7136 18.5176 11.1619C18.9658 11.6101 19.3213 12.1422 19.5639 12.7278C19.8065 13.3134 19.9313 13.9411 19.9313 14.575C19.9313 15.2088 19.8065 15.8365 19.5639 16.4221C19.3213 17.0077 18.9658 17.5398 18.5176 17.9881C18.0693 18.4363 17.5372 18.7918 16.9516 19.0344C16.366 19.277 15.7383 19.4018 15.1044 19.4018H11.3964C10.8442 19.4018 10.3964 19.8495 10.3964 20.4018C10.3964 20.9541 10.8442 21.4018 11.3964 21.4018H15.1044C16.001 21.4018 16.8887 21.2252 17.717 20.8822C18.5452 20.5391 19.2978 20.0362 19.9318 19.4023C20.5657 18.7683 21.0686 18.0158 21.4116 17.1875C21.7547 16.3592 21.9313 15.4715 21.9313 14.575C21.9313 13.6784 21.7547 12.7907 21.4116 11.9624C21.0686 11.1342 20.5657 10.3816 19.9318 9.74764C19.2978 9.11371 18.5452 8.61085 17.717 8.26777C16.8887 7.92469 16.001 7.7481 15.1044 7.7481H6.16287L9.60387 4.30711Z",
          fill: "currentColor"
        }
      )
    }
  )
};
function e9() {
  const r = () => {
    We.dispatch(m1);
  }, e = () => {
    We.dispatch(v1);
  };
  return /* @__PURE__ */ b.jsx(
    "div",
    {
      style: {
        display: "grid",
        gridTemplateColumns: "320px 1fr 320px"
      },
      className: "pointer-events-none absolute left-0 right-0 top-0 z-[205] flex h-[72px] items-center px-2",
      children: /* @__PURE__ */ b.jsxs("div", { className: "pointer-events-auto flex h-14 items-center gap-2", children: [
        /* @__PURE__ */ b.jsx("div", { className: "flex h-12 w-12 items-center justify-center rounded-md bg-background" }),
        /* @__PURE__ */ b.jsxs("div", { className: "flex h-12 items-center bg-background px-1.5", children: [
          /* @__PURE__ */ b.jsx(
            nr,
            {
              onClick: r,
              className: "text-muted-foreground",
              variant: "ghost",
              size: "icon",
              children: /* @__PURE__ */ b.jsx(Mv.undo, { width: 20 })
            }
          ),
          /* @__PURE__ */ b.jsx(
            nr,
            {
              onClick: e,
              className: "text-muted-foreground",
              variant: "ghost",
              size: "icon",
              children: /* @__PURE__ */ b.jsx(Mv.redo, { width: 20 })
            }
          )
        ] })
      ] })
    }
  );
}
var UA = Object.defineProperty, D1 = (r, e) => {
  for (var t in e)
    UA(r, t, {
      get: e[t],
      enumerable: !0,
      configurable: !0,
      set: (n) => e[t] = () => n
    });
};
if (typeof It != "function") {
  const r = [
    'Remotion requires React.createContext, but it is "undefined".',
    'If you are in a React Server Component, turn it into a client component by adding "use client" at the top of the file.',
    "",
    "Before:",
    '  import {useCurrentFrame} from "remotion";',
    "",
    "After:",
    '  "use client";',
    '  import {useCurrentFrame} from "remotion";'
  ];
  throw new Error(r.join(`
`));
}
function Pv() {
  return ["NOD", "E_EN", "V"].join("");
}
var Dv = () => ["e", "nv"].join(""), At = () => {
  const r = typeof window < "u" && window.remotion_isPlayer, e = typeof window < "u" && typeof window.process < "u" && typeof window.process.env < "u" && (window.process[Dv()][Pv()] === "test" || window.process[Dv()][Pv()] === "production" && typeof window < "u" && typeof window.remotion_puppeteerTimeout < "u");
  return {
    isStudio: typeof window < "u" && window.remotion_isStudio,
    isRendering: e,
    isPlayer: r
  };
}, $A = Ce.createElement, R1 = [], j1 = () => {
  if (!At().isStudio)
    return;
  const r = new Proxy($A, {
    apply(e, t, n) {
      if (R1.includes(n[0])) {
        const [i, s, ...a] = n, c = {
          ...s ?? {},
          stack: new Error().stack
        };
        return Reflect.apply(e, t, [i, c, ...a]);
      }
      return Reflect.apply(e, t, n);
    }
  });
  Ce.createElement = r;
}, ya = (r) => {
  R1.push(r), j1();
}, F1 = It(!1), YA = ({
  children: r
}) => /* @__PURE__ */ b.jsx(F1.Provider, {
  value: !0,
  children: r
}), Of = () => me(F1);
function Wl(r) {
  return !!r;
}
var _c = "4.0.229", XA = () => {
  if (typeof globalThis > "u")
    return;
  const r = globalThis.remotion_imported || typeof window < "u" && window.remotion_imported;
  if (r) {
    if (r === _c)
      return;
    throw new TypeError(`🚨 Multiple versions of Remotion detected: ${[
      _c,
      typeof r == "string" ? r : "an older version"
    ].filter(Wl).join(" and ")}. This will cause things to break in an unexpected way.
Check that all your Remotion packages are on the same version. If your dependencies depend on Remotion, make them peer dependencies. You can also run \`npx remotion versions\` from your terminal to see which versions are mismatching.`);
  }
  globalThis.remotion_imported = _c, typeof window < "u" && (window.remotion_imported = _c);
}, GA = (r, e) => {
  const { style: t, ...n } = r, i = ee(() => ({
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    width: "100%",
    height: "100%",
    display: "flex",
    flexDirection: "column",
    ...t
  }), [t]);
  return /* @__PURE__ */ b.jsx("div", {
    ref: e,
    style: i,
    ...n
  });
}, $o = Bt(GA), Zt = It(null), to = Ce.createContext({
  registerSequence: () => {
    throw new Error("SequenceManagerContext not initialized");
  },
  unregisterSequence: () => {
    throw new Error("SequenceManagerContext not initialized");
  },
  sequences: []
}), ba = Ce.createContext({
  hidden: {},
  setHidden: () => {
    throw new Error("SequenceVisibilityToggle not initialized");
  }
}), qA = ({ children: r }) => {
  const [e, t] = he([]), [n, i] = he({}), s = se((h) => {
    t((d) => [...d, h]);
  }, []), a = se((h) => {
    t((d) => d.filter((p) => p.id !== h));
  }, []), c = ee(() => ({
    registerSequence: s,
    sequences: e,
    unregisterSequence: a
  }), [s, e, a]), u = ee(() => ({
    hidden: n,
    setHidden: i
  }), [n]);
  return /* @__PURE__ */ b.jsx(to.Provider, {
    value: c,
    children: /* @__PURE__ */ b.jsx(ba.Provider, {
      value: u,
      children: r
    })
  });
}, ro = It({
  getNonce: () => 0,
  fastRefreshes: 0
}), If = () => {
  const r = me(ro), [e, t] = he(() => r.getNonce()), n = be(r);
  return ue(() => {
    n.current !== r && (n.current = r, t(r.getNonce));
  }, [r]), e;
}, L1 = {};
D1(L1, {
  useTimelineSetFrame: () => K1,
  useTimelinePosition: () => ls,
  usePlayingState: () => Df,
  persistCurrentFrame: () => X1,
  getInitialFrameState: () => G1,
  getFrameForComposition: () => q1,
  TimelineContext: () => an,
  SetTimelineContext: () => no
});
var xi = It({
  compositions: [],
  registerComposition: () => {
  },
  unregisterComposition: () => {
  },
  registerFolder: () => {
  },
  unregisterFolder: () => {
  },
  setCurrentCompositionMetadata: () => {
  },
  updateCompositionDefaultProps: () => {
  },
  folders: [],
  currentCompositionMetadata: null,
  canvasContent: null,
  setCanvasContent: () => {
  }
}), Hl = It({
  props: {},
  updateProps: () => {
    throw new Error("Not implemented");
  },
  resetUnsaved: () => {
    throw new Error("Not implemented");
  }
}), N1 = Ce.createRef(), B1 = ({ children: r }) => {
  const [e, t] = Ce.useState({}), n = se(({
    defaultProps: a,
    id: c,
    newProps: u
  }) => {
    t((h) => ({
      ...h,
      [c]: typeof u == "function" ? u(h[c] ?? a) : u
    }));
  }, []), i = se(() => {
    t({});
  }, []);
  qr(N1, () => ({
    getProps: () => e,
    setProps: t
  }), [e]);
  const s = ee(() => ({ props: e, updateProps: n, resetUnsaved: i }), [e, i, n]);
  return /* @__PURE__ */ b.jsx(Hl.Provider, {
    value: s,
    children: r
  });
}, KA = {
  "%3A": ":",
  "%2F": "/",
  "%3F": "?",
  "%23": "#",
  "%5B": "[",
  "%5D": "]",
  "%40": "@",
  "%21": "!",
  "%24": "$",
  "%26": "&",
  "%27": "'",
  "%28": "(",
  "%29": ")",
  "%2A": "*",
  "%2B": "+",
  "%2C": ",",
  "%3B": ";"
}, Rv = {}, ZA = (r) => {
  Rv[r] || (console.warn(r), Rv[r] = !0);
}, JA = (r) => {
  for (const e of Object.keys(KA))
    if (r.includes(e))
      return { containsHex: !0, hexCode: e };
  return { containsHex: !1 };
}, Id = (r) => r.startsWith("/") ? Id(r.substring(1)) : r, QA = (r) => {
  if (typeof window < "u" && window.remotion_staticBase) {
    if (r.startsWith(window.remotion_staticBase))
      throw new Error(`The value "${r}" is already prefixed with the static base ${window.remotion_staticBase}. You don't need to call staticFile() on it.`);
    return `${window.remotion_staticBase}/${Id(r)}`;
  }
  return `/${Id(r)}`;
}, eM = (r) => r.split("/").map((i) => encodeURIComponent(i)).join("/"), tM = (r) => {
  if (r === null)
    throw new TypeError("null was passed to staticFile()");
  if (typeof r > "u")
    throw new TypeError("undefined was passed to staticFile()");
  if (r.startsWith("http://") || r.startsWith("https://"))
    throw new TypeError(`staticFile() does not support remote URLs - got "${r}". Instead, pass the URL without wrapping it in staticFile(). See: https://remotion.dev/docs/staticfile-remote-urls`);
  if (r.startsWith("..") || r.startsWith("./"))
    throw new TypeError(`staticFile() does not support relative paths - got "${r}". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);
  if (r.startsWith("/Users") || r.startsWith("/home") || r.startsWith("/tmp") || r.startsWith("/etc") || r.startsWith("/opt") || r.startsWith("/var") || r.startsWith("C:") || r.startsWith("D:") || r.startsWith("E:"))
    throw new TypeError(`staticFile() does not support absolute paths - got "${r}". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);
  if (r.startsWith("public/"))
    throw new TypeError(`Do not include the public/ prefix when using staticFile() - got "${r}". See: https://remotion.dev/docs/staticfile-relative-paths`);
  const e = JA(r);
  e.containsHex && ZA(`WARNING: You seem to pass an already encoded path (path contains ${e.hexCode}). Since Remotion 4.0, the encoding is done by staticFile() itself. You may want to remove a encodeURIComponent() wrapping.`);
  const t = eM(r), n = QA(t);
  return n.startsWith("/") ? n : `/${n}`;
}, Ad = "remotion-date:", Md = "remotion-file:", rM = ({
  data: r,
  indent: e,
  staticBase: t
}) => {
  let n = !1, i = !1, s = !1, a = !1;
  try {
    return { serializedString: JSON.stringify(r, function(u, h) {
      const d = this[u];
      return d instanceof Date ? (n = !0, `${Ad}${d.toISOString()}`) : d instanceof Map ? (s = !0, h) : d instanceof Set ? (a = !0, h) : typeof d == "string" && t !== null && d.startsWith(t) ? (i = !0, `${Md}${d.replace(t + "/", "")}`) : h;
    }, e), customDateUsed: n, customFileUsed: i, mapUsed: s, setUsed: a };
  } catch (c) {
    throw new Error("Could not serialize the passed input props to JSON: " + c.message);
  }
}, V1 = (r) => JSON.parse(r, (e, t) => typeof t == "string" && t.startsWith(Ad) ? new Date(t.replace(Ad, "")) : typeof t == "string" && t.startsWith(Md) ? tM(t.replace(Md, "")) : t), Bi = (r) => At().isStudio ? V1(rM({
  data: r,
  indent: 2,
  staticBase: window.remotion_staticBase
}).serializedString) : r, jv = !1, nM = () => {
  jv || (jv = !0, console.warn("Called `getInputProps()` on the server. This function is not available server-side and has returned an empty object."), console.warn("To hide this warning, don't call this function on the server:"), console.warn("  typeof window === 'undefined' ? {} : getInputProps()"));
}, z1 = () => {
  if (typeof window > "u")
    return nM(), {};
  if (At().isPlayer)
    throw new Error("You cannot call `getInputProps()` from a <Player>. Instead, the props are available as React props from component that you passed as `component` prop.");
  const r = window.remotion_inputProps;
  return r ? V1(r) : {};
}, Fv = [
  "h264",
  "h265",
  "vp8",
  "vp9",
  "mp3",
  "aac",
  "wav",
  "prores",
  "h264-mkv",
  "h264-ts",
  "gif"
];
function iM(r, e) {
  if (!(typeof r > "u")) {
    if (typeof r != "string")
      throw new TypeError(`The "defaultCodec" prop ${e} must be a string, but you passed a value of type ${typeof r}.`);
    if (!Fv.includes(r))
      throw new Error(`The "defaultCodec" prop ${e} must be one of ${Fv.join(", ")}, but you passed ${r}.`);
  }
}
function al(r, e, t) {
  if (typeof r != "number")
    throw new Error(`The "${e}" prop ${t} must be a number, but you passed a value of type ${typeof r}`);
  if (isNaN(r))
    throw new TypeError(`The "${e}" prop ${t} must not be NaN, but is NaN.`);
  if (!Number.isFinite(r))
    throw new TypeError(`The "${e}" prop ${t} must be finite, but is ${r}.`);
  if (r % 1 !== 0)
    throw new TypeError(`The "${e}" prop ${t} must be an integer, but is ${r}.`);
  if (r <= 0)
    throw new TypeError(`The "${e}" prop ${t} must be positive, but got ${r}.`);
}
function Af(r, e) {
  const { allowFloats: t, component: n } = e;
  if (typeof r > "u")
    throw new Error(`The "durationInFrames" prop ${n} is missing.`);
  if (typeof r != "number")
    throw new Error(`The "durationInFrames" prop ${n} must be a number, but you passed a value of type ${typeof r}`);
  if (r <= 0)
    throw new TypeError(`The "durationInFrames" prop ${n} must be positive, but got ${r}.`);
  if (!t && r % 1 !== 0)
    throw new TypeError(`The "durationInFrames" prop ${n} must be an integer, but got ${r}.`);
  if (!Number.isFinite(r))
    throw new TypeError(`The "durationInFrames" prop ${n} must be finite, but got ${r}.`);
}
function W1(r, e, t) {
  if (typeof r != "number")
    throw new Error(`"fps" must be a number, but you passed a value of type ${typeof r} ${e}`);
  if (!Number.isFinite(r))
    throw new Error(`"fps" must be a finite, but you passed ${r} ${e}`);
  if (isNaN(r))
    throw new Error(`"fps" must not be NaN, but got ${r} ${e}`);
  if (r <= 0)
    throw new TypeError(`"fps" must be positive, but got ${r} ${e}`);
}
var Lv = ({
  calculated: r,
  compositionId: e,
  compositionFps: t,
  compositionHeight: n,
  compositionWidth: i,
  compositionDurationInFrames: s
}) => {
  const a = `calculated by calculateMetadata() for the composition "${e}"`, c = `of the "<Composition />" component with the id "${e}"`, u = r?.width ?? i ?? void 0;
  al(u, "width", r?.width ? a : c);
  const h = r?.height ?? n ?? void 0;
  al(h, "height", r?.height ? a : c);
  const d = r?.fps ?? t ?? null;
  W1(d, r?.fps ? a : c);
  const p = r?.durationInFrames ?? s ?? null;
  Af(p, {
    allowFloats: !1,
    component: `of the "<Composition />" component with the id "${e}"`
  });
  const g = r?.defaultCodec;
  return iM(g, a), { width: u, height: h, fps: d, durationInFrames: p, defaultCodec: g };
}, H1 = ({
  calculateMetadata: r,
  signal: e,
  defaultProps: t,
  originalProps: n,
  compositionId: i,
  compositionDurationInFrames: s,
  compositionFps: a,
  compositionHeight: c,
  compositionWidth: u
}) => {
  const h = r ? r({
    defaultProps: t,
    props: n,
    abortSignal: e,
    compositionId: i
  }) : null;
  if (h !== null && typeof h == "object" && "then" in h)
    return h.then((p) => {
      const { height: g, width: v, durationInFrames: y, fps: x, defaultCodec: _ } = Lv({
        calculated: p,
        compositionDurationInFrames: s,
        compositionFps: a,
        compositionHeight: c,
        compositionWidth: u,
        compositionId: i
      });
      return {
        width: v,
        height: g,
        fps: x,
        durationInFrames: y,
        id: i,
        defaultProps: Bi(t),
        props: Bi(p.props ?? n),
        defaultCodec: _ ?? null
      };
    });
  const d = Lv({
    calculated: h,
    compositionDurationInFrames: s,
    compositionFps: a,
    compositionHeight: c,
    compositionWidth: u,
    compositionId: i
  });
  return h === null ? {
    ...d,
    id: i,
    defaultProps: Bi(t ?? {}),
    props: Bi(n),
    defaultCodec: null
  } : {
    ...d,
    id: i,
    defaultProps: Bi(t ?? {}),
    props: Bi(h.props ?? n),
    defaultCodec: h.defaultCodec ?? null
  };
}, sM = (r) => {
  try {
    return {
      type: "success",
      result: H1(r)
    };
  } catch (e) {
    return {
      type: "error",
      error: e
    };
  }
}, Ul = It(null), U1 = ly(), $1 = (r) => !!r.calculateMetadata, oM = "remotion.propsUpdatedExternally", Y1 = ({ children: r }) => {
  const [e, t] = he(null), { compositions: n, canvasContent: i, currentCompositionMetadata: s } = me(xi), { fastRefreshes: a } = me(ro), c = ee(() => n.find((F) => i && i.type === "composition" && i.compositionId === F.id), [i, n]), u = n.find((F) => F.id === e), { props: h } = me(Hl), d = ee(() => typeof window > "u" || At().isPlayer ? {} : z1() ?? {}, []), [p, g] = he({}), v = ee(() => c ? h[c.id] ?? {} : {}, [h, c]), y = ee(() => u ? h[u.id] ?? {} : {}, [h, u]), x = !!s, _ = se(({
    calculateMetadata: F,
    combinedProps: $,
    compositionDurationInFrames: z,
    compositionFps: G,
    compositionHeight: H,
    compositionId: Y,
    compositionWidth: te,
    defaultProps: ge
  }) => {
    const Z = new AbortController();
    if (x)
      return Z;
    const { signal: de } = Z, oe = sM({
      compositionId: Y,
      calculateMetadata: F,
      originalProps: $,
      signal: de,
      defaultProps: ge,
      compositionDurationInFrames: z,
      compositionFps: G,
      compositionHeight: H,
      compositionWidth: te
    });
    if (oe.type === "error")
      return g((pe) => ({
        ...pe,
        [Y]: {
          type: "error",
          error: oe.error
        }
      })), Z;
    const ie = oe.result;
    return typeof ie == "object" && "then" in ie ? (g((pe) => {
      const re = pe[Y];
      return re?.type === "success" || re?.type === "success-and-refreshing" ? {
        ...pe,
        [Y]: {
          type: "success-and-refreshing",
          result: re.result
        }
      } : {
        ...pe,
        [Y]: {
          type: "loading"
        }
      };
    }), ie.then((pe) => {
      Z.signal.aborted || g((re) => ({
        ...re,
        [Y]: {
          type: "success",
          result: pe
        }
      }));
    }).catch((pe) => {
      Z.signal.aborted || g((re) => ({
        ...re,
        [Y]: {
          type: "error",
          error: pe
        }
      }));
    })) : g((pe) => ({
      ...pe,
      [Y]: {
        type: "success",
        result: ie
      }
    })), Z;
  }, [x]), C = i?.type === "composition" ? i.compositionId : null;
  qr(U1, () => ({
    setCurrentRenderModalComposition: (F) => {
      t(F);
    },
    reloadCurrentlySelectedComposition: () => {
      if (!C)
        return;
      const F = n.find((H) => H.id === C);
      if (!F)
        throw new Error(`Could not find composition with id ${C}`);
      const $ = h[C] ?? {}, z = {
        ...F.defaultProps ?? {},
        ...$ ?? {}
      }, G = {
        ...z,
        ...d ?? {}
      };
      _({
        defaultProps: z,
        calculateMetadata: F.calculateMetadata,
        combinedProps: G,
        compositionDurationInFrames: F.durationInFrames ?? null,
        compositionFps: F.fps ?? null,
        compositionHeight: F.height ?? null,
        compositionWidth: F.width ?? null,
        compositionId: F.id
      });
    }
  }), [
    h,
    n,
    C,
    _,
    d
  ]);
  const E = c?.id === u?.id, k = ee(() => ({
    ...c?.defaultProps ?? {},
    ...v ?? {}
  }), [c?.defaultProps, v]), O = ee(() => ({
    ...k,
    ...d ?? {}
  }), [k, d]), P = c && $1(c), j = typeof window < "u" && window.remotion_ignoreFastRefreshUpdate && a <= window.remotion_ignoreFastRefreshUpdate;
  ue(() => {
    if (!j && P) {
      const F = _({
        calculateMetadata: c.calculateMetadata,
        combinedProps: O,
        compositionDurationInFrames: c.durationInFrames ?? null,
        compositionFps: c.fps ?? null,
        compositionHeight: c.height ?? null,
        compositionWidth: c.width ?? null,
        defaultProps: k,
        compositionId: c.id
      });
      return () => {
        F.abort();
      };
    }
  }, [
    P,
    k,
    _,
    O,
    c?.calculateMetadata,
    c?.durationInFrames,
    c?.fps,
    c?.height,
    c?.id,
    c?.width,
    j
  ]), ue(() => {
    j || window.dispatchEvent(new CustomEvent("remotion.propsUpdatedExternally"));
  }, [a]), ue(() => {
    if (u && !E) {
      const F = {
        ...u.defaultProps ?? {},
        ...y ?? {},
        ...d ?? {}
      }, $ = _({
        calculateMetadata: u.calculateMetadata,
        compositionDurationInFrames: u.durationInFrames ?? null,
        compositionFps: u.fps ?? null,
        compositionHeight: u.height ?? null,
        compositionId: u.id,
        compositionWidth: u.width ?? null,
        defaultProps: k,
        combinedProps: F
      });
      return () => {
        $.abort();
      };
    }
  }, [
    k,
    _,
    d,
    E,
    u,
    y
  ]);
  const V = ee(() => {
    const F = n.filter(($) => $.calculateMetadata === null);
    return {
      ...p,
      ...F.reduce(($, z) => ({
        ...$,
        [z.id]: {
          type: "success",
          result: { ...z, defaultProps: z.defaultProps ?? {} }
        }
      }), {})
    };
  }, [n, p]);
  return /* @__PURE__ */ b.jsx(Ul.Provider, {
    value: V,
    children: r
  });
}, Mf = (r) => {
  const e = me(Ul), { props: t } = me(Hl), { compositions: n, canvasContent: i, currentCompositionMetadata: s } = me(xi), a = i?.type === "composition" ? i.compositionId : null, c = r ?? a, u = n.find((d) => d.id === c), h = ee(() => u ? t[u.id] ?? {} : {}, [t, u]);
  return ee(() => u ? s ? {
    type: "success",
    result: {
      ...s,
      id: u.id,
      props: s.props,
      defaultProps: u.defaultProps ?? {},
      defaultCodec: s.defaultCodec
    }
  } : $1(u) ? e[u.id] ? e[u.id] : null : (Af(u.durationInFrames, {
    allowFloats: !1,
    component: `in <Composition id="${u.id}">`
  }), W1(u.fps, `in <Composition id="${u.id}">`), al(u.width, "width", `in <Composition id="${u.id}">`), al(u.height, "height", `in <Composition id="${u.id}">`), {
    type: "success",
    result: {
      width: u.width,
      height: u.height,
      fps: u.fps,
      id: u.id,
      durationInFrames: u.durationInFrames,
      defaultProps: u.defaultProps ?? {},
      props: {
        ...u.defaultProps ?? {},
        ...h ?? {},
        ...typeof window > "u" || At().isPlayer ? {} : z1() ?? {}
      },
      defaultCodec: null
    }
  }) : null, [u, e, s, h]);
}, $l = () => {
  const { canvasContent: r, compositions: e, currentCompositionMetadata: t } = me(xi), n = e.find((s) => r?.type === "composition" && s.id === r.compositionId), i = Mf(n?.id ?? null);
  return ee(() => !i || i.type === "error" || i.type === "loading" || !n ? null : {
    ...i.result,
    defaultProps: n.defaultProps ?? {},
    id: n.id,
    ...t ?? {},
    component: n.component
  }, [t, i, n]);
}, an = It({
  frame: {},
  playing: !1,
  playbackRate: 1,
  rootId: "",
  imperativePlaying: {
    current: !1
  },
  setPlaybackRate: () => {
    throw new Error("default");
  },
  audioAndVideoTags: { current: [] }
}), no = It({
  setFrame: () => {
    throw new Error("default");
  },
  setPlaying: () => {
    throw new Error("default");
  }
}), Pf = () => "remotion.time-all", X1 = (r) => {
  localStorage.setItem(Pf(), JSON.stringify(r));
}, G1 = () => {
  const r = localStorage.getItem(Pf()) ?? "{}";
  return JSON.parse(r);
}, q1 = (r) => {
  const e = localStorage.getItem(Pf()) ?? "{}", t = JSON.parse(e);
  return t[r] !== void 0 ? Number(t[r]) : typeof window > "u" ? 0 : window.remotion_initialFrame ?? 0;
}, ls = () => {
  const r = $l(), e = me(an);
  if (!r)
    return typeof window > "u" ? 0 : window.remotion_initialFrame ?? 0;
  const t = e.frame[r.id] ?? (At().isPlayer ? 0 : q1(r.id));
  return Math.min(r.durationInFrames - 1, t);
}, K1 = () => {
  const { setFrame: r } = me(no);
  return r;
}, Df = () => {
  const { playing: r, imperativePlaying: e } = me(an), { setPlaying: t } = me(no);
  return ee(() => [r, t, e], [e, r, t]);
}, us = It(!1), Pd = ({ children: r }) => /* @__PURE__ */ b.jsx(us.Provider, {
  value: !0,
  children: r
}), Yl = () => {
  const r = me(Zt), e = r?.width ?? null, t = r?.height ?? null, n = r?.durationInFrames ?? null, i = $l();
  return ee(() => {
    if (!i)
      return null;
    const {
      id: s,
      durationInFrames: a,
      fps: c,
      height: u,
      width: h,
      defaultProps: d,
      props: p,
      defaultCodec: g
    } = i;
    return {
      id: s,
      width: e ?? h,
      height: t ?? u,
      fps: c,
      durationInFrames: n ?? a,
      defaultProps: d,
      props: p,
      defaultCodec: g
    };
  }, [n, t, e, i]);
}, _i = () => {
  const r = Yl(), e = me(us), t = Of();
  if (!r)
    throw typeof window < "u" && window.remotion_isPlayer || t ? new Error([
      "No video config found. Likely reasons:",
      "- You are probably calling useVideoConfig() from outside the component passed to <Player />. See https://www.remotion.dev/docs/player/examples for how to set up the Player correctly.",
      "- You have multiple versions of Remotion installed which causes the React context to get lost."
    ].join("-")) : new Error("No video config found. You are probably calling useVideoConfig() from a component which has not been registered as a <Composition />. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions for more information.");
  if (!e)
    throw new Error("Called useVideoConfig() outside a Remotion composition.");
  return r;
}, Si = () => {
  if (!me(us))
    throw At().isPlayer ? new Error("useCurrentFrame can only be called inside a component that was passed to <Player>. See: https://www.remotion.dev/docs/player/examples") : new Error("useCurrentFrame() can only be called inside a component that was registered as a composition. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions");
  const e = ls(), t = me(Zt), n = t ? t.cumulatedFrom + t.relativeFrom : 0;
  return e - n;
}, aM = ({
  frame: r,
  children: e,
  active: t = !0
}) => {
  const n = Si(), i = _i();
  if (typeof r > "u")
    throw new Error("The <Freeze /> component requires a 'frame' prop, but none was passed.");
  if (typeof r != "number")
    throw new Error(`The 'frame' prop of <Freeze /> must be a number, but is of type ${typeof r}`);
  if (Number.isNaN(r))
    throw new Error("The 'frame' prop of <Freeze /> must be a real number, but it is NaN.");
  if (!Number.isFinite(r))
    throw new Error(`The 'frame' prop of <Freeze /> must be a finite number, but it is ${r}.`);
  const s = ee(() => {
    if (typeof t == "boolean")
      return t;
    if (typeof t == "function")
      return t(n);
  }, [t, n]), a = me(an), u = me(Zt)?.relativeFrom ?? 0, h = ee(() => s ? {
    ...a,
    playing: !1,
    imperativePlaying: {
      current: !1
    },
    frame: {
      [i.id]: r + u
    }
  } : a, [s, a, i.id, r, u]);
  return /* @__PURE__ */ b.jsx(an.Provider, {
    value: h,
    children: e
  });
}, cM = ({
  from: r = 0,
  durationInFrames: e = 1 / 0,
  children: t,
  name: n,
  height: i,
  width: s,
  showInTimeline: a = !0,
  _remotionInternalLoopDisplay: c,
  _remotionInternalStack: u,
  _remotionInternalPremountDisplay: h,
  ...d
}, p) => {
  const { layout: g = "absolute-fill" } = d, [v] = he(() => String(Math.random())), y = me(Zt), { rootId: x } = me(an), _ = y ? y.cumulatedFrom + y.relativeFrom : 0, C = If();
  if (g !== "absolute-fill" && g !== "none")
    throw new TypeError(`The layout prop of <Sequence /> expects either "absolute-fill" or "none", but you passed: ${g}`);
  if (g === "none" && typeof d.style < "u")
    throw new TypeError('If layout="none", you may not pass a style.');
  if (typeof e != "number")
    throw new TypeError(`You passed to durationInFrames an argument of type ${typeof e}, but it must be a number.`);
  if (e <= 0)
    throw new TypeError(`durationInFrames must be positive, but got ${e}`);
  if (typeof r != "number")
    throw new TypeError(`You passed to the "from" props of your <Sequence> an argument of type ${typeof r}, but it must be a number.`);
  if (!Number.isFinite(r))
    throw new TypeError(`The "from" prop of a sequence must be finite, but got ${r}.`);
  const E = ls(), k = _i(), O = y ? Math.min(y.durationInFrames - r, e) : e, P = Math.max(0, Math.min(k.durationInFrames - r, O)), { registerSequence: j, unregisterSequence: V } = me(to), { hidden: F } = me(ba), $ = ee(() => y?.premounting ?? !!d._remotionInternalIsPremounting, [d._remotionInternalIsPremounting, y?.premounting]), z = ee(() => ({
    cumulatedFrom: _,
    relativeFrom: r,
    durationInFrames: P,
    parentFrom: y?.relativeFrom ?? 0,
    id: v,
    height: i ?? y?.height ?? null,
    width: s ?? y?.width ?? null,
    premounting: $
  }), [
    _,
    r,
    P,
    y,
    v,
    i,
    s,
    $
  ]), G = ee(() => n ?? "", [n]);
  ue(() => {
    if (At().isStudio)
      return j({
        from: r,
        duration: P,
        id: v,
        displayName: G,
        parent: y?.id ?? null,
        type: "sequence",
        rootId: x,
        showInTimeline: a,
        nonce: C,
        loopDisplay: c,
        stack: u ?? null,
        premountDisplay: h ?? null
      }), () => {
        V(v);
      };
  }, [
    e,
    v,
    n,
    j,
    G,
    V,
    y?.id,
    P,
    x,
    r,
    a,
    C,
    c,
    u,
    h
  ]);
  const H = Math.ceil(_ + r + e - 1), Y = E < _ + r || E > H ? null : t, te = d.layout === "none" ? void 0 : d.style, ge = ee(() => ({
    flexDirection: void 0,
    ...s ? { width: s } : {},
    ...i ? { height: i } : {},
    ...te ?? {}
  }), [i, te, s]);
  if (p !== null && g === "none")
    throw new TypeError('It is not supported to pass both a `ref` and `layout="none"` to <Sequence />.');
  return F[v] ?? !1 ? null : /* @__PURE__ */ b.jsx(Zt.Provider, {
    value: z,
    children: Y === null ? null : d.layout === "none" ? Y : /* @__PURE__ */ b.jsx($o, {
      ref: p,
      style: ge,
      className: d.className,
      children: Y
    })
  });
}, lM = Bt(cM), uM = (r, e) => {
  const t = Si();
  if (r.layout === "none")
    throw new Error('`<Sequence>` with `premountFor` prop does not support layout="none"');
  const { style: n, from: i = 0, premountFor: s = 0, ...a } = r, c = t < i && t >= i - s, u = ee(() => ({
    ...n,
    opacity: c ? 0 : 1,
    pointerEvents: c ? "none" : n?.pointerEvents ?? void 0
  }), [c, n]);
  return /* @__PURE__ */ b.jsx(aM, {
    frame: i,
    active: c,
    children: /* @__PURE__ */ b.jsx(wn, {
      ref: e,
      from: i,
      style: u,
      _remotionInternalPremountDisplay: s,
      _remotionInternalIsPremounting: c,
      ...a
    })
  });
}, hM = Bt(uM), dM = (r, e) => r.layout !== "none" && r.premountFor && !At().isRendering ? /* @__PURE__ */ b.jsx(hM, {
  ...r,
  ref: e
}) : /* @__PURE__ */ b.jsx(lM, {
  ...r,
  ref: e
}), wn = Bt(dM), fM = (r) => {
  if (typeof r != "string")
    throw new TypeError(`The "filename" must be a string, but you passed a value of type ${typeof r}`);
  if (r.trim() === "")
    throw new Error("The `filename` must not be empty");
  if (!r.match(/^([0-9a-zA-Z-!_.*'()/:&$@=;+,?]+)/g))
    throw new Error('The `filename` must match "/^([0-9a-zA-Z-!_.*\'()/:&$@=;+,?]+)/g". Use forward slashes only, even on Windows.');
}, pM = (r) => {
  if (typeof r != "string" && !(r instanceof Uint8Array))
    throw new TypeError(`The "content" must be a string or Uint8Array, but you passed a value of type ${typeof r}`);
  if (typeof r == "string" && r.trim() === "")
    throw new Error("The `content` must not be empty");
}, Z1 = (r) => {
  r.type === "artifact" && (fM(r.filename), pM(r.content));
}, hs = It({
  registerRenderAsset: () => {
  },
  unregisterRenderAsset: () => {
  },
  renderAssets: []
}), gM = ({ children: r }) => {
  const [e, t] = he([]), n = se((a) => {
    Z1(a), t((c) => [...c, a]);
  }, []), i = se((a) => {
    t((c) => c.filter((u) => u.id !== a));
  }, []);
  Xn(() => {
    typeof window < "u" && (window.remotion_collectAssets = () => (t([]), e));
  }, [e]);
  const s = ee(() => ({
    registerRenderAsset: n,
    unregisterRenderAsset: i,
    renderAssets: e
  }), [e, n, i]);
  return /* @__PURE__ */ b.jsx(hs.Provider, {
    value: s,
    children: r
  });
}, Gn = (r) => typeof window > "u" ? r : new URL(r, window.origin).href, J1 = ({
  endAt: r,
  mediaDuration: e,
  playbackRate: t,
  startFrom: n
}) => {
  let i = e;
  typeof r < "u" && (i = r), typeof n < "u" && (i -= n);
  const s = i / t;
  return Math.floor(s);
};
function ra(r) {
  let e;
  throw mM(r) ? (e = r, e.stack || (e.stack = new Error(e.message).stack)) : typeof r == "string" ? e = Error(r) : e = Error("Rendering was cancelled"), window.remotion_cancelledError = e.stack, e;
}
var mM = (r) => r instanceof Error ? !0 : !(r === null || typeof r != "object" || !("stack" in r) || typeof r.stack != "string" || !("message" in r) || typeof r.message != "string"), Q1 = It(null), vM = () => Ce.useContext(Q1), Xl = ({ durationInFrames: r, times: e = 1 / 0, children: t, name: n, ...i }) => {
  const s = Si(), { durationInFrames: a } = _i();
  if (Af(r, {
    component: "of the <Loop /> component",
    allowFloats: !0
  }), typeof e != "number")
    throw new TypeError(`You passed to "times" an argument of type ${typeof e}, but it must be a number.`);
  if (e !== 1 / 0 && e % 1 !== 0)
    throw new TypeError(`The "times" prop of a loop must be an integer, but got ${e}.`);
  if (e < 0)
    throw new TypeError(`The "times" prop of a loop must be at least 0, but got ${e}`);
  const c = Math.ceil(a / r), u = Math.min(c, e), h = i.layout === "none" ? void 0 : i.style, d = r * (u - 1), g = Math.floor(s / r) * r, v = Math.min(g, d), y = ee(() => ({
    numberOfTimes: u,
    startOffset: -v,
    durationInFrames: r
  }), [u, r, v]), x = ee(() => ({
    iteration: Math.floor(s / r),
    durationInFrames: r
  }), [s, r]);
  return /* @__PURE__ */ b.jsx(Q1.Provider, {
    value: x,
    children: /* @__PURE__ */ b.jsx(wn, {
      durationInFrames: r,
      from: v,
      name: n ?? "<Loop>",
      _remotionInternalLoopDisplay: y,
      layout: i.layout,
      style: h,
      children: t
    })
  });
};
Xl.useLoop = vM;
var Gl = It({}), Nv = {}, Lh = [], eb = ({ children: r }) => {
  const [e, t] = he(() => Nv);
  return ue(() => {
    const n = () => {
      t(Nv);
    };
    return Lh.push(n), () => {
      Lh = Lh.filter((i) => i !== n);
    };
  }, []), /* @__PURE__ */ b.jsx(Gl.Provider, {
    value: e,
    children: r
  });
}, io = (r) => me(Gl)[r] ?? r, Rf = (r, e) => {
  if (typeof r.volume != "number" && typeof r.volume != "function" && typeof r.volume < "u")
    throw new TypeError(`You have passed a volume of type ${typeof r.volume} to your <${e} /> component. Volume must be a number or a function with the signature '(frame: number) => number' undefined.`);
  if (typeof r.volume == "number" && r.volume < 0)
    throw new TypeError(`You have passed a volume below 0 to your <${e} /> component. Volume must be between 0 and 1`);
  if (typeof r.playbackRate != "number" && typeof r.playbackRate < "u")
    throw new TypeError(`You have passed a playbackRate of type ${typeof r.playbackRate} to your <${e} /> component. Playback rate must a real number or undefined.`);
  if (typeof r.playbackRate == "number" && (isNaN(r.playbackRate) || !Number.isFinite(r.playbackRate) || r.playbackRate <= 0))
    throw new TypeError(`You have passed a playbackRate of ${r.playbackRate} to your <${e} /> component. Playback rate must be a real number above 0.`);
}, jf = (r, e) => {
  if (typeof r < "u") {
    if (typeof r != "number")
      throw new TypeError(`type of startFrom prop must be a number, instead got type ${typeof r}.`);
    if (isNaN(r) || r === 1 / 0)
      throw new TypeError("startFrom prop can not be NaN or Infinity.");
    if (r < 0)
      throw new TypeError(`startFrom must be greater than equal to 0 instead got ${r}.`);
  }
  if (typeof e < "u") {
    if (typeof e != "number")
      throw new TypeError(`type of endAt prop must be a number, instead got type ${typeof e}.`);
    if (isNaN(e))
      throw new TypeError("endAt prop can not be NaN.");
    if (e <= 0)
      throw new TypeError(`endAt must be a positive number, instead got ${e}.`);
  }
  if (e < r)
    throw new TypeError("endAt prop must be greater than startFrom prop.");
}, yM = (r, e) => {
  switch (e.type) {
    case "got-duration": {
      const t = Gn(e.src);
      return r[t] === e.durationInSeconds ? r : {
        ...r,
        [t]: e.durationInSeconds
      };
    }
    default:
      return r;
  }
}, Ff = It({
  durations: {},
  setDurations: () => {
    throw new Error("context missing");
  }
}), tb = ({ children: r }) => {
  const [e, t] = S5(yM, {}), n = ee(() => ({
    durations: e,
    setDurations: t
  }), [e]);
  return /* @__PURE__ */ b.jsx(Ff.Provider, {
    value: n,
    children: r
  });
};
function Bv(r) {
  let e = r + 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function bM(r) {
  let e = 0, t = 0, n = 0;
  for (e = 0; e < r.length; e++)
    t = r.charCodeAt(e), n = (n << 5) - n + t, n |= 0;
  return n;
}
var ds = (r, e) => {
  if (r === null)
    return Math.random();
  if (typeof r == "string")
    return Bv(bM(r));
  if (typeof r == "number")
    return Bv(r * 1e10);
  throw new Error("random() argument must be a number or a string");
}, so = () => {
  const r = me(Zt);
  return Math.min(0, r?.relativeFrom ?? 0);
}, wa = (r) => {
  const e = Xl.useLoop(), t = Si(), n = so();
  return r === "repeat" || e === null ? t + n : t + n + e.durationInFrames * e.iteration;
}, wM = (r) => {
  if (/data:|blob:/.test(r.substring(0, 5)))
    return "Data URL";
  const e = r.split("/").map((t) => t.split("\\")).flat(1);
  return e[e.length - 1];
}, cl = (r, e, t) => {
  const { current: n } = r;
  if (!n)
    return;
  const i = n.play();
  i.catch && i.catch((s) => {
    if (n && !s.message.includes("request was interrupted by a call to pause") && !s.message.includes("The operation was aborted.") && !s.message.includes("The fetching process for the media resource was aborted by the user agent") && !s.message.includes("request was interrupted by a new load request") && !s.message.includes("because the media was removed from the document") && !(s.message.includes("user didn't interact with the document") && n.muted) && (console.log(`Could not play ${e} due to following error: `, s), !n.muted)) {
      if (t) {
        t();
        return;
      }
      console.log("The video will be muted and we'll retry playing it."), e === "video" && At().isPlayer && console.log("Use onAutoPlayError() to handle this error yourself."), n.muted = !0, n.play();
    }
  });
}, oo = ({
  frame: r,
  volume: e,
  mediaVolume: t = 1,
  allowAmplificationDuringRender: n
}) => {
  const i = n ? 1 / 0 : 1;
  if (typeof e == "number")
    return Math.min(i, e * t);
  if (typeof e > "u")
    return Number(t);
  const s = e(r) * t;
  if (typeof s != "number")
    throw new TypeError(`You passed in a a function to the volume prop but it did not return a number but a value of type ${typeof s} for frame ${r}`);
  if (Number.isNaN(s))
    throw new TypeError(`You passed in a function to the volume prop but it returned NaN for frame ${r}.`);
  if (!Number.isFinite(s))
    throw new TypeError(`You passed in a function to the volume prop but it returned a non-finite number for frame ${r}.`);
  return Math.max(0, Math.min(i, s));
}, Vv = {}, xM = (r) => {
  Vv[r] || (console.warn(r), Vv[r] = !0);
}, rb = ({
  volume: r,
  mediaVolume: e,
  mediaRef: t,
  src: n,
  mediaType: i,
  playbackRate: s,
  displayName: a,
  id: c,
  stack: u,
  showInTimeline: h,
  premountDisplay: d,
  onAutoPlayError: p
}) => {
  const g = _i(), { rootId: v, audioAndVideoTags: y } = me(an), x = me(Zt), _ = x ? x.relativeFrom + x.cumulatedFrom : 0, [C] = Df(), E = so(), { registerSequence: k, unregisterSequence: O } = me(to), [P] = he(() => r), j = If(), V = x ? Math.min(x.durationInFrames, g.durationInFrames) : g.durationInFrames, F = typeof r == "function", $ = ee(() => typeof r == "number" ? r : new Array(Math.floor(Math.max(0, V + E))).fill(!0).map((z, G) => oo({
    frame: G + E,
    volume: r,
    mediaVolume: e,
    allowAmplificationDuringRender: !1
  })).join(","), [V, E, r, e]);
  ue(() => {
    typeof r == "number" && r !== P && xM(`Remotion: The ${i} with src ${n} has changed it's volume. Prefer the callback syntax for setting volume to get better timeline display: https://www.remotion.dev/docs/using-audio/#controlling-volume`);
  }, [P, i, n, r]), ue(() => {
    if (t.current) {
      if (!n)
        throw new Error("No src passed");
      if (!(!At().isStudio && window.process?.env?.NODE_ENV !== "test") && h)
        return k({
          type: i,
          src: n,
          id: c,
          duration: V,
          from: 0,
          parent: x?.id ?? null,
          displayName: a ?? wM(n),
          rootId: v,
          volume: $,
          showInTimeline: !0,
          nonce: j,
          startMediaFrom: 0 - E,
          doesVolumeChange: F,
          loopDisplay: void 0,
          playbackRate: s,
          stack: u,
          premountDisplay: d
        }), () => {
          O(c);
        };
    }
  }, [
    _,
    V,
    c,
    x,
    n,
    k,
    v,
    O,
    g,
    $,
    F,
    j,
    t,
    i,
    E,
    s,
    a,
    u,
    h,
    d
  ]), ue(() => {
    const z = {
      id: c,
      play: () => {
        if (C)
          return cl(t, i, p);
      }
    };
    return y.current.push(z), () => {
      y.current = y.current.filter((G) => G.id !== c);
    };
  }, [y, c, t, i, p, C]);
}, _M = () => {
  const [r, e] = he([]), [t, n] = he([]), [i, s] = he([]), a = be(!1), c = se((d) => (e((p) => [...p, d]), {
    unblock: () => {
      e((p) => {
        const g = p.filter((v) => v !== d);
        return g.length === p.length ? p : g;
      });
    }
  }), []), u = se((d) => (n((p) => [...p, d]), {
    remove: () => {
      n((p) => p.filter((g) => g !== d));
    }
  }), []), h = se((d) => (s((p) => [...p, d]), {
    remove: () => {
      s((p) => p.filter((g) => g !== d));
    }
  }), []);
  return ue(() => {
    r.length > 0 && t.forEach((d) => d());
  }, [r]), ue(() => {
    r.length === 0 && i.forEach((d) => d());
  }, [r]), ee(() => ({ addBlock: c, listenForBuffering: u, listenForResume: h, buffering: a }), [c, a, u, h]);
}, ao = Ce.createContext(null), nb = ({ children: r }) => {
  const e = _M();
  return /* @__PURE__ */ b.jsx(ao.Provider, {
    value: e,
    children: r
  });
}, SM = (r) => {
  const [e, t] = he(r.buffering.current);
  return ue(() => {
    const n = () => {
      t(!0);
    }, i = () => {
      t(!1);
    };
    return r.listenForBuffering(n), r.listenForResume(i), () => {
      r.listenForBuffering(() => {
      }), r.listenForResume(() => {
      });
    };
  }, [r]), e;
}, Lf = () => {
  const r = me(ao), e = r ? r.addBlock : null;
  return ee(() => ({
    delayPlayback: () => {
      if (!e)
        throw new Error("Tried to enable the buffering state, but a Remotion context was not found. This API can only be called in a component that was passed to the Remotion Player or a <Composition>. Or you might have experienced a version mismatch - run `npx remotion versions` and ensure all packages have the same version. This error is thrown by the buffer state https://remotion.dev/docs/player/buffer-state");
      const { unblock: t } = e({
        id: String(Math.random())
      });
      return { unblock: t };
    }
  }), [e]);
}, CM = ({
  mediaRef: r,
  mediaType: e,
  onVariableFpsVideoDetected: t,
  pauseWhenBuffering: n
}) => {
  const i = be(!1), { delayPlayback: s } = Lf(), a = se((c) => {
    if (e !== "video" || !n)
      return;
    const u = r.current;
    if (!u || !u.requestVideoFrameCallback)
      return;
    i.current = !0;
    const h = s(), d = () => {
      h.unblock(), u.removeEventListener("ended", d, {
        once: !0
      }), u.removeEventListener("pause", d, {
        once: !0
      }), i.current = !1;
    }, p = () => {
      d();
    };
    u.requestVideoFrameCallback((g, v) => {
      Math.abs(v.mediaTime - c) > 0.5 && t(), d();
    }), u.addEventListener("ended", p, { once: !0 }), u.addEventListener("pause", p, { once: !0 }), u.addEventListener("canplay", p, {
      once: !0
    });
  }, [
    s,
    r,
    e,
    t,
    n
  ]);
  return ee(() => ({
    isBuffering: () => i.current,
    bufferUntilFirstFrame: a
  }), [a]);
}, TM = ({
  element: r,
  shouldBuffer: e,
  isPremounting: t
}) => {
  const n = Lf(), [i, s] = he(!1);
  return ue(() => {
    let a = [];
    const { current: c } = r;
    if (!c || !e || t)
      return;
    const u = () => {
      a.forEach((p) => p()), a = [], s(!1);
    }, h = () => {
      s(!0);
      const { unblock: p } = n.delayPlayback(), g = () => {
        u(), d();
      }, v = () => {
        u(), d();
      };
      c.addEventListener("canplay", g, {
        once: !0
      }), a.push(() => {
        c.removeEventListener("canplay", g);
      }), c.addEventListener("error", v, {
        once: !0
      }), a.push(() => {
        c.removeEventListener("error", v);
      }), a.push(() => {
        p();
      });
    }, d = () => {
      c.readyState < c.HAVE_FUTURE_DATA ? (h(), navigator.userAgent.includes("Firefox/") || c.load()) : (c.addEventListener("waiting", h), a.push(() => {
        c.removeEventListener("waiting", h);
      }));
    };
    return d(), () => {
      u();
    };
  }, [n, r, t, e]), i;
}, EM = ({
  mediaRef: r,
  mediaType: e,
  lastSeek: t,
  onVariableFpsVideoDetected: n
}) => {
  const i = be(null);
  return ue(() => {
    const { current: s } = r;
    if (s)
      i.current = s.currentTime;
    else {
      i.current = null;
      return;
    }
    if (e !== "video") {
      i.current = null;
      return;
    }
    const a = s;
    if (!a.requestVideoFrameCallback)
      return;
    let c = () => {
    };
    const u = () => {
      if (!a)
        return;
      const h = a.requestVideoFrameCallback((d, p) => {
        if (i.current !== null) {
          const g = Math.abs(i.current - p.mediaTime), v = Math.abs(t.current === null ? 1 / 0 : p.mediaTime - t.current);
          g > 0.5 && v > 0.5 && p.mediaTime > i.current && n();
        }
        i.current = p.mediaTime, u();
      });
      c = () => {
        a.cancelVideoFrameCallback(h), c = () => {
        };
      };
    };
    return u(), () => {
      c();
    };
  }, [t, r, e, n]), i;
};
function kM(r, e, t, n) {
  const { extrapolateLeft: i, extrapolateRight: s, easing: a } = n;
  let c = r;
  const [u, h] = e, [d, p] = t;
  if (c < u) {
    if (i === "identity")
      return c;
    if (i === "clamp")
      c = u;
    else if (i === "wrap") {
      const g = h - u;
      c = ((c - u) % g + g) % g + u;
    }
  }
  if (c > h) {
    if (s === "identity")
      return c;
    if (s === "clamp")
      c = h;
    else if (s === "wrap") {
      const g = h - u;
      c = ((c - u) % g + g) % g + u;
    }
  }
  return d === p ? d : (c = (c - u) / (h - u), c = a(c), c = c * (p - d) + d, c);
}
function OM(r, e) {
  let t;
  for (t = 1; t < e.length - 1 && !(e[t] >= r); ++t)
    ;
  return t - 1;
}
function IM(r) {
  for (let e = 1; e < r.length; ++e)
    if (!(r[e] > r[e - 1]))
      throw new Error(`inputRange must be strictly monotonically increasing but got [${r.join(",")}]`);
}
function zv(r, e) {
  if (e.length < 2)
    throw new Error(r + " must have at least 2 elements");
  for (const t of e) {
    if (typeof t != "number")
      throw new Error(`${r} must contain only numbers`);
    if (!Number.isFinite(t))
      throw new Error(`${r} must contain only finite numbers, but got [${e.join(",")}]`);
  }
}
function ib(r, e, t, n) {
  if (typeof r > "u")
    throw new Error("input can not be undefined");
  if (typeof e > "u")
    throw new Error("inputRange can not be undefined");
  if (typeof t > "u")
    throw new Error("outputRange can not be undefined");
  if (e.length !== t.length)
    throw new Error("inputRange (" + e.length + ") and outputRange (" + t.length + ") must have the same length");
  zv("inputRange", e), zv("outputRange", t), IM(e);
  const i = n?.easing ?? ((u) => u);
  let s = "extend";
  n?.extrapolateLeft !== void 0 && (s = n.extrapolateLeft);
  let a = "extend";
  if (n?.extrapolateRight !== void 0 && (a = n.extrapolateRight), typeof r != "number")
    throw new TypeError("Cannot interpolate an input which is not a number");
  const c = OM(r, e);
  return kM(r, [e[c], e[c + 1]], [t[c], t[c + 1]], {
    easing: i,
    extrapolateLeft: s,
    extrapolateRight: a
  });
}
var sb = ({
  frame: r,
  playbackRate: e,
  startFrom: t
}) => ib(r, [-1, t, t + 1], [-1, t, t + e]), ob = ({
  fps: r,
  frame: e,
  playbackRate: t,
  startFrom: n
}) => {
  const i = sb({
    frame: e,
    playbackRate: t,
    startFrom: n
  }), s = 1e3 / r;
  return i * s / 1e3;
}, ab = (r, e) => Math.round(r / e * 100) / 100, ql = () => {
  if (typeof window > "u")
    return !1;
  const r = /iP(ad|od|hone)/i.test(window.navigator.userAgent), e = /AppleWebKit/.test(window.navigator.userAgent);
  return r && e;
}, AM = (r) => ql() && r.startsWith("blob:"), Dd = ({
  actualFrom: r,
  fps: e
}) => ab(Math.max(0, -r), e), Rd = ({
  duration: r,
  fps: e
}) => ab(r, e), MM = ({
  actualSrc: r,
  actualFrom: e,
  duration: t,
  fps: n
}) => {
  if (AM(r) || r.startsWith("data:") || !!new URL(r, (typeof window > "u" ? null : window.location.href) ?? "http://localhost:3000").hash || !Number.isFinite(e))
    return r;
  const s = `${r}#t=${Dd({ actualFrom: e, fps: n })}`;
  return Number.isFinite(t) ? `${s},${Rd({ duration: t, fps: n })}` : s;
}, PM = ({
  prevStartFrom: r,
  newStartFrom: e,
  prevDuration: t,
  newDuration: n,
  fps: i
}) => {
  const s = Dd({ actualFrom: r, fps: i }), a = Dd({ actualFrom: e, fps: i }), c = Rd({ duration: t, fps: i }), u = Rd({ duration: n, fps: i });
  return !(a < s || u > c);
}, DM = ({
  actualSrc: r,
  actualFrom: e,
  duration: t,
  fps: n
}) => {
  const i = be(e), s = be(t), a = be(r);
  return (!PM({
    prevStartFrom: i.current,
    newStartFrom: e,
    prevDuration: s.current,
    newDuration: t,
    fps: n
  }) || r !== a.current) && (i.current = e, s.current = t, a.current = r), MM({
    actualSrc: a.current,
    actualFrom: i.current,
    duration: s.current,
    fps: n
  });
}, Wv = {}, RM = (r, e) => {
  if (r === null || r.seekable.length === 0 || r.seekable.length > 1 || Wv[r.src])
    return;
  const t = { start: r.seekable.start(0), end: r.seekable.end(0) };
  if (t.start === 0 && t.end === 0) {
    const n = [
      `The media ${r.src} cannot be seeked. This could be one of few reasons:`,
      "1) The media resource was replaced while the video is playing but it was not loaded yet.",
      "2) The media does not support seeking.",
      "3) The media was loaded with security headers prventing it from being included.",
      "Please see https://remotion.dev/docs/non-seekable-media for assistance."
    ].join(`
`);
    if (e === "console-error")
      console.error(n);
    else if (e === "console-warning")
      console.warn(`The media ${r.src} does not support seeking. The video will render fine, but may not play correctly in the Remotion Studio and in the <Player>. See https://remotion.dev/docs/non-seekable-media for an explanation.`);
    else
      throw new Error(n);
    Wv[r.src] = !0;
  }
}, Nf = 0.45, Nh = (r, e) => {
  if (!r.current)
    return;
  const t = ql() ? Number(e.toFixed(1)) : e;
  r.current.currentTime = t;
}, cb = ({
  mediaRef: r,
  src: e,
  mediaType: t,
  playbackRate: n,
  onlyWarnForMediaSeekingError: i,
  acceptableTimeshift: s,
  pauseWhenBuffering: a,
  isPremounting: c,
  debugSeeking: u,
  onAutoPlayError: h
}) => {
  const { playbackRate: d } = me(an), p = Si(), g = ls(), [v] = Df(), y = me(ao), { fps: x } = _i(), _ = so(), C = be(null), E = be(null);
  if (!y)
    throw new Error("useMediaPlayback must be used inside a <BufferingContext>");
  const k = be({}), O = se(() => {
    e && (u && console.log(`Detected ${e} as a variable FPS video. Disabling buffering while seeking.`), k.current[e] = !0);
  }, [u, e]), P = EM({
    mediaRef: r,
    mediaType: t,
    lastSeek: E,
    onVariableFpsVideoDetected: O
  }), j = ob({
    frame: p,
    playbackRate: n,
    startFrom: -_,
    fps: x
  }), V = TM({
    element: r,
    shouldBuffer: a,
    isPremounting: c
  }), { bufferUntilFirstFrame: F, isBuffering: $ } = CM({
    mediaRef: r,
    mediaType: t,
    onVariableFpsVideoDetected: O,
    pauseWhenBuffering: a
  }), z = n * d, G = r.current?.duration ? Math.min(r.current.duration, s ?? Nf) : s, H = SM(y);
  ue(() => {
    if (!v) {
      r.current?.pause();
      return;
    }
    const Y = V || $();
    H && !Y && r.current?.pause();
  }, [$, V, H, r, v]), ue(() => {
    const Y = t === "audio" ? "<Audio>" : "<Video>";
    if (!r.current)
      throw new Error(`No ${t} ref found`);
    if (!e)
      throw new Error(`No 'src' attribute was passed to the ${Y} element.`);
    const te = Math.max(0, z);
    r.current.playbackRate !== te && (r.current.playbackRate = te);
    const { duration: ge } = r.current, Z = !Number.isNaN(ge) && Number.isFinite(ge) ? Math.min(ge, j) : j, de = r.current.currentTime, oe = P.current ?? null, ie = k.current[e], pe = Math.abs(Z - de), re = oe ? Math.abs(Z - oe) : null, Be = re && !ie ? re : pe;
    if (u && console.log({
      mediaTagTime: de,
      rvcTime: oe,
      shouldBeTime: Z,
      state: r.current.readyState,
      playing: !r.current.paused,
      isVariableFpsVideo: ie
    }), Be > G && C.current !== Z) {
      u && console.log("Seeking", {
        shouldBeTime: Z,
        isTime: de,
        rvcTime: oe,
        timeShift: Be,
        isVariableFpsVideo: ie
      }), Nh(r, Z), E.current = Z, C.current = Z, v && !ie && (z > 0 && F(Z), r.current.paused && cl(r, t, h)), i || RM(r.current, i ? "console-warning" : "console-error");
      return;
    }
    const Ze = v ? 0.15 : 1e-5, ze = Math.abs(r.current.currentTime - Z) > Ze, Ee = V || $(), Ie = y.buffering.current && !Ee;
    if (!v || Ie) {
      ze && (Nh(r, Z), E.current = Z);
      return;
    }
    (r.current.paused && !r.current.ended || g === 0) && (ze && (Nh(r, Z), E.current = Z), cl(r, t, h), ie || z > 0 && F(Z));
  }, [
    g,
    G,
    F,
    y.buffering,
    P,
    u,
    j,
    $,
    V,
    r,
    t,
    i,
    z,
    v,
    e,
    h
  ]);
}, lb = (r) => {
  const [e, t] = he(1);
  return ue(() => {
    const n = r.current;
    if (!n)
      return;
    const i = () => {
      t(n.volume);
    };
    return n.addEventListener("volumechange", i), () => n.removeEventListener("volumechange", i);
  }, [r]), ue(() => {
    const n = r.current;
    n && n.volume !== e && t(n.volume);
  }, [e, r]), e;
}, jM = 1e-5, Bf = (r, e) => Math.abs(r - e) < jM, ub = ({
  volumePropFrame: r,
  actualVolume: e,
  volume: t,
  mediaVolume: n,
  mediaRef: i
}) => {
  ue(() => {
    const s = oo({
      frame: r,
      volume: t,
      mediaVolume: n,
      allowAmplificationDuringRender: !1
    });
    !Bf(s, e) && i.current && (i.current.volume = s);
  }, [e, r, i, t, n]);
}, Vf = It({
  mediaMuted: !1,
  mediaVolume: 1
}), zf = It({
  setMediaMuted: () => {
    throw new Error("default");
  },
  setMediaVolume: () => {
    throw new Error("default");
  }
}), Wf = () => {
  const { mediaVolume: r } = me(Vf), { setMediaVolume: e } = me(zf);
  return ee(() => [r, e], [r, e]);
}, Hf = () => {
  const { mediaMuted: r } = me(Vf), { setMediaMuted: e } = me(zf);
  return ee(() => [r, e], [r, e]);
}, Hv = "data:audio/mp3;base64,/+MYxAAJcAV8AAgAABn//////+/gQ5BAMA+D4Pg+BAQBAEAwD4Pg+D4EBAEAQDAPg++hYBH///hUFQVBUFREDQNHmf///////+MYxBUGkAGIMAAAAP/29Xt6lUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxDUAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV", FM = (r, e) => {
  const t = Object.keys(r).sort(), n = Object.keys(e).sort();
  if (t.length !== n.length)
    return !1;
  for (let i = 0; i < t.length; i++)
    if (t[i] !== n[i] || r[t[i]] !== e[n[i]])
      return !1;
  return !0;
}, LM = (r, e, t) => r === "src" && !t.startsWith("data:") && !e.startsWith("data:") ? new URL(t, window.origin).toString() !== new URL(e, window.origin).toString() : t !== e, Kl = It(null), hb = ({ children: r, numberOfAudioTags: e, component: t }) => {
  const n = be([]), [i] = he(e);
  if (e !== i)
    throw new Error("The number of shared audio tags has changed dynamically. Once you have set this property, you cannot change it afterwards.");
  const s = ee(() => new Array(e).fill(!0).map(() => ({ id: Math.random(), ref: ly() })), [e]), a = be(new Array(e).fill(!1)), c = se(() => {
    s.forEach(({ ref: y, id: x }) => {
      const _ = n.current?.find((E) => E.id === x), { current: C } = y;
      if (C) {
        if (_ === void 0) {
          C.src = Hv;
          return;
        }
        if (!_)
          throw new TypeError("Expected audio data to be there");
        Object.keys(_.props).forEach((E) => {
          LM(E, _.props[E], C[E]) && (C[E] = _.props[E]);
        });
      }
    });
  }, [s]), u = se((y, x) => {
    const _ = n.current?.find((j) => j.audioId === x);
    if (_)
      return _;
    const C = a.current.findIndex((j) => j === !1);
    if (C === -1)
      throw new Error(`Tried to simultaneously mount ${e + 1} <Audio /> tags at the same time. With the current settings, the maximum amount of <Audio /> tags is limited to ${e} at the same time. Remotion pre-mounts silent audio tags to help avoid browser autoplay restrictions. See https://remotion.dev/docs/player/autoplay#use-the-numberofsharedaudiotags-property for more information on how to increase this limit.`);
    const { id: E, ref: k } = s[C], O = [...a.current];
    O[C] = E, a.current = O;
    const P = {
      props: y,
      id: E,
      el: k,
      audioId: x
    };
    return n.current?.push(P), c(), P;
  }, [e, s, c]), h = se((y) => {
    const x = [...a.current], _ = s.findIndex((C) => C.id === y);
    if (_ === -1)
      throw new TypeError("Error occured in ");
    x[_] = !1, a.current = x, n.current = n.current?.filter((C) => C.id !== y), c();
  }, [s, c]), d = se(({
    aud: y,
    audioId: x,
    id: _
  }) => {
    let C = !1;
    n.current = n.current?.map((E) => E.id === _ ? FM(y, E.props) ? E : (C = !0, {
      ...E,
      props: y,
      audioId: x
    }) : E), C && c();
  }, [c]), p = se(() => {
    s.forEach((y) => {
      cl(y.ref, "audio", null);
    });
  }, [s]), g = ee(() => ({
    registerAudio: u,
    unregisterAudio: h,
    updateAudio: d,
    playAllAudios: p,
    numberOfAudioTags: e
  }), [
    e,
    p,
    u,
    h,
    d
  ]), v = se(() => {
    a.current = new Array(e).fill(!1), n.current = [], c();
  }, [e, c]);
  return ue(() => () => {
    v();
  }, [t, v]), /* @__PURE__ */ b.jsxs(Kl.Provider, {
    value: g,
    children: [
      s.map(({ id: y, ref: x }) => /* @__PURE__ */ b.jsx("audio", {
        ref: x,
        preload: "metadata",
        src: Hv
      }, y)),
      r
    ]
  });
}, NM = (r, e) => {
  const t = me(Kl), [n] = he(() => t && t.numberOfAudioTags > 0 ? t.registerAudio(r, e) : {
    el: Ce.createRef(),
    id: Math.random(),
    props: r,
    audioId: e
  }), i = Ce.useInsertionEffect ?? Ce.useLayoutEffect;
  return typeof document < "u" && (i(() => {
    t && t.numberOfAudioTags > 0 && t.updateAudio({ id: n.id, aud: r, audioId: e });
  }, [r, t, n.id, e]), i(() => () => {
    t && t.numberOfAudioTags > 0 && t.unregisterAudio(n.id);
  }, [t, n.id])), n;
}, BM = (r, e) => {
  const [t] = he(r.shouldPreMountAudioTags);
  if (r.shouldPreMountAudioTags !== t)
    throw new Error("Cannot change the behavior for pre-mounting audio tags dynamically.");
  const {
    volume: n,
    muted: i,
    playbackRate: s,
    shouldPreMountAudioTags: a,
    src: c,
    onDuration: u,
    acceptableTimeShiftInSeconds: h,
    _remotionInternalNeedsDurationCalculation: d,
    _remotionInternalNativeLoopPassed: p,
    _remotionInternalStack: g,
    _remotionDebugSeeking: v,
    allowAmplificationDuringRender: y,
    name: x,
    pauseWhenBuffering: _,
    showInTimeline: C,
    loopVolumeCurveBehavior: E,
    stack: k,
    ...O
  } = r, [P] = Wf(), [j] = Hf(), V = wa(E ?? "repeat"), { hidden: F } = me(ba);
  if (!c)
    throw new TypeError("No 'src' was passed to <Audio>.");
  const $ = io(c), z = me(Zt), [G] = he(() => String(Math.random())), H = F[G] ?? !1, Y = oo({
    frame: V,
    volume: n,
    mediaVolume: P,
    allowAmplificationDuringRender: !1
  }), te = ee(() => ({
    muted: i || j || H || Y <= 0,
    src: $,
    loop: p,
    ...O
  }), [
    p,
    H,
    j,
    i,
    O,
    $,
    Y
  ]), ge = ee(() => `audio-${ds(c ?? "")}-${z?.relativeFrom}-${z?.cumulatedFrom}-${z?.durationInFrames}-muted:${r.muted}-loop:${r.loop}`, [
    c,
    z?.relativeFrom,
    z?.cumulatedFrom,
    z?.durationInFrames,
    r.muted,
    r.loop
  ]), Z = NM(te, ge).el, de = lb(Z);
  ub({
    volumePropFrame: V,
    actualVolume: de,
    volume: n,
    mediaVolume: P,
    mediaRef: Z
  }), rb({
    volume: n,
    mediaVolume: P,
    mediaRef: Z,
    src: c,
    mediaType: "audio",
    playbackRate: s ?? 1,
    displayName: x ?? null,
    id: G,
    stack: g,
    showInTimeline: C,
    premountDisplay: null,
    onAutoPlayError: null
  }), cb({
    mediaRef: Z,
    src: c,
    mediaType: "audio",
    playbackRate: s ?? 1,
    onlyWarnForMediaSeekingError: !1,
    acceptableTimeshift: h ?? Nf,
    isPremounting: !!z?.premounting,
    pauseWhenBuffering: _,
    debugSeeking: v,
    onAutoPlayError: null
  }), qr(e, () => Z.current, [Z]);
  const oe = be();
  return oe.current = u, ue(() => {
    const { current: ie } = Z;
    if (!ie)
      return;
    if (ie.duration) {
      oe.current?.(ie.src, ie.duration);
      return;
    }
    const pe = () => {
      oe.current?.(ie.src, ie.duration);
    };
    return ie.addEventListener("loadedmetadata", pe), () => {
      ie.removeEventListener("loadedmetadata", pe);
    };
  }, [Z, c]), t ? null : /* @__PURE__ */ b.jsx("audio", {
    ref: Z,
    preload: "metadata",
    ...te
  });
}, VM = Bt(BM);
typeof window < "u" && (window.remotion_renderReady = !1);
var Kc = [];
typeof window < "u" && (window.remotion_delayRenderTimeouts = {});
var zM = "The delayRender was called:", WM = "Retries left: ", HM = "- Rendering the frame will be retried.", Uv = 3e4, fi = (r, e) => {
  if (typeof r != "string" && typeof r < "u")
    throw new Error("The label parameter of delayRender() must be a string or undefined, got: " + JSON.stringify(r));
  const t = Math.random();
  Kc.push(t);
  const n = Error().stack?.replace(/^Error/g, "") ?? "";
  if (At().isRendering) {
    const i = (e?.timeoutInMilliseconds ?? (typeof window > "u" ? Uv : window.remotion_puppeteerTimeout ?? Uv)) - 2e3;
    if (typeof window < "u") {
      const s = (e?.retries ?? 0) - (window.remotion_attempt - 1);
      window.remotion_delayRenderTimeouts[t] = {
        label: r ?? null,
        timeout: setTimeout(() => {
          const a = [
            "A delayRender()",
            r ? `"${r}"` : null,
            `was called but not cleared after ${i}ms. See https://remotion.dev/docs/timeout for help.`,
            s > 0 ? WM + s : null,
            s > 0 ? HM : null,
            zM,
            n
          ].filter(Wl).join(" ");
          ra(Error(a));
        }, i)
      };
    }
  }
  return typeof window < "u" && (window.remotion_renderReady = !1), t;
}, vt = (r) => {
  if (typeof r > "u")
    throw new TypeError("The continueRender() method must be called with a parameter that is the return value of delayRender(). No value was passed.");
  if (typeof r != "number")
    throw new TypeError("The parameter passed into continueRender() must be the return value of delayRender() which is a number. Got: " + JSON.stringify(r));
  Kc = Kc.filter((e) => e === r ? (At().isRendering && (clearTimeout(window.remotion_delayRenderTimeouts[r].timeout), delete window.remotion_delayRenderTimeouts[r]), !1) : !0), Kc.length === 0 && typeof window < "u" && (window.remotion_renderReady = !0);
}, UM = (r, e) => {
  const t = be(null), {
    volume: n,
    playbackRate: i,
    allowAmplificationDuringRender: s,
    onDuration: a,
    toneFrequency: c,
    _remotionInternalNeedsDurationCalculation: u,
    _remotionInternalNativeLoopPassed: h,
    acceptableTimeShiftInSeconds: d,
    name: p,
    onError: g,
    delayRenderRetries: v,
    delayRenderTimeoutInMilliseconds: y,
    loopVolumeCurveBehavior: x,
    pauseWhenBuffering: _,
    ...C
  } = r, E = ls(), k = wa(x ?? "repeat"), O = Si(), P = me(Zt), { registerRenderAsset: j, unregisterRenderAsset: V } = me(hs), F = ee(() => `audio-${ds(r.src ?? "")}-${P?.relativeFrom}-${P?.cumulatedFrom}-${P?.durationInFrames}`, [
    r.src,
    P?.relativeFrom,
    P?.cumulatedFrom,
    P?.durationInFrames
  ]), $ = oo({
    volume: n,
    frame: k,
    mediaVolume: 1,
    allowAmplificationDuringRender: s ?? !1
  });
  qr(e, () => t.current, []), ue(() => {
    if (!r.src)
      throw new Error("No src passed");
    if (window.remotion_audioEnabled && !r.muted && !($ <= 0))
      return j({
        type: "audio",
        src: Gn(r.src),
        id: F,
        frame: E,
        volume: $,
        mediaFrame: O,
        playbackRate: r.playbackRate ?? 1,
        allowAmplificationDuringRender: s ?? !1,
        toneFrequency: c ?? null,
        audioStartFrame: Math.max(0, -(P?.relativeFrom ?? 0))
      }), () => V(F);
  }, [
    r.muted,
    r.src,
    j,
    E,
    F,
    V,
    $,
    k,
    O,
    i,
    r.playbackRate,
    s,
    c,
    P?.relativeFrom
  ]);
  const { src: z } = r, G = e || u;
  return Xn(() => {
    if (window.process?.env?.NODE_ENV === "test" || !G)
      return;
    const H = fi("Loading <Audio> duration with src=" + z, {
      retries: v ?? void 0,
      timeoutInMilliseconds: y ?? void 0
    }), { current: Y } = t, te = () => {
      Y?.duration && a(Y.src, Y.duration), vt(H);
    };
    return Y?.duration ? (a(Y.src, Y.duration), vt(H)) : Y?.addEventListener("loadedmetadata", te, { once: !0 }), () => {
      Y?.removeEventListener("loadedmetadata", te), vt(H);
    };
  }, [
    z,
    a,
    G,
    v,
    y
  ]), G ? /* @__PURE__ */ b.jsx("audio", {
    ref: t,
    ...C
  }) : null;
}, $M = Bt(UM), YM = (r, e) => {
  const t = me(Kl), {
    startFrom: n,
    endAt: i,
    name: s,
    stack: a,
    pauseWhenBuffering: c,
    showInTimeline: u,
    _remotionDebugSeeking: h,
    ...d
  } = r, { loop: p, ...g } = r, { fps: v } = _i(), y = At(), { durations: x, setDurations: _ } = me(Ff);
  if (typeof r.src != "string")
    throw new TypeError(`The \`<Audio>\` tag requires a string for \`src\`, but got ${JSON.stringify(r.src)} instead.`);
  const C = io(r.src), E = se((P) => {
    console.log(P.currentTarget.error);
    const j = `Could not play audio with src ${C}: ${P.currentTarget.error}. See https://remotion.dev/docs/media-playback-error for help.`;
    p ? ra(new Error(j)) : console.warn(j);
  }, [p, C]), k = se((P, j) => {
    _({ type: "got-duration", durationInSeconds: j, src: P });
  }, [_]), O = x[Gn(C)] ?? x[Gn(r.src)];
  if (p && O !== void 0) {
    if (!Number.isFinite(O))
      return /* @__PURE__ */ b.jsx(Yo, {
        ...g,
        ref: e,
        _remotionInternalNativeLoopPassed: !0
      });
    const P = O * v;
    return /* @__PURE__ */ b.jsx(Xl, {
      layout: "none",
      durationInFrames: J1({
        endAt: i,
        mediaDuration: P,
        playbackRate: r.playbackRate ?? 1,
        startFrom: n
      }),
      children: /* @__PURE__ */ b.jsx(Yo, {
        ...g,
        ref: e,
        _remotionInternalNativeLoopPassed: !0
      })
    });
  }
  if (typeof n < "u" || typeof i < "u") {
    jf(n, i);
    const P = n ?? 0, j = i ?? 1 / 0;
    return /* @__PURE__ */ b.jsx(wn, {
      layout: "none",
      from: 0 - P,
      showInTimeline: !1,
      durationInFrames: j,
      name: s,
      children: /* @__PURE__ */ b.jsx(Yo, {
        _remotionInternalNeedsDurationCalculation: !!p,
        pauseWhenBuffering: c ?? !1,
        ...d,
        ref: e
      })
    });
  }
  return Rf(r, "Audio"), y.isRendering ? /* @__PURE__ */ b.jsx($M, {
    onDuration: k,
    ...r,
    ref: e,
    onError: E,
    _remotionInternalNeedsDurationCalculation: !!p
  }) : /* @__PURE__ */ b.jsx(VM, {
    _remotionInternalNativeLoopPassed: r._remotionInternalNativeLoopPassed ?? !1,
    _remotionDebugSeeking: h ?? !1,
    _remotionInternalStack: a ?? null,
    shouldPreMountAudioTags: t !== null && t.numberOfAudioTags > 0,
    ...r,
    ref: e,
    onError: E,
    onDuration: k,
    pauseWhenBuffering: c ?? !1,
    _remotionInternalNeedsDurationCalculation: !!p,
    showInTimeline: u ?? !0
  });
}, Yo = Bt(YM);
ya(Yo);
var XM = It({
  folderName: null,
  parentName: null
}), GM = {
  transform: "rotate(90deg)"
}, $v = 40, qM = {
  color: "white",
  fontSize: 14,
  fontFamily: "sans-serif"
}, KM = {
  justifyContent: "center",
  alignItems: "center"
}, ZM = () => /* @__PURE__ */ b.jsxs($o, {
  style: KM,
  id: "remotion-comp-loading",
  children: [
    /* @__PURE__ */ b.jsx("style", {
      type: "text/css",
      children: `
				@keyframes anim {
					from {
						opacity: 0
					}
					to {
						opacity: 1
					}
				}
				#remotion-comp-loading {
					animation: anim 2s;
					animation-fill-mode: forwards;
				}
			`
    }),
    /* @__PURE__ */ b.jsx("svg", {
      width: $v,
      height: $v,
      viewBox: "-100 -100 400 400",
      style: GM,
      children: /* @__PURE__ */ b.jsx("path", {
        fill: "#555",
        stroke: "#555",
        strokeWidth: "100",
        strokeLinejoin: "round",
        d: "M 2 172 a 196 100 0 0 0 195 5 A 196 240 0 0 0 100 2.259 A 196 240 0 0 0 2 172 z"
      })
    }),
    /* @__PURE__ */ b.jsxs("p", {
      style: qM,
      children: [
        "Resolving ",
        "<Suspense>",
        "..."
      ]
    })
  ]
}), Ar = null, jd = () => {
  if (!Ar) {
    if (typeof document > "u")
      throw new Error("Tried to call an API that only works in the browser from outside the browser");
    Ar = document.createElement("div"), Ar.style.position = "absolute", Ar.style.top = "0px", Ar.style.left = "0px", Ar.style.right = "0px", Ar.style.bottom = "0px", Ar.style.width = "100%", Ar.style.height = "100%", Ar.style.display = "flex", Ar.style.flexDirection = "column";
    const r = document.createElement("div");
    r.style.position = "fixed", r.style.top = "-999999px", r.appendChild(Ar), document.body.appendChild(r);
  }
  return Ar;
}, db = (r) => ee(() => {
  if ("lazyComponent" in r && typeof r.lazyComponent < "u")
    return Ce.lazy(r.lazyComponent);
  if ("component" in r)
    return typeof document > "u" ? r.component : Ce.lazy(() => Promise.resolve({ default: r.component }));
  throw new Error("You must pass either 'component' or 'lazyComponent'");
}, [r.component, r.lazyComponent]), fb = () => /^([a-zA-Z0-9-\u4E00-\u9FFF])+$/g, pb = (r) => r.match(fb()), JM = (r) => {
  if (!pb(r))
    throw new Error(`Composition id can only contain a-z, A-Z, 0-9, CJK characters and -. You passed ${r}`);
}, QM = `Composition ID must match ${String(fb())}`, eP = (r, e, t) => {
  if (r) {
    if (typeof r != "object")
      throw new Error(`"${e}" must be an object, but you passed a value of type ${typeof r}`);
    if (Array.isArray(r))
      throw new Error(`"${e}" must be an object, an array was passed ${t ? `for composition "${t}"` : ""}`);
  }
}, tP = () => (ue(() => {
  const r = fi("Waiting for Root component to unsuspend");
  return () => vt(r);
}, []), null), Yv = ({
  width: r,
  height: e,
  fps: t,
  durationInFrames: n,
  id: i,
  defaultProps: s,
  schema: a,
  ...c
}) => {
  const { registerComposition: u, unregisterComposition: h } = me(xi), d = $l(), p = db(c), g = If(), v = Of(), y = At();
  if (me(us))
    throw v ? new Error("<Composition> was mounted inside the `component` that was passed to the <Player>. See https://remotion.dev/docs/wrong-composition-mount for help.") : new Error("<Composition> mounted inside another composition. See https://remotion.dev/docs/wrong-composition-mount for help.");
  const { folderName: _, parentName: C } = me(XM);
  ue(() => {
    if (!i)
      throw new Error("No id for composition passed.");
    return JM(i), eP(s, "defaultProps", i), u({
      durationInFrames: n ?? void 0,
      fps: t ?? void 0,
      height: e ?? void 0,
      width: r ?? void 0,
      id: i,
      folderName: _,
      component: p,
      defaultProps: Bi(s ?? {}),
      nonce: g,
      parentFolderName: C,
      schema: a ?? null,
      calculateMetadata: c.calculateMetadata ?? null
    }), () => {
      h(i);
    };
  }, [
    n,
    t,
    e,
    p,
    i,
    _,
    s,
    u,
    h,
    r,
    g,
    C,
    a,
    c.calculateMetadata
  ]);
  const E = Mf(i);
  if (y.isStudio && d && d.component === p) {
    const k = p;
    return E === null || E.type !== "success" ? null : hd(/* @__PURE__ */ b.jsx(Pd, {
      children: /* @__PURE__ */ b.jsx(tl, {
        fallback: /* @__PURE__ */ b.jsx(ZM, {}),
        children: /* @__PURE__ */ b.jsx(k, {
          ...E.result.props ?? {}
        })
      })
    }), jd());
  }
  if (y.isRendering && d && d.component === p) {
    const k = p;
    return E === null || E.type !== "success" ? null : hd(/* @__PURE__ */ b.jsx(Pd, {
      children: /* @__PURE__ */ b.jsx(tl, {
        fallback: /* @__PURE__ */ b.jsx(tP, {}),
        children: /* @__PURE__ */ b.jsx(k, {
          ...E.result.props ?? {}
        })
      })
    }), jd());
  }
  return null;
}, gb = Ce.createRef(), rP = ({ children: r, numberOfAudioTags: e }) => {
  const [t, n] = he([]), i = be(t), [s, a] = he([]), [c, u] = he(null), [h, d] = he(null), p = se((k) => {
    n((O) => {
      const P = k(O);
      return i.current = P, P;
    });
  }, []), g = se((k) => {
    p((O) => {
      if (O.find((j) => j.id === k.id))
        throw new Error(`Multiple composition with id ${k.id} are registered.`);
      return [...O, k].slice().sort((j, V) => j.nonce - V.nonce);
    });
  }, [p]), v = se((k) => {
    n((O) => O.filter((P) => P.id !== k));
  }, []), y = se((k, O) => {
    a((P) => [
      ...P,
      {
        name: k,
        parent: O
      }
    ]);
  }, []), x = se((k, O) => {
    a((P) => P.filter((j) => !(j.name === k && j.parent === O)));
  }, []);
  qr(gb, () => ({
    getCompositions: () => i.current
  }), []);
  const _ = t.find((k) => c?.type === "composition" ? k.id === c.compositionId : null), C = se((k, O) => {
    n((P) => P.map((V) => V.id === k ? {
      ...V,
      defaultProps: O
    } : V));
  }, []), E = ee(() => ({
    compositions: t,
    registerComposition: g,
    unregisterComposition: v,
    folders: s,
    registerFolder: y,
    unregisterFolder: x,
    currentCompositionMetadata: h,
    setCurrentCompositionMetadata: d,
    canvasContent: c,
    setCanvasContent: u,
    updateCompositionDefaultProps: C
  }), [
    t,
    g,
    v,
    s,
    y,
    x,
    h,
    c,
    C
  ]);
  return /* @__PURE__ */ b.jsx(xi.Provider, {
    value: E,
    children: /* @__PURE__ */ b.jsx(qA, {
      children: /* @__PURE__ */ b.jsx(gM, {
        children: /* @__PURE__ */ b.jsx(Y1, {
          children: /* @__PURE__ */ b.jsx(hb, {
            numberOfAudioTags: e,
            component: _?.component ?? null,
            children: r
          })
        })
      })
    })
  });
}, nP = ({
  onLoad: r,
  onError: e,
  delayRenderRetries: t,
  delayRenderTimeoutInMilliseconds: n,
  ...i
}, s) => {
  const [a] = he(() => fi(`Loading <IFrame> with source ${i.src}`, {
    retries: t ?? void 0,
    timeoutInMilliseconds: n ?? void 0
  })), c = se((h) => {
    vt(a), r?.(h);
  }, [a, r]), u = se((h) => {
    vt(a), e ? e(h) : console.error("Error loading iframe:", h, "Handle the event using the onError() prop to make this message disappear.");
  }, [a, e]);
  return /* @__PURE__ */ b.jsx("iframe", {
    ...i,
    ref: s,
    onError: u,
    onLoad: c
  });
};
Bt(nP);
function iP(r) {
  return 1e3 * 2 ** (r - 1);
}
var sP = ({
  onError: r,
  maxRetries: e = 2,
  src: t,
  pauseWhenLoading: n,
  delayRenderRetries: i,
  delayRenderTimeoutInMilliseconds: s,
  onImageFrame: a,
  ...c
}, u) => {
  const h = be(null), d = be({}), { delayPlayback: p } = Lf(), g = me(Zt);
  if (!t)
    throw new Error('No "src" prop was passed to <Img>.');
  qr(u, () => h.current, []);
  const v = io(t), y = se((_) => {
    if (!h.current)
      return;
    const C = h.current.src;
    setTimeout(() => {
      if (!h.current)
        return;
      const E = h.current?.src;
      E === C && (h.current.removeAttribute("src"), h.current.setAttribute("src", E));
    }, _);
  }, []), x = se((_) => {
    if (d.current) {
      if (d.current[h.current?.src] = (d.current[h.current?.src] ?? 0) + 1, r && (d.current[h.current?.src] ?? 0) > e) {
        r(_);
        return;
      }
      if ((d.current[h.current?.src] ?? 0) <= e) {
        const C = iP(d.current[h.current?.src] ?? 0);
        console.warn(`Could not load image with source ${h.current?.src}, retrying again in ${C}ms`), y(C);
        return;
      }
      ra("Error loading image with src: " + h.current?.src);
    }
  }, [e, r, y]);
  if (typeof window < "u") {
    const _ = !!g?.premounting;
    Xn(() => {
      if (window.process?.env?.NODE_ENV === "test") {
        h.current && (h.current.src = v);
        return;
      }
      const C = fi("Loading <Img> with src=" + v, {
        retries: i ?? void 0,
        timeoutInMilliseconds: s ?? void 0
      }), E = n && !_ ? p().unblock : () => {
      }, { current: k } = h;
      let O = !1;
      const P = () => {
        O || ((d.current[h.current?.src] ?? 0) > 0 && (delete d.current[h.current?.src], console.info(`Retry successful - ${h.current?.src} is now loaded`)), k && (k.src = v, a?.(k)), E(), vt(C));
      }, j = new Image();
      return j.src = v, j.decode().then(P).catch((V) => {
        console.warn(V), j.complete ? P() : j.addEventListener("load", P);
      }), () => {
        O = !0, j.removeEventListener("load", P), E(), vt(C);
      };
    }, [
      v,
      p,
      i,
      s,
      n,
      _,
      a
    ]);
  }
  return /* @__PURE__ */ b.jsx("img", {
    ...c,
    ref: h,
    onError: x
  });
}, mb = Bt(sP), vb = {};
D1(vb, {
  makeDefaultPreviewCSS: () => aP,
  injectCSS: () => oP,
  OFFTHREAD_VIDEO_CLASS_NAME: () => ll
});
var Xv = {}, oP = (r) => {
  if (typeof document > "u" || Xv[r])
    return;
  const e = document.head || document.getElementsByTagName("head")[0], t = document.createElement("style");
  t.appendChild(document.createTextNode(r)), e.prepend(t), Xv[r] = !0;
}, ll = "__remotion_offthreadvideo", aP = (r, e) => r ? `
    ${r} * {
      box-sizing: border-box;
    }
    ${r} *:-webkit-full-screen {
      width: 100%;
      height: 100%;
    }
    ${r} .${ll} {
      object-fit: contain;
    }
  ` : `
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
	    background-color: ${e};
    }
    .${ll} {
      object-fit: contain;
    }
    `, yb = "__remotion-studio-container", cP = () => document.getElementById(yb), lP = null, Bh = [], uP = () => lP, hP = (r) => (Bh.push(r), () => {
  Bh = Bh.filter((e) => e !== r);
}), dP = ({ children: r, numberOfAudioTags: e }) => {
  const [t] = he(() => String(ds(null))), [n, i] = he(() => G1()), [s, a] = he(!1), c = be(!1), [u, h] = he(0), [d, p] = he(1), g = be([]);
  typeof window < "u" && Xn(() => {
    window.remotion_setFrame = (_, C, E) => {
      window.remotion_attempt = E;
      const k = fi(`Setting the current frame to ${_}`);
      let O = !0;
      i((P) => (P[C] ?? window.remotion_initialFrame) === _ ? (O = !1, P) : {
        ...P,
        [C]: _
      }), O ? requestAnimationFrame(() => vt(k)) : vt(k);
    }, window.remotion_isPlayer = !1;
  }, []);
  const v = ee(() => ({
    frame: n,
    playing: s,
    imperativePlaying: c,
    rootId: t,
    playbackRate: d,
    setPlaybackRate: p,
    audioAndVideoTags: g
  }), [n, d, s, t]), y = ee(() => ({
    setFrame: i,
    setPlaying: a
  }), []), x = ee(() => {
    let _ = 0;
    return {
      getNonce: () => _++,
      fastRefreshes: u
    };
  }, [u]);
  return ue(() => {
    typeof __webpack_module__ < "u" && __webpack_module__.hot && __webpack_module__.hot.addStatusHandler((_) => {
      _ === "idle" && h((C) => C + 1);
    });
  }, []), /* @__PURE__ */ b.jsx(ro.Provider, {
    value: x,
    children: /* @__PURE__ */ b.jsx(an.Provider, {
      value: v,
      children: /* @__PURE__ */ b.jsx(no.Provider, {
        value: y,
        children: /* @__PURE__ */ b.jsx(B1, {
          children: /* @__PURE__ */ b.jsx(eb, {
            children: /* @__PURE__ */ b.jsx(rP, {
              numberOfAudioTags: e,
              children: /* @__PURE__ */ b.jsx(tb, {
                children: /* @__PURE__ */ b.jsx(nb, {
                  children: r
                })
              })
            })
          })
        })
      })
    })
  });
}, fP = () => {
  if (At().isRendering) {
    const r = window.remotion_envVariables;
    return r ? { ...JSON.parse(r), NODE_ENV: "production" } : {};
  }
  return {
    NODE_ENV: "production"
  };
}, pP = () => {
  const r = fP();
  window.process || (window.process = {}), window.process.env || (window.process.env = {}), Object.keys(r).forEach((e) => {
    window.process.env[e] = r[e];
  });
}, gP = Ce.createContext(null), mP = It({
  setSize: () => {
  },
  size: { size: "auto", translation: { x: 0, y: 0 } }
}), vP = ({
  canvasSize: r,
  compositionHeight: e,
  compositionWidth: t,
  previewSize: n
}) => {
  const i = r.height / e, s = r.width / t, a = Math.min(i, s);
  return n === "auto" ? a : Number(n);
}, yP = "remotion_staticFilesChanged";
function bP() {
  const r = Ce.useContext(xi), e = Ce.useContext(an), t = Ce.useContext(no), n = Ce.useContext(Zt), i = Ce.useContext(ro), s = Ce.useContext(us), a = Ce.useContext(Gl), c = Ce.useContext(Ul), u = Ce.useContext(hs), h = Ce.useContext(to), d = Ce.useContext(ao);
  return ee(() => ({
    compositionManagerCtx: r,
    timelineContext: e,
    setTimelineContext: t,
    sequenceContext: n,
    nonceContext: i,
    canUseRemotionHooksContext: s,
    preloadContext: a,
    resolveCompositionContext: c,
    renderAssetManagerContext: u,
    sequenceManagerContext: h,
    bufferManagerContext: d
  }), [
    r,
    i,
    n,
    t,
    e,
    s,
    a,
    c,
    u,
    h,
    d
  ]);
}
var wP = (r) => {
  const { children: e, contexts: t } = r;
  return /* @__PURE__ */ b.jsx(us.Provider, {
    value: t.canUseRemotionHooksContext,
    children: /* @__PURE__ */ b.jsx(ro.Provider, {
      value: t.nonceContext,
      children: /* @__PURE__ */ b.jsx(Gl.Provider, {
        value: t.preloadContext,
        children: /* @__PURE__ */ b.jsx(xi.Provider, {
          value: t.compositionManagerCtx,
          children: /* @__PURE__ */ b.jsx(to.Provider, {
            value: t.sequenceManagerContext,
            children: /* @__PURE__ */ b.jsx(hs.Provider, {
              value: t.renderAssetManagerContext,
              children: /* @__PURE__ */ b.jsx(Ul.Provider, {
                value: t.resolveCompositionContext,
                children: /* @__PURE__ */ b.jsx(an.Provider, {
                  value: t.timelineContext,
                  children: /* @__PURE__ */ b.jsx(no.Provider, {
                    value: t.setTimelineContext,
                    children: /* @__PURE__ */ b.jsx(Zt.Provider, {
                      value: t.sequenceContext,
                      children: /* @__PURE__ */ b.jsx(ao.Provider, {
                        value: t.bufferManagerContext,
                        children: e
                      })
                    })
                  })
                })
              })
            })
          })
        })
      })
    })
  });
}, Te = {
  useUnsafeVideoConfig: Yl,
  Timeline: L1,
  CompositionManager: xi,
  SequenceManager: to,
  SequenceVisibilityToggleContext: ba,
  RemotionRoot: dP,
  useVideo: $l,
  getRoot: uP,
  useMediaVolumeState: Wf,
  useMediaMutedState: Hf,
  useLazyComponent: db,
  truthy: Wl,
  SequenceContext: Zt,
  useRemotionContexts: bP,
  RemotionContextProvider: wP,
  CSSUtils: vb,
  setupEnvVariables: pP,
  MediaVolumeContext: Vf,
  SetMediaVolumeContext: zf,
  getRemotionEnvironment: At,
  SharedAudioContext: Kl,
  SharedAudioContextProvider: hb,
  invalidCompositionErrorMessage: QM,
  isCompositionIdValid: pb,
  getPreviewDomElement: cP,
  compositionsRef: gb,
  portalNode: jd,
  waitForRoot: hP,
  CanUseRemotionHooksProvider: Pd,
  CanUseRemotionHooks: us,
  PrefetchProvider: eb,
  DurationsContextProvider: tb,
  IsPlayerContextProvider: YA,
  useIsPlayer: Of,
  EditorPropsProvider: B1,
  EditorPropsContext: Hl,
  usePreload: io,
  NonceContext: ro,
  resolveVideoConfig: H1,
  useResolvedVideoConfig: Mf,
  resolveCompositionsRef: U1,
  ResolveCompositionConfig: Y1,
  REMOTION_STUDIO_CONTAINER_ELEMENT: yb,
  RenderAssetManager: hs,
  persistCurrentFrame: X1,
  useTimelineSetFrame: K1,
  isIosSafari: ql,
  WATCH_REMOTION_STATIC_FILES: yP,
  addSequenceStackTraces: ya,
  useMediaStartsAt: so,
  BufferingProvider: nb,
  BufferingContextReact: ao,
  enableSequenceStackTraces: j1,
  CurrentScaleContext: gP,
  PreviewSizeContext: mP,
  calculateScale: vP,
  editorPropsProviderRef: N1,
  PROPS_UPDATED_EXTERNALLY: oM,
  validateRenderAsset: Z1
}, xP = ({
  src: r,
  transparent: e,
  currentTime: t,
  toneMapped: n
}) => `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(Gn(r))}&time=${encodeURIComponent(t)}&transparent=${String(e)}&toneMapped=${String(n)}`, bb = It(!1), _P = ({ children: r }) => /* @__PURE__ */ b.jsx(bb.Provider, {
  value: !1,
  children: r
}), SP = () => {
  if (!Ce.useContext(bb))
    throw new Error("This component must be inside a <Series /> component.");
}, CP = ({ children: r }, e) => (SP(), /* @__PURE__ */ b.jsx(_P, {
  children: r
})), TP = Bt(CP);
ya(TP);
var EP = ({
  onError: r,
  volume: e,
  playbackRate: t,
  src: n,
  muted: i,
  allowAmplificationDuringRender: s,
  transparent: a = !1,
  toneMapped: c = !0,
  toneFrequency: u,
  name: h,
  loopVolumeCurveBehavior: d,
  delayRenderRetries: p,
  delayRenderTimeoutInMilliseconds: g,
  onVideoFrame: v,
  ...y
}) => {
  const x = ls(), _ = Si(), C = wa(d ?? "repeat"), E = Yl(), k = me(Zt), O = so(), { registerRenderAsset: P, unregisterRenderAsset: j } = me(hs);
  if (!n)
    throw new TypeError("No `src` was passed to <OffthreadVideo>.");
  const V = ee(() => `offthreadvideo-${ds(n ?? "")}-${k?.cumulatedFrom}-${k?.relativeFrom}-${k?.durationInFrames}`, [
    n,
    k?.cumulatedFrom,
    k?.relativeFrom,
    k?.durationInFrames
  ]);
  if (!E)
    throw new Error("No video config found");
  const F = oo({
    volume: e,
    frame: C,
    mediaVolume: 1,
    allowAmplificationDuringRender: s ?? !1
  });
  ue(() => {
    if (!n)
      throw new Error("No src passed");
    if (window.remotion_audioEnabled && !i && !(F <= 0))
      return P({
        type: "video",
        src: Gn(n),
        id: V,
        frame: x,
        volume: F,
        mediaFrame: _,
        playbackRate: t ?? 1,
        allowAmplificationDuringRender: s ?? !1,
        toneFrequency: u ?? null,
        audioStartFrame: Math.max(0, -(k?.relativeFrom ?? 0))
      }), () => j(V);
  }, [
    i,
    n,
    P,
    V,
    j,
    F,
    _,
    x,
    t,
    s,
    u,
    k?.relativeFrom
  ]);
  const $ = ee(() => sb({
    frame: _,
    playbackRate: t || 1,
    startFrom: -O
  }) / E.fps, [_, O, t, E.fps]), z = ee(() => xP({
    src: n,
    currentTime: $,
    transparent: a,
    toneMapped: c
  }), [c, $, n, a]), [G, H] = he(null);
  Xn(() => {
    if (!window.remotion_videoEnabled)
      return;
    const Z = [];
    H(null);
    const de = new AbortController(), oe = fi(`Fetching ${z} from server`, {
      retries: p ?? void 0,
      timeoutInMilliseconds: g ?? void 0
    });
    return (async () => {
      try {
        const pe = await fetch(z, {
          signal: de.signal
        });
        if (pe.status !== 200) {
          if (pe.status === 500) {
            const Ze = await pe.json();
            if (Ze.error) {
              const ze = Ze.error.replace(/^Error: /, "");
              throw new Error(ze);
            }
          }
          throw new Error(`Server returned status ${pe.status} while fetching ${z}`);
        }
        const re = await pe.blob(), Be = URL.createObjectURL(re);
        Z.push(() => URL.revokeObjectURL(Be)), H({
          src: Be,
          handle: oe
        });
      } catch (pe) {
        if (pe.message.includes("aborted")) {
          vt(oe);
          return;
        }
        if (de.signal.aborted) {
          vt(oe);
          return;
        }
        pe.message.includes("Failed to fetch") && (pe = new Error(`Failed to fetch ${z}. This could be caused by Chrome rejecting the request because the disk space is low. Consider increasing the disk size of your environment.`, { cause: pe })), r ? r(pe) : ra(pe);
      }
    })(), Z.push(() => {
      de.signal.aborted || de.abort();
    }), () => {
      Z.forEach((pe) => pe());
    };
  }, [
    z,
    p,
    g,
    r
  ]);
  const Y = se(() => {
    r ? r?.(new Error("Failed to load image with src " + G)) : ra("Failed to load image with src " + G);
  }, [G, r]), te = ee(() => [ll, y.className].filter(Wl).join(" "), [y.className]), ge = se((Z) => {
    v && v(Z);
  }, [v]);
  return !G || !window.remotion_videoEnabled ? null : (vt(G.handle), /* @__PURE__ */ b.jsx(mb, {
    src: G.src,
    className: te,
    delayRenderRetries: p,
    delayRenderTimeoutInMilliseconds: g,
    onImageFrame: ge,
    ...y,
    onError: Y
  }));
}, kP = ({
  ref: r,
  onVideoFrame: e
}) => {
  ue(() => {
    const { current: t } = r;
    if (!t || !e)
      return;
    let n = 0;
    const i = () => {
      r.current && (e(r.current), n = r.current.requestVideoFrameCallback(i));
    };
    return i(), () => {
      t.cancelVideoFrameCallback(n);
    };
  }, [e, r]);
}, OP = (r, e) => {
  const t = be(null), {
    volume: n,
    muted: i,
    playbackRate: s,
    onlyWarnForMediaSeekingError: a,
    src: c,
    onDuration: u,
    acceptableTimeShift: h,
    acceptableTimeShiftInSeconds: d,
    toneFrequency: p,
    name: g,
    _remotionInternalNativeLoopPassed: v,
    _remotionInternalStack: y,
    _remotionDebugSeeking: x,
    style: _,
    pauseWhenBuffering: C,
    showInTimeline: E,
    loopVolumeCurveBehavior: k,
    onError: O,
    onAutoPlayError: P,
    onVideoFrame: j,
    crossOrigin: V,
    ...F
  } = r, $ = wa(k ?? "repeat"), { fps: z, durationInFrames: G } = _i(), H = me(Zt), { hidden: Y } = me(ba), [te] = he(() => String(Math.random())), ge = Y[te] ?? !1;
  if (typeof h < "u")
    throw new Error("acceptableTimeShift has been removed. Use acceptableTimeShiftInSeconds instead.");
  const Z = lb(t), [de] = Wf(), [oe] = Hf();
  rb({
    mediaRef: t,
    volume: n,
    mediaVolume: de,
    mediaType: "video",
    src: c,
    playbackRate: r.playbackRate ?? 1,
    displayName: g ?? null,
    id: te,
    stack: y,
    showInTimeline: E,
    premountDisplay: null,
    onAutoPlayError: P ?? null
  }), ub({
    volumePropFrame: $,
    actualVolume: Z,
    volume: n,
    mediaVolume: de,
    mediaRef: t
  }), cb({
    mediaRef: t,
    src: c,
    mediaType: "video",
    playbackRate: r.playbackRate ?? 1,
    onlyWarnForMediaSeekingError: a,
    acceptableTimeshift: d ?? Nf,
    isPremounting: !!H?.premounting,
    pauseWhenBuffering: C,
    debugSeeking: x,
    onAutoPlayError: P ?? null
  });
  const ie = H ? H.relativeFrom : 0, pe = H ? Math.min(H.durationInFrames, G) : G, re = DM({
    actualSrc: io(c),
    actualFrom: ie,
    duration: pe,
    fps: z
  });
  qr(e, () => t.current, []), ue(() => {
    const { current: Ee } = t;
    if (!Ee)
      return;
    const Ie = () => {
      if (Ee.error) {
        if (console.error("Error occurred in video", Ee?.error), O) {
          const dt = new Error(`Code ${Ee.error.code}: ${Ee.error.message}`);
          O(dt);
          return;
        }
        throw new Error(`The browser threw an error while playing the video ${c}: Code ${Ee.error.code} - ${Ee?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);
      } else {
        if (O) {
          const dt = new Error(`The browser threw an error while playing the video ${c}`);
          O(dt);
          return;
        }
        throw new Error("The browser threw an error while playing the video");
      }
    };
    return Ee.addEventListener("error", Ie, { once: !0 }), () => {
      Ee.removeEventListener("error", Ie);
    };
  }, [O, c]);
  const Be = be();
  Be.current = u, kP({ ref: t, onVideoFrame: j }), ue(() => {
    const { current: Ee } = t;
    if (!Ee)
      return;
    if (Ee.duration) {
      Be.current?.(c, Ee.duration);
      return;
    }
    const Ie = () => {
      Be.current?.(c, Ee.duration);
    };
    return Ee.addEventListener("loadedmetadata", Ie), () => {
      Ee.removeEventListener("loadedmetadata", Ie);
    };
  }, [c]), ue(() => {
    const { current: Ee } = t;
    Ee && (ql() ? Ee.preload = "metadata" : Ee.preload = "auto");
  }, []);
  const Ze = ee(() => ({
    ..._,
    opacity: ge ? 0 : _?.opacity ?? 1
  }), [ge, _]), ze = V ?? (j ? "anonymous" : void 0);
  return /* @__PURE__ */ b.jsx("video", {
    ref: t,
    muted: i || oe,
    playsInline: !0,
    src: re,
    loop: v,
    style: Ze,
    disableRemotePlayback: !0,
    crossOrigin: ze,
    ...F
  });
}, wb = Bt(OP), xb = (r) => {
  const {
    startFrom: e,
    endAt: t,
    name: n,
    pauseWhenBuffering: i,
    stack: s,
    showInTimeline: a,
    ...c
  } = r, u = At(), h = se(() => {
  }, []);
  if (typeof r.src != "string")
    throw new TypeError(`The \`<OffthreadVideo>\` tag requires a string for \`src\`, but got ${JSON.stringify(r.src)} instead.`);
  if (r.imageFormat)
    throw new TypeError("The `<OffthreadVideo>` tag does no longer accept `imageFormat`. Use the `transparent` prop if you want to render a transparent video.");
  if (typeof e < "u" || typeof t < "u") {
    jf(e, t);
    const C = e ?? 0, E = t ?? 1 / 0;
    return /* @__PURE__ */ b.jsx(wn, {
      layout: "none",
      from: 0 - C,
      showInTimeline: !1,
      durationInFrames: E,
      name: n,
      children: /* @__PURE__ */ b.jsx(xb, {
        pauseWhenBuffering: i ?? !1,
        ...c
      })
    });
  }
  if (Rf(r, "Video"), u.isRendering)
    return /* @__PURE__ */ b.jsx(EP, {
      ...c
    });
  const {
    transparent: d,
    toneMapped: p,
    _remotionDebugSeeking: g,
    onAutoPlayError: v,
    onVideoFrame: y,
    crossOrigin: x,
    ..._
  } = c;
  return /* @__PURE__ */ b.jsx(wb, {
    _remotionInternalStack: s ?? null,
    _remotionInternalNativeLoopPassed: !1,
    _remotionDebugSeeking: g ?? !1,
    onDuration: h,
    onlyWarnForMediaSeekingError: !0,
    pauseWhenBuffering: i ?? !1,
    showInTimeline: a ?? !0,
    onAutoPlayError: v ?? void 0,
    onVideoFrame: y ?? null,
    crossOrigin: x,
    ..._
  });
}, Gv = (r) => Math.round(r * 1e5) / 1e5, Vh = (r, e) => {
  if (Bf(r.currentTime, e))
    return {
      wait: Promise.resolve(e),
      cancel: () => {
      }
    };
  r.currentTime = e;
  let t, n = null;
  const i = new Promise((a) => {
    t = r.requestVideoFrameCallback((c, u) => {
      const h = u.expectedDisplayTime - c;
      if (h <= 0) {
        a(u.mediaTime);
        return;
      }
      setTimeout(() => {
        a(u.mediaTime);
      }, h + 150);
    });
  }), s = new Promise((a) => {
    const c = () => {
      a();
    };
    r.addEventListener("seeked", c, {
      once: !0
    }), n = () => {
      r.removeEventListener("seeked", c);
    };
  });
  return {
    wait: Promise.all([i, s]).then(([a]) => a),
    cancel: () => {
      n?.(), r.cancelVideoFrameCallback(t);
    }
  };
}, IP = (r, e, t) => {
  const n = 1 / t / 2;
  let i = () => {
  };
  return Number.isFinite(r.duration) && r.currentTime >= r.duration && e >= r.duration ? {
    prom: Promise.resolve(),
    cancel: () => {
    }
  } : {
    prom: new Promise((a, c) => {
      const u = Vh(r, e + n);
      u.wait.then((h) => {
        if (Math.abs(e - h) <= n)
          return a();
        const p = e > h ? 1 : -1, g = Vh(r, h + n * p);
        i = g.cancel, g.wait.then((v) => {
          const y = Math.abs(e - v);
          if (Gv(y) <= Gv(n))
            return a();
          const x = Vh(r, e + n);
          return i = x.cancel, x.wait.then(() => {
            a();
          }).catch((_) => {
            c(_);
          });
        }).catch((v) => {
          c(v);
        });
      }), i = u.cancel;
    }),
    cancel: () => {
      i();
    }
  };
}, AP = ({
  onError: r,
  volume: e,
  allowAmplificationDuringRender: t,
  playbackRate: n,
  onDuration: i,
  toneFrequency: s,
  name: a,
  acceptableTimeShiftInSeconds: c,
  delayRenderRetries: u,
  delayRenderTimeoutInMilliseconds: h,
  loopVolumeCurveBehavior: d,
  ...p
}, g) => {
  const v = ls(), y = Si(), x = wa(d ?? "repeat"), _ = Yl(), C = be(null), E = me(Zt), k = so(), O = At(), { registerRenderAsset: P, unregisterRenderAsset: j } = me(hs), V = ee(() => `video-${ds(p.src ?? "")}-${E?.cumulatedFrom}-${E?.relativeFrom}-${E?.durationInFrames}`, [
    p.src,
    E?.cumulatedFrom,
    E?.relativeFrom,
    E?.durationInFrames
  ]);
  if (!_)
    throw new Error("No video config found");
  const F = oo({
    volume: e,
    frame: x,
    mediaVolume: 1,
    allowAmplificationDuringRender: t ?? !1
  });
  ue(() => {
    if (!p.src)
      throw new Error("No src passed");
    if (!p.muted && !(F <= 0) && window.remotion_audioEnabled)
      return P({
        type: "video",
        src: Gn(p.src),
        id: V,
        frame: v,
        volume: F,
        mediaFrame: y,
        playbackRate: n ?? 1,
        allowAmplificationDuringRender: t ?? !1,
        toneFrequency: s ?? null,
        audioStartFrame: Math.max(0, -(E?.relativeFrom ?? 0))
      }), () => j(V);
  }, [
    p.muted,
    p.src,
    P,
    V,
    j,
    F,
    y,
    v,
    n,
    t,
    s,
    E?.relativeFrom
  ]), qr(g, () => C.current, []), ue(() => {
    if (!window.remotion_videoEnabled)
      return;
    const { current: z } = C;
    if (!z)
      return;
    const G = ob({
      frame: y,
      playbackRate: n || 1,
      startFrom: -k,
      fps: _.fps
    }), H = fi(`Rendering <Video /> with src="${p.src}" at time ${G}`, {
      retries: u ?? void 0,
      timeoutInMilliseconds: h ?? void 0
    });
    if (window.process?.env?.NODE_ENV === "test") {
      vt(H);
      return;
    }
    if (Bf(z.currentTime, G)) {
      if (z.readyState >= 2) {
        vt(H);
        return;
      }
      const Z = () => {
        vt(H);
      };
      return z.addEventListener("loadeddata", Z, { once: !0 }), () => {
        z.removeEventListener("loadeddata", Z);
      };
    }
    const Y = () => {
      vt(H);
    }, te = IP(z, G, _.fps);
    te.prom.then(() => {
      vt(H);
    }), z.addEventListener("ended", Y, { once: !0 });
    const ge = () => {
      if (z?.error) {
        if (console.error("Error occurred in video", z?.error), r)
          return;
        throw new Error(`The browser threw an error while playing the video ${p.src}: Code ${z.error.code} - ${z?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);
      } else
        throw new Error("The browser threw an error");
    };
    return z.addEventListener("error", ge, { once: !0 }), () => {
      te.cancel(), z.removeEventListener("ended", Y), z.removeEventListener("error", ge), vt(H);
    };
  }, [
    x,
    p.src,
    n,
    _.fps,
    y,
    k,
    r,
    u,
    h
  ]);
  const { src: $ } = p;
  return O.isRendering && Xn(() => {
    if (window.process?.env?.NODE_ENV === "test")
      return;
    const z = fi("Loading <Video> duration with src=" + $, {
      retries: u ?? void 0,
      timeoutInMilliseconds: h ?? void 0
    }), { current: G } = C, H = () => {
      G?.duration && i($, G.duration), vt(z);
    };
    return G?.duration ? (i($, G.duration), vt(z)) : G?.addEventListener("loadedmetadata", H, { once: !0 }), () => {
      G?.removeEventListener("loadedmetadata", H), vt(z);
    };
  }, [$, i, u, h]), /* @__PURE__ */ b.jsx("video", {
    ref: C,
    disableRemotePlayback: !0,
    ...p
  });
}, MP = Bt(AP), PP = (r, e) => {
  const {
    startFrom: t,
    endAt: n,
    name: i,
    pauseWhenBuffering: s,
    stack: a,
    _remotionInternalNativeLoopPassed: c,
    showInTimeline: u,
    onAutoPlayError: h,
    ...d
  } = r, { loop: p, _remotionDebugSeeking: g, ...v } = r, { fps: y } = _i(), x = At(), { durations: _, setDurations: C } = me(Ff);
  if (typeof e == "string")
    throw new Error("string refs are not supported");
  if (typeof r.src != "string")
    throw new TypeError(`The \`<Video>\` tag requires a string for \`src\`, but got ${JSON.stringify(r.src)} instead.`);
  const E = io(r.src), k = se((j, V) => {
    C({ type: "got-duration", durationInSeconds: V, src: j });
  }, [C]), O = se(() => {
  }, []), P = _[Gn(E)] ?? _[Gn(r.src)];
  if (p && P !== void 0) {
    if (!Number.isFinite(P))
      return /* @__PURE__ */ b.jsx(Zc, {
        ...v,
        ref: e,
        _remotionInternalNativeLoopPassed: !0
      });
    const j = P * y;
    return /* @__PURE__ */ b.jsx(Xl, {
      durationInFrames: J1({
        endAt: n,
        mediaDuration: j,
        playbackRate: r.playbackRate ?? 1,
        startFrom: t
      }),
      layout: "none",
      name: i,
      children: /* @__PURE__ */ b.jsx(Zc, {
        ...v,
        ref: e,
        _remotionInternalNativeLoopPassed: !0
      })
    });
  }
  if (typeof t < "u" || typeof n < "u") {
    jf(t, n);
    const j = t ?? 0, V = n ?? 1 / 0;
    return /* @__PURE__ */ b.jsx(wn, {
      layout: "none",
      from: 0 - j,
      showInTimeline: !1,
      durationInFrames: V,
      name: i,
      children: /* @__PURE__ */ b.jsx(Zc, {
        pauseWhenBuffering: s ?? !1,
        ...d,
        ref: e
      })
    });
  }
  return Rf(r, "Video"), x.isRendering ? /* @__PURE__ */ b.jsx(MP, {
    onDuration: k,
    onVideoFrame: O ?? null,
    ...d,
    ref: e
  }) : /* @__PURE__ */ b.jsx(wb, {
    onlyWarnForMediaSeekingError: !1,
    ...d,
    ref: e,
    onVideoFrame: null,
    pauseWhenBuffering: s ?? !1,
    onDuration: k,
    _remotionInternalStack: a ?? null,
    _remotionInternalNativeLoopPassed: c ?? !1,
    _remotionDebugSeeking: g ?? !1,
    showInTimeline: u ?? !0,
    onAutoPlayError: h ?? void 0
  });
}, Zc = Bt(PP);
ya(Zc);
XA();
var DP = {}, RP = new Proxy(DP, {
  get(r, e) {
    return e === "Bundling" || e === "Rendering" || e === "Log" || e === "Puppeteer" || e === "Output" ? RP : () => {
      console.warn("⚠️  The CLI configuration has been extracted from Remotion Core."), console.warn("Update the import from the config file:"), console.warn(), console.warn("- Delete:"), console.warn('import {Config} from "remotion";'), console.warn("+ Replace:"), console.warn('import {Config} from "@remotion/cli/config";'), console.warn(), console.warn("For more information, see https://www.remotion.dev/docs/4-0-migration."), process.exit(1);
    };
  }
});
ya(wn);
typeof window < "u" && (window.remotion_renderReady = !1);
typeof window < "u" && (window.remotion_delayRenderTimeouts = {});
var jP = (r, e, t) => {
  if (r) {
    if (typeof r != "object")
      throw new Error(`"${e}" must be an object, but you passed a value of type ${typeof r}`);
    if (Array.isArray(r))
      throw new Error(`"${e}" must be an object, an array was passed ${t ? `for composition "${t}"` : ""}`);
  }
};
function FP(r, e, t) {
  if (typeof r != "number")
    throw new Error(`The "${e}" prop ${t} must be a number, but you passed a value of type ${typeof r}`);
  if (isNaN(r))
    throw new TypeError(`The "${e}" prop ${t} must not be NaN, but is NaN.`);
  if (!Number.isFinite(r))
    throw new TypeError(`The "${e}" prop ${t} must be finite, but is ${r}.`);
  if (r % 1 !== 0)
    throw new TypeError(`The "${e}" prop ${t} must be an integer, but is ${r}.`);
  if (r <= 0)
    throw new TypeError(`The "${e}" prop ${t} must be positive, but got ${r}.`);
}
function LP(r, e) {
  const { allowFloats: t, component: n } = e;
  if (typeof r > "u")
    throw new Error(`The "durationInFrames" prop ${n} is missing.`);
  if (typeof r != "number")
    throw new Error(`The "durationInFrames" prop ${n} must be a number, but you passed a value of type ${typeof r}`);
  if (r <= 0)
    throw new TypeError(`The "durationInFrames" prop ${n} must be positive, but got ${r}.`);
  if (!t && r % 1 !== 0)
    throw new TypeError(`The "durationInFrames" prop ${n} must be an integer, but got ${r}.`);
  if (!Number.isFinite(r))
    throw new TypeError(`The "durationInFrames" prop ${n} must be finite, but got ${r}.`);
}
function NP(r, e, t) {
  if (typeof r != "number")
    throw new Error(`"fps" must be a number, but you passed a value of type ${typeof r} ${e}`);
  if (!Number.isFinite(r))
    throw new Error(`"fps" must be a finite, but you passed ${r} ${e}`);
  if (isNaN(r))
    throw new Error(`"fps" must not be NaN, but got ${r} ${e}`);
  if (r <= 0)
    throw new TypeError(`"fps" must be positive, but got ${r} ${e}`);
  if (t && r > 50)
    throw new TypeError("The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif");
}
var Zl = {
  validateFps: NP,
  validateDimension: FP,
  validateDurationInFrames: LP,
  validateDefaultAndInputProps: jP
}, Yt = 25, Fd = 16, BP = () => /* @__PURE__ */ b.jsx("svg", {
  width: Yt,
  height: Yt,
  viewBox: "0 0 25 25",
  fill: "none",
  children: /* @__PURE__ */ b.jsx("path", {
    d: "M8 6.375C7.40904 8.17576 7.06921 10.2486 7.01438 12.3871C6.95955 14.5255 7.19163 16.6547 7.6875 18.5625C9.95364 18.2995 12.116 17.6164 14.009 16.5655C15.902 15.5147 17.4755 14.124 18.6088 12.5C17.5158 10.8949 15.9949 9.51103 14.1585 8.45082C12.3222 7.3906 10.2174 6.68116 8 6.375Z",
    fill: "white",
    stroke: "white",
    strokeWidth: "6.25",
    strokeLinejoin: "round"
  })
}), VP = () => /* @__PURE__ */ b.jsxs("svg", {
  viewBox: "0 0 100 100",
  width: Yt,
  height: Yt,
  children: [
    /* @__PURE__ */ b.jsx("rect", {
      x: "25",
      y: "20",
      width: "20",
      height: "60",
      fill: "#fff",
      ry: "5",
      rx: "5"
    }),
    /* @__PURE__ */ b.jsx("rect", {
      x: "55",
      y: "20",
      width: "20",
      height: "60",
      fill: "#fff",
      ry: "5",
      rx: "5"
    })
  ]
}), zP = ({
  isFullscreen: r
}) => {
  const n = r ? 0 : 3, i = r ? 6 * 1.6 : 6 / 2, s = r ? 6 * 1.6 : 6 * 2;
  return /* @__PURE__ */ b.jsxs("svg", {
    viewBox: "0 0 32 32",
    height: Fd,
    width: Fd,
    children: [
      /* @__PURE__ */ b.jsx("path", {
        d: `
				M ${n} ${s}
				L ${i} ${i}
				L ${s} ${n}
				`,
        stroke: "#fff",
        strokeWidth: 6,
        fill: "none"
      }),
      /* @__PURE__ */ b.jsx("path", {
        d: `
				M ${32 - n} ${s}
				L ${32 - i} ${i}
				L ${32 - s} ${n}
				`,
        stroke: "#fff",
        strokeWidth: 6,
        fill: "none"
      }),
      /* @__PURE__ */ b.jsx("path", {
        d: `
				M ${n} ${32 - s}
				L ${i} ${32 - i}
				L ${s} ${32 - n}
				`,
        stroke: "#fff",
        strokeWidth: 6,
        fill: "none"
      }),
      /* @__PURE__ */ b.jsx("path", {
        d: `
				M ${32 - n} ${32 - s}
				L ${32 - i} ${32 - i}
				L ${32 - s} ${32 - n}
				`,
        stroke: "#fff",
        strokeWidth: 6,
        fill: "none"
      })
    ]
  });
}, WP = () => /* @__PURE__ */ b.jsx("svg", {
  width: Yt,
  height: Yt,
  viewBox: "0 0 24 24",
  children: /* @__PURE__ */ b.jsx("path", {
    d: "M3.63 3.63a.996.996 0 000 1.41L7.29 8.7 7 9H4c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h3l3.29 3.29c.63.63 1.71.18 1.71-.71v-4.17l4.18 4.18c-.49.37-1.02.68-1.6.91-.36.15-.58.53-.58.92 0 .72.73 1.18 1.39.91.8-.33 1.55-.77 2.22-1.31l1.34 1.34a.996.996 0 101.41-1.41L5.05 3.63c-.39-.39-1.02-.39-1.42 0zM19 12c0 .82-.15 1.61-.41 2.34l1.53 1.53c.56-1.17.88-2.48.88-3.87 0-3.83-2.4-7.11-5.78-8.4-.59-.23-1.22.23-1.22.86v.19c0 .38.25.71.61.85C17.18 6.54 19 9.06 19 12zm-8.71-6.29l-.17.17L12 7.76V6.41c0-.89-1.08-1.33-1.71-.7zM16.5 12A4.5 4.5 0 0014 7.97v1.79l2.48 2.48c.01-.08.02-.16.02-.24z",
    fill: "#fff"
  })
}), HP = () => /* @__PURE__ */ b.jsx("svg", {
  width: Yt,
  height: Yt,
  viewBox: "0 0 24 24",
  children: /* @__PURE__ */ b.jsx("path", {
    d: "M3 10v4c0 .55.45 1 1 1h3l3.29 3.29c.63.63 1.71.18 1.71-.71V6.41c0-.89-1.08-1.34-1.71-.71L7 9H4c-.55 0-1 .45-1 1zm13.5 2A4.5 4.5 0 0014 7.97v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 4.45v.2c0 .38.25.71.6.85C17.18 6.53 19 9.06 19 12s-1.82 5.47-4.4 6.5c-.36.14-.6.47-.6.85v.2c0 .63.63 1.07 1.21.85C18.6 19.11 21 15.84 21 12s-2.4-7.11-5.79-8.4c-.58-.23-1.21.22-1.21.85z",
    fill: "#fff"
  })
}), qv = "__remotion_buffering_indicator", Kv = "__remotion_buffering_animation", UP = {
  width: Yt,
  height: Yt,
  overflow: "hidden",
  lineHeight: "normal",
  fontSize: "inherit"
}, $P = {
  width: 14,
  height: 14,
  overflow: "hidden",
  lineHeight: "normal",
  fontSize: "inherit"
}, YP = ({ type: r }) => {
  const e = r === "player" ? UP : $P;
  return /* @__PURE__ */ b.jsxs(b.Fragment, {
    children: [
      /* @__PURE__ */ b.jsx("style", {
        type: "text/css",
        children: `
				@keyframes ${Kv} {
          0% {
            rotate: 0deg;
          }
          100% {
            rotate: 360deg;
          }
        }
        
        .${qv} {
            animation: ${Kv} 1s linear infinite;
        }        
			`
      }),
      /* @__PURE__ */ b.jsx("div", {
        style: e,
        children: /* @__PURE__ */ b.jsx("svg", {
          viewBox: r === "player" ? "0 0 22 22" : "0 0 18 18",
          style: e,
          className: qv,
          children: /* @__PURE__ */ b.jsx("path", {
            d: r === "player" ? "M 11 4 A 7 7 0 0 1 15.1145 16.66312" : "M 9 2 A 7 7 0 0 1 13.1145 14.66312",
            stroke: "white",
            strokeLinecap: "round",
            fill: "none",
            strokeWidth: 3
          })
        })
      })
    ]
  });
}, XP = ({
  currentSize: r,
  width: e,
  height: t,
  compositionWidth: n,
  compositionHeight: i
}) => e !== void 0 && t === void 0 ? {
  aspectRatio: [n, i].join("/")
} : t !== void 0 && e === void 0 ? {
  aspectRatio: [n, i].join("/")
} : r ? {
  width: n,
  height: i
} : {
  width: n,
  height: i
}, _b = ({
  previewSize: r,
  compositionWidth: e,
  compositionHeight: t,
  canvasSize: n
}) => {
  const i = Te.calculateScale({
    canvasSize: n,
    compositionHeight: t,
    compositionWidth: e,
    previewSize: r
  }), s = 0 - (1 - i) / 2, a = s * e, c = s * t, u = e * i, h = t * i, d = n.width / 2 - u / 2, p = n.height / 2 - h / 2;
  return {
    centerX: d,
    centerY: p,
    xCorrection: a,
    yCorrection: c,
    scale: i
  };
}, Sb = ({
  config: r,
  style: e,
  canvasSize: t,
  overflowVisible: n,
  layout: i
}) => r ? {
  position: "relative",
  overflow: n ? "visible" : "hidden",
  ...XP({
    compositionHeight: r.height,
    compositionWidth: r.width,
    currentSize: t,
    height: e?.height,
    width: e?.width
  }),
  opacity: i ? 1 : 0,
  ...e
} : {}, Cb = ({
  config: r,
  canvasSize: e,
  layout: t,
  scale: n,
  overflowVisible: i
}) => !r || !e || !t ? {} : {
  position: "absolute",
  width: r.width,
  height: r.height,
  display: "flex",
  transform: `scale(${n})`,
  marginLeft: t.xCorrection,
  marginTop: t.yCorrection,
  overflow: i ? "visible" : "hidden"
}, Tb = ({
  layout: r,
  scale: e,
  config: t,
  overflowVisible: n
}) => {
  if (!r || !t)
    return {};
  const { centerX: i, centerY: s } = r;
  return {
    width: t.width * e,
    height: t.height * e,
    display: "flex",
    flexDirection: "column",
    position: "absolute",
    left: i,
    top: s,
    overflow: n ? "visible" : "hidden"
  };
}, Eb = Ce.createContext(void 0), kb = Ce.createContext(void 0);
class GP {
  listeners = {
    ended: [],
    error: [],
    pause: [],
    play: [],
    ratechange: [],
    scalechange: [],
    seeked: [],
    timeupdate: [],
    frameupdate: [],
    fullscreenchange: [],
    volumechange: [],
    mutechange: [],
    waiting: [],
    resume: []
  };
  addEventListener(e, t) {
    this.listeners[e].push(t);
  }
  removeEventListener(e, t) {
    this.listeners[e] = this.listeners[e].filter((n) => n !== t);
  }
  dispatchEvent(e, t) {
    this.listeners[e].forEach((n) => {
      n({ detail: t });
    });
  }
  dispatchSeek(e) {
    this.dispatchEvent("seeked", {
      frame: e
    });
  }
  dispatchVolumeChange(e) {
    this.dispatchEvent("volumechange", {
      volume: e
    });
  }
  dispatchPause() {
    this.dispatchEvent("pause", void 0);
  }
  dispatchPlay() {
    this.dispatchEvent("play", void 0);
  }
  dispatchEnded() {
    this.dispatchEvent("ended", void 0);
  }
  dispatchRateChange(e) {
    this.dispatchEvent("ratechange", {
      playbackRate: e
    });
  }
  dispatchScaleChange(e) {
    this.dispatchEvent("scalechange", {
      scale: e
    });
  }
  dispatchError(e) {
    this.dispatchEvent("error", {
      error: e
    });
  }
  dispatchTimeUpdate(e) {
    this.dispatchEvent("timeupdate", e);
  }
  dispatchFrameUpdate(e) {
    this.dispatchEvent("frameupdate", e);
  }
  dispatchFullscreenChange(e) {
    this.dispatchEvent("fullscreenchange", e);
  }
  dispatchMuteChange(e) {
    this.dispatchEvent("mutechange", e);
  }
  dispatchWaiting(e) {
    this.dispatchEvent("waiting", e);
  }
  dispatchResume(e) {
    this.dispatchEvent("resume", e);
  }
}
class qP {
  listeners = {
    error: [],
    waiting: [],
    resume: []
  };
  addEventListener(e, t) {
    this.listeners[e].push(t);
  }
  removeEventListener(e, t) {
    this.listeners[e] = this.listeners[e].filter((n) => n !== t);
  }
  dispatchEvent(e, t) {
    this.listeners[e].forEach((n) => {
      n({ detail: t });
    });
  }
  dispatchError(e) {
    this.dispatchEvent("error", {
      error: e
    });
  }
  dispatchWaiting(e) {
    this.dispatchEvent("waiting", e);
  }
  dispatchResume(e) {
    this.dispatchEvent("resume", e);
  }
}
var Ob = (r) => {
  const e = me(Te.BufferingContextReact);
  if (!e)
    throw new Error("BufferingContextReact not found");
  ue(() => {
    const t = e.listenForBuffering(() => {
      e.buffering.current = !0, r.dispatchWaiting({});
    }), n = e.listenForResume(() => {
      e.buffering.current = !1, r.dispatchResume({});
    });
    return () => {
      t.remove(), n.remove();
    };
  }, [e, r]);
}, KP = ({ children: r, currentPlaybackRate: e }) => {
  const [t] = he(() => new GP());
  if (!me(Te.BufferingContextReact))
    throw new Error("BufferingContextReact not found");
  return ue(() => {
    e && t.dispatchRateChange(e);
  }, [t, e]), Ob(t), /* @__PURE__ */ b.jsx(Eb.Provider, {
    value: t,
    children: r
  });
}, Uf = (r, e) => {
  const [t, n] = he(!1);
  return ue(() => {
    const { current: i } = r;
    if (!i)
      return;
    let s;
    const a = () => {
      e && (clearTimeout(s), s = setTimeout(() => {
        n(!1);
      }, e === !0 ? 3e3 : e));
    }, c = () => {
      n(!0), a();
    }, u = () => {
      n(!1), clearTimeout(s);
    }, h = () => {
      n(!0), a();
    };
    return i.addEventListener("mouseenter", c), i.addEventListener("mouseleave", u), i.addEventListener("mousemove", h), () => {
      i.removeEventListener("mouseenter", c), i.removeEventListener("mouseleave", u), i.removeEventListener("mousemove", h), clearTimeout(s);
    };
  }, [e, r]), t;
}, Jl = () => {
  const [r, e, t] = Te.Timeline.usePlayingState(), [n, i] = he(!1), s = Te.Timeline.useTimelinePosition(), a = be(s), c = Te.Timeline.useTimelineSetFrame(), u = Te.Timeline.useTimelineSetFrame(), h = me(Te.SharedAudioContext), { audioAndVideoTags: d } = me(Te.Timeline.TimelineContext), p = be(s);
  p.current = s;
  const g = Te.useVideo(), v = Te.useUnsafeVideoConfig(), y = me(Eb), x = (v?.durationInFrames ?? 1) - 1, _ = s === x, C = s === 0;
  if (!y)
    throw new TypeError("Expected Player event emitter context");
  const E = me(Te.BufferingContextReact);
  if (!E)
    throw new Error("Missing the buffering context. Most likely you have a Remotion version mismatch.");
  const { buffering: k } = E, O = se((H) => {
    g?.id && u((Y) => ({ ...Y, [g.id]: H })), p.current = H, y.dispatchSeek(H);
  }, [y, u, g?.id]), P = se((H) => {
    t.current || (i(!0), _ && O(0), h && h.numberOfAudioTags > 0 && H && h.playAllAudios(), d.current.forEach((Y) => Y.play()), t.current = !0, e(!0), a.current = p.current, y.dispatchPlay());
  }, [
    t,
    _,
    h,
    e,
    y,
    O,
    d
  ]), j = se(() => {
    t.current && (t.current = !1, e(!1), y.dispatchPause());
  }, [y, t, e]), V = se(() => {
    t.current && (t.current = !1, p.current = a.current, v && (u((H) => ({
      ...H,
      [v.id]: a.current
    })), e(!1), y.dispatchPause()));
  }, [v, y, t, e, u]), F = g?.id, $ = se((H) => {
    if (!F)
      return null;
    t.current || c((Y) => {
      const te = Y[F] ?? window.remotion_initialFrame ?? 0;
      return {
        ...Y,
        [F]: Math.max(0, te - H)
      };
    });
  }, [t, c, F]), z = se((H) => {
    if (!F)
      return null;
    t.current || c((Y) => {
      const te = Y[F] ?? window.remotion_initialFrame ?? 0;
      return {
        ...Y,
        [F]: Math.min(x, te + H)
      };
    });
  }, [F, t, x, c]);
  return ee(() => ({
    frameBack: $,
    frameForward: z,
    isLastFrame: _,
    emitter: y,
    playing: r,
    play: P,
    pause: j,
    seek: O,
    isFirstFrame: C,
    getCurrentFrame: () => p.current,
    isPlaying: () => t.current,
    isBuffering: () => k.current,
    pauseAndReturnToPlayStart: V,
    hasPlayed: n,
    remotionInternal_currentFrameRef: p
  }), [
    $,
    z,
    _,
    y,
    r,
    P,
    j,
    O,
    C,
    V,
    n,
    t,
    k
  ]);
}, ZP = ({
  browserMediaControlsBehavior: r,
  videoConfig: e,
  playbackRate: t
}) => {
  const { playing: n, pause: i, play: s, emitter: a, getCurrentFrame: c, seek: u } = Jl();
  ue(() => {
    navigator.mediaSession && r.mode !== "do-nothing" && (n ? navigator.mediaSession.playbackState = "playing" : navigator.mediaSession.playbackState = "paused");
  }, [r.mode, n]), ue(() => {
    if (!navigator.mediaSession || r.mode === "do-nothing")
      return;
    const h = () => {
      e && navigator.mediaSession && navigator.mediaSession.setPositionState({
        duration: e.durationInFrames / e.fps,
        playbackRate: t,
        position: c() / e.fps
      });
    };
    return a.addEventListener("timeupdate", h), () => {
      a.removeEventListener("timeupdate", h);
    };
  }, [
    r.mode,
    a,
    c,
    t,
    e
  ]), ue(() => {
    if (navigator.mediaSession && r.mode !== "do-nothing")
      return navigator.mediaSession.setActionHandler("play", () => {
        r.mode === "register-media-session" && s();
      }), navigator.mediaSession.setActionHandler("pause", () => {
        r.mode === "register-media-session" && i();
      }), navigator.mediaSession.setActionHandler("seekto", (h) => {
        r.mode === "register-media-session" && h.seekTime !== void 0 && e && u(Math.round(h.seekTime * e.fps));
      }), navigator.mediaSession.setActionHandler("seekbackward", () => {
        r.mode === "register-media-session" && e && u(Math.max(0, Math.round((c() - 10) * e.fps)));
      }), navigator.mediaSession.setActionHandler("seekforward", () => {
        r.mode === "register-media-session" && e && u(Math.max(e.durationInFrames - 1, Math.round((c() + 10) * e.fps)));
      }), navigator.mediaSession.setActionHandler("previoustrack", () => {
        r.mode === "register-media-session" && u(0);
      }), () => {
        navigator.mediaSession.metadata = null, navigator.mediaSession.setActionHandler("play", null), navigator.mediaSession.setActionHandler("pause", null), navigator.mediaSession.setActionHandler("seekto", null), navigator.mediaSession.setActionHandler("seekbackward", null), navigator.mediaSession.setActionHandler("seekforward", null), navigator.mediaSession.setActionHandler("previoustrack", null);
      };
  }, [
    r.mode,
    c,
    i,
    s,
    u,
    e
  ]);
}, JP = ({
  time: r,
  currentFrame: e,
  playbackSpeed: t,
  fps: n,
  actualLastFrame: i,
  actualFirstFrame: s,
  framesAdvanced: a,
  shouldLoop: c
}) => {
  const h = (t < 0 ? Math.ceil : Math.floor)(r * t / (1e3 / n)) - a, d = h + e, p = e > i || e < s, g = d > i || d < s, v = !c && g && !p;
  return t > 0 ? g ? {
    nextFrame: s,
    framesToAdvance: h,
    hasEnded: v
  } : { nextFrame: d, framesToAdvance: h, hasEnded: v } : g ? { nextFrame: i, framesToAdvance: h, hasEnded: v } : { nextFrame: d, framesToAdvance: h, hasEnded: v };
}, Zv = () => typeof document > "u" ? !1 : document.visibilityState === "hidden", QP = () => {
  const r = be(Zv());
  return ue(() => {
    const e = () => {
      r.current = Zv();
    };
    return document.addEventListener("visibilitychange", e), () => {
      document.removeEventListener("visibilitychange", e);
    };
  }, []), r;
}, eD = ({
  loop: r,
  playbackRate: e,
  moveToBeginningWhenEnded: t,
  inFrame: n,
  outFrame: i,
  frameRef: s,
  browserMediaControlsBehavior: a
}) => {
  const c = Te.useUnsafeVideoConfig(), u = Te.Timeline.useTimelinePosition(), { playing: h, pause: d, emitter: p } = Jl(), g = Te.Timeline.useTimelineSetFrame(), v = be(null), y = QP(), x = be(null), _ = me(Te.BufferingContextReact);
  if (!_)
    throw new Error("Missing the buffering context. Most likely you have a Remotion version mismatch.");
  ZP({
    browserMediaControlsBehavior: a,
    playbackRate: e,
    videoConfig: c
  }), ue(() => {
    const C = _.listenForBuffering(() => {
      v.current = performance.now();
    }), E = _.listenForResume(() => {
      v.current = null;
    });
    return () => {
      C.remove(), E.remove();
    };
  }, [_]), ue(() => {
    if (!c || !h)
      return;
    let C = !1, E = null, k = performance.now(), O = 0;
    const P = () => {
      E !== null && (E.type === "raf" ? cancelAnimationFrame(E.id) : clearTimeout(E.id));
    }, j = () => {
      C = !0, P();
    }, V = () => {
      const z = performance.now() - k, G = i ?? c.durationInFrames - 1, H = n ?? 0, Y = s.current, { nextFrame: te, framesToAdvance: ge, hasEnded: Z } = JP({
        time: z,
        currentFrame: Y,
        playbackSpeed: e,
        fps: c.fps,
        actualFirstFrame: H,
        actualLastFrame: G,
        framesAdvanced: O,
        shouldLoop: r
      });
      if (O += ge, te !== s.current && (!Z || t) && g((de) => ({ ...de, [c.id]: te })), Z) {
        j(), d(), p.dispatchEnded();
        return;
      }
      C || F();
    }, F = () => {
      if (v.current) {
        const z = _.listenForResume(() => {
          z.remove(), !C && (k = performance.now(), O = 0, V());
        });
        return;
      }
      y.current ? E = {
        type: "timeout",
        id: setTimeout(V, 1e3 / c.fps)
      } : E = { type: "raf", id: requestAnimationFrame(V) };
    };
    F();
    const $ = () => {
      document.visibilityState !== "visible" && (P(), V());
    };
    return window.addEventListener("visibilitychange", $), () => {
      window.removeEventListener("visibilitychange", $), j();
    };
  }, [
    c,
    r,
    d,
    h,
    g,
    p,
    e,
    n,
    i,
    t,
    y,
    s,
    v,
    _
  ]), ue(() => {
    const C = setInterval(() => {
      x.current !== s.current && (p.dispatchTimeUpdate({ frame: s.current }), x.current = s.current);
    }, 250);
    return () => clearInterval(C);
  }, [p, s]), ue(() => {
    p.dispatchFrameUpdate({ frame: u });
  }, [p, u]);
}, zh = [], $f = (r, e) => {
  const [t, n] = he(() => {
    if (!r.current)
      return null;
    const a = r.current.getClientRects();
    return a[0] ? {
      width: a[0].width,
      height: a[0].height,
      left: a[0].x,
      top: a[0].y,
      windowSize: {
        height: window.innerHeight,
        width: window.innerWidth
      }
    } : null;
  }), i = ee(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((a) => {
    const { contentRect: c, target: u } = a[0], h = u.getClientRects();
    if (!h?.[0]) {
      n(null);
      return;
    }
    const d = c.width === 0 ? 1 : h[0].width / c.width, p = e.shouldApplyCssTransforms ? h[0].width : h[0].width * (1 / d), g = e.shouldApplyCssTransforms ? h[0].height : h[0].height * (1 / d);
    n({
      width: p,
      height: g,
      left: h[0].x,
      top: h[0].y,
      windowSize: {
        height: window.innerHeight,
        width: window.innerWidth
      }
    });
  }), [e.shouldApplyCssTransforms]), s = se(() => {
    if (!r.current)
      return;
    const a = r.current.getClientRects();
    if (!a[0]) {
      n(null);
      return;
    }
    n((c) => c && c.width === a[0].width && c.height === a[0].height && c.left === a[0].x && c.top === a[0].y && c.windowSize.height === window.innerHeight && c.windowSize.width === window.innerWidth ? c : {
      width: a[0].width,
      height: a[0].height,
      left: a[0].x,
      top: a[0].y,
      windowSize: {
        height: window.innerHeight,
        width: window.innerWidth
      }
    });
  }, [r]);
  return ue(() => {
    if (!i)
      return;
    const { current: a } = r;
    return a && i.observe(a), () => {
      a && i.unobserve(a);
    };
  }, [i, r, s]), ue(() => {
    if (e.triggerOnWindowResize)
      return window.addEventListener("resize", s), () => {
        window.removeEventListener("resize", s);
      };
  }, [e.triggerOnWindowResize, s]), ue(() => (zh.push(s), () => {
    zh = zh.filter((a) => a !== s);
  }), [s]), ee(() => t ? { ...t, refresh: s } : null, [t, s]);
}, Jv = ({ playing: r, buffering: e }) => r && e ? /* @__PURE__ */ b.jsx(YP, {
  type: "player"
}) : r ? /* @__PURE__ */ b.jsx(VP, {}) : /* @__PURE__ */ b.jsx(BP, {}), Ds = 12, Qv = 5, tD = ({
  volume: r,
  isVertical: e,
  onBlur: t,
  inputRef: n,
  setVolume: i
}) => {
  const s = ee(() => {
    const g = {
      paddingLeft: 5,
      height: Yt,
      width: Yi,
      display: "inline-flex",
      alignItems: "center"
    };
    return e ? {
      ...g,
      position: "absolute",
      transform: `rotate(-90deg) translateX(${Yi / 2 + Yt / 2}px)`
    } : {
      ...g
    };
  }, [e]), a = typeof Ce.useId > "u" ? "volume-slider" : Ce.useId(), [c] = he(() => `__remotion-volume-slider-${ds(a)}`.replace(".", "")), u = se((p) => {
    i(parseFloat(p.target.value));
  }, [i]), h = ee(() => {
    const p = {
      WebkitAppearance: "none",
      backgroundColor: "rgba(255, 255, 255, 0.5)",
      borderRadius: Qv / 2,
      cursor: "pointer",
      height: Qv,
      width: Yi,
      backgroundImage: `linear-gradient(
				to right,
				white ${r * 100}%, rgba(255, 255, 255, 0) ${r * 100}%
			)`
    };
    return e ? {
      ...p,
      bottom: Yt + Yi / 2
    } : p;
  }, [e, r]), d = `
	.${c}::-webkit-slider-thumb {
		-webkit-appearance: none;
		background-color: white;
		border-radius: ${Ds / 2}px;
		box-shadow: 0 0 2px black;
		height: ${Ds}px;
		width: ${Ds}px;
	}

	.${c}::-moz-range-thumb {
		-webkit-appearance: none;
		background-color: white;
		border-radius: ${Ds / 2}px;
		box-shadow: 0 0 2px black;
		height: ${Ds}px;
		width: ${Ds}px;
	}
`;
  return /* @__PURE__ */ b.jsxs("div", {
    style: s,
    children: [
      /* @__PURE__ */ b.jsx("style", {
        dangerouslySetInnerHTML: {
          __html: d
        }
      }),
      /* @__PURE__ */ b.jsx("input", {
        ref: n,
        "aria-label": "Change volume",
        className: c,
        max: 1,
        min: 0,
        onBlur: t,
        onChange: u,
        step: 0.01,
        type: "range",
        value: r,
        style: h
      })
    ]
  });
}, rD = (r) => /* @__PURE__ */ b.jsx(tD, {
  ...r
}), Yi = 100, nD = ({ displayVerticalVolumeSlider: r, renderMuteButton: e, renderVolumeSlider: t }) => {
  const [n, i] = Te.useMediaMutedState(), [s, a] = Te.useMediaVolumeState(), [c, u] = he(!1), h = be(null), d = be(null), p = Uf(h, !1), g = se(() => {
    setTimeout(() => {
      d.current && document.activeElement !== d.current && u(!1);
    }, 10);
  }, []), v = s === 0, y = se(() => {
    if (v) {
      a(1), i(!1);
      return;
    }
    i((O) => !O);
  }, [v, i, a]), x = ee(() => ({
    display: "inline-flex",
    background: "none",
    border: "none",
    justifyContent: "center",
    alignItems: "center",
    touchAction: "none",
    ...r && { position: "relative" }
  }), [r]), _ = ee(() => ({
    display: "inline",
    width: Yt,
    height: Yt,
    cursor: "pointer",
    appearance: "none",
    background: "none",
    border: "none",
    padding: 0
  }), []), C = se(({ muted: O, volume: P }) => {
    const j = O || P === 0;
    return /* @__PURE__ */ b.jsx("button", {
      "aria-label": j ? "Unmute sound" : "Mute sound",
      title: j ? "Unmute sound" : "Mute sound",
      onClick: y,
      onBlur: g,
      onFocus: () => u(!0),
      style: _,
      type: "button",
      children: j ? /* @__PURE__ */ b.jsx(WP, {}) : /* @__PURE__ */ b.jsx(HP, {})
    });
  }, [g, y, _]), E = ee(() => e ? e({ muted: n, volume: s }) : C({ muted: n, volume: s }), [n, s, C, e]), k = ee(() => (c || p) && !n && !Te.isIosSafari() ? (t ?? rD)({
    isVertical: r,
    volume: s,
    onBlur: () => u(!1),
    inputRef: d,
    setVolume: a
  }) : null, [
    r,
    c,
    p,
    n,
    s,
    t,
    a
  ]);
  return /* @__PURE__ */ b.jsxs("div", {
    ref: h,
    style: x,
    children: [
      E,
      k
    ]
  });
};
function iD(r) {
  const [e, t] = he(r), n = be(null);
  return ue(() => {
    const i = (s) => {
      n.current && !n.current.contains(s.target) && t(!1);
    };
    return document.addEventListener("pointerup", i, !0), () => {
      document.removeEventListener("pointerup", i, !0);
    };
  }, []), { ref: n, isComponentVisible: e, setIsComponentVisible: t };
}
var sD = 35, oD = 70, aD = {
  height: 30,
  paddingRight: 15,
  paddingLeft: 12,
  display: "flex",
  flexDirection: "row",
  alignItems: "center"
}, cD = {
  width: 22,
  display: "flex",
  alignItems: "center"
}, lD = {
  width: 14,
  height: 14,
  color: "black"
}, uD = () => /* @__PURE__ */ b.jsx("svg", {
  viewBox: "0 0 512 512",
  style: lD,
  children: /* @__PURE__ */ b.jsx("path", {
    fill: "currentColor",
    d: "M435.848 83.466L172.804 346.51l-96.652-96.652c-4.686-4.686-12.284-4.686-16.971 0l-28.284 28.284c-4.686 4.686-4.686 12.284 0 16.971l133.421 133.421c4.686 4.686 12.284 4.686 16.971 0l299.813-299.813c4.686-4.686 4.686-12.284 0-16.971l-28.284-28.284c-4.686-4.686-12.284-4.686-16.97 0z"
  })
}), hD = ({ rate: r, onSelect: e, selectedRate: t, keyboardSelectedRate: n }) => {
  const i = se((p) => {
    p.stopPropagation(), p.preventDefault(), e(r);
  }, [e, r]), [s, a] = he(!1), c = se(() => {
    a(!0);
  }, []), u = se(() => {
    a(!1);
  }, []), h = n === r, d = ee(() => ({
    ...aD,
    backgroundColor: s || h ? "#eee" : "transparent"
  }), [s, h]);
  return /* @__PURE__ */ b.jsxs("div", {
    onMouseEnter: c,
    onMouseLeave: u,
    tabIndex: 0,
    style: d,
    onClick: i,
    children: [
      /* @__PURE__ */ b.jsx("div", {
        style: cD,
        children: r === t ? /* @__PURE__ */ b.jsx(uD, {}) : null
      }),
      r.toFixed(1),
      "x"
    ]
  }, r);
}, dD = ({ setIsComponentVisible: r, playbackRates: e, canvasSize: t }) => {
  const { setPlaybackRate: n, playbackRate: i } = me(Te.Timeline.TimelineContext), [s, a] = he(i);
  ue(() => {
    const h = (d) => {
      if (d.preventDefault(), d.key === "ArrowUp") {
        const p = e.findIndex((g) => g === s);
        if (p === 0)
          return;
        a(p === -1 ? e[0] : e[p - 1]);
      } else if (d.key === "ArrowDown") {
        const p = e.findIndex((g) => g === s);
        if (p === e.length - 1)
          return;
        a(p === -1 ? e[e.length - 1] : e[p + 1]);
      } else d.key === "Enter" && (n(s), r(!1));
    };
    return window.addEventListener("keydown", h), () => {
      window.removeEventListener("keydown", h);
    };
  }, [
    e,
    s,
    n,
    r
  ]);
  const c = se((h) => {
    n(h), r(!1);
  }, [r, n]), u = ee(() => ({
    position: "absolute",
    right: 0,
    width: 125,
    maxHeight: t.height - oD - sD,
    bottom: 35,
    background: "#fff",
    borderRadius: 4,
    overflow: "auto",
    color: "black",
    textAlign: "left"
  }), [t.height]);
  return /* @__PURE__ */ b.jsx("div", {
    style: u,
    children: e.map((h) => /* @__PURE__ */ b.jsx(hD, {
      selectedRate: i,
      onSelect: c,
      rate: h,
      keyboardSelectedRate: s
    }, h))
  });
}, fD = {
  fontSize: 13,
  fontWeight: "bold",
  color: "white",
  border: "2px solid white",
  borderRadius: 20,
  paddingLeft: 8,
  paddingRight: 8,
  paddingTop: 2,
  paddingBottom: 2
}, Ld = {
  appearance: "none",
  backgroundColor: "transparent",
  border: "none",
  cursor: "pointer",
  paddingLeft: 0,
  paddingRight: 0,
  paddingTop: 6,
  paddingBottom: 6,
  height: 37,
  display: "inline-flex",
  marginBottom: 0,
  marginTop: 0,
  alignItems: "center"
}, pD = {
  ...Ld,
  position: "relative"
}, gD = ({ playbackRates: r, canvasSize: e }) => {
  const { ref: t, isComponentVisible: n, setIsComponentVisible: i } = iD(!1), { playbackRate: s } = me(Te.Timeline.TimelineContext), a = se((c) => {
    c.stopPropagation(), c.preventDefault(), i((u) => !u);
  }, [i]);
  return /* @__PURE__ */ b.jsx("div", {
    ref: t,
    children: /* @__PURE__ */ b.jsxs("button", {
      type: "button",
      "aria-label": "Change playback rate",
      style: pD,
      onClick: a,
      children: [
        /* @__PURE__ */ b.jsxs("div", {
          style: fD,
          children: [
            s,
            "x"
          ]
        }),
        n && /* @__PURE__ */ b.jsx(dD, {
          canvasSize: e,
          playbackRates: r,
          setIsComponentVisible: i
        })
      ]
    })
  });
}, e0 = (r, e, t) => Math.round(ib(r, [0, t], [0, e - 1], {
  extrapolateLeft: "clamp",
  extrapolateRight: "clamp"
})), Ls = 5, No = 12, Nd = 4, mD = {
  userSelect: "none",
  WebkitUserSelect: "none",
  paddingTop: Nd,
  paddingBottom: Nd,
  boxSizing: "border-box",
  cursor: "pointer",
  position: "relative",
  touchAction: "none"
}, vD = {
  height: Ls,
  backgroundColor: "rgba(255, 255, 255, 0.25)",
  width: "100%",
  borderRadius: Ls / 2
}, yD = (r) => {
  let e = r;
  for (; e.parentElement; )
    e = e.parentElement;
  return e;
}, bD = ({ durationInFrames: r, onSeekEnd: e, onSeekStart: t, inFrame: n, outFrame: i }) => {
  const s = be(null), a = Uf(s, !1), c = $f(s, {
    triggerOnWindowResize: !0,
    shouldApplyCssTransforms: !0
  }), { seek: u, play: h, pause: d, playing: p } = Jl(), g = Te.Timeline.useTimelinePosition(), [v, y] = he({
    dragging: !1
  }), x = c?.width ?? 0, _ = se((j) => {
    if (j.button !== 0)
      return;
    const V = s.current?.getBoundingClientRect().left, F = e0(j.clientX - V, r, x);
    d(), u(F), y({
      dragging: !0,
      wasPlaying: p
    }), t();
  }, [r, x, d, u, p, t]), C = se((j) => {
    if (!c)
      throw new Error("Player has no size");
    if (!v.dragging)
      return;
    const V = s.current?.getBoundingClientRect().left, F = e0(j.clientX - V, r, c.width);
    u(F);
  }, [v.dragging, r, u, c]), E = se(() => {
    y({
      dragging: !1
    }), v.dragging && (v.wasPlaying ? h() : d(), e());
  }, [v, e, d, h]);
  ue(() => {
    if (!v.dragging)
      return;
    const j = yD(s.current);
    return j.addEventListener("pointermove", C), j.addEventListener("pointerup", E), () => {
      j.removeEventListener("pointermove", C), j.removeEventListener("pointerup", E);
    };
  }, [v.dragging, C, E]);
  const k = ee(() => ({
    height: No,
    width: No,
    borderRadius: No / 2,
    position: "absolute",
    top: Nd - No / 2 + 5 / 2,
    backgroundColor: "white",
    left: Math.max(0, g / Math.max(1, r - 1) * x - No / 2),
    boxShadow: "0 0 2px black",
    opacity: Number(a)
  }), [a, r, g, x]), O = ee(() => ({
    height: Ls,
    backgroundColor: "rgba(255, 255, 255, 1)",
    width: (g - (n ?? 0)) / (r - 1) * 100 + "%",
    marginLeft: (n ?? 0) / (r - 1) * 100 + "%",
    borderRadius: Ls / 2
  }), [r, g, n]), P = ee(() => ({
    height: Ls,
    backgroundColor: "rgba(255, 255, 255, 0.25)",
    width: ((i ?? r - 1) - (n ?? 0)) / (r - 1) * 100 + "%",
    marginLeft: (n ?? 0) / (r - 1) * 100 + "%",
    borderRadius: Ls / 2,
    position: "absolute"
  }), [r, n, i]);
  return /* @__PURE__ */ b.jsxs("div", {
    ref: s,
    onPointerDown: _,
    style: mD,
    children: [
      /* @__PURE__ */ b.jsxs("div", {
        style: vD,
        children: [
          /* @__PURE__ */ b.jsx("div", {
            style: P
          }),
          /* @__PURE__ */ b.jsx("div", {
            style: O
          })
        ]
      }),
      /* @__PURE__ */ b.jsx("div", {
        style: k
      })
    ]
  });
}, t0 = (r) => {
  const e = Math.floor(r / 60), t = Math.floor(r - e * 60);
  return `${String(e)}:${String(t).padStart(2, "0")}`;
}, wD = 10, Bd = 12, xD = ({
  allowFullscreen: r,
  playerWidth: e
}) => ee(() => {
  const n = Yt, i = Yt, s = r ? Fd : 0, a = i + n + s + Bd * 2 + wD * 2, c = e - a, u = Math.max(c, 0), h = u - Yi, p = (h < Yi ? u : h) + a + Yi, g = e < p;
  return {
    maxTimeLabelWidth: u === 0 ? null : u,
    displayVerticalVolumeSlider: g
  };
}, [r, e]), _D = [
  0,
  0.013,
  0.049,
  0.104,
  0.175,
  0.259,
  0.352,
  0.45,
  0.55,
  0.648,
  0.741,
  0.825,
  0.896,
  0.951,
  0.987
], SD = [
  0,
  8.1,
  15.5,
  22.5,
  29,
  35.3,
  41.2,
  47.1,
  52.9,
  58.8,
  64.7,
  71,
  77.5,
  84.5,
  91.9
], CD = 1 / 0.7, TD = {
  boxSizing: "border-box",
  position: "absolute",
  bottom: 0,
  width: "100%",
  paddingTop: 40,
  paddingBottom: 10,
  backgroundImage: `linear-gradient(to bottom,${_D.map((r, e) => `hsla(0, 0%, 0%, ${r}) ${SD[e] * CD}%`).join(", ")}, hsl(0, 0%, 0%) 100%)`,
  backgroundSize: "auto 145px",
  display: "flex",
  paddingRight: Bd,
  paddingLeft: Bd,
  flexDirection: "column",
  transition: "opacity 0.3s"
}, ED = {
  display: "flex",
  flexDirection: "row",
  width: "100%",
  alignItems: "center",
  justifyContent: "center",
  userSelect: "none",
  WebkitUserSelect: "none"
}, kD = {
  display: "flex",
  flexDirection: "row",
  userSelect: "none",
  WebkitUserSelect: "none",
  alignItems: "center"
}, Sc = {
  width: 12
}, OD = {
  height: 8
}, ID = {
  flex: 1
}, AD = {}, MD = ({
  durationInFrames: r,
  isFullscreen: e,
  fps: t,
  player: n,
  showVolumeControls: i,
  onFullscreenButtonClick: s,
  allowFullscreen: a,
  onExitFullscreenButtonClick: c,
  spaceKeyToPlayOrPause: u,
  onSeekEnd: h,
  onSeekStart: d,
  inFrame: p,
  outFrame: g,
  initiallyShowControls: v,
  canvasSize: y,
  renderPlayPauseButton: x,
  renderFullscreenButton: _,
  alwaysShowControls: C,
  showPlaybackRateControl: E,
  containerRef: k,
  buffering: O,
  hideControlsWhenPointerDoesntMove: P,
  onPointerDown: j,
  onDoubleClick: V,
  renderMuteButton: F,
  renderVolumeSlider: $
}) => {
  const z = be(null), G = Te.Timeline.useTimelinePosition(), [H, Y] = he(!1), te = Uf(k, P), { maxTimeLabelWidth: ge, displayVerticalVolumeSlider: Z } = xD({
    allowFullscreen: a,
    playerWidth: y?.width ?? 0
  }), [de, oe] = he(() => {
    if (typeof v == "boolean")
      return v;
    if (typeof v == "number") {
      if (v % 1 !== 0)
        throw new Error("initiallyShowControls must be an integer or a boolean");
      if (Number.isNaN(v))
        throw new Error("initiallyShowControls must not be NaN");
      if (!Number.isFinite(v))
        throw new Error("initiallyShowControls must be finite");
      if (v <= 0)
        throw new Error("initiallyShowControls must be a positive integer");
      return v;
    }
    throw new TypeError("initiallyShowControls must be a number or a boolean");
  }), ie = ee(() => {
    const Ie = te || !n.playing || de || C;
    return {
      ...TD,
      opacity: Number(Ie)
    };
  }, [te, de, n.playing, C]);
  ue(() => {
    z.current && u && z.current.focus({
      preventScroll: !0
    });
  }, [n.playing, u]), ue(() => {
    Y((typeof document < "u" && (document.fullscreenEnabled || document.webkitFullscreenEnabled)) ?? !1);
  }, []), ue(() => {
    if (de === !1)
      return;
    const dt = setTimeout(() => {
      oe(!1);
    }, de === !0 ? 2e3 : de);
    return () => {
      clearInterval(dt);
    };
  }, [de]);
  const pe = ee(() => ({
    color: "white",
    fontFamily: "sans-serif",
    fontSize: 14,
    maxWidth: ge === null ? void 0 : ge,
    overflow: "hidden",
    textOverflow: "ellipsis"
  }), [ge]), re = ee(() => {
    if (E === !0)
      return [0.5, 0.8, 1, 1.2, 1.5, 1.8, 2, 2.5, 3];
    if (Array.isArray(E)) {
      for (const Ie of E) {
        if (typeof Ie != "number")
          throw new Error("Every item in showPlaybackRateControl must be a number");
        if (Ie <= 0)
          throw new Error("Every item in showPlaybackRateControl must be positive");
      }
      return E;
    }
    return null;
  }, [E]), Be = be(null), Ze = be(null), ze = se((Ie) => {
    (Ie.target === Be.current || Ie.target === Ze.current) && j?.(Ie);
  }, [j]), Ee = se((Ie) => {
    (Ie.target === Be.current || Ie.target === Ze.current) && V?.(Ie);
  }, [V]);
  return /* @__PURE__ */ b.jsxs("div", {
    ref: Be,
    style: ie,
    onPointerDown: ze,
    onDoubleClick: Ee,
    children: [
      /* @__PURE__ */ b.jsxs("div", {
        ref: Ze,
        style: ED,
        children: [
          /* @__PURE__ */ b.jsxs("div", {
            style: kD,
            children: [
              /* @__PURE__ */ b.jsx("button", {
                ref: z,
                type: "button",
                style: Ld,
                onClick: n.playing ? n.pause : n.play,
                "aria-label": n.playing ? "Pause video" : "Play video",
                title: n.playing ? "Pause video" : "Play video",
                children: x === null ? /* @__PURE__ */ b.jsx(Jv, {
                  buffering: O,
                  playing: n.playing
                }) : x({
                  playing: n.playing,
                  isBuffering: O
                }) ?? /* @__PURE__ */ b.jsx(Jv, {
                  buffering: O,
                  playing: n.playing
                })
              }),
              i ? /* @__PURE__ */ b.jsxs(b.Fragment, {
                children: [
                  /* @__PURE__ */ b.jsx("div", {
                    style: Sc
                  }),
                  /* @__PURE__ */ b.jsx(nD, {
                    renderMuteButton: F,
                    renderVolumeSlider: $,
                    displayVerticalVolumeSlider: Z
                  })
                ]
              }) : null,
              /* @__PURE__ */ b.jsx("div", {
                style: Sc
              }),
              /* @__PURE__ */ b.jsxs("div", {
                style: pe,
                children: [
                  t0(G / t),
                  " / ",
                  t0(r / t)
                ]
              }),
              /* @__PURE__ */ b.jsx("div", {
                style: Sc
              })
            ]
          }),
          /* @__PURE__ */ b.jsx("div", {
            style: ID
          }),
          re && y && /* @__PURE__ */ b.jsx(gD, {
            canvasSize: y,
            playbackRates: re
          }),
          re && H && a ? /* @__PURE__ */ b.jsx("div", {
            style: Sc
          }) : null,
          /* @__PURE__ */ b.jsx("div", {
            style: AD,
            children: H && a ? /* @__PURE__ */ b.jsx("button", {
              type: "button",
              "aria-label": e ? "Exit fullscreen" : "Enter Fullscreen",
              title: e ? "Exit fullscreen" : "Enter Fullscreen",
              style: Ld,
              onClick: e ? c : s,
              children: _ === null ? /* @__PURE__ */ b.jsx(zP, {
                isFullscreen: e
              }) : _({ isFullscreen: e })
            }) : null
          })
        ]
      }),
      /* @__PURE__ */ b.jsx("div", {
        style: OD
      }),
      /* @__PURE__ */ b.jsx(bD, {
        onSeekEnd: h,
        onSeekStart: d,
        durationInFrames: r,
        inFrame: p,
        outFrame: g
      })
    ]
  });
}, PD = {
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  flex: 1,
  height: "100%",
  width: "100%"
};
class Ib extends Ce.Component {
  state = { hasError: null };
  static getDerivedStateFromError(e) {
    return { hasError: e };
  }
  componentDidCatch(e) {
    this.props.onError(e);
  }
  render() {
    return this.state.hasError ? /* @__PURE__ */ b.jsx("div", {
      style: PD,
      children: this.props.errorFallback({
        error: this.state.hasError
      })
    }) : this.props.children;
  }
}
var Yf = "__remotion-player", Ab = typeof document > "u", DD = (r) => {
  let e = !1;
  return {
    promise: new Promise((n, i) => {
      r.then((s) => {
        if (e) {
          i({ isCanceled: e, value: s });
          return;
        }
        n(s);
      }).catch((s) => {
        i({ isCanceled: e, error: s });
      });
    }),
    cancel: () => {
      e = !0;
    }
  };
}, RD = (r) => new Promise((e) => setTimeout(e, r)), jD = () => {
  const r = be([]), e = se((s) => {
    r.current = [...r.current, s];
  }, []), t = se((s) => {
    r.current = r.current.filter((a) => a !== s);
  }, []), n = se(() => r.current.map((s) => s.cancel()), []);
  return ee(() => ({
    appendPendingPromise: e,
    removePendingPromise: t,
    clearPendingPromises: n
  }), [e, n, t]);
}, FD = (r, e, t) => {
  const n = jD(), i = se(async (u) => {
    if (u instanceof PointerEvent ? u.pointerType === "touch" : u.nativeEvent.pointerType === "touch") {
      r(u);
      return;
    }
    n.clearPendingPromises();
    const h = DD(RD(200));
    n.appendPendingPromise(h);
    try {
      await h.promise, n.removePendingPromise(h), r(u);
    } catch (d) {
      const p = d;
      if (n.removePendingPromise(h), !p.isCanceled)
        throw p.error;
    }
  }, [n, r]), s = se(() => {
    document.addEventListener("pointerup", (u) => {
      i(u);
    }, {
      once: !0
    });
  }, [i]), a = se(() => {
    n.clearPendingPromises(), e();
  }, [n, e]);
  return ee(() => t ? { handlePointerDown: s, handleDoubleClick: a } : { handlePointerDown: r, handleDoubleClick: () => {
  } }, [t, a, s, r]);
}, Vd = Ce.version.split(".")[0];
if (Vd === "0")
  throw new Error(`Version ${Vd} of "react" is not supported by Remotion`);
var LD = parseInt(Vd, 10) >= 18, ND = ({
  controls: r,
  style: e,
  loop: t,
  autoPlay: n,
  allowFullscreen: i,
  inputProps: s,
  clickToPlay: a,
  showVolumeControls: c,
  doubleClickToFullscreen: u,
  spaceKeyToPlayOrPause: h,
  errorFallback: d,
  playbackRate: p,
  renderLoading: g,
  renderPoster: v,
  className: y,
  moveToBeginningWhenEnded: x,
  showPosterWhenUnplayed: _,
  showPosterWhenEnded: C,
  showPosterWhenPaused: E,
  showPosterWhenBuffering: k,
  inFrame: O,
  outFrame: P,
  initiallyShowControls: j,
  renderFullscreen: V,
  renderPlayPauseButton: F,
  renderMuteButton: $,
  renderVolumeSlider: z,
  alwaysShowControls: G,
  showPlaybackRateControl: H,
  posterFillMode: Y,
  bufferStateDelayInMilliseconds: te,
  hideControlsWhenPointerDoesntMove: ge,
  overflowVisible: Z,
  browserMediaControlsBehavior: de
}, oe) => {
  const ie = Te.useUnsafeVideoConfig(), pe = Te.useVideo(), re = be(null), Be = $f(re, {
    triggerOnWindowResize: !1,
    shouldApplyCssTransforms: !1
  }), [Ze, ze] = he(!1), [Ee, Ie] = he(n), [dt, lr] = he(() => !1), [Wt, Mt] = he(!1), ur = ee(() => typeof document > "u" ? !1 : !!(document.fullscreenEnabled || document.webkitFullscreenEnabled), []), ye = Jl();
  eD({
    loop: t,
    playbackRate: p,
    moveToBeginningWhenEnded: x,
    inFrame: O,
    outFrame: P,
    frameRef: ye.remotionInternal_currentFrameRef,
    browserMediaControlsBehavior: de
  }), ue(() => {
    Ze && !ye.playing && (ze(!1), ye.play());
  }, [Ze, ye]), ue(() => {
    const { current: $e } = re;
    if (!$e)
      return;
    const He = () => {
      const Sr = document.fullscreenElement === $e || document.webkitFullscreenElement === $e;
      lr(Sr);
    };
    return document.addEventListener("fullscreenchange", He), document.addEventListener("webkitfullscreenchange", He), () => {
      document.removeEventListener("fullscreenchange", He), document.removeEventListener("webkitfullscreenchange", He);
    };
  }, []);
  const wr = se(($e) => {
    ye.isPlaying() ? ye.pause() : ye.play($e);
  }, [ye]), st = se(() => {
    if (!i)
      throw new Error("allowFullscreen is false");
    if (!ur)
      throw new Error("Browser doesnt support fullscreen");
    if (!re.current)
      throw new Error("No player ref found");
    re.current.webkitRequestFullScreen ? re.current.webkitRequestFullScreen() : re.current.requestFullscreen();
  }, [i, ur]), Vt = se(() => {
    document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.exitFullscreen();
  }, []);
  ue(() => {
    const { current: $e } = re;
    if (!$e)
      return;
    const He = () => {
      const Sr = document.webkitFullscreenElement ?? document.fullscreenElement;
      Sr && Sr === re.current ? ye.emitter.dispatchFullscreenChange({
        isFullscreen: !0
      }) : ye.emitter.dispatchFullscreenChange({
        isFullscreen: !1
      });
    };
    return $e.addEventListener("webkitfullscreenchange", He), $e.addEventListener("fullscreenchange", He), () => {
      $e.removeEventListener("webkitfullscreenchange", He), $e.removeEventListener("fullscreenchange", He);
    };
  }, [ye.emitter]);
  const Jn = ie?.durationInFrames ?? 1, nt = ee(() => !ie || !Be ? null : _b({
    canvasSize: Be,
    compositionHeight: ie.height,
    compositionWidth: ie.width,
    previewSize: "auto"
  }), [Be, ie]), Pt = nt?.scale ?? 1, In = be(!1);
  ue(() => {
    if (!In.current) {
      In.current = !0;
      return;
    }
    ye.emitter.dispatchScaleChange(Pt);
  }, [ye.emitter, Pt]);
  const { setMediaVolume: xr, setMediaMuted: A } = me(Te.SetMediaVolumeContext), { mediaMuted: le, mediaVolume: ce } = me(Te.MediaVolumeContext);
  ue(() => {
    ye.emitter.dispatchVolumeChange(ce);
  }, [ye.emitter, ce]);
  const je = le || ce === 0;
  ue(() => {
    ye.emitter.dispatchMuteChange({
      isMuted: je
    });
  }, [ye.emitter, je]);
  const [et, Ge] = he(!1);
  ue(() => {
    let $e = null, He = !1;
    const Sr = () => {
      He = !1, requestAnimationFrame(() => {
        te === 0 ? Ge(!0) : $e = setTimeout(() => {
          He || Ge(!0);
        }, te);
      });
    }, pn = () => {
      requestAnimationFrame(() => {
        He = !0, Ge(!1), $e && clearTimeout($e);
      });
    };
    return ye.emitter.addEventListener("waiting", Sr), ye.emitter.addEventListener("resume", pn), () => {
      ye.emitter.removeEventListener("waiting", Sr), ye.emitter.removeEventListener("resume", pn), Ge(!1), $e && clearTimeout($e), He = !0;
    };
  }, [te, ye.emitter]), qr(oe, () => {
    const $e = {
      play: ye.play,
      pause: () => {
        ze(!1), ye.pause();
      },
      toggle: wr,
      getContainerNode: () => re.current,
      getCurrentFrame: ye.getCurrentFrame,
      isPlaying: ye.isPlaying,
      seekTo: (He) => {
        const Sr = Jn - 1, pn = Math.max(0, Math.min(Sr, He));
        ye.isPlaying() && (ze(pn !== Sr || t), ye.pause()), pn === Sr && !t && ye.emitter.dispatchEnded(), ye.seek(pn);
      },
      isFullscreen: () => {
        const { current: He } = re;
        return He ? document.fullscreenElement === He || document.webkitFullscreenElement === He : !1;
      },
      requestFullscreen: st,
      exitFullscreen: Vt,
      getVolume: () => le ? 0 : ce,
      setVolume: (He) => {
        if (typeof He != "number")
          throw new TypeError(`setVolume() takes a number, got value of type ${typeof He}`);
        if (isNaN(He))
          throw new TypeError("setVolume() got a number that is NaN. Volume must be between 0 and 1.");
        if (He < 0 || He > 1)
          throw new TypeError(`setVolume() got a number that is out of range. Must be between 0 and 1, got ${typeof He}`);
        xr(He);
      },
      isMuted: () => je,
      mute: () => {
        A(!0);
      },
      unmute: () => {
        A(!1);
      },
      getScale: () => Pt,
      pauseAndReturnToPlayStart: () => {
        ye.pauseAndReturnToPlayStart();
      }
    };
    return Object.assign(ye.emitter, $e);
  }, [
    Jn,
    Vt,
    t,
    le,
    je,
    ce,
    ye,
    st,
    A,
    xr,
    wr,
    Pt
  ]);
  const Se = pe ? pe.component : null, ot = ee(() => Sb({
    canvasSize: Be,
    config: ie,
    style: e,
    overflowVisible: Z,
    layout: nt
  }), [Be, ie, nt, Z, e]), hr = ee(() => Tb({ config: ie, layout: nt, scale: Pt, overflowVisible: Z }), [ie, nt, Z, Pt]), xt = ee(() => Cb({
    canvasSize: Be,
    config: ie,
    layout: nt,
    scale: Pt,
    overflowVisible: Z
  }), [Be, ie, nt, Z, Pt]), _r = se(($e) => {
    ye.pause(), ye.emitter.dispatchError($e);
  }, [ye]), Zr = se(($e) => {
    $e.stopPropagation(), st();
  }, [st]), dr = se(($e) => {
    $e.stopPropagation(), Vt();
  }, [Vt]), fn = se(($e) => {
    ($e instanceof MouseEvent ? $e.button === 2 : $e.nativeEvent.button) || wr($e);
  }, [wr]), Jt = se(() => {
    Mt(!0);
  }, []), mo = se(() => {
    Mt(!1);
  }, []), vo = se(() => {
    dt ? Vt() : st();
  }, [Vt, dt, st]), { handlePointerDown: vs, handleDoubleClick: ys } = FD(fn, vo, u && i && ur);
  ue(() => {
    Ee && (ye.play(), Ie(!1));
  }, [Ee, ye]);
  const wu = ee(() => g ? g({
    height: ot.height,
    width: ot.width,
    isBuffering: et
  }) : null, [ot.height, ot.width, g, et]), Ia = ee(() => ({
    type: "scale",
    scale: Pt
  }), [Pt]);
  if (!ie)
    return null;
  const ki = v ? v({
    height: Y === "player-size" ? ot.height : ie.height,
    width: Y === "player-size" ? ot.width : ie.width,
    isBuffering: et
  }) : null;
  if (ki === void 0)
    throw new TypeError("renderPoster() must return a React element, but undefined was returned");
  const Aa = ki && [
    E && !ye.isPlaying() && !Wt,
    C && ye.isLastFrame && !ye.isPlaying(),
    _ && !ye.hasPlayed && !ye.isPlaying(),
    k && et && ye.isPlaying()
  ].some(Boolean), { left: Pp, top: Dp, width: Rp, height: xu, ..._u } = hr, Ma = /* @__PURE__ */ b.jsxs(b.Fragment, {
    children: [
      /* @__PURE__ */ b.jsx("div", {
        style: hr,
        onPointerDown: a ? vs : void 0,
        onDoubleClick: u ? ys : void 0,
        children: /* @__PURE__ */ b.jsxs("div", {
          style: xt,
          className: Yf,
          children: [
            Se ? /* @__PURE__ */ b.jsx(Ib, {
              onError: _r,
              errorFallback: d,
              children: /* @__PURE__ */ b.jsx(Te.CurrentScaleContext.Provider, {
                value: Ia,
                children: /* @__PURE__ */ b.jsx(Se, {
                  ...pe?.props ?? {},
                  ...s ?? {}
                })
              })
            }) : null,
            Aa && Y === "composition-size" ? /* @__PURE__ */ b.jsx("div", {
              style: {
                ..._u,
                width: ie.width,
                height: ie.height
              },
              onPointerDown: a ? vs : void 0,
              onDoubleClick: u ? ys : void 0,
              children: ki
            }) : null
          ]
        })
      }),
      Aa && Y === "player-size" ? /* @__PURE__ */ b.jsx("div", {
        style: hr,
        onPointerDown: a ? vs : void 0,
        onDoubleClick: u ? ys : void 0,
        children: ki
      }) : null,
      r ? /* @__PURE__ */ b.jsx(MD, {
        fps: ie.fps,
        durationInFrames: ie.durationInFrames,
        player: ye,
        containerRef: re,
        onFullscreenButtonClick: Zr,
        isFullscreen: dt,
        allowFullscreen: i,
        showVolumeControls: c,
        onExitFullscreenButtonClick: dr,
        spaceKeyToPlayOrPause: h,
        onSeekEnd: mo,
        onSeekStart: Jt,
        inFrame: O,
        outFrame: P,
        initiallyShowControls: j,
        canvasSize: Be,
        renderFullscreenButton: V,
        renderPlayPauseButton: F,
        alwaysShowControls: G,
        showPlaybackRateControl: H,
        buffering: et,
        hideControlsWhenPointerDoesntMove: ge,
        onDoubleClick: u ? ys : void 0,
        onPointerDown: a ? vs : void 0,
        renderMuteButton: $,
        renderVolumeSlider: z
      }) : null
    ]
  });
  return Ab && !LD ? /* @__PURE__ */ b.jsx("div", {
    ref: re,
    style: ot,
    className: y,
    children: Ma
  }) : /* @__PURE__ */ b.jsx("div", {
    ref: re,
    style: ot,
    className: y,
    children: /* @__PURE__ */ b.jsx(tl, {
      fallback: wu,
      children: Ma
    })
  });
}, BD = Bt(ND), Mb = "remotion.volumePreference", VD = (r) => {
  if (!(typeof window > "u"))
    try {
      window.localStorage.setItem(Mb, String(r));
    } catch (e) {
      console.log("Could not persist volume", e);
    }
}, zD = () => {
  if (typeof window > "u")
    return 1;
  try {
    const r = window.localStorage.getItem(Mb);
    return r ? Number(r) : 1;
  } catch {
    return 1;
  }
}, Xf = "player-comp", Pb = ({
  children: r,
  timelineContext: e,
  fps: t,
  compositionHeight: n,
  compositionWidth: i,
  durationInFrames: s,
  component: a,
  numberOfSharedAudioTags: c,
  initiallyMuted: u
}) => {
  const h = ee(() => ({
    compositions: [
      {
        component: a,
        durationInFrames: s,
        height: n,
        width: i,
        fps: t,
        id: Xf,
        nonce: 777,
        folderName: null,
        parentFolderName: null,
        schema: null,
        calculateMetadata: null
      }
    ],
    folders: [],
    registerFolder: () => {
    },
    unregisterFolder: () => {
    },
    registerComposition: () => {
    },
    unregisterComposition: () => {
    },
    currentCompositionMetadata: null,
    setCurrentCompositionMetadata: () => {
    },
    canvasContent: { type: "composition", compositionId: "player-comp" },
    setCanvasContent: () => {
    },
    updateCompositionDefaultProps: () => {
    }
  }), [a, s, n, i, t]), [d, p] = he(() => u), [g, v] = he(() => zD()), y = ee(() => ({
    mediaMuted: d,
    mediaVolume: g
  }), [d, g]), x = se((C) => {
    v(C), VD(C);
  }, []), _ = ee(() => ({
    setMediaMuted: p,
    setMediaVolume: x
  }), [x]);
  return /* @__PURE__ */ b.jsx(Te.CanUseRemotionHooksProvider, {
    children: /* @__PURE__ */ b.jsx(Te.Timeline.TimelineContext.Provider, {
      value: e,
      children: /* @__PURE__ */ b.jsx(Te.CompositionManager.Provider, {
        value: h,
        children: /* @__PURE__ */ b.jsx(Te.ResolveCompositionConfig, {
          children: /* @__PURE__ */ b.jsx(Te.PrefetchProvider, {
            children: /* @__PURE__ */ b.jsx(Te.DurationsContextProvider, {
              children: /* @__PURE__ */ b.jsx(Te.MediaVolumeContext.Provider, {
                value: y,
                children: /* @__PURE__ */ b.jsx(Te.SetMediaVolumeContext.Provider, {
                  value: _,
                  children: /* @__PURE__ */ b.jsx(Te.SharedAudioContextProvider, {
                    numberOfAudioTags: c,
                    component: a,
                    children: /* @__PURE__ */ b.jsx(Te.BufferingProvider, {
                      children: r
                    })
                  })
                })
              })
            })
          })
        })
      })
    })
  });
}, r0 = (r, e) => {
  if (typeof r > "u" || r === null)
    return r ?? null;
  if (typeof r != "number")
    throw new TypeError(`"${e}" must be a number, but is ${JSON.stringify(r)}`);
  if (Number.isNaN(r))
    throw new TypeError(`"${e}" must not be NaN, but is ${JSON.stringify(r)}`);
  if (!Number.isFinite(r))
    throw new TypeError(`"${e}" must be finite, but is ${JSON.stringify(r)}`);
  if (r % 1 !== 0)
    throw new TypeError(`"${e}" must be an integer, but is ${JSON.stringify(r)}`);
  return r;
}, WD = ({
  inFrame: r,
  durationInFrames: e,
  outFrame: t
}) => {
  const n = r0(r, "inFrame"), i = r0(t, "outFrame");
  if (!(n === null && i === null)) {
    if (n !== null && n > e - 1)
      throw new Error("inFrame must be less than (durationInFrames - 1), but is " + n);
    if (i !== null && i > e - 1)
      throw new Error("outFrame must be less than (durationInFrames - 1), but is " + i);
    if (n !== null && n < 0)
      throw new Error("inFrame must be greater than 0, but is " + n);
    if (i !== null && i <= 0)
      throw new Error(`outFrame must be greater than 0, but is ${i}. If you want to render a single frame, use <Thumbnail /> instead.`);
    if (i !== null && n !== null && i <= n)
      throw new Error("outFrame must be greater than inFrame, but is " + i + " <= " + n);
  }
}, HD = ({
  initialFrame: r,
  durationInFrames: e
}) => {
  if (typeof e != "number")
    throw new Error(`\`durationInFrames\` must be a number, but is ${JSON.stringify(e)}`);
  if (!(typeof r > "u")) {
    if (typeof r != "number")
      throw new Error(`\`initialFrame\` must be a number, but is ${JSON.stringify(r)}`);
    if (Number.isNaN(r))
      throw new Error("`initialFrame` must be a number, but is NaN");
    if (!Number.isFinite(r))
      throw new Error("`initialFrame` must be a number, but is Infinity");
    if (r % 1 !== 0)
      throw new Error(`\`initialFrame\` must be an integer, but is ${JSON.stringify(r)}`);
    if (r > e - 1)
      throw new Error(`\`initialFrame\` must be less or equal than \`durationInFrames - 1\`, but is ${JSON.stringify(r)}`);
  }
}, UD = (r) => {
  if (r !== void 0) {
    if (r > 4)
      throw new Error(`The highest possible playback rate is 4. You passed: ${r}`);
    if (r < -4)
      throw new Error(`The lowest possible playback rate is -4. You passed: ${r}`);
    if (r === 0)
      throw new Error("A playback rate of 0 is not supported.");
  }
}, $D = Zl.validateFps, n0 = Zl.validateDimension, YD = Zl.validateDurationInFrames, XD = Zl.validateDefaultAndInputProps, GD = (r) => "component" in r ? r.component : null, qD = ({
  durationInFrames: r,
  compositionHeight: e,
  compositionWidth: t,
  fps: n,
  inputProps: i,
  style: s,
  controls: a = !1,
  loop: c = !1,
  autoPlay: u = !1,
  showVolumeControls: h = !0,
  allowFullscreen: d = !0,
  clickToPlay: p,
  doubleClickToFullscreen: g = !1,
  spaceKeyToPlayOrPause: v = !0,
  moveToBeginningWhenEnded: y = !0,
  numberOfSharedAudioTags: x = 5,
  errorFallback: _ = () => "⚠️",
  playbackRate: C = 1,
  renderLoading: E,
  className: k,
  showPosterWhenUnplayed: O,
  showPosterWhenEnded: P,
  showPosterWhenPaused: j,
  showPosterWhenBuffering: V,
  initialFrame: F,
  renderPoster: $,
  inFrame: z,
  outFrame: G,
  initiallyShowControls: H,
  renderFullscreenButton: Y,
  renderPlayPauseButton: te,
  renderVolumeSlider: ge,
  alwaysShowControls: Z = !1,
  initiallyMuted: de = !1,
  showPlaybackRateControl: oe = !1,
  posterFillMode: ie = "player-size",
  bufferStateDelayInMilliseconds: pe,
  hideControlsWhenPointerDoesntMove: re = !0,
  overflowVisible: Be = !1,
  renderMuteButton: Ze,
  browserMediaControlsBehavior: ze,
  ...Ee
}, Ie) => {
  if (typeof window < "u" && Xn(() => {
    window.remotion_isPlayer = !0;
  }, []), Ee.defaultProps !== void 0)
    throw new Error("The <Player /> component does not accept `defaultProps`, but some were passed. Use `inputProps` instead.");
  const dt = GD(Ee);
  if (dt?.type === Yv)
    throw new TypeError("'component' should not be an instance of <Composition/>. Pass the React component directly, and set the duration, fps and dimensions as separate props. See https://www.remotion.dev/docs/player/examples for an example.");
  if (dt === Yv)
    throw new TypeError("'component' must not be the 'Composition' component. Pass your own React component directly, and set the duration, fps and dimensions as separate props. See https://www.remotion.dev/docs/player/examples for an example.");
  const lr = Te.useLazyComponent(Ee);
  HD({ initialFrame: F, durationInFrames: r });
  const [Wt, Mt] = he(() => ({
    [Xf]: F ?? 0
  })), [ur, ye] = he(!1), [wr] = he("player-comp"), st = be(null), Vt = be([]), Jn = be(!1), [nt, Pt] = he(C);
  if (typeof e != "number")
    throw new TypeError(`'compositionHeight' must be a number but got '${typeof e}' instead`);
  if (typeof t != "number")
    throw new TypeError(`'compositionWidth' must be a number but got '${typeof t}' instead`);
  if (n0(e, "compositionHeight", "of the <Player /> component"), n0(t, "compositionWidth", "of the <Player /> component"), YD(r, {
    component: "of the <Player/> component",
    allowFloats: !1
  }), $D(n, "as a prop of the <Player/> component", !1), XD(i, "inputProps", null), WD({
    durationInFrames: r,
    inFrame: z,
    outFrame: G
  }), typeof a != "boolean" && typeof a < "u")
    throw new TypeError(`'controls' must be a boolean or undefined but got '${typeof a}' instead`);
  if (typeof u != "boolean" && typeof u < "u")
    throw new TypeError(`'autoPlay' must be a boolean or undefined but got '${typeof u}' instead`);
  if (typeof c != "boolean" && typeof c < "u")
    throw new TypeError(`'loop' must be a boolean or undefined but got '${typeof c}' instead`);
  if (typeof g != "boolean" && typeof g < "u")
    throw new TypeError(`'doubleClickToFullscreen' must be a boolean or undefined but got '${typeof g}' instead`);
  if (typeof h != "boolean" && typeof h < "u")
    throw new TypeError(`'showVolumeControls' must be a boolean or undefined but got '${typeof h}' instead`);
  if (typeof d != "boolean" && typeof d < "u")
    throw new TypeError(`'allowFullscreen' must be a boolean or undefined but got '${typeof d}' instead`);
  if (typeof p != "boolean" && typeof p < "u")
    throw new TypeError(`'clickToPlay' must be a boolean or undefined but got '${typeof p}' instead`);
  if (typeof v != "boolean" && typeof v < "u")
    throw new TypeError(`'spaceKeyToPlayOrPause' must be a boolean or undefined but got '${typeof v}' instead`);
  if (typeof x != "number" || x % 1 !== 0 || !Number.isFinite(x) || Number.isNaN(x) || x < 0)
    throw new TypeError(`'numberOfSharedAudioTags' must be an integer but got '${x}' instead`);
  UD(nt), ue(() => {
    Pt(C);
  }, [C]), qr(Ie, () => st.current, []);
  const In = ee(() => ({
    frame: Wt,
    playing: ur,
    rootId: wr,
    playbackRate: nt,
    imperativePlaying: Jn,
    setPlaybackRate: (ce) => {
      Pt(ce);
    },
    audioAndVideoTags: Vt
  }), [Wt, nt, ur, wr]), xr = ee(() => ({
    setFrame: Mt,
    setPlaying: ye
  }), [Mt]);
  typeof window < "u" && Xn(() => {
    Te.CSSUtils.injectCSS(Te.CSSUtils.makeDefaultPreviewCSS(`.${Yf}`, "#fff"));
  }, []);
  const A = ee(() => i ?? {}, [i]), le = ee(() => ze ?? {
    mode: "prevent-media-session"
  }, [ze]);
  return /* @__PURE__ */ b.jsx(Te.IsPlayerContextProvider, {
    children: /* @__PURE__ */ b.jsx(Pb, {
      timelineContext: In,
      component: lr,
      compositionHeight: e,
      compositionWidth: t,
      durationInFrames: r,
      fps: n,
      numberOfSharedAudioTags: x,
      initiallyMuted: de,
      children: /* @__PURE__ */ b.jsx(Te.Timeline.SetTimelineContext.Provider, {
        value: xr,
        children: /* @__PURE__ */ b.jsx(KP, {
          currentPlaybackRate: nt,
          children: /* @__PURE__ */ b.jsx(BD, {
            ref: st,
            posterFillMode: ie,
            renderLoading: E,
            autoPlay: !!u,
            loop: !!c,
            controls: !!a,
            errorFallback: _,
            style: s,
            inputProps: A,
            allowFullscreen: !!d,
            moveToBeginningWhenEnded: !!y,
            clickToPlay: typeof p == "boolean" ? p : !!a,
            showVolumeControls: !!h,
            doubleClickToFullscreen: !!g,
            spaceKeyToPlayOrPause: !!v,
            playbackRate: nt,
            className: k ?? void 0,
            showPosterWhenUnplayed: !!O,
            showPosterWhenEnded: !!P,
            showPosterWhenPaused: !!j,
            showPosterWhenBuffering: !!V,
            renderPoster: $,
            inFrame: z ?? null,
            outFrame: G ?? null,
            initiallyShowControls: H ?? !0,
            renderFullscreen: Y ?? null,
            renderPlayPauseButton: te ?? null,
            renderMuteButton: Ze ?? null,
            renderVolumeSlider: ge ?? null,
            alwaysShowControls: Z,
            showPlaybackRateControl: oe,
            bufferStateDelayInMilliseconds: pe ?? 300,
            hideControlsWhenPointerDoesntMove: re,
            overflowVisible: Be,
            browserMediaControlsBehavior: le
          })
        })
      })
    })
  });
}, KD = Bt, ZD = KD(qD), JD = () => {
  const r = me(kb);
  if (!r)
    throw new TypeError("Expected Player event emitter context");
  return ee(() => ({
    emitter: r
  }), [r]);
}, zd = Ce.version.split(".")[0];
if (zd === "0")
  throw new Error(`Version ${zd} of "react" is not supported by Remotion`);
var QD = parseInt(zd, 10) >= 18, e4 = ({ style: r, inputProps: e, errorFallback: t, renderLoading: n, className: i, overflowVisible: s }, a) => {
  const c = Te.useUnsafeVideoConfig(), u = Te.useVideo(), h = be(null), d = $f(h, {
    triggerOnWindowResize: !1,
    shouldApplyCssTransforms: !1
  }), p = ee(() => !c || !d ? null : _b({
    canvasSize: d,
    compositionHeight: c.height,
    compositionWidth: c.width,
    previewSize: "auto"
  }), [d, c]), g = p?.scale ?? 1, v = JD();
  Ob(v.emitter), qr(a, () => {
    const j = {
      getContainerNode: () => h.current,
      getScale: () => g
    };
    return Object.assign(v.emitter, j);
  }, [g, v.emitter]);
  const y = u ? u.component : null, x = ee(() => Sb({
    config: c,
    style: r,
    canvasSize: d,
    overflowVisible: s,
    layout: p
  }), [d, c, p, s, r]), _ = ee(() => Tb({ config: c, layout: p, scale: g, overflowVisible: s }), [c, p, s, g]), C = ee(() => Cb({
    canvasSize: d,
    config: c,
    layout: p,
    scale: g,
    overflowVisible: s
  }), [d, c, p, s, g]), E = se((j) => {
    v.emitter.dispatchError(j);
  }, [v.emitter]), k = ee(() => n ? n({
    height: x.height,
    width: x.width,
    isBuffering: !1
  }) : null, [x.height, x.width, n]), O = ee(() => ({
    type: "scale",
    scale: g
  }), [g]);
  if (!c)
    return null;
  const P = /* @__PURE__ */ b.jsx("div", {
    style: _,
    children: /* @__PURE__ */ b.jsx("div", {
      style: C,
      className: Yf,
      children: y ? /* @__PURE__ */ b.jsx(Ib, {
        onError: E,
        errorFallback: t,
        children: /* @__PURE__ */ b.jsx(Te.CurrentScaleContext.Provider, {
          value: O,
          children: /* @__PURE__ */ b.jsx(y, {
            ...u?.props ?? {},
            ...e ?? {}
          })
        })
      }) : null
    })
  });
  return Ab && !QD ? /* @__PURE__ */ b.jsx("div", {
    ref: h,
    style: x,
    className: i,
    children: P
  }) : /* @__PURE__ */ b.jsx("div", {
    ref: h,
    style: x,
    className: i,
    children: /* @__PURE__ */ b.jsx(tl, {
      fallback: k,
      children: P
    })
  });
}, t4 = Bt(e4), r4 = ({
  frameToDisplay: r,
  style: e,
  inputProps: t,
  compositionHeight: n,
  compositionWidth: i,
  durationInFrames: s,
  fps: a,
  className: c,
  errorFallback: u = () => "⚠️",
  renderLoading: h,
  overflowVisible: d = !1,
  ...p
}, g) => {
  typeof window < "u" && Xn(() => {
    window.remotion_isPlayer = !0;
  }, []);
  const [v] = he(() => String(ds(null))), y = be(null), x = ee(() => ({
    playing: !1,
    frame: {
      [Xf]: r
    },
    rootId: v,
    imperativePlaying: {
      current: !1
    },
    playbackRate: 1,
    setPlaybackRate: () => {
      throw new Error("thumbnail");
    },
    audioAndVideoTags: { current: [] }
  }), [r, v]);
  qr(g, () => y.current, []);
  const _ = Te.useLazyComponent(p), [C] = he(() => new qP()), E = ee(() => t ?? {}, [t]);
  return /* @__PURE__ */ b.jsx(Te.IsPlayerContextProvider, {
    children: /* @__PURE__ */ b.jsx(Pb, {
      timelineContext: x,
      component: _,
      compositionHeight: n,
      compositionWidth: i,
      durationInFrames: s,
      fps: a,
      numberOfSharedAudioTags: 0,
      initiallyMuted: !0,
      children: /* @__PURE__ */ b.jsx(kb.Provider, {
        value: C,
        children: /* @__PURE__ */ b.jsx(t4, {
          ref: y,
          className: c,
          errorFallback: u,
          inputProps: E,
          renderLoading: h,
          style: e,
          overflowVisible: d
        })
      })
    })
  });
}, n4 = Bt;
n4(r4);
const Cc = (r, e) => {
  const t = r.from / 1e3 * e, n = r.to / 1e3 * e - t;
  return { from: t, durationInFrames: n };
}, i4 = {
  text: (r, e) => {
    const { fps: t, height: n, width: i } = e, { from: s, durationInFrames: a } = Cc(r.display, t);
    return /* @__PURE__ */ b.jsx(
      wn,
      {
        from: s,
        durationInFrames: a,
        "data-track-item": "transition-element",
        style: {
          position: "absolute",
          width: r.details.width ?? 300,
          height: r.details.height ?? 400,
          transform: r.details.transform ?? "none",
          fontSize: r.details.fontSize || "16px",
          // Updated default font size
          textAlign: r.details.textAlign || "left",
          // Updated default text alignment
          top: r.details.top ?? 300,
          left: r.details.left ?? 600,
          color: r.details.color || "#000000",
          // Updated text color (fill)
          backgroundColor: r.details.backgroundColor || "transparent",
          // Updated background color
          border: r.details.border ?? "none",
          // Updated border
          opacity: r.details.opacity ?? 100 / 100,
          fontFamily: r.details.fontFamily || "Arial",
          // Updated default font family
          textDecoration: r.details.textDecoration || "none",
          fontWeight: r.details.fontWeight || "normal",
          lineHeight: r.details.lineHeight || "normal",
          // Added line height
          letterSpacing: r.details.letterSpacing || "normal",
          // Added letter spacing
          wordSpacing: r.details.wordSpacing || "normal",
          // Added word spacing
          wordWrap: r.details.wordWrap || "normal",
          //'break-word'
          wordBreak: r.details.wordBreak || "normal",
          //'break-all',
          pointerEvents: "auto"
        },
        children: /* @__PURE__ */ b.jsx("div", { children: r.details.text })
      },
      r.id
    );
  },
  image: (r, e) => {
    const { fps: t } = e, { from: n, durationInFrames: i } = Cc(r.display, t);
    return /* @__PURE__ */ b.jsx(
      wn,
      {
        from: n,
        durationInFrames: i,
        style: {
          width: r.details.width ?? "100%",
          // Default width
          height: r.details.height ?? "auto",
          // Default height
          transform: r.details.transform ?? "none",
          opacity: (r.details.opacity ?? 100) / 100 || 1,
          border: r.details.border ?? "none",
          // Default border
          borderRadius: r.details.borderRadius ?? "0",
          // Default border radius
          boxShadow: r.details.boxShadow ?? "none",
          // Default box shadow
          filter: r.details.filter || "none",
          top: r.details.top ?? 0,
          left: r.details.left ?? 0
        },
        children: /* @__PURE__ */ b.jsx($o, { style: { pointerEvents: "none" }, children: /* @__PURE__ */ b.jsx(
          mb,
          {
            style: { pointerEvents: "none" },
            "data-id": r.id,
            src: r.details.src
          }
        ) })
      },
      r.id
    );
  },
  video: (r, e) => {
    const { fps: t } = e, { from: n, durationInFrames: i } = Cc(r.display, t), s = r.trim, a = r.details.crop || {
      x: 0,
      y: 0,
      width: r.details.width,
      height: r.details.height
    };
    return s ? /* @__PURE__ */ b.jsx(
      wn,
      {
        premountFor: 30 * 5,
        from: n,
        durationInFrames: i,
        style: {
          width: a.width || "100%",
          // Default width
          height: a.height || "auto",
          // Default height
          transform: r.details.transform ?? "none",
          opacity: (r.details.opacity ?? 100) / 100 || 1,
          border: r.details.border ?? "none",
          // Default border
          borderRadius: r.details.borderRadius ?? "0",
          // Default border radius
          boxShadow: r.details.boxShadow ?? "none",
          // Default box shadow
          top: r.details.top ?? 0,
          left: r.details.left ?? 0,
          overflow: "hidden"
        },
        children: /* @__PURE__ */ b.jsx(
          $o,
          {
            style: {
              pointerEvents: "none",
              width: r.details.width,
              height: r.details.height,
              top: -a.y,
              left: -a.x
            },
            children: /* @__PURE__ */ b.jsx(
              xb,
              {
                startFrom: s.from / 1e3 * t,
                endAt: s.to / 1e3 * t,
                src: r.details.src,
                volume: (r.details.volume ?? 100) / 100,
                style: {
                  pointerEvents: "none",
                  width: r.details.width,
                  height: r.details.height
                }
              }
            )
          }
        )
      },
      r.id
    ) : /* @__PURE__ */ b.jsx(b.Fragment, {});
  },
  audio: (r, e) => {
    const { fps: t } = e, { from: n, durationInFrames: i } = Cc(r.display, t), s = r.trim;
    return s ? /* @__PURE__ */ b.jsx(
      wn,
      {
        className: `moonshine-scene-item id-${r.id} moonshine-scene-item-type-${r.type}`,
        from: n,
        durationInFrames: i,
        style: {
          userSelect: "none",
          pointerEvents: "none"
        },
        children: /* @__PURE__ */ b.jsx($o, { children: /* @__PURE__ */ b.jsx(
          Yo,
          {
            startFrom: s.from / 1e3 * t,
            endAt: s.to / 1e3 * t,
            src: r.details.src,
            volume: (r.details.volume ?? 100) / 100
          }
        ) })
      },
      r.id
    ) : /* @__PURE__ */ b.jsx(b.Fragment, {});
  }
};
var ul = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
ul.exports;
(function(r, e) {
  (function() {
    var t, n = "4.17.21", i = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", a = "Expected a function", c = "Invalid `variable` option passed into `_.template`", u = "__lodash_hash_undefined__", h = 500, d = "__lodash_placeholder__", p = 1, g = 2, v = 4, y = 1, x = 2, _ = 1, C = 2, E = 4, k = 8, O = 16, P = 32, j = 64, V = 128, F = 256, $ = 512, z = 30, G = "...", H = 800, Y = 16, te = 1, ge = 2, Z = 3, de = 1 / 0, oe = 9007199254740991, ie = 17976931348623157e292, pe = NaN, re = 4294967295, Be = re - 1, Ze = re >>> 1, ze = [
      ["ary", V],
      ["bind", _],
      ["bindKey", C],
      ["curry", k],
      ["curryRight", O],
      ["flip", $],
      ["partial", P],
      ["partialRight", j],
      ["rearg", F]
    ], Ee = "[object Arguments]", Ie = "[object Array]", dt = "[object AsyncFunction]", lr = "[object Boolean]", Wt = "[object Date]", Mt = "[object DOMException]", ur = "[object Error]", ye = "[object Function]", wr = "[object GeneratorFunction]", st = "[object Map]", Vt = "[object Number]", Jn = "[object Null]", nt = "[object Object]", Pt = "[object Promise]", In = "[object Proxy]", xr = "[object RegExp]", A = "[object Set]", le = "[object String]", ce = "[object Symbol]", je = "[object Undefined]", et = "[object WeakMap]", Ge = "[object WeakSet]", Se = "[object ArrayBuffer]", ot = "[object DataView]", hr = "[object Float32Array]", xt = "[object Float64Array]", _r = "[object Int8Array]", Zr = "[object Int16Array]", dr = "[object Int32Array]", fn = "[object Uint8Array]", Jt = "[object Uint8ClampedArray]", mo = "[object Uint16Array]", vo = "[object Uint32Array]", vs = /\b__p \+= '';/g, ys = /\b(__p \+=) '' \+/g, wu = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Ia = /&(?:amp|lt|gt|quot|#39);/g, ki = /[&<>"']/g, Aa = RegExp(Ia.source), Pp = RegExp(ki.source), Dp = /<%-([\s\S]+?)%>/g, Rp = /<%([\s\S]+?)%>/g, xu = /<%=([\s\S]+?)%>/g, _u = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Ma = /^\w*$/, $e = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, He = /[\\^$.*+?()[\]{}|]/g, Sr = RegExp(He.source), pn = /^\s+/, jp = /\s/, e_ = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, t_ = /\{\n\/\* \[wrapped with (.+)\] \*/, r_ = /,? & /, n_ = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, i_ = /[()=,{}\[\]\/\s]/, s_ = /\\(\\)?/g, o_ = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Fp = /\w*$/, a_ = /^[-+]0x[0-9a-f]+$/i, c_ = /^0b[01]+$/i, l_ = /^\[object .+?Constructor\]$/, u_ = /^0o[0-7]+$/i, h_ = /^(?:0|[1-9]\d*)$/, d_ = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Pa = /($^)/, f_ = /['\n\r\u2028\u2029\\]/g, Da = "\\ud800-\\udfff", p_ = "\\u0300-\\u036f", g_ = "\\ufe20-\\ufe2f", m_ = "\\u20d0-\\u20ff", Lp = p_ + g_ + m_, Np = "\\u2700-\\u27bf", Bp = "a-z\\xdf-\\xf6\\xf8-\\xff", v_ = "\\xac\\xb1\\xd7\\xf7", y_ = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", b_ = "\\u2000-\\u206f", w_ = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Vp = "A-Z\\xc0-\\xd6\\xd8-\\xde", zp = "\\ufe0e\\ufe0f", Wp = v_ + y_ + b_ + w_, Su = "['’]", x_ = "[" + Da + "]", Hp = "[" + Wp + "]", Ra = "[" + Lp + "]", Up = "\\d+", __ = "[" + Np + "]", $p = "[" + Bp + "]", Yp = "[^" + Da + Wp + Up + Np + Bp + Vp + "]", Cu = "\\ud83c[\\udffb-\\udfff]", S_ = "(?:" + Ra + "|" + Cu + ")", Xp = "[^" + Da + "]", Tu = "(?:\\ud83c[\\udde6-\\uddff]){2}", Eu = "[\\ud800-\\udbff][\\udc00-\\udfff]", bs = "[" + Vp + "]", Gp = "\\u200d", qp = "(?:" + $p + "|" + Yp + ")", C_ = "(?:" + bs + "|" + Yp + ")", Kp = "(?:" + Su + "(?:d|ll|m|re|s|t|ve))?", Zp = "(?:" + Su + "(?:D|LL|M|RE|S|T|VE))?", Jp = S_ + "?", Qp = "[" + zp + "]?", T_ = "(?:" + Gp + "(?:" + [Xp, Tu, Eu].join("|") + ")" + Qp + Jp + ")*", E_ = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", k_ = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", eg = Qp + Jp + T_, O_ = "(?:" + [__, Tu, Eu].join("|") + ")" + eg, I_ = "(?:" + [Xp + Ra + "?", Ra, Tu, Eu, x_].join("|") + ")", A_ = RegExp(Su, "g"), M_ = RegExp(Ra, "g"), ku = RegExp(Cu + "(?=" + Cu + ")|" + I_ + eg, "g"), P_ = RegExp([
      bs + "?" + $p + "+" + Kp + "(?=" + [Hp, bs, "$"].join("|") + ")",
      C_ + "+" + Zp + "(?=" + [Hp, bs + qp, "$"].join("|") + ")",
      bs + "?" + qp + "+" + Kp,
      bs + "+" + Zp,
      k_,
      E_,
      Up,
      O_
    ].join("|"), "g"), D_ = RegExp("[" + Gp + Da + Lp + zp + "]"), R_ = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, j_ = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], F_ = -1, at = {};
    at[hr] = at[xt] = at[_r] = at[Zr] = at[dr] = at[fn] = at[Jt] = at[mo] = at[vo] = !0, at[Ee] = at[Ie] = at[Se] = at[lr] = at[ot] = at[Wt] = at[ur] = at[ye] = at[st] = at[Vt] = at[nt] = at[xr] = at[A] = at[le] = at[et] = !1;
    var it = {};
    it[Ee] = it[Ie] = it[Se] = it[ot] = it[lr] = it[Wt] = it[hr] = it[xt] = it[_r] = it[Zr] = it[dr] = it[st] = it[Vt] = it[nt] = it[xr] = it[A] = it[le] = it[ce] = it[fn] = it[Jt] = it[mo] = it[vo] = !0, it[ur] = it[ye] = it[et] = !1;
    var L_ = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, N_ = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, B_ = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, V_ = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, z_ = parseFloat, W_ = parseInt, tg = typeof Do == "object" && Do && Do.Object === Object && Do, H_ = typeof self == "object" && self && self.Object === Object && self, Ht = tg || H_ || Function("return this")(), Ou = e && !e.nodeType && e, Oi = Ou && !0 && r && !r.nodeType && r, rg = Oi && Oi.exports === Ou, Iu = rg && tg.process, Fr = function() {
      try {
        var L = Oi && Oi.require && Oi.require("util").types;
        return L || Iu && Iu.binding && Iu.binding("util");
      } catch {
      }
    }(), ng = Fr && Fr.isArrayBuffer, ig = Fr && Fr.isDate, sg = Fr && Fr.isMap, og = Fr && Fr.isRegExp, ag = Fr && Fr.isSet, cg = Fr && Fr.isTypedArray;
    function Cr(L, X, U) {
      switch (U.length) {
        case 0:
          return L.call(X);
        case 1:
          return L.call(X, U[0]);
        case 2:
          return L.call(X, U[0], U[1]);
        case 3:
          return L.call(X, U[0], U[1], U[2]);
      }
      return L.apply(X, U);
    }
    function U_(L, X, U, fe) {
      for (var ke = -1, Ye = L == null ? 0 : L.length; ++ke < Ye; ) {
        var Dt = L[ke];
        X(fe, Dt, U(Dt), L);
      }
      return fe;
    }
    function Lr(L, X) {
      for (var U = -1, fe = L == null ? 0 : L.length; ++U < fe && X(L[U], U, L) !== !1; )
        ;
      return L;
    }
    function $_(L, X) {
      for (var U = L == null ? 0 : L.length; U-- && X(L[U], U, L) !== !1; )
        ;
      return L;
    }
    function lg(L, X) {
      for (var U = -1, fe = L == null ? 0 : L.length; ++U < fe; )
        if (!X(L[U], U, L))
          return !1;
      return !0;
    }
    function Qn(L, X) {
      for (var U = -1, fe = L == null ? 0 : L.length, ke = 0, Ye = []; ++U < fe; ) {
        var Dt = L[U];
        X(Dt, U, L) && (Ye[ke++] = Dt);
      }
      return Ye;
    }
    function ja(L, X) {
      var U = L == null ? 0 : L.length;
      return !!U && ws(L, X, 0) > -1;
    }
    function Au(L, X, U) {
      for (var fe = -1, ke = L == null ? 0 : L.length; ++fe < ke; )
        if (U(X, L[fe]))
          return !0;
      return !1;
    }
    function lt(L, X) {
      for (var U = -1, fe = L == null ? 0 : L.length, ke = Array(fe); ++U < fe; )
        ke[U] = X(L[U], U, L);
      return ke;
    }
    function ei(L, X) {
      for (var U = -1, fe = X.length, ke = L.length; ++U < fe; )
        L[ke + U] = X[U];
      return L;
    }
    function Mu(L, X, U, fe) {
      var ke = -1, Ye = L == null ? 0 : L.length;
      for (fe && Ye && (U = L[++ke]); ++ke < Ye; )
        U = X(U, L[ke], ke, L);
      return U;
    }
    function Y_(L, X, U, fe) {
      var ke = L == null ? 0 : L.length;
      for (fe && ke && (U = L[--ke]); ke--; )
        U = X(U, L[ke], ke, L);
      return U;
    }
    function Pu(L, X) {
      for (var U = -1, fe = L == null ? 0 : L.length; ++U < fe; )
        if (X(L[U], U, L))
          return !0;
      return !1;
    }
    var X_ = Du("length");
    function G_(L) {
      return L.split("");
    }
    function q_(L) {
      return L.match(n_) || [];
    }
    function ug(L, X, U) {
      var fe;
      return U(L, function(ke, Ye, Dt) {
        if (X(ke, Ye, Dt))
          return fe = Ye, !1;
      }), fe;
    }
    function Fa(L, X, U, fe) {
      for (var ke = L.length, Ye = U + (fe ? 1 : -1); fe ? Ye-- : ++Ye < ke; )
        if (X(L[Ye], Ye, L))
          return Ye;
      return -1;
    }
    function ws(L, X, U) {
      return X === X ? aS(L, X, U) : Fa(L, hg, U);
    }
    function K_(L, X, U, fe) {
      for (var ke = U - 1, Ye = L.length; ++ke < Ye; )
        if (fe(L[ke], X))
          return ke;
      return -1;
    }
    function hg(L) {
      return L !== L;
    }
    function dg(L, X) {
      var U = L == null ? 0 : L.length;
      return U ? ju(L, X) / U : pe;
    }
    function Du(L) {
      return function(X) {
        return X == null ? t : X[L];
      };
    }
    function Ru(L) {
      return function(X) {
        return L == null ? t : L[X];
      };
    }
    function fg(L, X, U, fe, ke) {
      return ke(L, function(Ye, Dt, tt) {
        U = fe ? (fe = !1, Ye) : X(U, Ye, Dt, tt);
      }), U;
    }
    function Z_(L, X) {
      var U = L.length;
      for (L.sort(X); U--; )
        L[U] = L[U].value;
      return L;
    }
    function ju(L, X) {
      for (var U, fe = -1, ke = L.length; ++fe < ke; ) {
        var Ye = X(L[fe]);
        Ye !== t && (U = U === t ? Ye : U + Ye);
      }
      return U;
    }
    function Fu(L, X) {
      for (var U = -1, fe = Array(L); ++U < L; )
        fe[U] = X(U);
      return fe;
    }
    function J_(L, X) {
      return lt(X, function(U) {
        return [U, L[U]];
      });
    }
    function pg(L) {
      return L && L.slice(0, yg(L) + 1).replace(pn, "");
    }
    function Tr(L) {
      return function(X) {
        return L(X);
      };
    }
    function Lu(L, X) {
      return lt(X, function(U) {
        return L[U];
      });
    }
    function yo(L, X) {
      return L.has(X);
    }
    function gg(L, X) {
      for (var U = -1, fe = L.length; ++U < fe && ws(X, L[U], 0) > -1; )
        ;
      return U;
    }
    function mg(L, X) {
      for (var U = L.length; U-- && ws(X, L[U], 0) > -1; )
        ;
      return U;
    }
    function Q_(L, X) {
      for (var U = L.length, fe = 0; U--; )
        L[U] === X && ++fe;
      return fe;
    }
    var eS = Ru(L_), tS = Ru(N_);
    function rS(L) {
      return "\\" + V_[L];
    }
    function nS(L, X) {
      return L == null ? t : L[X];
    }
    function xs(L) {
      return D_.test(L);
    }
    function iS(L) {
      return R_.test(L);
    }
    function sS(L) {
      for (var X, U = []; !(X = L.next()).done; )
        U.push(X.value);
      return U;
    }
    function Nu(L) {
      var X = -1, U = Array(L.size);
      return L.forEach(function(fe, ke) {
        U[++X] = [ke, fe];
      }), U;
    }
    function vg(L, X) {
      return function(U) {
        return L(X(U));
      };
    }
    function ti(L, X) {
      for (var U = -1, fe = L.length, ke = 0, Ye = []; ++U < fe; ) {
        var Dt = L[U];
        (Dt === X || Dt === d) && (L[U] = d, Ye[ke++] = U);
      }
      return Ye;
    }
    function La(L) {
      var X = -1, U = Array(L.size);
      return L.forEach(function(fe) {
        U[++X] = fe;
      }), U;
    }
    function oS(L) {
      var X = -1, U = Array(L.size);
      return L.forEach(function(fe) {
        U[++X] = [fe, fe];
      }), U;
    }
    function aS(L, X, U) {
      for (var fe = U - 1, ke = L.length; ++fe < ke; )
        if (L[fe] === X)
          return fe;
      return -1;
    }
    function cS(L, X, U) {
      for (var fe = U + 1; fe--; )
        if (L[fe] === X)
          return fe;
      return fe;
    }
    function _s(L) {
      return xs(L) ? uS(L) : X_(L);
    }
    function Jr(L) {
      return xs(L) ? hS(L) : G_(L);
    }
    function yg(L) {
      for (var X = L.length; X-- && jp.test(L.charAt(X)); )
        ;
      return X;
    }
    var lS = Ru(B_);
    function uS(L) {
      for (var X = ku.lastIndex = 0; ku.test(L); )
        ++X;
      return X;
    }
    function hS(L) {
      return L.match(ku) || [];
    }
    function dS(L) {
      return L.match(P_) || [];
    }
    var fS = function L(X) {
      X = X == null ? Ht : Ss.defaults(Ht.Object(), X, Ss.pick(Ht, j_));
      var U = X.Array, fe = X.Date, ke = X.Error, Ye = X.Function, Dt = X.Math, tt = X.Object, Bu = X.RegExp, pS = X.String, Nr = X.TypeError, Na = U.prototype, gS = Ye.prototype, Cs = tt.prototype, Ba = X["__core-js_shared__"], Va = gS.toString, Je = Cs.hasOwnProperty, mS = 0, bg = function() {
        var o = /[^.]+$/.exec(Ba && Ba.keys && Ba.keys.IE_PROTO || "");
        return o ? "Symbol(src)_1." + o : "";
      }(), za = Cs.toString, vS = Va.call(tt), yS = Ht._, bS = Bu(
        "^" + Va.call(Je).replace(He, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Wa = rg ? X.Buffer : t, ri = X.Symbol, Ha = X.Uint8Array, wg = Wa ? Wa.allocUnsafe : t, Ua = vg(tt.getPrototypeOf, tt), xg = tt.create, _g = Cs.propertyIsEnumerable, $a = Na.splice, Sg = ri ? ri.isConcatSpreadable : t, bo = ri ? ri.iterator : t, Ii = ri ? ri.toStringTag : t, Ya = function() {
        try {
          var o = Ri(tt, "defineProperty");
          return o({}, "", {}), o;
        } catch {
        }
      }(), wS = X.clearTimeout !== Ht.clearTimeout && X.clearTimeout, xS = fe && fe.now !== Ht.Date.now && fe.now, _S = X.setTimeout !== Ht.setTimeout && X.setTimeout, Xa = Dt.ceil, Ga = Dt.floor, Vu = tt.getOwnPropertySymbols, SS = Wa ? Wa.isBuffer : t, Cg = X.isFinite, CS = Na.join, TS = vg(tt.keys, tt), Rt = Dt.max, Xt = Dt.min, ES = fe.now, kS = X.parseInt, Tg = Dt.random, OS = Na.reverse, zu = Ri(X, "DataView"), wo = Ri(X, "Map"), Wu = Ri(X, "Promise"), Ts = Ri(X, "Set"), xo = Ri(X, "WeakMap"), _o = Ri(tt, "create"), qa = xo && new xo(), Es = {}, IS = ji(zu), AS = ji(wo), MS = ji(Wu), PS = ji(Ts), DS = ji(xo), Ka = ri ? ri.prototype : t, So = Ka ? Ka.valueOf : t, Eg = Ka ? Ka.toString : t;
      function S(o) {
        if (mt(o) && !Oe(o) && !(o instanceof Le)) {
          if (o instanceof Br)
            return o;
          if (Je.call(o, "__wrapped__"))
            return km(o);
        }
        return new Br(o);
      }
      var ks = /* @__PURE__ */ function() {
        function o() {
        }
        return function(l) {
          if (!ft(l))
            return {};
          if (xg)
            return xg(l);
          o.prototype = l;
          var f = new o();
          return o.prototype = t, f;
        };
      }();
      function Za() {
      }
      function Br(o, l) {
        this.__wrapped__ = o, this.__actions__ = [], this.__chain__ = !!l, this.__index__ = 0, this.__values__ = t;
      }
      S.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Dp,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: Rp,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: xu,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: S
        }
      }, S.prototype = Za.prototype, S.prototype.constructor = S, Br.prototype = ks(Za.prototype), Br.prototype.constructor = Br;
      function Le(o) {
        this.__wrapped__ = o, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = re, this.__views__ = [];
      }
      function RS() {
        var o = new Le(this.__wrapped__);
        return o.__actions__ = fr(this.__actions__), o.__dir__ = this.__dir__, o.__filtered__ = this.__filtered__, o.__iteratees__ = fr(this.__iteratees__), o.__takeCount__ = this.__takeCount__, o.__views__ = fr(this.__views__), o;
      }
      function jS() {
        if (this.__filtered__) {
          var o = new Le(this);
          o.__dir__ = -1, o.__filtered__ = !0;
        } else
          o = this.clone(), o.__dir__ *= -1;
        return o;
      }
      function FS() {
        var o = this.__wrapped__.value(), l = this.__dir__, f = Oe(o), m = l < 0, w = f ? o.length : 0, T = GC(0, w, this.__views__), I = T.start, M = T.end, N = M - I, q = m ? M : I - 1, K = this.__iteratees__, J = K.length, ae = 0, ve = Xt(N, this.__takeCount__);
        if (!f || !m && w == N && ve == N)
          return Kg(o, this.__actions__);
        var xe = [];
        e:
          for (; N-- && ae < ve; ) {
            q += l;
            for (var De = -1, _e = o[q]; ++De < J; ) {
              var Fe = K[De], Ve = Fe.iteratee, Or = Fe.type, tr = Ve(_e);
              if (Or == ge)
                _e = tr;
              else if (!tr) {
                if (Or == te)
                  continue e;
                break e;
              }
            }
            xe[ae++] = _e;
          }
        return xe;
      }
      Le.prototype = ks(Za.prototype), Le.prototype.constructor = Le;
      function Ai(o) {
        var l = -1, f = o == null ? 0 : o.length;
        for (this.clear(); ++l < f; ) {
          var m = o[l];
          this.set(m[0], m[1]);
        }
      }
      function LS() {
        this.__data__ = _o ? _o(null) : {}, this.size = 0;
      }
      function NS(o) {
        var l = this.has(o) && delete this.__data__[o];
        return this.size -= l ? 1 : 0, l;
      }
      function BS(o) {
        var l = this.__data__;
        if (_o) {
          var f = l[o];
          return f === u ? t : f;
        }
        return Je.call(l, o) ? l[o] : t;
      }
      function VS(o) {
        var l = this.__data__;
        return _o ? l[o] !== t : Je.call(l, o);
      }
      function zS(o, l) {
        var f = this.__data__;
        return this.size += this.has(o) ? 0 : 1, f[o] = _o && l === t ? u : l, this;
      }
      Ai.prototype.clear = LS, Ai.prototype.delete = NS, Ai.prototype.get = BS, Ai.prototype.has = VS, Ai.prototype.set = zS;
      function An(o) {
        var l = -1, f = o == null ? 0 : o.length;
        for (this.clear(); ++l < f; ) {
          var m = o[l];
          this.set(m[0], m[1]);
        }
      }
      function WS() {
        this.__data__ = [], this.size = 0;
      }
      function HS(o) {
        var l = this.__data__, f = Ja(l, o);
        if (f < 0)
          return !1;
        var m = l.length - 1;
        return f == m ? l.pop() : $a.call(l, f, 1), --this.size, !0;
      }
      function US(o) {
        var l = this.__data__, f = Ja(l, o);
        return f < 0 ? t : l[f][1];
      }
      function $S(o) {
        return Ja(this.__data__, o) > -1;
      }
      function YS(o, l) {
        var f = this.__data__, m = Ja(f, o);
        return m < 0 ? (++this.size, f.push([o, l])) : f[m][1] = l, this;
      }
      An.prototype.clear = WS, An.prototype.delete = HS, An.prototype.get = US, An.prototype.has = $S, An.prototype.set = YS;
      function Mn(o) {
        var l = -1, f = o == null ? 0 : o.length;
        for (this.clear(); ++l < f; ) {
          var m = o[l];
          this.set(m[0], m[1]);
        }
      }
      function XS() {
        this.size = 0, this.__data__ = {
          hash: new Ai(),
          map: new (wo || An)(),
          string: new Ai()
        };
      }
      function GS(o) {
        var l = uc(this, o).delete(o);
        return this.size -= l ? 1 : 0, l;
      }
      function qS(o) {
        return uc(this, o).get(o);
      }
      function KS(o) {
        return uc(this, o).has(o);
      }
      function ZS(o, l) {
        var f = uc(this, o), m = f.size;
        return f.set(o, l), this.size += f.size == m ? 0 : 1, this;
      }
      Mn.prototype.clear = XS, Mn.prototype.delete = GS, Mn.prototype.get = qS, Mn.prototype.has = KS, Mn.prototype.set = ZS;
      function Mi(o) {
        var l = -1, f = o == null ? 0 : o.length;
        for (this.__data__ = new Mn(); ++l < f; )
          this.add(o[l]);
      }
      function JS(o) {
        return this.__data__.set(o, u), this;
      }
      function QS(o) {
        return this.__data__.has(o);
      }
      Mi.prototype.add = Mi.prototype.push = JS, Mi.prototype.has = QS;
      function Qr(o) {
        var l = this.__data__ = new An(o);
        this.size = l.size;
      }
      function eC() {
        this.__data__ = new An(), this.size = 0;
      }
      function tC(o) {
        var l = this.__data__, f = l.delete(o);
        return this.size = l.size, f;
      }
      function rC(o) {
        return this.__data__.get(o);
      }
      function nC(o) {
        return this.__data__.has(o);
      }
      function iC(o, l) {
        var f = this.__data__;
        if (f instanceof An) {
          var m = f.__data__;
          if (!wo || m.length < i - 1)
            return m.push([o, l]), this.size = ++f.size, this;
          f = this.__data__ = new Mn(m);
        }
        return f.set(o, l), this.size = f.size, this;
      }
      Qr.prototype.clear = eC, Qr.prototype.delete = tC, Qr.prototype.get = rC, Qr.prototype.has = nC, Qr.prototype.set = iC;
      function kg(o, l) {
        var f = Oe(o), m = !f && Fi(o), w = !f && !m && ai(o), T = !f && !m && !w && Ms(o), I = f || m || w || T, M = I ? Fu(o.length, pS) : [], N = M.length;
        for (var q in o)
          (l || Je.call(o, q)) && !(I && // Safari 9 has enumerable `arguments.length` in strict mode.
          (q == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          w && (q == "offset" || q == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          T && (q == "buffer" || q == "byteLength" || q == "byteOffset") || // Skip index properties.
          jn(q, N))) && M.push(q);
        return M;
      }
      function Og(o) {
        var l = o.length;
        return l ? o[Qu(0, l - 1)] : t;
      }
      function sC(o, l) {
        return hc(fr(o), Pi(l, 0, o.length));
      }
      function oC(o) {
        return hc(fr(o));
      }
      function Hu(o, l, f) {
        (f !== t && !en(o[l], f) || f === t && !(l in o)) && Pn(o, l, f);
      }
      function Co(o, l, f) {
        var m = o[l];
        (!(Je.call(o, l) && en(m, f)) || f === t && !(l in o)) && Pn(o, l, f);
      }
      function Ja(o, l) {
        for (var f = o.length; f--; )
          if (en(o[f][0], l))
            return f;
        return -1;
      }
      function aC(o, l, f, m) {
        return ni(o, function(w, T, I) {
          l(m, w, f(w), I);
        }), m;
      }
      function Ig(o, l) {
        return o && mn(l, zt(l), o);
      }
      function cC(o, l) {
        return o && mn(l, gr(l), o);
      }
      function Pn(o, l, f) {
        l == "__proto__" && Ya ? Ya(o, l, {
          configurable: !0,
          enumerable: !0,
          value: f,
          writable: !0
        }) : o[l] = f;
      }
      function Uu(o, l) {
        for (var f = -1, m = l.length, w = U(m), T = o == null; ++f < m; )
          w[f] = T ? t : Ch(o, l[f]);
        return w;
      }
      function Pi(o, l, f) {
        return o === o && (f !== t && (o = o <= f ? o : f), l !== t && (o = o >= l ? o : l)), o;
      }
      function Vr(o, l, f, m, w, T) {
        var I, M = l & p, N = l & g, q = l & v;
        if (f && (I = w ? f(o, m, w, T) : f(o)), I !== t)
          return I;
        if (!ft(o))
          return o;
        var K = Oe(o);
        if (K) {
          if (I = KC(o), !M)
            return fr(o, I);
        } else {
          var J = Gt(o), ae = J == ye || J == wr;
          if (ai(o))
            return Qg(o, M);
          if (J == nt || J == Ee || ae && !w) {
            if (I = N || ae ? {} : ym(o), !M)
              return N ? BC(o, cC(I, o)) : NC(o, Ig(I, o));
          } else {
            if (!it[J])
              return w ? o : {};
            I = ZC(o, J, M);
          }
        }
        T || (T = new Qr());
        var ve = T.get(o);
        if (ve)
          return ve;
        T.set(o, I), Xm(o) ? o.forEach(function(_e) {
          I.add(Vr(_e, l, f, _e, o, T));
        }) : $m(o) && o.forEach(function(_e, Fe) {
          I.set(Fe, Vr(_e, l, f, Fe, o, T));
        });
        var xe = q ? N ? uh : lh : N ? gr : zt, De = K ? t : xe(o);
        return Lr(De || o, function(_e, Fe) {
          De && (Fe = _e, _e = o[Fe]), Co(I, Fe, Vr(_e, l, f, Fe, o, T));
        }), I;
      }
      function lC(o) {
        var l = zt(o);
        return function(f) {
          return Ag(f, o, l);
        };
      }
      function Ag(o, l, f) {
        var m = f.length;
        if (o == null)
          return !m;
        for (o = tt(o); m--; ) {
          var w = f[m], T = l[w], I = o[w];
          if (I === t && !(w in o) || !T(I))
            return !1;
        }
        return !0;
      }
      function Mg(o, l, f) {
        if (typeof o != "function")
          throw new Nr(a);
        return Mo(function() {
          o.apply(t, f);
        }, l);
      }
      function To(o, l, f, m) {
        var w = -1, T = ja, I = !0, M = o.length, N = [], q = l.length;
        if (!M)
          return N;
        f && (l = lt(l, Tr(f))), m ? (T = Au, I = !1) : l.length >= i && (T = yo, I = !1, l = new Mi(l));
        e:
          for (; ++w < M; ) {
            var K = o[w], J = f == null ? K : f(K);
            if (K = m || K !== 0 ? K : 0, I && J === J) {
              for (var ae = q; ae--; )
                if (l[ae] === J)
                  continue e;
              N.push(K);
            } else T(l, J, m) || N.push(K);
          }
        return N;
      }
      var ni = im(gn), Pg = im(Yu, !0);
      function uC(o, l) {
        var f = !0;
        return ni(o, function(m, w, T) {
          return f = !!l(m, w, T), f;
        }), f;
      }
      function Qa(o, l, f) {
        for (var m = -1, w = o.length; ++m < w; ) {
          var T = o[m], I = l(T);
          if (I != null && (M === t ? I === I && !kr(I) : f(I, M)))
            var M = I, N = T;
        }
        return N;
      }
      function hC(o, l, f, m) {
        var w = o.length;
        for (f = Ae(f), f < 0 && (f = -f > w ? 0 : w + f), m = m === t || m > w ? w : Ae(m), m < 0 && (m += w), m = f > m ? 0 : qm(m); f < m; )
          o[f++] = l;
        return o;
      }
      function Dg(o, l) {
        var f = [];
        return ni(o, function(m, w, T) {
          l(m, w, T) && f.push(m);
        }), f;
      }
      function Ut(o, l, f, m, w) {
        var T = -1, I = o.length;
        for (f || (f = QC), w || (w = []); ++T < I; ) {
          var M = o[T];
          l > 0 && f(M) ? l > 1 ? Ut(M, l - 1, f, m, w) : ei(w, M) : m || (w[w.length] = M);
        }
        return w;
      }
      var $u = sm(), Rg = sm(!0);
      function gn(o, l) {
        return o && $u(o, l, zt);
      }
      function Yu(o, l) {
        return o && Rg(o, l, zt);
      }
      function ec(o, l) {
        return Qn(l, function(f) {
          return Fn(o[f]);
        });
      }
      function Di(o, l) {
        l = si(l, o);
        for (var f = 0, m = l.length; o != null && f < m; )
          o = o[vn(l[f++])];
        return f && f == m ? o : t;
      }
      function jg(o, l, f) {
        var m = l(o);
        return Oe(o) ? m : ei(m, f(o));
      }
      function Qt(o) {
        return o == null ? o === t ? je : Jn : Ii && Ii in tt(o) ? XC(o) : oT(o);
      }
      function Xu(o, l) {
        return o > l;
      }
      function dC(o, l) {
        return o != null && Je.call(o, l);
      }
      function fC(o, l) {
        return o != null && l in tt(o);
      }
      function pC(o, l, f) {
        return o >= Xt(l, f) && o < Rt(l, f);
      }
      function Gu(o, l, f) {
        for (var m = f ? Au : ja, w = o[0].length, T = o.length, I = T, M = U(T), N = 1 / 0, q = []; I--; ) {
          var K = o[I];
          I && l && (K = lt(K, Tr(l))), N = Xt(K.length, N), M[I] = !f && (l || w >= 120 && K.length >= 120) ? new Mi(I && K) : t;
        }
        K = o[0];
        var J = -1, ae = M[0];
        e:
          for (; ++J < w && q.length < N; ) {
            var ve = K[J], xe = l ? l(ve) : ve;
            if (ve = f || ve !== 0 ? ve : 0, !(ae ? yo(ae, xe) : m(q, xe, f))) {
              for (I = T; --I; ) {
                var De = M[I];
                if (!(De ? yo(De, xe) : m(o[I], xe, f)))
                  continue e;
              }
              ae && ae.push(xe), q.push(ve);
            }
          }
        return q;
      }
      function gC(o, l, f, m) {
        return gn(o, function(w, T, I) {
          l(m, f(w), T, I);
        }), m;
      }
      function Eo(o, l, f) {
        l = si(l, o), o = _m(o, l);
        var m = o == null ? o : o[vn(Wr(l))];
        return m == null ? t : Cr(m, o, f);
      }
      function Fg(o) {
        return mt(o) && Qt(o) == Ee;
      }
      function mC(o) {
        return mt(o) && Qt(o) == Se;
      }
      function vC(o) {
        return mt(o) && Qt(o) == Wt;
      }
      function ko(o, l, f, m, w) {
        return o === l ? !0 : o == null || l == null || !mt(o) && !mt(l) ? o !== o && l !== l : yC(o, l, f, m, ko, w);
      }
      function yC(o, l, f, m, w, T) {
        var I = Oe(o), M = Oe(l), N = I ? Ie : Gt(o), q = M ? Ie : Gt(l);
        N = N == Ee ? nt : N, q = q == Ee ? nt : q;
        var K = N == nt, J = q == nt, ae = N == q;
        if (ae && ai(o)) {
          if (!ai(l))
            return !1;
          I = !0, K = !1;
        }
        if (ae && !K)
          return T || (T = new Qr()), I || Ms(o) ? gm(o, l, f, m, w, T) : $C(o, l, N, f, m, w, T);
        if (!(f & y)) {
          var ve = K && Je.call(o, "__wrapped__"), xe = J && Je.call(l, "__wrapped__");
          if (ve || xe) {
            var De = ve ? o.value() : o, _e = xe ? l.value() : l;
            return T || (T = new Qr()), w(De, _e, f, m, T);
          }
        }
        return ae ? (T || (T = new Qr()), YC(o, l, f, m, w, T)) : !1;
      }
      function bC(o) {
        return mt(o) && Gt(o) == st;
      }
      function qu(o, l, f, m) {
        var w = f.length, T = w, I = !m;
        if (o == null)
          return !T;
        for (o = tt(o); w--; ) {
          var M = f[w];
          if (I && M[2] ? M[1] !== o[M[0]] : !(M[0] in o))
            return !1;
        }
        for (; ++w < T; ) {
          M = f[w];
          var N = M[0], q = o[N], K = M[1];
          if (I && M[2]) {
            if (q === t && !(N in o))
              return !1;
          } else {
            var J = new Qr();
            if (m)
              var ae = m(q, K, N, o, l, J);
            if (!(ae === t ? ko(K, q, y | x, m, J) : ae))
              return !1;
          }
        }
        return !0;
      }
      function Lg(o) {
        if (!ft(o) || tT(o))
          return !1;
        var l = Fn(o) ? bS : l_;
        return l.test(ji(o));
      }
      function wC(o) {
        return mt(o) && Qt(o) == xr;
      }
      function xC(o) {
        return mt(o) && Gt(o) == A;
      }
      function _C(o) {
        return mt(o) && vc(o.length) && !!at[Qt(o)];
      }
      function Ng(o) {
        return typeof o == "function" ? o : o == null ? mr : typeof o == "object" ? Oe(o) ? zg(o[0], o[1]) : Vg(o) : ov(o);
      }
      function Ku(o) {
        if (!Ao(o))
          return TS(o);
        var l = [];
        for (var f in tt(o))
          Je.call(o, f) && f != "constructor" && l.push(f);
        return l;
      }
      function SC(o) {
        if (!ft(o))
          return sT(o);
        var l = Ao(o), f = [];
        for (var m in o)
          m == "constructor" && (l || !Je.call(o, m)) || f.push(m);
        return f;
      }
      function Zu(o, l) {
        return o < l;
      }
      function Bg(o, l) {
        var f = -1, m = pr(o) ? U(o.length) : [];
        return ni(o, function(w, T, I) {
          m[++f] = l(w, T, I);
        }), m;
      }
      function Vg(o) {
        var l = dh(o);
        return l.length == 1 && l[0][2] ? wm(l[0][0], l[0][1]) : function(f) {
          return f === o || qu(f, o, l);
        };
      }
      function zg(o, l) {
        return ph(o) && bm(l) ? wm(vn(o), l) : function(f) {
          var m = Ch(f, o);
          return m === t && m === l ? Th(f, o) : ko(l, m, y | x);
        };
      }
      function tc(o, l, f, m, w) {
        o !== l && $u(l, function(T, I) {
          if (w || (w = new Qr()), ft(T))
            CC(o, l, I, f, tc, m, w);
          else {
            var M = m ? m(mh(o, I), T, I + "", o, l, w) : t;
            M === t && (M = T), Hu(o, I, M);
          }
        }, gr);
      }
      function CC(o, l, f, m, w, T, I) {
        var M = mh(o, f), N = mh(l, f), q = I.get(N);
        if (q) {
          Hu(o, f, q);
          return;
        }
        var K = T ? T(M, N, f + "", o, l, I) : t, J = K === t;
        if (J) {
          var ae = Oe(N), ve = !ae && ai(N), xe = !ae && !ve && Ms(N);
          K = N, ae || ve || xe ? Oe(M) ? K = M : _t(M) ? K = fr(M) : ve ? (J = !1, K = Qg(N, !0)) : xe ? (J = !1, K = em(N, !0)) : K = [] : Po(N) || Fi(N) ? (K = M, Fi(M) ? K = Km(M) : (!ft(M) || Fn(M)) && (K = ym(N))) : J = !1;
        }
        J && (I.set(N, K), w(K, N, m, T, I), I.delete(N)), Hu(o, f, K);
      }
      function Wg(o, l) {
        var f = o.length;
        if (f)
          return l += l < 0 ? f : 0, jn(l, f) ? o[l] : t;
      }
      function Hg(o, l, f) {
        l.length ? l = lt(l, function(T) {
          return Oe(T) ? function(I) {
            return Di(I, T.length === 1 ? T[0] : T);
          } : T;
        }) : l = [mr];
        var m = -1;
        l = lt(l, Tr(we()));
        var w = Bg(o, function(T, I, M) {
          var N = lt(l, function(q) {
            return q(T);
          });
          return { criteria: N, index: ++m, value: T };
        });
        return Z_(w, function(T, I) {
          return LC(T, I, f);
        });
      }
      function TC(o, l) {
        return Ug(o, l, function(f, m) {
          return Th(o, m);
        });
      }
      function Ug(o, l, f) {
        for (var m = -1, w = l.length, T = {}; ++m < w; ) {
          var I = l[m], M = Di(o, I);
          f(M, I) && Oo(T, si(I, o), M);
        }
        return T;
      }
      function EC(o) {
        return function(l) {
          return Di(l, o);
        };
      }
      function Ju(o, l, f, m) {
        var w = m ? K_ : ws, T = -1, I = l.length, M = o;
        for (o === l && (l = fr(l)), f && (M = lt(o, Tr(f))); ++T < I; )
          for (var N = 0, q = l[T], K = f ? f(q) : q; (N = w(M, K, N, m)) > -1; )
            M !== o && $a.call(M, N, 1), $a.call(o, N, 1);
        return o;
      }
      function $g(o, l) {
        for (var f = o ? l.length : 0, m = f - 1; f--; ) {
          var w = l[f];
          if (f == m || w !== T) {
            var T = w;
            jn(w) ? $a.call(o, w, 1) : rh(o, w);
          }
        }
        return o;
      }
      function Qu(o, l) {
        return o + Ga(Tg() * (l - o + 1));
      }
      function kC(o, l, f, m) {
        for (var w = -1, T = Rt(Xa((l - o) / (f || 1)), 0), I = U(T); T--; )
          I[m ? T : ++w] = o, o += f;
        return I;
      }
      function eh(o, l) {
        var f = "";
        if (!o || l < 1 || l > oe)
          return f;
        do
          l % 2 && (f += o), l = Ga(l / 2), l && (o += o);
        while (l);
        return f;
      }
      function Re(o, l) {
        return vh(xm(o, l, mr), o + "");
      }
      function OC(o) {
        return Og(Ps(o));
      }
      function IC(o, l) {
        var f = Ps(o);
        return hc(f, Pi(l, 0, f.length));
      }
      function Oo(o, l, f, m) {
        if (!ft(o))
          return o;
        l = si(l, o);
        for (var w = -1, T = l.length, I = T - 1, M = o; M != null && ++w < T; ) {
          var N = vn(l[w]), q = f;
          if (N === "__proto__" || N === "constructor" || N === "prototype")
            return o;
          if (w != I) {
            var K = M[N];
            q = m ? m(K, N, M) : t, q === t && (q = ft(K) ? K : jn(l[w + 1]) ? [] : {});
          }
          Co(M, N, q), M = M[N];
        }
        return o;
      }
      var Yg = qa ? function(o, l) {
        return qa.set(o, l), o;
      } : mr, AC = Ya ? function(o, l) {
        return Ya(o, "toString", {
          configurable: !0,
          enumerable: !1,
          value: kh(l),
          writable: !0
        });
      } : mr;
      function MC(o) {
        return hc(Ps(o));
      }
      function zr(o, l, f) {
        var m = -1, w = o.length;
        l < 0 && (l = -l > w ? 0 : w + l), f = f > w ? w : f, f < 0 && (f += w), w = l > f ? 0 : f - l >>> 0, l >>>= 0;
        for (var T = U(w); ++m < w; )
          T[m] = o[m + l];
        return T;
      }
      function PC(o, l) {
        var f;
        return ni(o, function(m, w, T) {
          return f = l(m, w, T), !f;
        }), !!f;
      }
      function rc(o, l, f) {
        var m = 0, w = o == null ? m : o.length;
        if (typeof l == "number" && l === l && w <= Ze) {
          for (; m < w; ) {
            var T = m + w >>> 1, I = o[T];
            I !== null && !kr(I) && (f ? I <= l : I < l) ? m = T + 1 : w = T;
          }
          return w;
        }
        return th(o, l, mr, f);
      }
      function th(o, l, f, m) {
        var w = 0, T = o == null ? 0 : o.length;
        if (T === 0)
          return 0;
        l = f(l);
        for (var I = l !== l, M = l === null, N = kr(l), q = l === t; w < T; ) {
          var K = Ga((w + T) / 2), J = f(o[K]), ae = J !== t, ve = J === null, xe = J === J, De = kr(J);
          if (I)
            var _e = m || xe;
          else q ? _e = xe && (m || ae) : M ? _e = xe && ae && (m || !ve) : N ? _e = xe && ae && !ve && (m || !De) : ve || De ? _e = !1 : _e = m ? J <= l : J < l;
          _e ? w = K + 1 : T = K;
        }
        return Xt(T, Be);
      }
      function Xg(o, l) {
        for (var f = -1, m = o.length, w = 0, T = []; ++f < m; ) {
          var I = o[f], M = l ? l(I) : I;
          if (!f || !en(M, N)) {
            var N = M;
            T[w++] = I === 0 ? 0 : I;
          }
        }
        return T;
      }
      function Gg(o) {
        return typeof o == "number" ? o : kr(o) ? pe : +o;
      }
      function Er(o) {
        if (typeof o == "string")
          return o;
        if (Oe(o))
          return lt(o, Er) + "";
        if (kr(o))
          return Eg ? Eg.call(o) : "";
        var l = o + "";
        return l == "0" && 1 / o == -1 / 0 ? "-0" : l;
      }
      function ii(o, l, f) {
        var m = -1, w = ja, T = o.length, I = !0, M = [], N = M;
        if (f)
          I = !1, w = Au;
        else if (T >= i) {
          var q = l ? null : HC(o);
          if (q)
            return La(q);
          I = !1, w = yo, N = new Mi();
        } else
          N = l ? [] : M;
        e:
          for (; ++m < T; ) {
            var K = o[m], J = l ? l(K) : K;
            if (K = f || K !== 0 ? K : 0, I && J === J) {
              for (var ae = N.length; ae--; )
                if (N[ae] === J)
                  continue e;
              l && N.push(J), M.push(K);
            } else w(N, J, f) || (N !== M && N.push(J), M.push(K));
          }
        return M;
      }
      function rh(o, l) {
        return l = si(l, o), o = _m(o, l), o == null || delete o[vn(Wr(l))];
      }
      function qg(o, l, f, m) {
        return Oo(o, l, f(Di(o, l)), m);
      }
      function nc(o, l, f, m) {
        for (var w = o.length, T = m ? w : -1; (m ? T-- : ++T < w) && l(o[T], T, o); )
          ;
        return f ? zr(o, m ? 0 : T, m ? T + 1 : w) : zr(o, m ? T + 1 : 0, m ? w : T);
      }
      function Kg(o, l) {
        var f = o;
        return f instanceof Le && (f = f.value()), Mu(l, function(m, w) {
          return w.func.apply(w.thisArg, ei([m], w.args));
        }, f);
      }
      function nh(o, l, f) {
        var m = o.length;
        if (m < 2)
          return m ? ii(o[0]) : [];
        for (var w = -1, T = U(m); ++w < m; )
          for (var I = o[w], M = -1; ++M < m; )
            M != w && (T[w] = To(T[w] || I, o[M], l, f));
        return ii(Ut(T, 1), l, f);
      }
      function Zg(o, l, f) {
        for (var m = -1, w = o.length, T = l.length, I = {}; ++m < w; ) {
          var M = m < T ? l[m] : t;
          f(I, o[m], M);
        }
        return I;
      }
      function ih(o) {
        return _t(o) ? o : [];
      }
      function sh(o) {
        return typeof o == "function" ? o : mr;
      }
      function si(o, l) {
        return Oe(o) ? o : ph(o, l) ? [o] : Em(qe(o));
      }
      var DC = Re;
      function oi(o, l, f) {
        var m = o.length;
        return f = f === t ? m : f, !l && f >= m ? o : zr(o, l, f);
      }
      var Jg = wS || function(o) {
        return Ht.clearTimeout(o);
      };
      function Qg(o, l) {
        if (l)
          return o.slice();
        var f = o.length, m = wg ? wg(f) : new o.constructor(f);
        return o.copy(m), m;
      }
      function oh(o) {
        var l = new o.constructor(o.byteLength);
        return new Ha(l).set(new Ha(o)), l;
      }
      function RC(o, l) {
        var f = l ? oh(o.buffer) : o.buffer;
        return new o.constructor(f, o.byteOffset, o.byteLength);
      }
      function jC(o) {
        var l = new o.constructor(o.source, Fp.exec(o));
        return l.lastIndex = o.lastIndex, l;
      }
      function FC(o) {
        return So ? tt(So.call(o)) : {};
      }
      function em(o, l) {
        var f = l ? oh(o.buffer) : o.buffer;
        return new o.constructor(f, o.byteOffset, o.length);
      }
      function tm(o, l) {
        if (o !== l) {
          var f = o !== t, m = o === null, w = o === o, T = kr(o), I = l !== t, M = l === null, N = l === l, q = kr(l);
          if (!M && !q && !T && o > l || T && I && N && !M && !q || m && I && N || !f && N || !w)
            return 1;
          if (!m && !T && !q && o < l || q && f && w && !m && !T || M && f && w || !I && w || !N)
            return -1;
        }
        return 0;
      }
      function LC(o, l, f) {
        for (var m = -1, w = o.criteria, T = l.criteria, I = w.length, M = f.length; ++m < I; ) {
          var N = tm(w[m], T[m]);
          if (N) {
            if (m >= M)
              return N;
            var q = f[m];
            return N * (q == "desc" ? -1 : 1);
          }
        }
        return o.index - l.index;
      }
      function rm(o, l, f, m) {
        for (var w = -1, T = o.length, I = f.length, M = -1, N = l.length, q = Rt(T - I, 0), K = U(N + q), J = !m; ++M < N; )
          K[M] = l[M];
        for (; ++w < I; )
          (J || w < T) && (K[f[w]] = o[w]);
        for (; q--; )
          K[M++] = o[w++];
        return K;
      }
      function nm(o, l, f, m) {
        for (var w = -1, T = o.length, I = -1, M = f.length, N = -1, q = l.length, K = Rt(T - M, 0), J = U(K + q), ae = !m; ++w < K; )
          J[w] = o[w];
        for (var ve = w; ++N < q; )
          J[ve + N] = l[N];
        for (; ++I < M; )
          (ae || w < T) && (J[ve + f[I]] = o[w++]);
        return J;
      }
      function fr(o, l) {
        var f = -1, m = o.length;
        for (l || (l = U(m)); ++f < m; )
          l[f] = o[f];
        return l;
      }
      function mn(o, l, f, m) {
        var w = !f;
        f || (f = {});
        for (var T = -1, I = l.length; ++T < I; ) {
          var M = l[T], N = m ? m(f[M], o[M], M, f, o) : t;
          N === t && (N = o[M]), w ? Pn(f, M, N) : Co(f, M, N);
        }
        return f;
      }
      function NC(o, l) {
        return mn(o, fh(o), l);
      }
      function BC(o, l) {
        return mn(o, mm(o), l);
      }
      function ic(o, l) {
        return function(f, m) {
          var w = Oe(f) ? U_ : aC, T = l ? l() : {};
          return w(f, o, we(m, 2), T);
        };
      }
      function Os(o) {
        return Re(function(l, f) {
          var m = -1, w = f.length, T = w > 1 ? f[w - 1] : t, I = w > 2 ? f[2] : t;
          for (T = o.length > 3 && typeof T == "function" ? (w--, T) : t, I && er(f[0], f[1], I) && (T = w < 3 ? t : T, w = 1), l = tt(l); ++m < w; ) {
            var M = f[m];
            M && o(l, M, m, T);
          }
          return l;
        });
      }
      function im(o, l) {
        return function(f, m) {
          if (f == null)
            return f;
          if (!pr(f))
            return o(f, m);
          for (var w = f.length, T = l ? w : -1, I = tt(f); (l ? T-- : ++T < w) && m(I[T], T, I) !== !1; )
            ;
          return f;
        };
      }
      function sm(o) {
        return function(l, f, m) {
          for (var w = -1, T = tt(l), I = m(l), M = I.length; M--; ) {
            var N = I[o ? M : ++w];
            if (f(T[N], N, T) === !1)
              break;
          }
          return l;
        };
      }
      function VC(o, l, f) {
        var m = l & _, w = Io(o);
        function T() {
          var I = this && this !== Ht && this instanceof T ? w : o;
          return I.apply(m ? f : this, arguments);
        }
        return T;
      }
      function om(o) {
        return function(l) {
          l = qe(l);
          var f = xs(l) ? Jr(l) : t, m = f ? f[0] : l.charAt(0), w = f ? oi(f, 1).join("") : l.slice(1);
          return m[o]() + w;
        };
      }
      function Is(o) {
        return function(l) {
          return Mu(iv(nv(l).replace(A_, "")), o, "");
        };
      }
      function Io(o) {
        return function() {
          var l = arguments;
          switch (l.length) {
            case 0:
              return new o();
            case 1:
              return new o(l[0]);
            case 2:
              return new o(l[0], l[1]);
            case 3:
              return new o(l[0], l[1], l[2]);
            case 4:
              return new o(l[0], l[1], l[2], l[3]);
            case 5:
              return new o(l[0], l[1], l[2], l[3], l[4]);
            case 6:
              return new o(l[0], l[1], l[2], l[3], l[4], l[5]);
            case 7:
              return new o(l[0], l[1], l[2], l[3], l[4], l[5], l[6]);
          }
          var f = ks(o.prototype), m = o.apply(f, l);
          return ft(m) ? m : f;
        };
      }
      function zC(o, l, f) {
        var m = Io(o);
        function w() {
          for (var T = arguments.length, I = U(T), M = T, N = As(w); M--; )
            I[M] = arguments[M];
          var q = T < 3 && I[0] !== N && I[T - 1] !== N ? [] : ti(I, N);
          if (T -= q.length, T < f)
            return hm(
              o,
              l,
              sc,
              w.placeholder,
              t,
              I,
              q,
              t,
              t,
              f - T
            );
          var K = this && this !== Ht && this instanceof w ? m : o;
          return Cr(K, this, I);
        }
        return w;
      }
      function am(o) {
        return function(l, f, m) {
          var w = tt(l);
          if (!pr(l)) {
            var T = we(f, 3);
            l = zt(l), f = function(M) {
              return T(w[M], M, w);
            };
          }
          var I = o(l, f, m);
          return I > -1 ? w[T ? l[I] : I] : t;
        };
      }
      function cm(o) {
        return Rn(function(l) {
          var f = l.length, m = f, w = Br.prototype.thru;
          for (o && l.reverse(); m--; ) {
            var T = l[m];
            if (typeof T != "function")
              throw new Nr(a);
            if (w && !I && lc(T) == "wrapper")
              var I = new Br([], !0);
          }
          for (m = I ? m : f; ++m < f; ) {
            T = l[m];
            var M = lc(T), N = M == "wrapper" ? hh(T) : t;
            N && gh(N[0]) && N[1] == (V | k | P | F) && !N[4].length && N[9] == 1 ? I = I[lc(N[0])].apply(I, N[3]) : I = T.length == 1 && gh(T) ? I[M]() : I.thru(T);
          }
          return function() {
            var q = arguments, K = q[0];
            if (I && q.length == 1 && Oe(K))
              return I.plant(K).value();
            for (var J = 0, ae = f ? l[J].apply(this, q) : K; ++J < f; )
              ae = l[J].call(this, ae);
            return ae;
          };
        });
      }
      function sc(o, l, f, m, w, T, I, M, N, q) {
        var K = l & V, J = l & _, ae = l & C, ve = l & (k | O), xe = l & $, De = ae ? t : Io(o);
        function _e() {
          for (var Fe = arguments.length, Ve = U(Fe), Or = Fe; Or--; )
            Ve[Or] = arguments[Or];
          if (ve)
            var tr = As(_e), Ir = Q_(Ve, tr);
          if (m && (Ve = rm(Ve, m, w, ve)), T && (Ve = nm(Ve, T, I, ve)), Fe -= Ir, ve && Fe < q) {
            var St = ti(Ve, tr);
            return hm(
              o,
              l,
              sc,
              _e.placeholder,
              f,
              Ve,
              St,
              M,
              N,
              q - Fe
            );
          }
          var tn = J ? f : this, Nn = ae ? tn[o] : o;
          return Fe = Ve.length, M ? Ve = aT(Ve, M) : xe && Fe > 1 && Ve.reverse(), K && N < Fe && (Ve.length = N), this && this !== Ht && this instanceof _e && (Nn = De || Io(Nn)), Nn.apply(tn, Ve);
        }
        return _e;
      }
      function lm(o, l) {
        return function(f, m) {
          return gC(f, o, l(m), {});
        };
      }
      function oc(o, l) {
        return function(f, m) {
          var w;
          if (f === t && m === t)
            return l;
          if (f !== t && (w = f), m !== t) {
            if (w === t)
              return m;
            typeof f == "string" || typeof m == "string" ? (f = Er(f), m = Er(m)) : (f = Gg(f), m = Gg(m)), w = o(f, m);
          }
          return w;
        };
      }
      function ah(o) {
        return Rn(function(l) {
          return l = lt(l, Tr(we())), Re(function(f) {
            var m = this;
            return o(l, function(w) {
              return Cr(w, m, f);
            });
          });
        });
      }
      function ac(o, l) {
        l = l === t ? " " : Er(l);
        var f = l.length;
        if (f < 2)
          return f ? eh(l, o) : l;
        var m = eh(l, Xa(o / _s(l)));
        return xs(l) ? oi(Jr(m), 0, o).join("") : m.slice(0, o);
      }
      function WC(o, l, f, m) {
        var w = l & _, T = Io(o);
        function I() {
          for (var M = -1, N = arguments.length, q = -1, K = m.length, J = U(K + N), ae = this && this !== Ht && this instanceof I ? T : o; ++q < K; )
            J[q] = m[q];
          for (; N--; )
            J[q++] = arguments[++M];
          return Cr(ae, w ? f : this, J);
        }
        return I;
      }
      function um(o) {
        return function(l, f, m) {
          return m && typeof m != "number" && er(l, f, m) && (f = m = t), l = Ln(l), f === t ? (f = l, l = 0) : f = Ln(f), m = m === t ? l < f ? 1 : -1 : Ln(m), kC(l, f, m, o);
        };
      }
      function cc(o) {
        return function(l, f) {
          return typeof l == "string" && typeof f == "string" || (l = Hr(l), f = Hr(f)), o(l, f);
        };
      }
      function hm(o, l, f, m, w, T, I, M, N, q) {
        var K = l & k, J = K ? I : t, ae = K ? t : I, ve = K ? T : t, xe = K ? t : T;
        l |= K ? P : j, l &= ~(K ? j : P), l & E || (l &= -4);
        var De = [
          o,
          l,
          w,
          ve,
          J,
          xe,
          ae,
          M,
          N,
          q
        ], _e = f.apply(t, De);
        return gh(o) && Sm(_e, De), _e.placeholder = m, Cm(_e, o, l);
      }
      function ch(o) {
        var l = Dt[o];
        return function(f, m) {
          if (f = Hr(f), m = m == null ? 0 : Xt(Ae(m), 292), m && Cg(f)) {
            var w = (qe(f) + "e").split("e"), T = l(w[0] + "e" + (+w[1] + m));
            return w = (qe(T) + "e").split("e"), +(w[0] + "e" + (+w[1] - m));
          }
          return l(f);
        };
      }
      var HC = Ts && 1 / La(new Ts([, -0]))[1] == de ? function(o) {
        return new Ts(o);
      } : Ah;
      function dm(o) {
        return function(l) {
          var f = Gt(l);
          return f == st ? Nu(l) : f == A ? oS(l) : J_(l, o(l));
        };
      }
      function Dn(o, l, f, m, w, T, I, M) {
        var N = l & C;
        if (!N && typeof o != "function")
          throw new Nr(a);
        var q = m ? m.length : 0;
        if (q || (l &= -97, m = w = t), I = I === t ? I : Rt(Ae(I), 0), M = M === t ? M : Ae(M), q -= w ? w.length : 0, l & j) {
          var K = m, J = w;
          m = w = t;
        }
        var ae = N ? t : hh(o), ve = [
          o,
          l,
          f,
          m,
          w,
          K,
          J,
          T,
          I,
          M
        ];
        if (ae && iT(ve, ae), o = ve[0], l = ve[1], f = ve[2], m = ve[3], w = ve[4], M = ve[9] = ve[9] === t ? N ? 0 : o.length : Rt(ve[9] - q, 0), !M && l & (k | O) && (l &= -25), !l || l == _)
          var xe = VC(o, l, f);
        else l == k || l == O ? xe = zC(o, l, M) : (l == P || l == (_ | P)) && !w.length ? xe = WC(o, l, f, m) : xe = sc.apply(t, ve);
        var De = ae ? Yg : Sm;
        return Cm(De(xe, ve), o, l);
      }
      function fm(o, l, f, m) {
        return o === t || en(o, Cs[f]) && !Je.call(m, f) ? l : o;
      }
      function pm(o, l, f, m, w, T) {
        return ft(o) && ft(l) && (T.set(l, o), tc(o, l, t, pm, T), T.delete(l)), o;
      }
      function UC(o) {
        return Po(o) ? t : o;
      }
      function gm(o, l, f, m, w, T) {
        var I = f & y, M = o.length, N = l.length;
        if (M != N && !(I && N > M))
          return !1;
        var q = T.get(o), K = T.get(l);
        if (q && K)
          return q == l && K == o;
        var J = -1, ae = !0, ve = f & x ? new Mi() : t;
        for (T.set(o, l), T.set(l, o); ++J < M; ) {
          var xe = o[J], De = l[J];
          if (m)
            var _e = I ? m(De, xe, J, l, o, T) : m(xe, De, J, o, l, T);
          if (_e !== t) {
            if (_e)
              continue;
            ae = !1;
            break;
          }
          if (ve) {
            if (!Pu(l, function(Fe, Ve) {
              if (!yo(ve, Ve) && (xe === Fe || w(xe, Fe, f, m, T)))
                return ve.push(Ve);
            })) {
              ae = !1;
              break;
            }
          } else if (!(xe === De || w(xe, De, f, m, T))) {
            ae = !1;
            break;
          }
        }
        return T.delete(o), T.delete(l), ae;
      }
      function $C(o, l, f, m, w, T, I) {
        switch (f) {
          case ot:
            if (o.byteLength != l.byteLength || o.byteOffset != l.byteOffset)
              return !1;
            o = o.buffer, l = l.buffer;
          case Se:
            return !(o.byteLength != l.byteLength || !T(new Ha(o), new Ha(l)));
          case lr:
          case Wt:
          case Vt:
            return en(+o, +l);
          case ur:
            return o.name == l.name && o.message == l.message;
          case xr:
          case le:
            return o == l + "";
          case st:
            var M = Nu;
          case A:
            var N = m & y;
            if (M || (M = La), o.size != l.size && !N)
              return !1;
            var q = I.get(o);
            if (q)
              return q == l;
            m |= x, I.set(o, l);
            var K = gm(M(o), M(l), m, w, T, I);
            return I.delete(o), K;
          case ce:
            if (So)
              return So.call(o) == So.call(l);
        }
        return !1;
      }
      function YC(o, l, f, m, w, T) {
        var I = f & y, M = lh(o), N = M.length, q = lh(l), K = q.length;
        if (N != K && !I)
          return !1;
        for (var J = N; J--; ) {
          var ae = M[J];
          if (!(I ? ae in l : Je.call(l, ae)))
            return !1;
        }
        var ve = T.get(o), xe = T.get(l);
        if (ve && xe)
          return ve == l && xe == o;
        var De = !0;
        T.set(o, l), T.set(l, o);
        for (var _e = I; ++J < N; ) {
          ae = M[J];
          var Fe = o[ae], Ve = l[ae];
          if (m)
            var Or = I ? m(Ve, Fe, ae, l, o, T) : m(Fe, Ve, ae, o, l, T);
          if (!(Or === t ? Fe === Ve || w(Fe, Ve, f, m, T) : Or)) {
            De = !1;
            break;
          }
          _e || (_e = ae == "constructor");
        }
        if (De && !_e) {
          var tr = o.constructor, Ir = l.constructor;
          tr != Ir && "constructor" in o && "constructor" in l && !(typeof tr == "function" && tr instanceof tr && typeof Ir == "function" && Ir instanceof Ir) && (De = !1);
        }
        return T.delete(o), T.delete(l), De;
      }
      function Rn(o) {
        return vh(xm(o, t, Am), o + "");
      }
      function lh(o) {
        return jg(o, zt, fh);
      }
      function uh(o) {
        return jg(o, gr, mm);
      }
      var hh = qa ? function(o) {
        return qa.get(o);
      } : Ah;
      function lc(o) {
        for (var l = o.name + "", f = Es[l], m = Je.call(Es, l) ? f.length : 0; m--; ) {
          var w = f[m], T = w.func;
          if (T == null || T == o)
            return w.name;
        }
        return l;
      }
      function As(o) {
        var l = Je.call(S, "placeholder") ? S : o;
        return l.placeholder;
      }
      function we() {
        var o = S.iteratee || Oh;
        return o = o === Oh ? Ng : o, arguments.length ? o(arguments[0], arguments[1]) : o;
      }
      function uc(o, l) {
        var f = o.__data__;
        return eT(l) ? f[typeof l == "string" ? "string" : "hash"] : f.map;
      }
      function dh(o) {
        for (var l = zt(o), f = l.length; f--; ) {
          var m = l[f], w = o[m];
          l[f] = [m, w, bm(w)];
        }
        return l;
      }
      function Ri(o, l) {
        var f = nS(o, l);
        return Lg(f) ? f : t;
      }
      function XC(o) {
        var l = Je.call(o, Ii), f = o[Ii];
        try {
          o[Ii] = t;
          var m = !0;
        } catch {
        }
        var w = za.call(o);
        return m && (l ? o[Ii] = f : delete o[Ii]), w;
      }
      var fh = Vu ? function(o) {
        return o == null ? [] : (o = tt(o), Qn(Vu(o), function(l) {
          return _g.call(o, l);
        }));
      } : Mh, mm = Vu ? function(o) {
        for (var l = []; o; )
          ei(l, fh(o)), o = Ua(o);
        return l;
      } : Mh, Gt = Qt;
      (zu && Gt(new zu(new ArrayBuffer(1))) != ot || wo && Gt(new wo()) != st || Wu && Gt(Wu.resolve()) != Pt || Ts && Gt(new Ts()) != A || xo && Gt(new xo()) != et) && (Gt = function(o) {
        var l = Qt(o), f = l == nt ? o.constructor : t, m = f ? ji(f) : "";
        if (m)
          switch (m) {
            case IS:
              return ot;
            case AS:
              return st;
            case MS:
              return Pt;
            case PS:
              return A;
            case DS:
              return et;
          }
        return l;
      });
      function GC(o, l, f) {
        for (var m = -1, w = f.length; ++m < w; ) {
          var T = f[m], I = T.size;
          switch (T.type) {
            case "drop":
              o += I;
              break;
            case "dropRight":
              l -= I;
              break;
            case "take":
              l = Xt(l, o + I);
              break;
            case "takeRight":
              o = Rt(o, l - I);
              break;
          }
        }
        return { start: o, end: l };
      }
      function qC(o) {
        var l = o.match(t_);
        return l ? l[1].split(r_) : [];
      }
      function vm(o, l, f) {
        l = si(l, o);
        for (var m = -1, w = l.length, T = !1; ++m < w; ) {
          var I = vn(l[m]);
          if (!(T = o != null && f(o, I)))
            break;
          o = o[I];
        }
        return T || ++m != w ? T : (w = o == null ? 0 : o.length, !!w && vc(w) && jn(I, w) && (Oe(o) || Fi(o)));
      }
      function KC(o) {
        var l = o.length, f = new o.constructor(l);
        return l && typeof o[0] == "string" && Je.call(o, "index") && (f.index = o.index, f.input = o.input), f;
      }
      function ym(o) {
        return typeof o.constructor == "function" && !Ao(o) ? ks(Ua(o)) : {};
      }
      function ZC(o, l, f) {
        var m = o.constructor;
        switch (l) {
          case Se:
            return oh(o);
          case lr:
          case Wt:
            return new m(+o);
          case ot:
            return RC(o, f);
          case hr:
          case xt:
          case _r:
          case Zr:
          case dr:
          case fn:
          case Jt:
          case mo:
          case vo:
            return em(o, f);
          case st:
            return new m();
          case Vt:
          case le:
            return new m(o);
          case xr:
            return jC(o);
          case A:
            return new m();
          case ce:
            return FC(o);
        }
      }
      function JC(o, l) {
        var f = l.length;
        if (!f)
          return o;
        var m = f - 1;
        return l[m] = (f > 1 ? "& " : "") + l[m], l = l.join(f > 2 ? ", " : " "), o.replace(e_, `{
/* [wrapped with ` + l + `] */
`);
      }
      function QC(o) {
        return Oe(o) || Fi(o) || !!(Sg && o && o[Sg]);
      }
      function jn(o, l) {
        var f = typeof o;
        return l = l ?? oe, !!l && (f == "number" || f != "symbol" && h_.test(o)) && o > -1 && o % 1 == 0 && o < l;
      }
      function er(o, l, f) {
        if (!ft(f))
          return !1;
        var m = typeof l;
        return (m == "number" ? pr(f) && jn(l, f.length) : m == "string" && l in f) ? en(f[l], o) : !1;
      }
      function ph(o, l) {
        if (Oe(o))
          return !1;
        var f = typeof o;
        return f == "number" || f == "symbol" || f == "boolean" || o == null || kr(o) ? !0 : Ma.test(o) || !_u.test(o) || l != null && o in tt(l);
      }
      function eT(o) {
        var l = typeof o;
        return l == "string" || l == "number" || l == "symbol" || l == "boolean" ? o !== "__proto__" : o === null;
      }
      function gh(o) {
        var l = lc(o), f = S[l];
        if (typeof f != "function" || !(l in Le.prototype))
          return !1;
        if (o === f)
          return !0;
        var m = hh(f);
        return !!m && o === m[0];
      }
      function tT(o) {
        return !!bg && bg in o;
      }
      var rT = Ba ? Fn : Ph;
      function Ao(o) {
        var l = o && o.constructor, f = typeof l == "function" && l.prototype || Cs;
        return o === f;
      }
      function bm(o) {
        return o === o && !ft(o);
      }
      function wm(o, l) {
        return function(f) {
          return f == null ? !1 : f[o] === l && (l !== t || o in tt(f));
        };
      }
      function nT(o) {
        var l = gc(o, function(m) {
          return f.size === h && f.clear(), m;
        }), f = l.cache;
        return l;
      }
      function iT(o, l) {
        var f = o[1], m = l[1], w = f | m, T = w < (_ | C | V), I = m == V && f == k || m == V && f == F && o[7].length <= l[8] || m == (V | F) && l[7].length <= l[8] && f == k;
        if (!(T || I))
          return o;
        m & _ && (o[2] = l[2], w |= f & _ ? 0 : E);
        var M = l[3];
        if (M) {
          var N = o[3];
          o[3] = N ? rm(N, M, l[4]) : M, o[4] = N ? ti(o[3], d) : l[4];
        }
        return M = l[5], M && (N = o[5], o[5] = N ? nm(N, M, l[6]) : M, o[6] = N ? ti(o[5], d) : l[6]), M = l[7], M && (o[7] = M), m & V && (o[8] = o[8] == null ? l[8] : Xt(o[8], l[8])), o[9] == null && (o[9] = l[9]), o[0] = l[0], o[1] = w, o;
      }
      function sT(o) {
        var l = [];
        if (o != null)
          for (var f in tt(o))
            l.push(f);
        return l;
      }
      function oT(o) {
        return za.call(o);
      }
      function xm(o, l, f) {
        return l = Rt(l === t ? o.length - 1 : l, 0), function() {
          for (var m = arguments, w = -1, T = Rt(m.length - l, 0), I = U(T); ++w < T; )
            I[w] = m[l + w];
          w = -1;
          for (var M = U(l + 1); ++w < l; )
            M[w] = m[w];
          return M[l] = f(I), Cr(o, this, M);
        };
      }
      function _m(o, l) {
        return l.length < 2 ? o : Di(o, zr(l, 0, -1));
      }
      function aT(o, l) {
        for (var f = o.length, m = Xt(l.length, f), w = fr(o); m--; ) {
          var T = l[m];
          o[m] = jn(T, f) ? w[T] : t;
        }
        return o;
      }
      function mh(o, l) {
        if (!(l === "constructor" && typeof o[l] == "function") && l != "__proto__")
          return o[l];
      }
      var Sm = Tm(Yg), Mo = _S || function(o, l) {
        return Ht.setTimeout(o, l);
      }, vh = Tm(AC);
      function Cm(o, l, f) {
        var m = l + "";
        return vh(o, JC(m, cT(qC(m), f)));
      }
      function Tm(o) {
        var l = 0, f = 0;
        return function() {
          var m = ES(), w = Y - (m - f);
          if (f = m, w > 0) {
            if (++l >= H)
              return arguments[0];
          } else
            l = 0;
          return o.apply(t, arguments);
        };
      }
      function hc(o, l) {
        var f = -1, m = o.length, w = m - 1;
        for (l = l === t ? m : l; ++f < l; ) {
          var T = Qu(f, w), I = o[T];
          o[T] = o[f], o[f] = I;
        }
        return o.length = l, o;
      }
      var Em = nT(function(o) {
        var l = [];
        return o.charCodeAt(0) === 46 && l.push(""), o.replace($e, function(f, m, w, T) {
          l.push(w ? T.replace(s_, "$1") : m || f);
        }), l;
      });
      function vn(o) {
        if (typeof o == "string" || kr(o))
          return o;
        var l = o + "";
        return l == "0" && 1 / o == -1 / 0 ? "-0" : l;
      }
      function ji(o) {
        if (o != null) {
          try {
            return Va.call(o);
          } catch {
          }
          try {
            return o + "";
          } catch {
          }
        }
        return "";
      }
      function cT(o, l) {
        return Lr(ze, function(f) {
          var m = "_." + f[0];
          l & f[1] && !ja(o, m) && o.push(m);
        }), o.sort();
      }
      function km(o) {
        if (o instanceof Le)
          return o.clone();
        var l = new Br(o.__wrapped__, o.__chain__);
        return l.__actions__ = fr(o.__actions__), l.__index__ = o.__index__, l.__values__ = o.__values__, l;
      }
      function lT(o, l, f) {
        (f ? er(o, l, f) : l === t) ? l = 1 : l = Rt(Ae(l), 0);
        var m = o == null ? 0 : o.length;
        if (!m || l < 1)
          return [];
        for (var w = 0, T = 0, I = U(Xa(m / l)); w < m; )
          I[T++] = zr(o, w, w += l);
        return I;
      }
      function uT(o) {
        for (var l = -1, f = o == null ? 0 : o.length, m = 0, w = []; ++l < f; ) {
          var T = o[l];
          T && (w[m++] = T);
        }
        return w;
      }
      function hT() {
        var o = arguments.length;
        if (!o)
          return [];
        for (var l = U(o - 1), f = arguments[0], m = o; m--; )
          l[m - 1] = arguments[m];
        return ei(Oe(f) ? fr(f) : [f], Ut(l, 1));
      }
      var dT = Re(function(o, l) {
        return _t(o) ? To(o, Ut(l, 1, _t, !0)) : [];
      }), fT = Re(function(o, l) {
        var f = Wr(l);
        return _t(f) && (f = t), _t(o) ? To(o, Ut(l, 1, _t, !0), we(f, 2)) : [];
      }), pT = Re(function(o, l) {
        var f = Wr(l);
        return _t(f) && (f = t), _t(o) ? To(o, Ut(l, 1, _t, !0), t, f) : [];
      });
      function gT(o, l, f) {
        var m = o == null ? 0 : o.length;
        return m ? (l = f || l === t ? 1 : Ae(l), zr(o, l < 0 ? 0 : l, m)) : [];
      }
      function mT(o, l, f) {
        var m = o == null ? 0 : o.length;
        return m ? (l = f || l === t ? 1 : Ae(l), l = m - l, zr(o, 0, l < 0 ? 0 : l)) : [];
      }
      function vT(o, l) {
        return o && o.length ? nc(o, we(l, 3), !0, !0) : [];
      }
      function yT(o, l) {
        return o && o.length ? nc(o, we(l, 3), !0) : [];
      }
      function bT(o, l, f, m) {
        var w = o == null ? 0 : o.length;
        return w ? (f && typeof f != "number" && er(o, l, f) && (f = 0, m = w), hC(o, l, f, m)) : [];
      }
      function Om(o, l, f) {
        var m = o == null ? 0 : o.length;
        if (!m)
          return -1;
        var w = f == null ? 0 : Ae(f);
        return w < 0 && (w = Rt(m + w, 0)), Fa(o, we(l, 3), w);
      }
      function Im(o, l, f) {
        var m = o == null ? 0 : o.length;
        if (!m)
          return -1;
        var w = m - 1;
        return f !== t && (w = Ae(f), w = f < 0 ? Rt(m + w, 0) : Xt(w, m - 1)), Fa(o, we(l, 3), w, !0);
      }
      function Am(o) {
        var l = o == null ? 0 : o.length;
        return l ? Ut(o, 1) : [];
      }
      function wT(o) {
        var l = o == null ? 0 : o.length;
        return l ? Ut(o, de) : [];
      }
      function xT(o, l) {
        var f = o == null ? 0 : o.length;
        return f ? (l = l === t ? 1 : Ae(l), Ut(o, l)) : [];
      }
      function _T(o) {
        for (var l = -1, f = o == null ? 0 : o.length, m = {}; ++l < f; ) {
          var w = o[l];
          m[w[0]] = w[1];
        }
        return m;
      }
      function Mm(o) {
        return o && o.length ? o[0] : t;
      }
      function ST(o, l, f) {
        var m = o == null ? 0 : o.length;
        if (!m)
          return -1;
        var w = f == null ? 0 : Ae(f);
        return w < 0 && (w = Rt(m + w, 0)), ws(o, l, w);
      }
      function CT(o) {
        var l = o == null ? 0 : o.length;
        return l ? zr(o, 0, -1) : [];
      }
      var TT = Re(function(o) {
        var l = lt(o, ih);
        return l.length && l[0] === o[0] ? Gu(l) : [];
      }), ET = Re(function(o) {
        var l = Wr(o), f = lt(o, ih);
        return l === Wr(f) ? l = t : f.pop(), f.length && f[0] === o[0] ? Gu(f, we(l, 2)) : [];
      }), kT = Re(function(o) {
        var l = Wr(o), f = lt(o, ih);
        return l = typeof l == "function" ? l : t, l && f.pop(), f.length && f[0] === o[0] ? Gu(f, t, l) : [];
      });
      function OT(o, l) {
        return o == null ? "" : CS.call(o, l);
      }
      function Wr(o) {
        var l = o == null ? 0 : o.length;
        return l ? o[l - 1] : t;
      }
      function IT(o, l, f) {
        var m = o == null ? 0 : o.length;
        if (!m)
          return -1;
        var w = m;
        return f !== t && (w = Ae(f), w = w < 0 ? Rt(m + w, 0) : Xt(w, m - 1)), l === l ? cS(o, l, w) : Fa(o, hg, w, !0);
      }
      function AT(o, l) {
        return o && o.length ? Wg(o, Ae(l)) : t;
      }
      var MT = Re(Pm);
      function Pm(o, l) {
        return o && o.length && l && l.length ? Ju(o, l) : o;
      }
      function PT(o, l, f) {
        return o && o.length && l && l.length ? Ju(o, l, we(f, 2)) : o;
      }
      function DT(o, l, f) {
        return o && o.length && l && l.length ? Ju(o, l, t, f) : o;
      }
      var RT = Rn(function(o, l) {
        var f = o == null ? 0 : o.length, m = Uu(o, l);
        return $g(o, lt(l, function(w) {
          return jn(w, f) ? +w : w;
        }).sort(tm)), m;
      });
      function jT(o, l) {
        var f = [];
        if (!(o && o.length))
          return f;
        var m = -1, w = [], T = o.length;
        for (l = we(l, 3); ++m < T; ) {
          var I = o[m];
          l(I, m, o) && (f.push(I), w.push(m));
        }
        return $g(o, w), f;
      }
      function yh(o) {
        return o == null ? o : OS.call(o);
      }
      function FT(o, l, f) {
        var m = o == null ? 0 : o.length;
        return m ? (f && typeof f != "number" && er(o, l, f) ? (l = 0, f = m) : (l = l == null ? 0 : Ae(l), f = f === t ? m : Ae(f)), zr(o, l, f)) : [];
      }
      function LT(o, l) {
        return rc(o, l);
      }
      function NT(o, l, f) {
        return th(o, l, we(f, 2));
      }
      function BT(o, l) {
        var f = o == null ? 0 : o.length;
        if (f) {
          var m = rc(o, l);
          if (m < f && en(o[m], l))
            return m;
        }
        return -1;
      }
      function VT(o, l) {
        return rc(o, l, !0);
      }
      function zT(o, l, f) {
        return th(o, l, we(f, 2), !0);
      }
      function WT(o, l) {
        var f = o == null ? 0 : o.length;
        if (f) {
          var m = rc(o, l, !0) - 1;
          if (en(o[m], l))
            return m;
        }
        return -1;
      }
      function HT(o) {
        return o && o.length ? Xg(o) : [];
      }
      function UT(o, l) {
        return o && o.length ? Xg(o, we(l, 2)) : [];
      }
      function $T(o) {
        var l = o == null ? 0 : o.length;
        return l ? zr(o, 1, l) : [];
      }
      function YT(o, l, f) {
        return o && o.length ? (l = f || l === t ? 1 : Ae(l), zr(o, 0, l < 0 ? 0 : l)) : [];
      }
      function XT(o, l, f) {
        var m = o == null ? 0 : o.length;
        return m ? (l = f || l === t ? 1 : Ae(l), l = m - l, zr(o, l < 0 ? 0 : l, m)) : [];
      }
      function GT(o, l) {
        return o && o.length ? nc(o, we(l, 3), !1, !0) : [];
      }
      function qT(o, l) {
        return o && o.length ? nc(o, we(l, 3)) : [];
      }
      var KT = Re(function(o) {
        return ii(Ut(o, 1, _t, !0));
      }), ZT = Re(function(o) {
        var l = Wr(o);
        return _t(l) && (l = t), ii(Ut(o, 1, _t, !0), we(l, 2));
      }), JT = Re(function(o) {
        var l = Wr(o);
        return l = typeof l == "function" ? l : t, ii(Ut(o, 1, _t, !0), t, l);
      });
      function QT(o) {
        return o && o.length ? ii(o) : [];
      }
      function e2(o, l) {
        return o && o.length ? ii(o, we(l, 2)) : [];
      }
      function t2(o, l) {
        return l = typeof l == "function" ? l : t, o && o.length ? ii(o, t, l) : [];
      }
      function bh(o) {
        if (!(o && o.length))
          return [];
        var l = 0;
        return o = Qn(o, function(f) {
          if (_t(f))
            return l = Rt(f.length, l), !0;
        }), Fu(l, function(f) {
          return lt(o, Du(f));
        });
      }
      function Dm(o, l) {
        if (!(o && o.length))
          return [];
        var f = bh(o);
        return l == null ? f : lt(f, function(m) {
          return Cr(l, t, m);
        });
      }
      var r2 = Re(function(o, l) {
        return _t(o) ? To(o, l) : [];
      }), n2 = Re(function(o) {
        return nh(Qn(o, _t));
      }), i2 = Re(function(o) {
        var l = Wr(o);
        return _t(l) && (l = t), nh(Qn(o, _t), we(l, 2));
      }), s2 = Re(function(o) {
        var l = Wr(o);
        return l = typeof l == "function" ? l : t, nh(Qn(o, _t), t, l);
      }), o2 = Re(bh);
      function a2(o, l) {
        return Zg(o || [], l || [], Co);
      }
      function c2(o, l) {
        return Zg(o || [], l || [], Oo);
      }
      var l2 = Re(function(o) {
        var l = o.length, f = l > 1 ? o[l - 1] : t;
        return f = typeof f == "function" ? (o.pop(), f) : t, Dm(o, f);
      });
      function Rm(o) {
        var l = S(o);
        return l.__chain__ = !0, l;
      }
      function u2(o, l) {
        return l(o), o;
      }
      function dc(o, l) {
        return l(o);
      }
      var h2 = Rn(function(o) {
        var l = o.length, f = l ? o[0] : 0, m = this.__wrapped__, w = function(T) {
          return Uu(T, o);
        };
        return l > 1 || this.__actions__.length || !(m instanceof Le) || !jn(f) ? this.thru(w) : (m = m.slice(f, +f + (l ? 1 : 0)), m.__actions__.push({
          func: dc,
          args: [w],
          thisArg: t
        }), new Br(m, this.__chain__).thru(function(T) {
          return l && !T.length && T.push(t), T;
        }));
      });
      function d2() {
        return Rm(this);
      }
      function f2() {
        return new Br(this.value(), this.__chain__);
      }
      function p2() {
        this.__values__ === t && (this.__values__ = Gm(this.value()));
        var o = this.__index__ >= this.__values__.length, l = o ? t : this.__values__[this.__index__++];
        return { done: o, value: l };
      }
      function g2() {
        return this;
      }
      function m2(o) {
        for (var l, f = this; f instanceof Za; ) {
          var m = km(f);
          m.__index__ = 0, m.__values__ = t, l ? w.__wrapped__ = m : l = m;
          var w = m;
          f = f.__wrapped__;
        }
        return w.__wrapped__ = o, l;
      }
      function v2() {
        var o = this.__wrapped__;
        if (o instanceof Le) {
          var l = o;
          return this.__actions__.length && (l = new Le(this)), l = l.reverse(), l.__actions__.push({
            func: dc,
            args: [yh],
            thisArg: t
          }), new Br(l, this.__chain__);
        }
        return this.thru(yh);
      }
      function y2() {
        return Kg(this.__wrapped__, this.__actions__);
      }
      var b2 = ic(function(o, l, f) {
        Je.call(o, f) ? ++o[f] : Pn(o, f, 1);
      });
      function w2(o, l, f) {
        var m = Oe(o) ? lg : uC;
        return f && er(o, l, f) && (l = t), m(o, we(l, 3));
      }
      function x2(o, l) {
        var f = Oe(o) ? Qn : Dg;
        return f(o, we(l, 3));
      }
      var _2 = am(Om), S2 = am(Im);
      function C2(o, l) {
        return Ut(fc(o, l), 1);
      }
      function T2(o, l) {
        return Ut(fc(o, l), de);
      }
      function E2(o, l, f) {
        return f = f === t ? 1 : Ae(f), Ut(fc(o, l), f);
      }
      function jm(o, l) {
        var f = Oe(o) ? Lr : ni;
        return f(o, we(l, 3));
      }
      function Fm(o, l) {
        var f = Oe(o) ? $_ : Pg;
        return f(o, we(l, 3));
      }
      var k2 = ic(function(o, l, f) {
        Je.call(o, f) ? o[f].push(l) : Pn(o, f, [l]);
      });
      function O2(o, l, f, m) {
        o = pr(o) ? o : Ps(o), f = f && !m ? Ae(f) : 0;
        var w = o.length;
        return f < 0 && (f = Rt(w + f, 0)), yc(o) ? f <= w && o.indexOf(l, f) > -1 : !!w && ws(o, l, f) > -1;
      }
      var I2 = Re(function(o, l, f) {
        var m = -1, w = typeof l == "function", T = pr(o) ? U(o.length) : [];
        return ni(o, function(I) {
          T[++m] = w ? Cr(l, I, f) : Eo(I, l, f);
        }), T;
      }), A2 = ic(function(o, l, f) {
        Pn(o, f, l);
      });
      function fc(o, l) {
        var f = Oe(o) ? lt : Bg;
        return f(o, we(l, 3));
      }
      function M2(o, l, f, m) {
        return o == null ? [] : (Oe(l) || (l = l == null ? [] : [l]), f = m ? t : f, Oe(f) || (f = f == null ? [] : [f]), Hg(o, l, f));
      }
      var P2 = ic(function(o, l, f) {
        o[f ? 0 : 1].push(l);
      }, function() {
        return [[], []];
      });
      function D2(o, l, f) {
        var m = Oe(o) ? Mu : fg, w = arguments.length < 3;
        return m(o, we(l, 4), f, w, ni);
      }
      function R2(o, l, f) {
        var m = Oe(o) ? Y_ : fg, w = arguments.length < 3;
        return m(o, we(l, 4), f, w, Pg);
      }
      function j2(o, l) {
        var f = Oe(o) ? Qn : Dg;
        return f(o, mc(we(l, 3)));
      }
      function F2(o) {
        var l = Oe(o) ? Og : OC;
        return l(o);
      }
      function L2(o, l, f) {
        (f ? er(o, l, f) : l === t) ? l = 1 : l = Ae(l);
        var m = Oe(o) ? sC : IC;
        return m(o, l);
      }
      function N2(o) {
        var l = Oe(o) ? oC : MC;
        return l(o);
      }
      function B2(o) {
        if (o == null)
          return 0;
        if (pr(o))
          return yc(o) ? _s(o) : o.length;
        var l = Gt(o);
        return l == st || l == A ? o.size : Ku(o).length;
      }
      function V2(o, l, f) {
        var m = Oe(o) ? Pu : PC;
        return f && er(o, l, f) && (l = t), m(o, we(l, 3));
      }
      var z2 = Re(function(o, l) {
        if (o == null)
          return [];
        var f = l.length;
        return f > 1 && er(o, l[0], l[1]) ? l = [] : f > 2 && er(l[0], l[1], l[2]) && (l = [l[0]]), Hg(o, Ut(l, 1), []);
      }), pc = xS || function() {
        return Ht.Date.now();
      };
      function W2(o, l) {
        if (typeof l != "function")
          throw new Nr(a);
        return o = Ae(o), function() {
          if (--o < 1)
            return l.apply(this, arguments);
        };
      }
      function Lm(o, l, f) {
        return l = f ? t : l, l = o && l == null ? o.length : l, Dn(o, V, t, t, t, t, l);
      }
      function Nm(o, l) {
        var f;
        if (typeof l != "function")
          throw new Nr(a);
        return o = Ae(o), function() {
          return --o > 0 && (f = l.apply(this, arguments)), o <= 1 && (l = t), f;
        };
      }
      var wh = Re(function(o, l, f) {
        var m = _;
        if (f.length) {
          var w = ti(f, As(wh));
          m |= P;
        }
        return Dn(o, m, l, f, w);
      }), Bm = Re(function(o, l, f) {
        var m = _ | C;
        if (f.length) {
          var w = ti(f, As(Bm));
          m |= P;
        }
        return Dn(l, m, o, f, w);
      });
      function Vm(o, l, f) {
        l = f ? t : l;
        var m = Dn(o, k, t, t, t, t, t, l);
        return m.placeholder = Vm.placeholder, m;
      }
      function zm(o, l, f) {
        l = f ? t : l;
        var m = Dn(o, O, t, t, t, t, t, l);
        return m.placeholder = zm.placeholder, m;
      }
      function Wm(o, l, f) {
        var m, w, T, I, M, N, q = 0, K = !1, J = !1, ae = !0;
        if (typeof o != "function")
          throw new Nr(a);
        l = Hr(l) || 0, ft(f) && (K = !!f.leading, J = "maxWait" in f, T = J ? Rt(Hr(f.maxWait) || 0, l) : T, ae = "trailing" in f ? !!f.trailing : ae);
        function ve(St) {
          var tn = m, Nn = w;
          return m = w = t, q = St, I = o.apply(Nn, tn), I;
        }
        function xe(St) {
          return q = St, M = Mo(Fe, l), K ? ve(St) : I;
        }
        function De(St) {
          var tn = St - N, Nn = St - q, av = l - tn;
          return J ? Xt(av, T - Nn) : av;
        }
        function _e(St) {
          var tn = St - N, Nn = St - q;
          return N === t || tn >= l || tn < 0 || J && Nn >= T;
        }
        function Fe() {
          var St = pc();
          if (_e(St))
            return Ve(St);
          M = Mo(Fe, De(St));
        }
        function Ve(St) {
          return M = t, ae && m ? ve(St) : (m = w = t, I);
        }
        function Or() {
          M !== t && Jg(M), q = 0, m = N = w = M = t;
        }
        function tr() {
          return M === t ? I : Ve(pc());
        }
        function Ir() {
          var St = pc(), tn = _e(St);
          if (m = arguments, w = this, N = St, tn) {
            if (M === t)
              return xe(N);
            if (J)
              return Jg(M), M = Mo(Fe, l), ve(N);
          }
          return M === t && (M = Mo(Fe, l)), I;
        }
        return Ir.cancel = Or, Ir.flush = tr, Ir;
      }
      var H2 = Re(function(o, l) {
        return Mg(o, 1, l);
      }), U2 = Re(function(o, l, f) {
        return Mg(o, Hr(l) || 0, f);
      });
      function $2(o) {
        return Dn(o, $);
      }
      function gc(o, l) {
        if (typeof o != "function" || l != null && typeof l != "function")
          throw new Nr(a);
        var f = function() {
          var m = arguments, w = l ? l.apply(this, m) : m[0], T = f.cache;
          if (T.has(w))
            return T.get(w);
          var I = o.apply(this, m);
          return f.cache = T.set(w, I) || T, I;
        };
        return f.cache = new (gc.Cache || Mn)(), f;
      }
      gc.Cache = Mn;
      function mc(o) {
        if (typeof o != "function")
          throw new Nr(a);
        return function() {
          var l = arguments;
          switch (l.length) {
            case 0:
              return !o.call(this);
            case 1:
              return !o.call(this, l[0]);
            case 2:
              return !o.call(this, l[0], l[1]);
            case 3:
              return !o.call(this, l[0], l[1], l[2]);
          }
          return !o.apply(this, l);
        };
      }
      function Y2(o) {
        return Nm(2, o);
      }
      var X2 = DC(function(o, l) {
        l = l.length == 1 && Oe(l[0]) ? lt(l[0], Tr(we())) : lt(Ut(l, 1), Tr(we()));
        var f = l.length;
        return Re(function(m) {
          for (var w = -1, T = Xt(m.length, f); ++w < T; )
            m[w] = l[w].call(this, m[w]);
          return Cr(o, this, m);
        });
      }), xh = Re(function(o, l) {
        var f = ti(l, As(xh));
        return Dn(o, P, t, l, f);
      }), Hm = Re(function(o, l) {
        var f = ti(l, As(Hm));
        return Dn(o, j, t, l, f);
      }), G2 = Rn(function(o, l) {
        return Dn(o, F, t, t, t, l);
      });
      function q2(o, l) {
        if (typeof o != "function")
          throw new Nr(a);
        return l = l === t ? l : Ae(l), Re(o, l);
      }
      function K2(o, l) {
        if (typeof o != "function")
          throw new Nr(a);
        return l = l == null ? 0 : Rt(Ae(l), 0), Re(function(f) {
          var m = f[l], w = oi(f, 0, l);
          return m && ei(w, m), Cr(o, this, w);
        });
      }
      function Z2(o, l, f) {
        var m = !0, w = !0;
        if (typeof o != "function")
          throw new Nr(a);
        return ft(f) && (m = "leading" in f ? !!f.leading : m, w = "trailing" in f ? !!f.trailing : w), Wm(o, l, {
          leading: m,
          maxWait: l,
          trailing: w
        });
      }
      function J2(o) {
        return Lm(o, 1);
      }
      function Q2(o, l) {
        return xh(sh(l), o);
      }
      function eE() {
        if (!arguments.length)
          return [];
        var o = arguments[0];
        return Oe(o) ? o : [o];
      }
      function tE(o) {
        return Vr(o, v);
      }
      function rE(o, l) {
        return l = typeof l == "function" ? l : t, Vr(o, v, l);
      }
      function nE(o) {
        return Vr(o, p | v);
      }
      function iE(o, l) {
        return l = typeof l == "function" ? l : t, Vr(o, p | v, l);
      }
      function sE(o, l) {
        return l == null || Ag(o, l, zt(l));
      }
      function en(o, l) {
        return o === l || o !== o && l !== l;
      }
      var oE = cc(Xu), aE = cc(function(o, l) {
        return o >= l;
      }), Fi = Fg(/* @__PURE__ */ function() {
        return arguments;
      }()) ? Fg : function(o) {
        return mt(o) && Je.call(o, "callee") && !_g.call(o, "callee");
      }, Oe = U.isArray, cE = ng ? Tr(ng) : mC;
      function pr(o) {
        return o != null && vc(o.length) && !Fn(o);
      }
      function _t(o) {
        return mt(o) && pr(o);
      }
      function lE(o) {
        return o === !0 || o === !1 || mt(o) && Qt(o) == lr;
      }
      var ai = SS || Ph, uE = ig ? Tr(ig) : vC;
      function hE(o) {
        return mt(o) && o.nodeType === 1 && !Po(o);
      }
      function dE(o) {
        if (o == null)
          return !0;
        if (pr(o) && (Oe(o) || typeof o == "string" || typeof o.splice == "function" || ai(o) || Ms(o) || Fi(o)))
          return !o.length;
        var l = Gt(o);
        if (l == st || l == A)
          return !o.size;
        if (Ao(o))
          return !Ku(o).length;
        for (var f in o)
          if (Je.call(o, f))
            return !1;
        return !0;
      }
      function fE(o, l) {
        return ko(o, l);
      }
      function pE(o, l, f) {
        f = typeof f == "function" ? f : t;
        var m = f ? f(o, l) : t;
        return m === t ? ko(o, l, t, f) : !!m;
      }
      function _h(o) {
        if (!mt(o))
          return !1;
        var l = Qt(o);
        return l == ur || l == Mt || typeof o.message == "string" && typeof o.name == "string" && !Po(o);
      }
      function gE(o) {
        return typeof o == "number" && Cg(o);
      }
      function Fn(o) {
        if (!ft(o))
          return !1;
        var l = Qt(o);
        return l == ye || l == wr || l == dt || l == In;
      }
      function Um(o) {
        return typeof o == "number" && o == Ae(o);
      }
      function vc(o) {
        return typeof o == "number" && o > -1 && o % 1 == 0 && o <= oe;
      }
      function ft(o) {
        var l = typeof o;
        return o != null && (l == "object" || l == "function");
      }
      function mt(o) {
        return o != null && typeof o == "object";
      }
      var $m = sg ? Tr(sg) : bC;
      function mE(o, l) {
        return o === l || qu(o, l, dh(l));
      }
      function vE(o, l, f) {
        return f = typeof f == "function" ? f : t, qu(o, l, dh(l), f);
      }
      function yE(o) {
        return Ym(o) && o != +o;
      }
      function bE(o) {
        if (rT(o))
          throw new ke(s);
        return Lg(o);
      }
      function wE(o) {
        return o === null;
      }
      function xE(o) {
        return o == null;
      }
      function Ym(o) {
        return typeof o == "number" || mt(o) && Qt(o) == Vt;
      }
      function Po(o) {
        if (!mt(o) || Qt(o) != nt)
          return !1;
        var l = Ua(o);
        if (l === null)
          return !0;
        var f = Je.call(l, "constructor") && l.constructor;
        return typeof f == "function" && f instanceof f && Va.call(f) == vS;
      }
      var Sh = og ? Tr(og) : wC;
      function _E(o) {
        return Um(o) && o >= -9007199254740991 && o <= oe;
      }
      var Xm = ag ? Tr(ag) : xC;
      function yc(o) {
        return typeof o == "string" || !Oe(o) && mt(o) && Qt(o) == le;
      }
      function kr(o) {
        return typeof o == "symbol" || mt(o) && Qt(o) == ce;
      }
      var Ms = cg ? Tr(cg) : _C;
      function SE(o) {
        return o === t;
      }
      function CE(o) {
        return mt(o) && Gt(o) == et;
      }
      function TE(o) {
        return mt(o) && Qt(o) == Ge;
      }
      var EE = cc(Zu), kE = cc(function(o, l) {
        return o <= l;
      });
      function Gm(o) {
        if (!o)
          return [];
        if (pr(o))
          return yc(o) ? Jr(o) : fr(o);
        if (bo && o[bo])
          return sS(o[bo]());
        var l = Gt(o), f = l == st ? Nu : l == A ? La : Ps;
        return f(o);
      }
      function Ln(o) {
        if (!o)
          return o === 0 ? o : 0;
        if (o = Hr(o), o === de || o === -1 / 0) {
          var l = o < 0 ? -1 : 1;
          return l * ie;
        }
        return o === o ? o : 0;
      }
      function Ae(o) {
        var l = Ln(o), f = l % 1;
        return l === l ? f ? l - f : l : 0;
      }
      function qm(o) {
        return o ? Pi(Ae(o), 0, re) : 0;
      }
      function Hr(o) {
        if (typeof o == "number")
          return o;
        if (kr(o))
          return pe;
        if (ft(o)) {
          var l = typeof o.valueOf == "function" ? o.valueOf() : o;
          o = ft(l) ? l + "" : l;
        }
        if (typeof o != "string")
          return o === 0 ? o : +o;
        o = pg(o);
        var f = c_.test(o);
        return f || u_.test(o) ? W_(o.slice(2), f ? 2 : 8) : a_.test(o) ? pe : +o;
      }
      function Km(o) {
        return mn(o, gr(o));
      }
      function OE(o) {
        return o ? Pi(Ae(o), -9007199254740991, oe) : o === 0 ? o : 0;
      }
      function qe(o) {
        return o == null ? "" : Er(o);
      }
      var IE = Os(function(o, l) {
        if (Ao(l) || pr(l)) {
          mn(l, zt(l), o);
          return;
        }
        for (var f in l)
          Je.call(l, f) && Co(o, f, l[f]);
      }), Zm = Os(function(o, l) {
        mn(l, gr(l), o);
      }), bc = Os(function(o, l, f, m) {
        mn(l, gr(l), o, m);
      }), AE = Os(function(o, l, f, m) {
        mn(l, zt(l), o, m);
      }), ME = Rn(Uu);
      function PE(o, l) {
        var f = ks(o);
        return l == null ? f : Ig(f, l);
      }
      var DE = Re(function(o, l) {
        o = tt(o);
        var f = -1, m = l.length, w = m > 2 ? l[2] : t;
        for (w && er(l[0], l[1], w) && (m = 1); ++f < m; )
          for (var T = l[f], I = gr(T), M = -1, N = I.length; ++M < N; ) {
            var q = I[M], K = o[q];
            (K === t || en(K, Cs[q]) && !Je.call(o, q)) && (o[q] = T[q]);
          }
        return o;
      }), RE = Re(function(o) {
        return o.push(t, pm), Cr(Jm, t, o);
      });
      function jE(o, l) {
        return ug(o, we(l, 3), gn);
      }
      function FE(o, l) {
        return ug(o, we(l, 3), Yu);
      }
      function LE(o, l) {
        return o == null ? o : $u(o, we(l, 3), gr);
      }
      function NE(o, l) {
        return o == null ? o : Rg(o, we(l, 3), gr);
      }
      function BE(o, l) {
        return o && gn(o, we(l, 3));
      }
      function VE(o, l) {
        return o && Yu(o, we(l, 3));
      }
      function zE(o) {
        return o == null ? [] : ec(o, zt(o));
      }
      function WE(o) {
        return o == null ? [] : ec(o, gr(o));
      }
      function Ch(o, l, f) {
        var m = o == null ? t : Di(o, l);
        return m === t ? f : m;
      }
      function HE(o, l) {
        return o != null && vm(o, l, dC);
      }
      function Th(o, l) {
        return o != null && vm(o, l, fC);
      }
      var UE = lm(function(o, l, f) {
        l != null && typeof l.toString != "function" && (l = za.call(l)), o[l] = f;
      }, kh(mr)), $E = lm(function(o, l, f) {
        l != null && typeof l.toString != "function" && (l = za.call(l)), Je.call(o, l) ? o[l].push(f) : o[l] = [f];
      }, we), YE = Re(Eo);
      function zt(o) {
        return pr(o) ? kg(o) : Ku(o);
      }
      function gr(o) {
        return pr(o) ? kg(o, !0) : SC(o);
      }
      function XE(o, l) {
        var f = {};
        return l = we(l, 3), gn(o, function(m, w, T) {
          Pn(f, l(m, w, T), m);
        }), f;
      }
      function GE(o, l) {
        var f = {};
        return l = we(l, 3), gn(o, function(m, w, T) {
          Pn(f, w, l(m, w, T));
        }), f;
      }
      var qE = Os(function(o, l, f) {
        tc(o, l, f);
      }), Jm = Os(function(o, l, f, m) {
        tc(o, l, f, m);
      }), KE = Rn(function(o, l) {
        var f = {};
        if (o == null)
          return f;
        var m = !1;
        l = lt(l, function(T) {
          return T = si(T, o), m || (m = T.length > 1), T;
        }), mn(o, uh(o), f), m && (f = Vr(f, p | g | v, UC));
        for (var w = l.length; w--; )
          rh(f, l[w]);
        return f;
      });
      function ZE(o, l) {
        return Qm(o, mc(we(l)));
      }
      var JE = Rn(function(o, l) {
        return o == null ? {} : TC(o, l);
      });
      function Qm(o, l) {
        if (o == null)
          return {};
        var f = lt(uh(o), function(m) {
          return [m];
        });
        return l = we(l), Ug(o, f, function(m, w) {
          return l(m, w[0]);
        });
      }
      function QE(o, l, f) {
        l = si(l, o);
        var m = -1, w = l.length;
        for (w || (w = 1, o = t); ++m < w; ) {
          var T = o == null ? t : o[vn(l[m])];
          T === t && (m = w, T = f), o = Fn(T) ? T.call(o) : T;
        }
        return o;
      }
      function ek(o, l, f) {
        return o == null ? o : Oo(o, l, f);
      }
      function tk(o, l, f, m) {
        return m = typeof m == "function" ? m : t, o == null ? o : Oo(o, l, f, m);
      }
      var ev = dm(zt), tv = dm(gr);
      function rk(o, l, f) {
        var m = Oe(o), w = m || ai(o) || Ms(o);
        if (l = we(l, 4), f == null) {
          var T = o && o.constructor;
          w ? f = m ? new T() : [] : ft(o) ? f = Fn(T) ? ks(Ua(o)) : {} : f = {};
        }
        return (w ? Lr : gn)(o, function(I, M, N) {
          return l(f, I, M, N);
        }), f;
      }
      function nk(o, l) {
        return o == null ? !0 : rh(o, l);
      }
      function ik(o, l, f) {
        return o == null ? o : qg(o, l, sh(f));
      }
      function sk(o, l, f, m) {
        return m = typeof m == "function" ? m : t, o == null ? o : qg(o, l, sh(f), m);
      }
      function Ps(o) {
        return o == null ? [] : Lu(o, zt(o));
      }
      function ok(o) {
        return o == null ? [] : Lu(o, gr(o));
      }
      function ak(o, l, f) {
        return f === t && (f = l, l = t), f !== t && (f = Hr(f), f = f === f ? f : 0), l !== t && (l = Hr(l), l = l === l ? l : 0), Pi(Hr(o), l, f);
      }
      function ck(o, l, f) {
        return l = Ln(l), f === t ? (f = l, l = 0) : f = Ln(f), o = Hr(o), pC(o, l, f);
      }
      function lk(o, l, f) {
        if (f && typeof f != "boolean" && er(o, l, f) && (l = f = t), f === t && (typeof l == "boolean" ? (f = l, l = t) : typeof o == "boolean" && (f = o, o = t)), o === t && l === t ? (o = 0, l = 1) : (o = Ln(o), l === t ? (l = o, o = 0) : l = Ln(l)), o > l) {
          var m = o;
          o = l, l = m;
        }
        if (f || o % 1 || l % 1) {
          var w = Tg();
          return Xt(o + w * (l - o + z_("1e-" + ((w + "").length - 1))), l);
        }
        return Qu(o, l);
      }
      var uk = Is(function(o, l, f) {
        return l = l.toLowerCase(), o + (f ? rv(l) : l);
      });
      function rv(o) {
        return Eh(qe(o).toLowerCase());
      }
      function nv(o) {
        return o = qe(o), o && o.replace(d_, eS).replace(M_, "");
      }
      function hk(o, l, f) {
        o = qe(o), l = Er(l);
        var m = o.length;
        f = f === t ? m : Pi(Ae(f), 0, m);
        var w = f;
        return f -= l.length, f >= 0 && o.slice(f, w) == l;
      }
      function dk(o) {
        return o = qe(o), o && Pp.test(o) ? o.replace(ki, tS) : o;
      }
      function fk(o) {
        return o = qe(o), o && Sr.test(o) ? o.replace(He, "\\$&") : o;
      }
      var pk = Is(function(o, l, f) {
        return o + (f ? "-" : "") + l.toLowerCase();
      }), gk = Is(function(o, l, f) {
        return o + (f ? " " : "") + l.toLowerCase();
      }), mk = om("toLowerCase");
      function vk(o, l, f) {
        o = qe(o), l = Ae(l);
        var m = l ? _s(o) : 0;
        if (!l || m >= l)
          return o;
        var w = (l - m) / 2;
        return ac(Ga(w), f) + o + ac(Xa(w), f);
      }
      function yk(o, l, f) {
        o = qe(o), l = Ae(l);
        var m = l ? _s(o) : 0;
        return l && m < l ? o + ac(l - m, f) : o;
      }
      function bk(o, l, f) {
        o = qe(o), l = Ae(l);
        var m = l ? _s(o) : 0;
        return l && m < l ? ac(l - m, f) + o : o;
      }
      function wk(o, l, f) {
        return f || l == null ? l = 0 : l && (l = +l), kS(qe(o).replace(pn, ""), l || 0);
      }
      function xk(o, l, f) {
        return (f ? er(o, l, f) : l === t) ? l = 1 : l = Ae(l), eh(qe(o), l);
      }
      function _k() {
        var o = arguments, l = qe(o[0]);
        return o.length < 3 ? l : l.replace(o[1], o[2]);
      }
      var Sk = Is(function(o, l, f) {
        return o + (f ? "_" : "") + l.toLowerCase();
      });
      function Ck(o, l, f) {
        return f && typeof f != "number" && er(o, l, f) && (l = f = t), f = f === t ? re : f >>> 0, f ? (o = qe(o), o && (typeof l == "string" || l != null && !Sh(l)) && (l = Er(l), !l && xs(o)) ? oi(Jr(o), 0, f) : o.split(l, f)) : [];
      }
      var Tk = Is(function(o, l, f) {
        return o + (f ? " " : "") + Eh(l);
      });
      function Ek(o, l, f) {
        return o = qe(o), f = f == null ? 0 : Pi(Ae(f), 0, o.length), l = Er(l), o.slice(f, f + l.length) == l;
      }
      function kk(o, l, f) {
        var m = S.templateSettings;
        f && er(o, l, f) && (l = t), o = qe(o), l = bc({}, l, m, fm);
        var w = bc({}, l.imports, m.imports, fm), T = zt(w), I = Lu(w, T), M, N, q = 0, K = l.interpolate || Pa, J = "__p += '", ae = Bu(
          (l.escape || Pa).source + "|" + K.source + "|" + (K === xu ? o_ : Pa).source + "|" + (l.evaluate || Pa).source + "|$",
          "g"
        ), ve = "//# sourceURL=" + (Je.call(l, "sourceURL") ? (l.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++F_ + "]") + `
`;
        o.replace(ae, function(_e, Fe, Ve, Or, tr, Ir) {
          return Ve || (Ve = Or), J += o.slice(q, Ir).replace(f_, rS), Fe && (M = !0, J += `' +
__e(` + Fe + `) +
'`), tr && (N = !0, J += `';
` + tr + `;
__p += '`), Ve && (J += `' +
((__t = (` + Ve + `)) == null ? '' : __t) +
'`), q = Ir + _e.length, _e;
        }), J += `';
`;
        var xe = Je.call(l, "variable") && l.variable;
        if (!xe)
          J = `with (obj) {
` + J + `
}
`;
        else if (i_.test(xe))
          throw new ke(c);
        J = (N ? J.replace(vs, "") : J).replace(ys, "$1").replace(wu, "$1;"), J = "function(" + (xe || "obj") + `) {
` + (xe ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (M ? ", __e = _.escape" : "") + (N ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + J + `return __p
}`;
        var De = sv(function() {
          return Ye(T, ve + "return " + J).apply(t, I);
        });
        if (De.source = J, _h(De))
          throw De;
        return De;
      }
      function Ok(o) {
        return qe(o).toLowerCase();
      }
      function Ik(o) {
        return qe(o).toUpperCase();
      }
      function Ak(o, l, f) {
        if (o = qe(o), o && (f || l === t))
          return pg(o);
        if (!o || !(l = Er(l)))
          return o;
        var m = Jr(o), w = Jr(l), T = gg(m, w), I = mg(m, w) + 1;
        return oi(m, T, I).join("");
      }
      function Mk(o, l, f) {
        if (o = qe(o), o && (f || l === t))
          return o.slice(0, yg(o) + 1);
        if (!o || !(l = Er(l)))
          return o;
        var m = Jr(o), w = mg(m, Jr(l)) + 1;
        return oi(m, 0, w).join("");
      }
      function Pk(o, l, f) {
        if (o = qe(o), o && (f || l === t))
          return o.replace(pn, "");
        if (!o || !(l = Er(l)))
          return o;
        var m = Jr(o), w = gg(m, Jr(l));
        return oi(m, w).join("");
      }
      function Dk(o, l) {
        var f = z, m = G;
        if (ft(l)) {
          var w = "separator" in l ? l.separator : w;
          f = "length" in l ? Ae(l.length) : f, m = "omission" in l ? Er(l.omission) : m;
        }
        o = qe(o);
        var T = o.length;
        if (xs(o)) {
          var I = Jr(o);
          T = I.length;
        }
        if (f >= T)
          return o;
        var M = f - _s(m);
        if (M < 1)
          return m;
        var N = I ? oi(I, 0, M).join("") : o.slice(0, M);
        if (w === t)
          return N + m;
        if (I && (M += N.length - M), Sh(w)) {
          if (o.slice(M).search(w)) {
            var q, K = N;
            for (w.global || (w = Bu(w.source, qe(Fp.exec(w)) + "g")), w.lastIndex = 0; q = w.exec(K); )
              var J = q.index;
            N = N.slice(0, J === t ? M : J);
          }
        } else if (o.indexOf(Er(w), M) != M) {
          var ae = N.lastIndexOf(w);
          ae > -1 && (N = N.slice(0, ae));
        }
        return N + m;
      }
      function Rk(o) {
        return o = qe(o), o && Aa.test(o) ? o.replace(Ia, lS) : o;
      }
      var jk = Is(function(o, l, f) {
        return o + (f ? " " : "") + l.toUpperCase();
      }), Eh = om("toUpperCase");
      function iv(o, l, f) {
        return o = qe(o), l = f ? t : l, l === t ? iS(o) ? dS(o) : q_(o) : o.match(l) || [];
      }
      var sv = Re(function(o, l) {
        try {
          return Cr(o, t, l);
        } catch (f) {
          return _h(f) ? f : new ke(f);
        }
      }), Fk = Rn(function(o, l) {
        return Lr(l, function(f) {
          f = vn(f), Pn(o, f, wh(o[f], o));
        }), o;
      });
      function Lk(o) {
        var l = o == null ? 0 : o.length, f = we();
        return o = l ? lt(o, function(m) {
          if (typeof m[1] != "function")
            throw new Nr(a);
          return [f(m[0]), m[1]];
        }) : [], Re(function(m) {
          for (var w = -1; ++w < l; ) {
            var T = o[w];
            if (Cr(T[0], this, m))
              return Cr(T[1], this, m);
          }
        });
      }
      function Nk(o) {
        return lC(Vr(o, p));
      }
      function kh(o) {
        return function() {
          return o;
        };
      }
      function Bk(o, l) {
        return o == null || o !== o ? l : o;
      }
      var Vk = cm(), zk = cm(!0);
      function mr(o) {
        return o;
      }
      function Oh(o) {
        return Ng(typeof o == "function" ? o : Vr(o, p));
      }
      function Wk(o) {
        return Vg(Vr(o, p));
      }
      function Hk(o, l) {
        return zg(o, Vr(l, p));
      }
      var Uk = Re(function(o, l) {
        return function(f) {
          return Eo(f, o, l);
        };
      }), $k = Re(function(o, l) {
        return function(f) {
          return Eo(o, f, l);
        };
      });
      function Ih(o, l, f) {
        var m = zt(l), w = ec(l, m);
        f == null && !(ft(l) && (w.length || !m.length)) && (f = l, l = o, o = this, w = ec(l, zt(l)));
        var T = !(ft(f) && "chain" in f) || !!f.chain, I = Fn(o);
        return Lr(w, function(M) {
          var N = l[M];
          o[M] = N, I && (o.prototype[M] = function() {
            var q = this.__chain__;
            if (T || q) {
              var K = o(this.__wrapped__), J = K.__actions__ = fr(this.__actions__);
              return J.push({ func: N, args: arguments, thisArg: o }), K.__chain__ = q, K;
            }
            return N.apply(o, ei([this.value()], arguments));
          });
        }), o;
      }
      function Yk() {
        return Ht._ === this && (Ht._ = yS), this;
      }
      function Ah() {
      }
      function Xk(o) {
        return o = Ae(o), Re(function(l) {
          return Wg(l, o);
        });
      }
      var Gk = ah(lt), qk = ah(lg), Kk = ah(Pu);
      function ov(o) {
        return ph(o) ? Du(vn(o)) : EC(o);
      }
      function Zk(o) {
        return function(l) {
          return o == null ? t : Di(o, l);
        };
      }
      var Jk = um(), Qk = um(!0);
      function Mh() {
        return [];
      }
      function Ph() {
        return !1;
      }
      function e5() {
        return {};
      }
      function t5() {
        return "";
      }
      function r5() {
        return !0;
      }
      function n5(o, l) {
        if (o = Ae(o), o < 1 || o > oe)
          return [];
        var f = re, m = Xt(o, re);
        l = we(l), o -= re;
        for (var w = Fu(m, l); ++f < o; )
          l(f);
        return w;
      }
      function i5(o) {
        return Oe(o) ? lt(o, vn) : kr(o) ? [o] : fr(Em(qe(o)));
      }
      function s5(o) {
        var l = ++mS;
        return qe(o) + l;
      }
      var o5 = oc(function(o, l) {
        return o + l;
      }, 0), a5 = ch("ceil"), c5 = oc(function(o, l) {
        return o / l;
      }, 1), l5 = ch("floor");
      function u5(o) {
        return o && o.length ? Qa(o, mr, Xu) : t;
      }
      function h5(o, l) {
        return o && o.length ? Qa(o, we(l, 2), Xu) : t;
      }
      function d5(o) {
        return dg(o, mr);
      }
      function f5(o, l) {
        return dg(o, we(l, 2));
      }
      function p5(o) {
        return o && o.length ? Qa(o, mr, Zu) : t;
      }
      function g5(o, l) {
        return o && o.length ? Qa(o, we(l, 2), Zu) : t;
      }
      var m5 = oc(function(o, l) {
        return o * l;
      }, 1), v5 = ch("round"), y5 = oc(function(o, l) {
        return o - l;
      }, 0);
      function b5(o) {
        return o && o.length ? ju(o, mr) : 0;
      }
      function w5(o, l) {
        return o && o.length ? ju(o, we(l, 2)) : 0;
      }
      return S.after = W2, S.ary = Lm, S.assign = IE, S.assignIn = Zm, S.assignInWith = bc, S.assignWith = AE, S.at = ME, S.before = Nm, S.bind = wh, S.bindAll = Fk, S.bindKey = Bm, S.castArray = eE, S.chain = Rm, S.chunk = lT, S.compact = uT, S.concat = hT, S.cond = Lk, S.conforms = Nk, S.constant = kh, S.countBy = b2, S.create = PE, S.curry = Vm, S.curryRight = zm, S.debounce = Wm, S.defaults = DE, S.defaultsDeep = RE, S.defer = H2, S.delay = U2, S.difference = dT, S.differenceBy = fT, S.differenceWith = pT, S.drop = gT, S.dropRight = mT, S.dropRightWhile = vT, S.dropWhile = yT, S.fill = bT, S.filter = x2, S.flatMap = C2, S.flatMapDeep = T2, S.flatMapDepth = E2, S.flatten = Am, S.flattenDeep = wT, S.flattenDepth = xT, S.flip = $2, S.flow = Vk, S.flowRight = zk, S.fromPairs = _T, S.functions = zE, S.functionsIn = WE, S.groupBy = k2, S.initial = CT, S.intersection = TT, S.intersectionBy = ET, S.intersectionWith = kT, S.invert = UE, S.invertBy = $E, S.invokeMap = I2, S.iteratee = Oh, S.keyBy = A2, S.keys = zt, S.keysIn = gr, S.map = fc, S.mapKeys = XE, S.mapValues = GE, S.matches = Wk, S.matchesProperty = Hk, S.memoize = gc, S.merge = qE, S.mergeWith = Jm, S.method = Uk, S.methodOf = $k, S.mixin = Ih, S.negate = mc, S.nthArg = Xk, S.omit = KE, S.omitBy = ZE, S.once = Y2, S.orderBy = M2, S.over = Gk, S.overArgs = X2, S.overEvery = qk, S.overSome = Kk, S.partial = xh, S.partialRight = Hm, S.partition = P2, S.pick = JE, S.pickBy = Qm, S.property = ov, S.propertyOf = Zk, S.pull = MT, S.pullAll = Pm, S.pullAllBy = PT, S.pullAllWith = DT, S.pullAt = RT, S.range = Jk, S.rangeRight = Qk, S.rearg = G2, S.reject = j2, S.remove = jT, S.rest = q2, S.reverse = yh, S.sampleSize = L2, S.set = ek, S.setWith = tk, S.shuffle = N2, S.slice = FT, S.sortBy = z2, S.sortedUniq = HT, S.sortedUniqBy = UT, S.split = Ck, S.spread = K2, S.tail = $T, S.take = YT, S.takeRight = XT, S.takeRightWhile = GT, S.takeWhile = qT, S.tap = u2, S.throttle = Z2, S.thru = dc, S.toArray = Gm, S.toPairs = ev, S.toPairsIn = tv, S.toPath = i5, S.toPlainObject = Km, S.transform = rk, S.unary = J2, S.union = KT, S.unionBy = ZT, S.unionWith = JT, S.uniq = QT, S.uniqBy = e2, S.uniqWith = t2, S.unset = nk, S.unzip = bh, S.unzipWith = Dm, S.update = ik, S.updateWith = sk, S.values = Ps, S.valuesIn = ok, S.without = r2, S.words = iv, S.wrap = Q2, S.xor = n2, S.xorBy = i2, S.xorWith = s2, S.zip = o2, S.zipObject = a2, S.zipObjectDeep = c2, S.zipWith = l2, S.entries = ev, S.entriesIn = tv, S.extend = Zm, S.extendWith = bc, Ih(S, S), S.add = o5, S.attempt = sv, S.camelCase = uk, S.capitalize = rv, S.ceil = a5, S.clamp = ak, S.clone = tE, S.cloneDeep = nE, S.cloneDeepWith = iE, S.cloneWith = rE, S.conformsTo = sE, S.deburr = nv, S.defaultTo = Bk, S.divide = c5, S.endsWith = hk, S.eq = en, S.escape = dk, S.escapeRegExp = fk, S.every = w2, S.find = _2, S.findIndex = Om, S.findKey = jE, S.findLast = S2, S.findLastIndex = Im, S.findLastKey = FE, S.floor = l5, S.forEach = jm, S.forEachRight = Fm, S.forIn = LE, S.forInRight = NE, S.forOwn = BE, S.forOwnRight = VE, S.get = Ch, S.gt = oE, S.gte = aE, S.has = HE, S.hasIn = Th, S.head = Mm, S.identity = mr, S.includes = O2, S.indexOf = ST, S.inRange = ck, S.invoke = YE, S.isArguments = Fi, S.isArray = Oe, S.isArrayBuffer = cE, S.isArrayLike = pr, S.isArrayLikeObject = _t, S.isBoolean = lE, S.isBuffer = ai, S.isDate = uE, S.isElement = hE, S.isEmpty = dE, S.isEqual = fE, S.isEqualWith = pE, S.isError = _h, S.isFinite = gE, S.isFunction = Fn, S.isInteger = Um, S.isLength = vc, S.isMap = $m, S.isMatch = mE, S.isMatchWith = vE, S.isNaN = yE, S.isNative = bE, S.isNil = xE, S.isNull = wE, S.isNumber = Ym, S.isObject = ft, S.isObjectLike = mt, S.isPlainObject = Po, S.isRegExp = Sh, S.isSafeInteger = _E, S.isSet = Xm, S.isString = yc, S.isSymbol = kr, S.isTypedArray = Ms, S.isUndefined = SE, S.isWeakMap = CE, S.isWeakSet = TE, S.join = OT, S.kebabCase = pk, S.last = Wr, S.lastIndexOf = IT, S.lowerCase = gk, S.lowerFirst = mk, S.lt = EE, S.lte = kE, S.max = u5, S.maxBy = h5, S.mean = d5, S.meanBy = f5, S.min = p5, S.minBy = g5, S.stubArray = Mh, S.stubFalse = Ph, S.stubObject = e5, S.stubString = t5, S.stubTrue = r5, S.multiply = m5, S.nth = AT, S.noConflict = Yk, S.noop = Ah, S.now = pc, S.pad = vk, S.padEnd = yk, S.padStart = bk, S.parseInt = wk, S.random = lk, S.reduce = D2, S.reduceRight = R2, S.repeat = xk, S.replace = _k, S.result = QE, S.round = v5, S.runInContext = L, S.sample = F2, S.size = B2, S.snakeCase = Sk, S.some = V2, S.sortedIndex = LT, S.sortedIndexBy = NT, S.sortedIndexOf = BT, S.sortedLastIndex = VT, S.sortedLastIndexBy = zT, S.sortedLastIndexOf = WT, S.startCase = Tk, S.startsWith = Ek, S.subtract = y5, S.sum = b5, S.sumBy = w5, S.template = kk, S.times = n5, S.toFinite = Ln, S.toInteger = Ae, S.toLength = qm, S.toLower = Ok, S.toNumber = Hr, S.toSafeInteger = OE, S.toString = qe, S.toUpper = Ik, S.trim = Ak, S.trimEnd = Mk, S.trimStart = Pk, S.truncate = Dk, S.unescape = Rk, S.uniqueId = s5, S.upperCase = jk, S.upperFirst = Eh, S.each = jm, S.eachRight = Fm, S.first = Mm, Ih(S, function() {
        var o = {};
        return gn(S, function(l, f) {
          Je.call(S.prototype, f) || (o[f] = l);
        }), o;
      }(), { chain: !1 }), S.VERSION = n, Lr(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(o) {
        S[o].placeholder = S;
      }), Lr(["drop", "take"], function(o, l) {
        Le.prototype[o] = function(f) {
          f = f === t ? 1 : Rt(Ae(f), 0);
          var m = this.__filtered__ && !l ? new Le(this) : this.clone();
          return m.__filtered__ ? m.__takeCount__ = Xt(f, m.__takeCount__) : m.__views__.push({
            size: Xt(f, re),
            type: o + (m.__dir__ < 0 ? "Right" : "")
          }), m;
        }, Le.prototype[o + "Right"] = function(f) {
          return this.reverse()[o](f).reverse();
        };
      }), Lr(["filter", "map", "takeWhile"], function(o, l) {
        var f = l + 1, m = f == te || f == Z;
        Le.prototype[o] = function(w) {
          var T = this.clone();
          return T.__iteratees__.push({
            iteratee: we(w, 3),
            type: f
          }), T.__filtered__ = T.__filtered__ || m, T;
        };
      }), Lr(["head", "last"], function(o, l) {
        var f = "take" + (l ? "Right" : "");
        Le.prototype[o] = function() {
          return this[f](1).value()[0];
        };
      }), Lr(["initial", "tail"], function(o, l) {
        var f = "drop" + (l ? "" : "Right");
        Le.prototype[o] = function() {
          return this.__filtered__ ? new Le(this) : this[f](1);
        };
      }), Le.prototype.compact = function() {
        return this.filter(mr);
      }, Le.prototype.find = function(o) {
        return this.filter(o).head();
      }, Le.prototype.findLast = function(o) {
        return this.reverse().find(o);
      }, Le.prototype.invokeMap = Re(function(o, l) {
        return typeof o == "function" ? new Le(this) : this.map(function(f) {
          return Eo(f, o, l);
        });
      }), Le.prototype.reject = function(o) {
        return this.filter(mc(we(o)));
      }, Le.prototype.slice = function(o, l) {
        o = Ae(o);
        var f = this;
        return f.__filtered__ && (o > 0 || l < 0) ? new Le(f) : (o < 0 ? f = f.takeRight(-o) : o && (f = f.drop(o)), l !== t && (l = Ae(l), f = l < 0 ? f.dropRight(-l) : f.take(l - o)), f);
      }, Le.prototype.takeRightWhile = function(o) {
        return this.reverse().takeWhile(o).reverse();
      }, Le.prototype.toArray = function() {
        return this.take(re);
      }, gn(Le.prototype, function(o, l) {
        var f = /^(?:filter|find|map|reject)|While$/.test(l), m = /^(?:head|last)$/.test(l), w = S[m ? "take" + (l == "last" ? "Right" : "") : l], T = m || /^find/.test(l);
        w && (S.prototype[l] = function() {
          var I = this.__wrapped__, M = m ? [1] : arguments, N = I instanceof Le, q = M[0], K = N || Oe(I), J = function(Fe) {
            var Ve = w.apply(S, ei([Fe], M));
            return m && ae ? Ve[0] : Ve;
          };
          K && f && typeof q == "function" && q.length != 1 && (N = K = !1);
          var ae = this.__chain__, ve = !!this.__actions__.length, xe = T && !ae, De = N && !ve;
          if (!T && K) {
            I = De ? I : new Le(this);
            var _e = o.apply(I, M);
            return _e.__actions__.push({ func: dc, args: [J], thisArg: t }), new Br(_e, ae);
          }
          return xe && De ? o.apply(this, M) : (_e = this.thru(J), xe ? m ? _e.value()[0] : _e.value() : _e);
        });
      }), Lr(["pop", "push", "shift", "sort", "splice", "unshift"], function(o) {
        var l = Na[o], f = /^(?:push|sort|unshift)$/.test(o) ? "tap" : "thru", m = /^(?:pop|shift)$/.test(o);
        S.prototype[o] = function() {
          var w = arguments;
          if (m && !this.__chain__) {
            var T = this.value();
            return l.apply(Oe(T) ? T : [], w);
          }
          return this[f](function(I) {
            return l.apply(Oe(I) ? I : [], w);
          });
        };
      }), gn(Le.prototype, function(o, l) {
        var f = S[l];
        if (f) {
          var m = f.name + "";
          Je.call(Es, m) || (Es[m] = []), Es[m].push({ name: l, func: f });
        }
      }), Es[sc(t, C).name] = [{
        name: "wrapper",
        func: t
      }], Le.prototype.clone = RS, Le.prototype.reverse = jS, Le.prototype.value = FS, S.prototype.at = h2, S.prototype.chain = d2, S.prototype.commit = f2, S.prototype.next = p2, S.prototype.plant = m2, S.prototype.reverse = v2, S.prototype.toJSON = S.prototype.valueOf = S.prototype.value = y2, S.prototype.first = S.prototype.head, bo && (S.prototype[bo] = g2), S;
    }, Ss = fS();
    Oi ? ((Oi.exports = Ss)._ = Ss, Ou._ = Ss) : Ht._ = Ss;
  }).call(Do);
})(ul, ul.exports);
var Xe = ul.exports;
const s4 = () => {
  const { trackItemIds: r, trackItemsMap: e, fps: t, trackItemDetailsMap: n } = Qi(), i = Xe.merge(e, n);
  return /* @__PURE__ */ b.jsx(b.Fragment, { children: r.map((s) => {
    const a = i[s];
    return i4[a.type](a, {
      fps: t
    });
  }) });
};
var Db = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(r) {
  (function() {
    var e = {}.hasOwnProperty;
    function t() {
      for (var s = "", a = 0; a < arguments.length; a++) {
        var c = arguments[a];
        c && (s = i(s, n(c)));
      }
      return s;
    }
    function n(s) {
      if (typeof s == "string" || typeof s == "number")
        return s;
      if (typeof s != "object")
        return "";
      if (Array.isArray(s))
        return t.apply(null, s);
      if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]"))
        return s.toString();
      var a = "";
      for (var c in s)
        e.call(s, c) && s[c] && (a = i(a, c));
      return a;
    }
    function i(s, a) {
      return a ? s ? s + " " + a : s + a : s;
    }
    r.exports ? (t.default = t, r.exports = t) : window.classNames = t;
  })();
})(Db);
var o4 = Db.exports;
const Wo = /* @__PURE__ */ C5(o4), a4 = { asChild: { type: "boolean" } }, c4 = { width: { type: "string", className: "rt-r-w", customProperties: ["--width"], responsive: !0 }, minWidth: { type: "string", className: "rt-r-min-w", customProperties: ["--min-width"], responsive: !0 }, maxWidth: { type: "string", className: "rt-r-max-w", customProperties: ["--max-width"], responsive: !0 } }, l4 = { height: { type: "string", className: "rt-r-h", customProperties: ["--height"], responsive: !0 }, minHeight: { type: "string", className: "rt-r-min-h", customProperties: ["--min-height"], responsive: !0 }, maxHeight: { type: "string", className: "rt-r-max-h", customProperties: ["--max-height"], responsive: !0 } }, Gf = ["initial", "xs", "sm", "md", "lg", "xl"];
function Rb(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
function Xo(r) {
  return typeof r == "object" && Object.keys(r).some((e) => Gf.includes(e));
}
function u4({ className: r, customProperties: e, ...t }) {
  const n = jb({ allowArbitraryValues: !0, className: r, ...t }), i = h4({ customProperties: e, ...t });
  return [n, i];
}
function jb({ allowArbitraryValues: r, value: e, className: t, propValues: n, parseValue: i = (s) => s }) {
  const s = [];
  if (e) {
    if (typeof e == "string" && n.includes(e)) return i0(t, e, i);
    if (Xo(e)) {
      const a = e;
      for (const c in a) {
        if (!Rb(a, c) || !Gf.includes(c)) continue;
        const u = a[c];
        if (u !== void 0) {
          if (n.includes(u)) {
            const h = i0(t, u, i), d = c === "initial" ? h : `${c}:${h}`;
            s.push(d);
          } else if (r) {
            const h = c === "initial" ? t : `${c}:${t}`;
            s.push(h);
          }
        }
      }
      return s.join(" ");
    }
    if (r) return t;
  }
}
function i0(r, e, t) {
  const n = r ? "-" : "", i = t(e), s = i?.startsWith("-"), a = s ? "-" : "", c = s ? i?.substring(1) : i;
  return `${a}${r}${n}${c}`;
}
function h4({ customProperties: r, value: e, propValues: t, parseValue: n = (i) => i }) {
  let i = {};
  if (!(!e || typeof e == "string" && t.includes(e))) {
    if (typeof e == "string" && (i = Object.fromEntries(r.map((s) => [s, e]))), Xo(e)) {
      const s = e;
      for (const a in s) {
        if (!Rb(s, a) || !Gf.includes(a)) continue;
        const c = s[a];
        if (!t.includes(c)) for (const u of r) i = { [a === "initial" ? u : `${u}-${a}`]: c, ...i };
      }
    }
    for (const s in i) {
      const a = i[s];
      a !== void 0 && (i[s] = n(a));
    }
    return i;
  }
}
function s0(...r) {
  let e = {};
  for (const t of r) t && (e = { ...e, ...t });
  return Object.keys(e).length ? e : void 0;
}
function d4(...r) {
  return Object.assign({}, ...r);
}
function f4(r, ...e) {
  let t, n;
  const i = { ...r }, s = d4(...e);
  for (const a in s) {
    let c = i[a];
    const u = s[a];
    if (u.default !== void 0 && c === void 0 && (c = u.default), u.type === "enum" && ![u.default, ...u.values].includes(c) && !Xo(c) && (c = u.default), i[a] = c, "className" in u && u.className) {
      delete i[a];
      const h = "responsive" in u;
      if (!c || Xo(c) && !h) continue;
      if (Xo(c) && (u.default !== void 0 && c.initial === void 0 && (c.initial = u.default), u.type === "enum" && ([u.default, ...u.values].includes(c.initial) || (c.initial = u.default))), u.type === "enum") {
        const d = jb({ allowArbitraryValues: !1, value: c, className: u.className, propValues: u.values, parseValue: u.parseValue });
        t = Wo(t, d);
        continue;
      }
      if (u.type === "string" || u.type === "enum | string") {
        const d = u.type === "string" ? [] : u.values, [p, g] = u4({ className: u.className, customProperties: u.customProperties, propValues: d, parseValue: u.parseValue, value: c });
        n = s0(n, g), t = Wo(t, p);
        continue;
      }
      if (u.type === "boolean" && c) {
        t = Wo(t, u.className);
        continue;
      }
    }
  }
  return i.className = Wo(t, r.className), i.style = s0(n, r.style), i;
}
const Li = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9"], p4 = { m: { type: "enum | string", values: Li, responsive: !0, className: "rt-r-m", customProperties: ["--m"] }, mx: { type: "enum | string", values: Li, responsive: !0, className: "rt-r-mx", customProperties: ["--ml", "--mr"] }, my: { type: "enum | string", values: Li, responsive: !0, className: "rt-r-my", customProperties: ["--mt", "--mb"] }, mt: { type: "enum | string", values: Li, responsive: !0, className: "rt-r-mt", customProperties: ["--mt"] }, mr: { type: "enum | string", values: Li, responsive: !0, className: "rt-r-mr", customProperties: ["--mr"] }, mb: { type: "enum | string", values: Li, responsive: !0, className: "rt-r-mb", customProperties: ["--mb"] }, ml: { type: "enum | string", values: Li, responsive: !0, className: "rt-r-ml", customProperties: ["--ml"] } }, g4 = M5, Ni = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], m4 = { p: { type: "enum | string", className: "rt-r-p", customProperties: ["--p"], values: Ni, responsive: !0 }, px: { type: "enum | string", className: "rt-r-px", customProperties: ["--pl", "--pr"], values: Ni, responsive: !0 }, py: { type: "enum | string", className: "rt-r-py", customProperties: ["--pt", "--pb"], values: Ni, responsive: !0 }, pt: { type: "enum | string", className: "rt-r-pt", customProperties: ["--pt"], values: Ni, responsive: !0 }, pr: { type: "enum | string", className: "rt-r-pr", customProperties: ["--pr"], values: Ni, responsive: !0 }, pb: { type: "enum | string", className: "rt-r-pb", customProperties: ["--pb"], values: Ni, responsive: !0 }, pl: { type: "enum | string", className: "rt-r-pl", customProperties: ["--pl"], values: Ni, responsive: !0 } }, Wh = ["visible", "hidden", "clip", "scroll", "auto"], v4 = ["static", "relative", "absolute", "fixed", "sticky"], Bo = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9"], y4 = ["0", "1"], b4 = ["0", "1"], w4 = { ...m4, ...c4, ...l4, position: { type: "enum", className: "rt-r-position", values: v4, responsive: !0 }, inset: { type: "enum | string", className: "rt-r-inset", customProperties: ["--inset"], values: Bo, responsive: !0 }, top: { type: "enum | string", className: "rt-r-top", customProperties: ["--top"], values: Bo, responsive: !0 }, right: { type: "enum | string", className: "rt-r-right", customProperties: ["--right"], values: Bo, responsive: !0 }, bottom: { type: "enum | string", className: "rt-r-bottom", customProperties: ["--bottom"], values: Bo, responsive: !0 }, left: { type: "enum | string", className: "rt-r-left", customProperties: ["--left"], values: Bo, responsive: !0 }, overflow: { type: "enum", className: "rt-r-overflow", values: Wh, responsive: !0 }, overflowX: { type: "enum", className: "rt-r-ox", values: Wh, responsive: !0 }, overflowY: { type: "enum", className: "rt-r-oy", values: Wh, responsive: !0 }, flexBasis: { type: "string", className: "rt-r-fb", customProperties: ["--flex-basis"], responsive: !0 }, flexShrink: { type: "enum | string", className: "rt-r-fs", customProperties: ["--flex-shrink"], values: y4, responsive: !0 }, flexGrow: { type: "enum | string", className: "rt-r-fg", customProperties: ["--flex-grow"], values: b4, responsive: !0 }, gridArea: { type: "string", className: "rt-r-ga", customProperties: ["--grid-area"], responsive: !0 }, gridColumn: { type: "string", className: "rt-r-gc", customProperties: ["--grid-column"], responsive: !0 }, gridColumnStart: { type: "string", className: "rt-r-gcs", customProperties: ["--grid-column-start"], responsive: !0 }, gridColumnEnd: { type: "string", className: "rt-r-gce", customProperties: ["--grid-column-end"], responsive: !0 }, gridRow: { type: "string", className: "rt-r-gr", customProperties: ["--grid-row"], responsive: !0 }, gridRowStart: { type: "string", className: "rt-r-grs", customProperties: ["--grid-row-start"], responsive: !0 }, gridRowEnd: { type: "string", className: "rt-r-gre", customProperties: ["--grid-row-end"], responsive: !0 } }, Hh = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], x4 = { gap: { type: "enum | string", className: "rt-r-gap", customProperties: ["--gap"], values: Hh, responsive: !0 }, gapX: { type: "enum | string", className: "rt-r-cg", customProperties: ["--column-gap"], values: Hh, responsive: !0 }, gapY: { type: "enum | string", className: "rt-r-rg", customProperties: ["--row-gap"], values: Hh, responsive: !0 } }, _4 = ["div", "span"], S4 = ["none", "inline-flex", "flex"], C4 = ["row", "column", "row-reverse", "column-reverse"], T4 = ["start", "center", "end", "baseline", "stretch"], E4 = ["start", "center", "end", "between"], k4 = ["nowrap", "wrap", "wrap-reverse"], O4 = { as: { type: "enum", values: _4, default: "div" }, ...a4, display: { type: "enum", className: "rt-r-display", values: S4, responsive: !0 }, direction: { type: "enum", className: "rt-r-fd", values: C4, responsive: !0 }, align: { type: "enum", className: "rt-r-ai", values: T4, responsive: !0 }, justify: { type: "enum", className: "rt-r-jc", values: E4, parseValue: I4, responsive: !0 }, wrap: { type: "enum", className: "rt-r-fw", values: k4, responsive: !0 }, ...x4 };
function I4(r) {
  return r === "between" ? "space-between" : r;
}
const qf = W.forwardRef((r, e) => {
  const { className: t, asChild: n, as: i = "div", ...s } = f4(r, O4, w4, p4);
  return W.createElement(n ? g4 : i, { ...s, ref: e, className: Wo("rt-Flex", t) });
});
qf.displayName = "Flex";
const A4 = () => {
  const r = be(null), { setPlayerRef: e, duration: t, fps: n, size: i } = Qi();
  return ue(() => {
    e(r);
  }, []), /* @__PURE__ */ b.jsx(qf, { className: "size-full", children: /* @__PURE__ */ b.jsx(
    ZD,
    {
      ref: r,
      component: s4,
      durationInFrames: Math.round(t / 1e3 * n) || 5 * 30,
      compositionWidth: 1920,
      compositionHeight: 1080,
      style: { width: "100%", height: "100%" },
      inputProps: {},
      fps: n,
      controls: !0
    }
  ) });
}, M4 = ({ scrollLeft: r }) => {
  const e = be(null), { playerRef: t, fps: n, scale: i } = Qi(), s = kf(t ?? void 0), a = Ot(s / n * 1e3, i.zoom) - r, [c, u] = he(!1), [h, d] = he(0), [p, g] = he(a), v = () => {
    u(!1);
  }, y = (_) => {
    u(!0);
    const C = "touches" in _ ? _.touches[0].clientX : _.clientX;
    d(C), g(a);
  }, x = (_) => {
    if (c) {
      const E = ("touches" in _ ? _.touches[0].clientX : _.clientX) - h, k = p + E, O = Ji(k, i.zoom);
      t?.current?.seekTo(O * n / 1e3);
    }
  };
  return ue(() => {
    const _ = (C) => {
      C.preventDefault();
    };
    return c ? (document.addEventListener("mousemove", x), document.addEventListener("mouseup", v), document.addEventListener("touchmove", x), document.addEventListener("touchend", v), document.addEventListener("dragstart", _)) : (document.removeEventListener("mousemove", x), document.removeEventListener("mouseup", v), document.removeEventListener("touchmove", x), document.removeEventListener("touchend", v)), () => {
      document.removeEventListener("mousemove", x), document.removeEventListener("mouseup", v), document.removeEventListener("touchmove", x), document.removeEventListener("touchend", v), document.removeEventListener("dragstart", _);
    };
  }, [c, x, v]), /* @__PURE__ */ b.jsx(
    "div",
    {
      ref: e,
      role: "button",
      tabIndex: 0,
      onMouseDown: (_) => {
        y(_);
      },
      onTouchStart: (_) => {
        y(_);
      },
      onKeyDown: (_) => {
        (_.key === "Enter" || _.key === " ") && y(_);
      },
      style: {
        position: "absolute",
        left: 40 + Ef + a,
        top: 80,
        width: 1,
        height: "calc(100% - 80px)",
        background: "#d4d4d8",
        zIndex: 10,
        cursor: "pointer"
      },
      children: /* @__PURE__ */ b.jsxs("div", { className: "relative h-full", children: [
        /* @__PURE__ */ b.jsx("div", { className: "absolute top-0  h-full w-3 -translate-x-1/2" }),
        /* @__PURE__ */ b.jsx("div", { className: "absolute top-0  h-full w-0.5 -translate-x-1/2 bg-white/50" }),
        /* @__PURE__ */ b.jsx(
          "div",
          {
            style: {
              borderRadius: "0 0 20px 20px"
            },
            className: "absolute h-3 -translate-x-1/2 px-1.5",
            children: /* @__PURE__ */ b.jsx(
              "svg",
              {
                height: "12",
                viewBox: "0 0 12 12",
                fill: "none",
                children: /* @__PURE__ */ b.jsx(
                  "path",
                  {
                    fill: "currentColor",
                    d: "M11.6585 7.04881L6.6585 11.4238C6.28148 11.7537 5.71852 11.7537 5.3415 11.4238L0.341495 7.04881C0.12448 6.85892 0 6.58459 0 6.29623V1C0 0.447715 0.447715 0 1 0H11C11.5523 0 12 0.447715 12 1V6.29623C12 6.58459 11.8755 6.85892 11.6585 7.04881Z"
                  }
                )
              }
            )
          }
        )
      ] })
    }
  );
}, P4 = (r) => {
  const {
    height: e = 40,
    // Increased height to give space for the text
    longLineSize: t = 8,
    shortLineSize: n = 6,
    offsetX: i = Od + Ef,
    textOffsetY: s = 12,
    // Place the text above the lines but inside the canvas
    textFormat: a = eA,
    scrollLeft: c = 0,
    onClick: u
  } = r, { scale: h } = Qi(), d = be(null), [p, g] = he(null), [v, y] = he({
    width: 0,
    height: e
    // Increased height for text space
  });
  ue(() => {
    const E = d.current;
    if (E) {
      const k = E.getContext("2d");
      g(k), x(E, k, c);
    }
  }, []), ue(() => {
    p && x(d.current, p, c);
  }, [p, c, h]);
  const x = (E, k, O) => {
    if (!E || !k) return;
    const j = E.offsetParent.offsetWidth ?? E.offsetWidth, V = v.height;
    E.width = j, E.height = V, _(k, O, j, V), y({ width: j, height: V });
  }, _ = (E, k, O, P) => {
    const j = h.zoom, V = h.unit, F = h.segments;
    E.clearRect(0, 0, O, P), E.save(), E.strokeStyle = "#71717a", E.fillStyle = "#71717a", E.lineWidth = 1, E.font = `${GI}px ${qI}`, E.textBaseline = "top", E.translate(0.5, 0), E.beginPath();
    const $ = V * j * Vl, z = Math.floor(k / $), H = Math.ceil((k + O) / $) - z;
    for (let Y = 0; Y <= H; ++Y) {
      const te = Y + z;
      if (te < 0) continue;
      const ge = te * $ / j, Z = (ge - k / j) * j;
      if (Z < -$ || Z >= O + $) continue;
      const de = a(ge), ie = -E.measureText(de).width / 2;
      E.fillText(de, Z + ie + i, s);
    }
    for (let Y = 0; Y <= H; ++Y) {
      const te = Y + z;
      if (te < 0) continue;
      const Z = te * $ - k + i;
      for (let de = 0; de < F; ++de) {
        const oe = Z + de / F * $;
        if (oe < 0 || oe >= O) continue;
        const ie = de % F ? n : t;
        ie === n ? E.strokeStyle = "#a1a1aa" : E.strokeStyle = "#d4d4d8";
        const pe = 32, [re, Be] = [oe, pe], [Ze, ze] = [re, Be + ie];
        E.beginPath(), E.moveTo(re, Be), E.lineTo(Ze, ze), E.stroke();
      }
    }
    E.restore();
  }, C = (E) => {
    const k = d.current;
    if (!k) return;
    const O = k.getBoundingClientRect(), j = E.clientX - O.left + c - Od;
    u?.(j);
  };
  return /* @__PURE__ */ b.jsx(
    "div",
    {
      className: "border-border border-t",
      style: {
        position: "relative",
        width: "100%",
        height: `${v.height}px`,
        backgroundColor: "transparent"
      },
      children: /* @__PURE__ */ b.jsx(
        "canvas",
        {
          onClick: C,
          ref: d,
          height: v.height
        }
      )
    }
  );
}, t9 = () => /* @__PURE__ */ b.jsx(
  qf,
  {
    flexGrow: "1",
    justify: "center",
    width: "100%",
    height: "100%",
    className: "bg-scene py-3",
    children: /* @__PURE__ */ b.jsx("div", { className: "max-w-3xl flex-1  w-full h-full flex relative", children: /* @__PURE__ */ b.jsx(A4, {}) })
  }
);
function R(r, e, t) {
  return (e = function(n) {
    var i = function(s, a) {
      if (typeof s != "object" || !s) return s;
      var c = s[Symbol.toPrimitive];
      if (c !== void 0) {
        var u = c.call(s, a);
        if (typeof u != "object") return u;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (a === "string" ? String : Number)(s);
    }(n, "string");
    return typeof i == "symbol" ? i : i + "";
  }(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function o0(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function D(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? o0(Object(t), !0).forEach(function(n) {
      R(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : o0(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function ht(r, e) {
  if (r == null) return {};
  var t, n, i = function(a, c) {
    if (a == null) return {};
    var u = {};
    for (var h in a) if ({}.hasOwnProperty.call(a, h)) {
      if (c.indexOf(h) >= 0) continue;
      u[h] = a[h];
    }
    return u;
  }(r, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) >= 0 || {}.propertyIsEnumerable.call(r, t) && (i[t] = r[t]);
  }
  return i;
}
function Ci(r, e) {
  return e || (e = r.slice(0)), Object.freeze(Object.defineProperties(r, { raw: { value: Object.freeze(e) } }));
}
class a0 {
  constructor() {
    R(this, "browserShadowBlurConstant", 1), R(this, "DPI", 96), R(this, "devicePixelRatio", typeof window < "u" ? window.devicePixelRatio : 1), R(this, "perfLimitSizeTotal", 2097152), R(this, "maxCacheSideLimit", 4096), R(this, "minCacheSideLimit", 256), R(this, "disableStyleCopyPaste", !1), R(this, "enableGLFiltering", !0), R(this, "textureSize", 4096), R(this, "forceGLPutImageData", !1), R(this, "cachesBoundsOfCurve", !1), R(this, "fontPaths", {}), R(this, "NUM_FRACTION_DIGITS", 4);
  }
}
const Ue = new class extends a0 {
  constructor(r) {
    super(), this.configure(r);
  }
  configure() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.assign(this, r);
  }
  addFonts() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.fontPaths = D(D({}, this.fontPaths), r);
  }
  removeFonts() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((r) => {
      delete this.fontPaths[r];
    });
  }
  clearFonts() {
    this.fontPaths = {};
  }
  restoreDefaults(r) {
    const e = new a0(), t = r?.reduce((n, i) => (n[i] = e[i], n), {}) || e;
    this.configure(t);
  }
}(), pi = function(r) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) t[n - 1] = arguments[n];
  return console[r]("fabric", ...t);
};
class xn extends Error {
  constructor(e, t) {
    super("fabric: ".concat(e), t);
  }
}
class Fb extends xn {
  constructor(e) {
    super("".concat(e, " 'options.signal' is in 'aborted' state"));
  }
}
class D4 {
}
class R4 extends D4 {
  testPrecision(e, t) {
    const n = "precision ".concat(t, ` float;
void main(){}`), i = e.createShader(e.FRAGMENT_SHADER);
    return !!i && (e.shaderSource(i, n), e.compileShader(i), !!e.getShaderParameter(i, e.COMPILE_STATUS));
  }
  queryWebGL(e) {
    const t = e.getContext("webgl");
    t && (this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), this.GLPrecision = ["highp", "mediump", "lowp"].find((n) => this.testPrecision(t, n)), t.getExtension("WEBGL_lose_context").loseContext(), pi("log", "WebGL: max texture size ".concat(this.maxTextureSize)));
  }
  isSupported(e) {
    return !!this.maxTextureSize && this.maxTextureSize >= e;
  }
}
const j4 = {};
let c0;
const En = () => c0 || (c0 = { document, window, isTouchSupported: "ontouchstart" in window || "ontouchstart" in document || window && window.navigator && window.navigator.maxTouchPoints > 0, WebGLProbe: new R4(), dispose() {
}, copyPasteData: j4 }), co = () => En().document, Ql = () => En().window, Lb = () => {
  var r;
  return Math.max((r = Ue.devicePixelRatio) !== null && r !== void 0 ? r : Ql().devicePixelRatio, 1);
}, Go = new class {
  constructor() {
    R(this, "charWidthsCache", {}), R(this, "boundsOfCurveCache", {});
  }
  getFontCache(r) {
    let { fontFamily: e, fontStyle: t, fontWeight: n } = r;
    e = e.toLowerCase(), this.charWidthsCache[e] || (this.charWidthsCache[e] = {});
    const i = this.charWidthsCache[e], s = "".concat(t.toLowerCase(), "_").concat((n + "").toLowerCase());
    return i[s] || (i[s] = {}), i[s];
  }
  clearFontCache(r) {
    (r = (r || "").toLowerCase()) ? this.charWidthsCache[r] && delete this.charWidthsCache[r] : this.charWidthsCache = {};
  }
  limitDimsByArea(r) {
    const { perfLimitSizeTotal: e } = Ue, t = Math.sqrt(e * r);
    return [Math.floor(t), Math.floor(e / t)];
  }
}(), Wd = "6.5.4";
function Ki() {
}
const gi = Math.PI / 2, qn = 2 * Math.PI, Kf = Math.PI / 180, or = Object.freeze([1, 0, 0, 1, 0, 0]), Zf = 16, ui = 0.4477152502, Pe = "center", Ke = "left", vr = "top", Hd = "bottom", Ct = "right", yr = "none", Jf = /\r?\n/, Nb = "moving", eu = "scaling", Bb = "rotating", Qf = "rotate", Vb = "skewing", na = "resizing", zb = "modifyPoly", F4 = "modifyPath", hl = "changed", tu = "scale", ar = "scaleX", Dr = "scaleY", lo = "skewX", uo = "skewY", Lt = "fill", br = "stroke", dl = "modified", Rs = "json", Uh = "svg", ne = new class {
  constructor() {
    this[Rs] = /* @__PURE__ */ new Map(), this[Uh] = /* @__PURE__ */ new Map();
  }
  has(r) {
    return this[Rs].has(r);
  }
  getClass(r) {
    const e = this[Rs].get(r);
    if (!e) throw new xn("No class registered for ".concat(r));
    return e;
  }
  setClass(r, e) {
    e ? this[Rs].set(e, r) : (this[Rs].set(r.type, r), this[Rs].set(r.type.toLowerCase(), r));
  }
  getSVGClass(r) {
    return this[Uh].get(r);
  }
  setSVGClass(r, e) {
    this[Uh].set(e ?? r.type.toLowerCase(), r);
  }
}(), fl = new class extends Array {
  remove(r) {
    const e = this.indexOf(r);
    e > -1 && this.splice(e, 1);
  }
  cancelAll() {
    const r = this.splice(0);
    return r.forEach((e) => e.abort()), r;
  }
  cancelByCanvas(r) {
    if (!r) return [];
    const e = this.filter((t) => {
      var n;
      return t.target === r || typeof t.target == "object" && ((n = t.target) === null || n === void 0 ? void 0 : n.canvas) === r;
    });
    return e.forEach((t) => t.abort()), e;
  }
  cancelByTarget(r) {
    if (!r) return [];
    const e = this.filter((t) => t.target === r);
    return e.forEach((t) => t.abort()), e;
  }
}();
class L4 {
  constructor() {
    R(this, "__eventListeners", {});
  }
  on(e, t) {
    if (this.__eventListeners || (this.__eventListeners = {}), typeof e == "object") return Object.entries(e).forEach((n) => {
      let [i, s] = n;
      this.on(i, s);
    }), () => this.off(e);
    if (t) {
      const n = e;
      return this.__eventListeners[n] || (this.__eventListeners[n] = []), this.__eventListeners[n].push(t), () => this.off(n, t);
    }
    return () => !1;
  }
  once(e, t) {
    if (typeof e == "object") {
      const n = [];
      return Object.entries(e).forEach((i) => {
        let [s, a] = i;
        n.push(this.once(s, a));
      }), () => n.forEach((i) => i());
    }
    if (t) {
      const n = this.on(e, function() {
        for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++) s[a] = arguments[a];
        t.call(this, ...s), n();
      });
      return n;
    }
    return () => !1;
  }
  _removeEventListener(e, t) {
    if (this.__eventListeners[e]) if (t) {
      const n = this.__eventListeners[e], i = n.indexOf(t);
      i > -1 && n.splice(i, 1);
    } else this.__eventListeners[e] = [];
  }
  off(e, t) {
    if (this.__eventListeners) if (e === void 0) for (const n in this.__eventListeners) this._removeEventListener(n);
    else typeof e == "object" ? Object.entries(e).forEach((n) => {
      let [i, s] = n;
      this._removeEventListener(i, s);
    }) : this._removeEventListener(e, t);
  }
  fire(e, t) {
    var n;
    if (!this.__eventListeners) return;
    const i = (n = this.__eventListeners[e]) === null || n === void 0 ? void 0 : n.concat();
    if (i) for (let s = 0; s < i.length; s++) i[s].call(this, t || {});
  }
}
const zi = (r, e) => {
  const t = r.indexOf(e);
  return t !== -1 && r.splice(t, 1), r;
}, cn = (r) => {
  if (r === 0) return 1;
  switch (Math.abs(r) / gi) {
    case 1:
    case 3:
      return 0;
    case 2:
      return -1;
  }
  return Math.cos(r);
}, ln = (r) => {
  if (r === 0) return 0;
  const e = r / gi, t = Math.sign(r);
  switch (e) {
    case 1:
      return t;
    case 2:
      return 0;
    case 3:
      return -t;
  }
  return Math.sin(r);
};
class B {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    typeof e == "object" ? (this.x = e.x, this.y = e.y) : (this.x = e, this.y = t);
  }
  add(e) {
    return new B(this.x + e.x, this.y + e.y);
  }
  addEquals(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  scalarAdd(e) {
    return new B(this.x + e, this.y + e);
  }
  scalarAddEquals(e) {
    return this.x += e, this.y += e, this;
  }
  subtract(e) {
    return new B(this.x - e.x, this.y - e.y);
  }
  subtractEquals(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  scalarSubtract(e) {
    return new B(this.x - e, this.y - e);
  }
  scalarSubtractEquals(e) {
    return this.x -= e, this.y -= e, this;
  }
  multiply(e) {
    return new B(this.x * e.x, this.y * e.y);
  }
  scalarMultiply(e) {
    return new B(this.x * e, this.y * e);
  }
  scalarMultiplyEquals(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return new B(this.x / e.x, this.y / e.y);
  }
  scalarDivide(e) {
    return new B(this.x / e, this.y / e);
  }
  scalarDivideEquals(e) {
    return this.x /= e, this.y /= e, this;
  }
  eq(e) {
    return this.x === e.x && this.y === e.y;
  }
  lt(e) {
    return this.x < e.x && this.y < e.y;
  }
  lte(e) {
    return this.x <= e.x && this.y <= e.y;
  }
  gt(e) {
    return this.x > e.x && this.y > e.y;
  }
  gte(e) {
    return this.x >= e.x && this.y >= e.y;
  }
  lerp(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;
    return t = Math.max(Math.min(1, t), 0), new B(this.x + (e.x - this.x) * t, this.y + (e.y - this.y) * t);
  }
  distanceFrom(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return Math.sqrt(t * t + n * n);
  }
  midPointFrom(e) {
    return this.lerp(e);
  }
  min(e) {
    return new B(Math.min(this.x, e.x), Math.min(this.y, e.y));
  }
  max(e) {
    return new B(Math.max(this.x, e.x), Math.max(this.y, e.y));
  }
  toString() {
    return "".concat(this.x, ",").concat(this.y);
  }
  setXY(e, t) {
    return this.x = e, this.y = t, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setFromPoint(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  swap(e) {
    const t = this.x, n = this.y;
    this.x = e.x, this.y = e.y, e.x = t, e.y = n;
  }
  clone() {
    return new B(this.x, this.y);
  }
  rotate(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ep;
    const n = ln(e), i = cn(e), s = this.subtract(t);
    return new B(s.x * i - s.y * n, s.x * n + s.y * i).add(t);
  }
  transform(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    return new B(e[0] * this.x + e[2] * this.y + (t ? 0 : e[4]), e[1] * this.x + e[3] * this.y + (t ? 0 : e[5]));
  }
}
const ep = new B(0, 0), Jc = (r) => !!r && Array.isArray(r._objects);
function Wb(r) {
  class e extends r {
    constructor() {
      super(...arguments), R(this, "_objects", []);
    }
    _onObjectAdded(n) {
    }
    _onObjectRemoved(n) {
    }
    _onStackOrderChanged(n) {
    }
    add() {
      for (var n = arguments.length, i = new Array(n), s = 0; s < n; s++) i[s] = arguments[s];
      const a = this._objects.push(...i);
      return i.forEach((c) => this._onObjectAdded(c)), a;
    }
    insertAt(n) {
      for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++) s[a - 1] = arguments[a];
      return this._objects.splice(n, 0, ...s), s.forEach((c) => this._onObjectAdded(c)), this._objects.length;
    }
    remove() {
      const n = this._objects, i = [];
      for (var s = arguments.length, a = new Array(s), c = 0; c < s; c++) a[c] = arguments[c];
      return a.forEach((u) => {
        const h = n.indexOf(u);
        h !== -1 && (n.splice(h, 1), i.push(u), this._onObjectRemoved(u));
      }), i;
    }
    forEachObject(n) {
      this.getObjects().forEach((i, s, a) => n(i, s, a));
    }
    getObjects() {
      for (var n = arguments.length, i = new Array(n), s = 0; s < n; s++) i[s] = arguments[s];
      return i.length === 0 ? [...this._objects] : this._objects.filter((a) => a.isType(...i));
    }
    item(n) {
      return this._objects[n];
    }
    isEmpty() {
      return this._objects.length === 0;
    }
    size() {
      return this._objects.length;
    }
    contains(n, i) {
      return !!this._objects.includes(n) || !!i && this._objects.some((s) => s instanceof e && s.contains(n, !0));
    }
    complexity() {
      return this._objects.reduce((n, i) => n += i.complexity ? i.complexity() : 0, 0);
    }
    sendObjectToBack(n) {
      return !(!n || n === this._objects[0]) && (zi(this._objects, n), this._objects.unshift(n), this._onStackOrderChanged(n), !0);
    }
    bringObjectToFront(n) {
      return !(!n || n === this._objects[this._objects.length - 1]) && (zi(this._objects, n), this._objects.push(n), this._onStackOrderChanged(n), !0);
    }
    sendObjectBackwards(n, i) {
      if (!n) return !1;
      const s = this._objects.indexOf(n);
      if (s !== 0) {
        const a = this.findNewLowerIndex(n, s, i);
        return zi(this._objects, n), this._objects.splice(a, 0, n), this._onStackOrderChanged(n), !0;
      }
      return !1;
    }
    bringObjectForward(n, i) {
      if (!n) return !1;
      const s = this._objects.indexOf(n);
      if (s !== this._objects.length - 1) {
        const a = this.findNewUpperIndex(n, s, i);
        return zi(this._objects, n), this._objects.splice(a, 0, n), this._onStackOrderChanged(n), !0;
      }
      return !1;
    }
    moveObjectTo(n, i) {
      return n !== this._objects[i] && (zi(this._objects, n), this._objects.splice(i, 0, n), this._onStackOrderChanged(n), !0);
    }
    findNewLowerIndex(n, i, s) {
      let a;
      if (s) {
        a = i;
        for (let c = i - 1; c >= 0; --c) if (n.isOverlapping(this._objects[c])) {
          a = c;
          break;
        }
      } else a = i - 1;
      return a;
    }
    findNewUpperIndex(n, i, s) {
      let a;
      if (s) {
        a = i;
        for (let c = i + 1; c < this._objects.length; ++c) if (n.isOverlapping(this._objects[c])) {
          a = c;
          break;
        }
      } else a = i + 1;
      return a;
    }
    collectObjects(n) {
      let { left: i, top: s, width: a, height: c } = n, { includeIntersecting: u = !0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const h = [], d = new B(i, s), p = d.add(new B(a, c));
      for (let g = this._objects.length - 1; g >= 0; g--) {
        const v = this._objects[g];
        v.selectable && v.visible && (u && v.intersectsWithRect(d, p) || v.isContainedWithinRect(d, p) || u && v.containsPoint(d) || u && v.containsPoint(p)) && h.push(v);
      }
      return h;
    }
  }
  return e;
}
class Hb extends L4 {
  _setOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    for (const t in e) this.set(t, e[t]);
  }
  _setObject(e) {
    for (const t in e) this._set(t, e[t]);
  }
  set(e, t) {
    return typeof e == "object" ? this._setObject(e) : this._set(e, t), this;
  }
  _set(e, t) {
    this[e] = t;
  }
  toggle(e) {
    const t = this.get(e);
    return typeof t == "boolean" && this.set(e, !t), this;
  }
  get(e) {
    return this[e];
  }
}
function qo(r) {
  return Ql().requestAnimationFrame(r);
}
function Ub(r) {
  return Ql().cancelAnimationFrame(r);
}
let N4 = 0;
const mi = () => N4++, Gr = () => {
  const r = co().createElement("canvas");
  if (!r || r.getContext === void 0) throw new xn("Failed to create `canvas` element");
  return r;
}, $b = () => co().createElement("img"), un = (r) => {
  const e = Gr();
  return e.width = r.width, e.height = r.height, e;
}, tp = (r, e, t) => r.toDataURL("image/".concat(e), t), bt = (r) => r * Kf, vi = (r) => r / Kf, Yb = (r) => r.every((e, t) => e === or[t]), qt = (r, e, t) => new B(r).transform(e, t), Pr = (r) => {
  const e = 1 / (r[0] * r[3] - r[1] * r[2]), t = [e * r[3], -e * r[1], -e * r[2], e * r[0], 0, 0], { x: n, y: i } = new B(r[4], r[5]).transform(t, !0);
  return t[4] = -n, t[5] = -i, t;
}, wt = (r, e, t) => [r[0] * e[0] + r[2] * e[1], r[1] * e[0] + r[3] * e[1], r[0] * e[2] + r[2] * e[3], r[1] * e[2] + r[3] * e[3], t ? 0 : r[0] * e[4] + r[2] * e[5] + r[4], t ? 0 : r[1] * e[4] + r[3] * e[5] + r[5]], ru = (r, e) => r.reduceRight((t, n) => n && t ? wt(n, t, e) : n || t, void 0) || or.concat(), Xb = (r) => {
  let [e, t] = r;
  return Math.atan2(t, e);
}, Ys = (r) => {
  const e = Xb(r), t = Math.pow(r[0], 2) + Math.pow(r[1], 2), n = Math.sqrt(t), i = (r[0] * r[3] - r[2] * r[1]) / n, s = Math.atan2(r[0] * r[2] + r[1] * r[3], t);
  return { angle: vi(e), scaleX: n, scaleY: i, skewX: vi(s), skewY: 0, translateX: r[4] || 0, translateY: r[5] || 0 };
}, ho = function(r) {
  return [1, 0, 0, 1, r, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0];
};
function fo() {
  let { angle: r = 0 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { x: e = 0, y: t = 0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const n = bt(r), i = cn(n), s = ln(n);
  return [i, s, -s, i, e ? e - (i * e - s * t) : 0, t ? t - (s * e + i * t) : 0];
}
const nu = function(r) {
  return [r, 0, 0, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : r, 0, 0];
}, Gb = (r) => Math.tan(bt(r)), rp = (r) => [1, 0, Gb(r), 1, 0, 0], np = (r) => [1, Gb(r), 0, 1, 0, 0], xa = (r) => {
  let { scaleX: e = 1, scaleY: t = 1, flipX: n = !1, flipY: i = !1, skewX: s = 0, skewY: a = 0 } = r, c = nu(n ? -e : e, i ? -t : t);
  return s && (c = wt(c, rp(s), !0)), a && (c = wt(c, np(a), !0)), c;
}, qb = (r) => {
  const { translateX: e = 0, translateY: t = 0, angle: n = 0 } = r;
  let i = ho(e, t);
  n && (i = wt(i, fo({ angle: n })));
  const s = xa(r);
  return Yb(s) || (i = wt(i, s)), i;
}, Ko = function(r) {
  let { signal: e, crossOrigin: t = null } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise(function(n, i) {
    if (e && e.aborted) return i(new Fb("loadImage"));
    const s = $b();
    let a;
    e && (a = function(u) {
      s.src = "", i(u);
    }, e.addEventListener("abort", a, { once: !0 }));
    const c = function() {
      s.onload = s.onerror = null, a && e?.removeEventListener("abort", a), n(s);
    };
    r ? (s.onload = c, s.onerror = function() {
      a && e?.removeEventListener("abort", a), i(new xn("Error loading ".concat(s.src)));
    }, t && (s.crossOrigin = t), s.src = r) : c();
  });
}, Xs = function(r) {
  let { signal: e, reviver: t = Ki } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((n, i) => {
    const s = [];
    e && e.addEventListener("abort", i, { once: !0 }), Promise.all(r.map((a) => ne.getClass(a.type).fromObject(a, { signal: e }).then((c) => (t(a, c), s.push(c), c)))).then(n).catch((a) => {
      s.forEach((c) => {
        c.dispose && c.dispose();
      }), i(a);
    }).finally(() => {
      e && e.removeEventListener("abort", i);
    });
  });
}, _a = function(r) {
  let { signal: e } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((t, n) => {
    const i = [];
    e && e.addEventListener("abort", n, { once: !0 });
    const s = Object.values(r).map((c) => c && c.type && ne.has(c.type) ? Xs([c], { signal: e }).then((u) => {
      let [h] = u;
      return i.push(h), h;
    }) : c), a = Object.keys(r);
    Promise.all(s).then((c) => c.reduce((u, h, d) => (u[a[d]] = h, u), {})).then(t).catch((c) => {
      i.forEach((u) => {
        u.dispose && u.dispose();
      }), n(c);
    }).finally(() => {
      e && e.removeEventListener("abort", n);
    });
  });
}, fs = function(r) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []).reduce((e, t) => (t in r && (e[t] = r[t]), e), {});
}, ip = (r, e) => Object.keys(r).reduce((t, n) => (e(r[n], n, r) && (t[n] = r[n]), t), {}), l0 = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aqua: "#0FF", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000", blanchedalmond: "#FFEBCD", blue: "#00F", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#0FF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgrey: "#A9A9A9", darkgreen: "#006400", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", fuchsia: "#F0F", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", gray: "#808080", grey: "#808080", green: "#008000", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgray: "#D3D3D3", lightgrey: "#D3D3D3", lightgreen: "#90EE90", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#789", lightslategrey: "#789", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", lime: "#0F0", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#F0F", maroon: "#800000", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", navy: "#000080", oldlace: "#FDF5E6", olive: "#808000", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", purple: "#800080", rebeccapurple: "#639", red: "#F00", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", silver: "#C0C0C0", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", teal: "#008080", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", white: "#FFF", whitesmoke: "#F5F5F5", yellow: "#FF0", yellowgreen: "#9ACD32" }, $h = (r, e, t) => (t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? r + 6 * (e - r) * t : t < 0.5 ? e : t < 2 / 3 ? r + (e - r) * (2 / 3 - t) * 6 : r), u0 = (r, e, t, n) => {
  r /= 255, e /= 255, t /= 255;
  const i = Math.max(r, e, t), s = Math.min(r, e, t);
  let a, c;
  const u = (i + s) / 2;
  if (i === s) a = c = 0;
  else {
    const h = i - s;
    switch (c = u > 0.5 ? h / (2 - i - s) : h / (i + s), i) {
      case r:
        a = (e - t) / h + (e < t ? 6 : 0);
        break;
      case e:
        a = (t - r) / h + 2;
        break;
      case t:
        a = (r - e) / h + 4;
    }
    a /= 6;
  }
  return [Math.round(360 * a), Math.round(100 * c), Math.round(100 * u), n];
}, h0 = function() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "1";
  return parseFloat(r) / (r.endsWith("%") ? 100 : 1);
}, Tc = (r) => Math.min(Math.round(r), 255).toString(16).toUpperCase().padStart(2, "0"), d0 = (r) => {
  let [e, t, n, i = 1] = r;
  const s = Math.round(0.3 * e + 0.59 * t + 0.11 * n);
  return [s, s, s, i];
};
class Qe {
  constructor(e) {
    if (R(this, "isUnrecognised", !1), e) if (e instanceof Qe) this.setSource([...e._source]);
    else if (Array.isArray(e)) {
      const [t, n, i, s = 1] = e;
      this.setSource([t, n, i, s]);
    } else this.setSource(this._tryParsingColor(e));
    else this.setSource([0, 0, 0, 1]);
  }
  _tryParsingColor(e) {
    return (e = e.toLowerCase()) in l0 && (e = l0[e]), e === "transparent" ? [255, 255, 255, 0] : Qe.sourceFromHex(e) || Qe.sourceFromRgb(e) || Qe.sourceFromHsl(e) || (this.isUnrecognised = !0) && [0, 0, 0, 1];
  }
  getSource() {
    return this._source;
  }
  setSource(e) {
    this._source = e;
  }
  toRgb() {
    const [e, t, n] = this.getSource();
    return "rgb(".concat(e, ",").concat(t, ",").concat(n, ")");
  }
  toRgba() {
    return "rgba(".concat(this.getSource().join(","), ")");
  }
  toHsl() {
    const [e, t, n] = u0(...this.getSource());
    return "hsl(".concat(e, ",").concat(t, "%,").concat(n, "%)");
  }
  toHsla() {
    const [e, t, n, i] = u0(...this.getSource());
    return "hsla(".concat(e, ",").concat(t, "%,").concat(n, "%,").concat(i, ")");
  }
  toHex() {
    return this.toHexa().slice(0, 6);
  }
  toHexa() {
    const [e, t, n, i] = this.getSource();
    return "".concat(Tc(e)).concat(Tc(t)).concat(Tc(n)).concat(Tc(Math.round(255 * i)));
  }
  getAlpha() {
    return this.getSource()[3];
  }
  setAlpha(e) {
    return this._source[3] = e, this;
  }
  toGrayscale() {
    return this.setSource(d0(this.getSource())), this;
  }
  toBlackWhite(e) {
    const [t, , , n] = d0(this.getSource()), i = t < (e || 127) ? 0 : 255;
    return this.setSource([i, i, i, n]), this;
  }
  overlayWith(e) {
    e instanceof Qe || (e = new Qe(e));
    const t = this.getSource(), n = e.getSource(), [i, s, a] = t.map((c, u) => Math.round(0.5 * c + 0.5 * n[u]));
    return this.setSource([i, s, a, t[3]]), this;
  }
  static fromRgb(e) {
    return Qe.fromRgba(e);
  }
  static fromRgba(e) {
    return new Qe(Qe.sourceFromRgb(e));
  }
  static sourceFromRgb(e) {
    const t = e.match(/^rgba?\(\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*(?:\s*[,/]\s*(\d{0,3}(?:\.\d+)?%?)\s*)?\)$/i);
    if (t) {
      const [n, i, s] = t.slice(1, 4).map((a) => {
        const c = parseFloat(a);
        return a.endsWith("%") ? Math.round(2.55 * c) : c;
      });
      return [n, i, s, h0(t[4])];
    }
  }
  static fromHsl(e) {
    return Qe.fromHsla(e);
  }
  static fromHsla(e) {
    return new Qe(Qe.sourceFromHsl(e));
  }
  static sourceFromHsl(e) {
    const t = e.match(/^hsla?\(\s*([+-]?\d{0,3}(?:\.\d+)?(?:deg|turn|rad)?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*(?:\s*[,/]\s*(\d*(?:\.\d+)?%?)\s*)?\)$/i);
    if (!t) return;
    const n = (Qe.parseAngletoDegrees(t[1]) % 360 + 360) % 360 / 360, i = parseFloat(t[2]) / 100, s = parseFloat(t[3]) / 100;
    let a, c, u;
    if (i === 0) a = c = u = s;
    else {
      const h = s <= 0.5 ? s * (i + 1) : s + i - s * i, d = 2 * s - h;
      a = $h(d, h, n + 1 / 3), c = $h(d, h, n), u = $h(d, h, n - 1 / 3);
    }
    return [Math.round(255 * a), Math.round(255 * c), Math.round(255 * u), h0(t[4])];
  }
  static fromHex(e) {
    return new Qe(Qe.sourceFromHex(e));
  }
  static sourceFromHex(e) {
    if (e.match(/^#?(([0-9a-f]){3,4}|([0-9a-f]{2}){3,4})$/i)) {
      const t = e.slice(e.indexOf("#") + 1);
      let n;
      n = t.length <= 4 ? t.split("").map((u) => u + u) : t.match(/.{2}/g);
      const [i, s, a, c = 255] = n.map((u) => parseInt(u, 16));
      return [i, s, a, c / 255];
    }
  }
  static parseAngletoDegrees(e) {
    const t = e.toLowerCase(), n = parseFloat(t);
    return t.includes("rad") ? vi(n) : t.includes("turn") ? 360 * n : n;
  }
}
const ut = (r, e) => parseFloat(Number(r).toFixed(e)), Zi = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Zf;
  const t = /\D{0,2}$/.exec(r), n = parseFloat(r), i = Ue.DPI;
  switch (t?.[0]) {
    case "mm":
      return n * i / 25.4;
    case "cm":
      return n * i / 2.54;
    case "in":
      return n * i;
    case "pt":
      return n * i / 72;
    case "pc":
      return n * i / 72 * 12;
    case "em":
      return n * e;
    default:
      return n;
  }
}, Kb = (r) => {
  const [e, t] = r.trim().split(" "), [n, i] = (s = e) && s !== yr ? [s.slice(1, 4), s.slice(5, 8)] : s === yr ? [s, s] : ["Mid", "Mid"];
  var s;
  return { meetOrSlice: t || "meet", alignX: n, alignY: i };
}, ia = (r) => "matrix(" + r.map((e) => ut(e, Ue.NUM_FRACTION_DIGITS)).join(" ") + ")", sa = function(r, e) {
  let t, n, i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
  if (e) if (e.toLive) t = "url(#SVGID_".concat(e.id, ")");
  else {
    const s = new Qe(e), a = s.getAlpha();
    t = s.toRgb(), a !== 1 && (n = a.toString());
  }
  else t = "none";
  return i ? "".concat(r, ": ").concat(t, "; ").concat(n ? "".concat(r, "-opacity: ").concat(n, "; ") : "") : "".concat(r, '="').concat(t, '" ').concat(n ? "".concat(r, '-opacity="').concat(n, '" ') : "");
}, Yr = (r) => !!r && r.toLive !== void 0, f0 = (r) => !!r && typeof r.toObject == "function", p0 = (r) => !!r && r.offsetX !== void 0 && "source" in r, Wi = (r) => !!r && "multiSelectionStacking" in r;
function Zb(r) {
  const e = r && sn(r);
  let t = 0, n = 0;
  if (!r || !e) return { left: t, top: n };
  let i = r;
  const s = e.documentElement, a = e.body || { scrollLeft: 0, scrollTop: 0 };
  for (; i && (i.parentNode || i.host) && (i = i.parentNode || i.host, i === e ? (t = a.scrollLeft || s.scrollLeft || 0, n = a.scrollTop || s.scrollTop || 0) : (t += i.scrollLeft || 0, n += i.scrollTop || 0), i.nodeType !== 1 || i.style.position !== "fixed"); ) ;
  return { left: t, top: n };
}
const sn = (r) => r.ownerDocument || null, Jb = (r) => {
  var e;
  return ((e = r.ownerDocument) === null || e === void 0 ? void 0 : e.defaultView) || null;
}, Qb = function(r, e, t) {
  let { width: n, height: i } = t, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  r.width = n, r.height = i, s > 1 && (r.setAttribute("width", (n * s).toString()), r.setAttribute("height", (i * s).toString()), e.scale(s, s));
}, Ud = (r, e) => {
  let { width: t, height: n } = e;
  t && (r.style.width = typeof t == "number" ? "".concat(t, "px") : t), n && (r.style.height = typeof n == "number" ? "".concat(n, "px") : n);
};
function g0(r) {
  return r.onselectstart !== void 0 && (r.onselectstart = () => !1), r.style.userSelect = yr, r;
}
class ew {
  constructor(e) {
    R(this, "_originalCanvasStyle", void 0), R(this, "lower", void 0);
    const t = this.createLowerCanvas(e);
    this.lower = { el: t, ctx: t.getContext("2d") };
  }
  createLowerCanvas(e) {
    const t = (n = e) && n.getContext !== void 0 ? e : e && co().getElementById(e) || Gr();
    var n;
    if (t.hasAttribute("data-fabric")) throw new xn("Trying to initialize a canvas that has already been initialized. Did you forget to dispose the canvas?");
    return this._originalCanvasStyle = t.style.cssText, t.setAttribute("data-fabric", "main"), t.classList.add("lower-canvas"), t;
  }
  cleanupDOM(e) {
    let { width: t, height: n } = e;
    const { el: i } = this.lower;
    i.classList.remove("lower-canvas"), i.removeAttribute("data-fabric"), i.setAttribute("width", "".concat(t)), i.setAttribute("height", "".concat(n)), i.style.cssText = this._originalCanvasStyle || "", this._originalCanvasStyle = void 0;
  }
  setDimensions(e, t) {
    const { el: n, ctx: i } = this.lower;
    Qb(n, i, e, t);
  }
  setCSSDimensions(e) {
    Ud(this.lower.el, e);
  }
  calcOffset() {
    return function(e) {
      var t;
      const n = e && sn(e), i = { left: 0, top: 0 };
      if (!n) return i;
      const s = ((t = Jb(e)) === null || t === void 0 ? void 0 : t.getComputedStyle(e, null)) || {};
      i.left += parseInt(s.borderLeftWidth, 10) || 0, i.top += parseInt(s.borderTopWidth, 10) || 0, i.left += parseInt(s.paddingLeft, 10) || 0, i.top += parseInt(s.paddingTop, 10) || 0;
      let a = { left: 0, top: 0 };
      const c = n.documentElement;
      e.getBoundingClientRect !== void 0 && (a = e.getBoundingClientRect());
      const u = Zb(e);
      return { left: a.left + u.left - (c.clientLeft || 0) + i.left, top: a.top + u.top - (c.clientTop || 0) + i.top };
    }(this.lower.el);
  }
  dispose() {
    En().dispose(this.lower.el), delete this.lower;
  }
}
const B4 = { backgroundVpt: !0, backgroundColor: "", overlayVpt: !0, overlayColor: "", includeDefaultValues: !0, svgViewportTransformation: !0, renderOnAddRemove: !0, skipOffscreen: !0, enableRetinaScaling: !0, imageSmoothingEnabled: !0, controlsAboveOverlay: !1, allowTouchScrolling: !1, viewportTransform: [...or] };
class Sa extends Wb(Hb) {
  get lowerCanvasEl() {
    var e;
    return (e = this.elements.lower) === null || e === void 0 ? void 0 : e.el;
  }
  get contextContainer() {
    var e;
    return (e = this.elements.lower) === null || e === void 0 ? void 0 : e.ctx;
  }
  static getDefaults() {
    return Sa.ownDefaults;
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, this.constructor.getDefaults()), this.set(t), this.initElements(e), this._setDimensionsImpl({ width: this.width || this.elements.lower.el.width || 0, height: this.height || this.elements.lower.el.height || 0 }), this.skipControlsDrawing = !1, this.viewportTransform = [...this.viewportTransform], this.calcViewportBoundaries();
  }
  initElements(e) {
    this.elements = new ew(e);
  }
  add() {
    const e = super.add(...arguments);
    return arguments.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), e;
  }
  insertAt(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
    const s = super.insertAt(e, ...n);
    return n.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), s;
  }
  remove() {
    const e = super.remove(...arguments);
    return e.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), e;
  }
  _onObjectAdded(e) {
    e.canvas && e.canvas !== this && (pi("warn", `Canvas is trying to add an object that belongs to a different canvas.
Resulting to default behavior: removing object from previous canvas and adding to new canvas`), e.canvas.remove(e)), e._set("canvas", this), e.setCoords(), this.fire("object:added", { target: e }), e.fire("added", { target: this });
  }
  _onObjectRemoved(e) {
    e._set("canvas", void 0), this.fire("object:removed", { target: e }), e.fire("removed", { target: this });
  }
  _onStackOrderChanged() {
    this.renderOnAddRemove && this.requestRenderAll();
  }
  getRetinaScaling() {
    return this.enableRetinaScaling ? Lb() : 1;
  }
  calcOffset() {
    return this._offset = this.elements.calcOffset();
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  setWidth(e, t) {
    return this.setDimensions({ width: e }, t);
  }
  setHeight(e, t) {
    return this.setDimensions({ height: e }, t);
  }
  _setDimensionsImpl(e) {
    let { cssOnly: t = !1, backstoreOnly: n = !1 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!t) {
      const i = D({ width: this.width, height: this.height }, e);
      this.elements.setDimensions(i, this.getRetinaScaling()), this.hasLostContext = !0, this.width = i.width, this.height = i.height;
    }
    n || this.elements.setCSSDimensions(e), this.calcOffset();
  }
  setDimensions(e, t) {
    this._setDimensionsImpl(e, t), t && t.cssOnly || this.requestRenderAll();
  }
  getZoom() {
    return this.viewportTransform[0];
  }
  setViewportTransform(e) {
    this.viewportTransform = e, this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll();
  }
  zoomToPoint(e, t) {
    const n = e, i = [...this.viewportTransform], s = qt(e, Pr(i));
    i[0] = t, i[3] = t;
    const a = qt(s, i);
    i[4] += n.x - a.x, i[5] += n.y - a.y, this.setViewportTransform(i);
  }
  setZoom(e) {
    this.zoomToPoint(new B(0, 0), e);
  }
  absolutePan(e) {
    const t = [...this.viewportTransform];
    return t[4] = -e.x, t[5] = -e.y, this.setViewportTransform(t);
  }
  relativePan(e) {
    return this.absolutePan(new B(-e.x - this.viewportTransform[4], -e.y - this.viewportTransform[5]));
  }
  getElement() {
    return this.elements.lower.el;
  }
  clearContext(e) {
    e.clearRect(0, 0, this.width, this.height);
  }
  getContext() {
    return this.elements.lower.ctx;
  }
  clear() {
    this.remove(...this.getObjects()), this.backgroundImage = void 0, this.overlayImage = void 0, this.backgroundColor = "", this.overlayColor = "", this.clearContext(this.getContext()), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll();
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || this.renderCanvas(this.getContext(), this._objects);
  }
  renderAndReset() {
    this.nextRenderHandle = 0, this.renderAll();
  }
  requestRenderAll() {
    this.nextRenderHandle || this.disposed || this.destroyed || (this.nextRenderHandle = qo(() => this.renderAndReset()));
  }
  calcViewportBoundaries() {
    const e = this.width, t = this.height, n = Pr(this.viewportTransform), i = qt({ x: 0, y: 0 }, n), s = qt({ x: e, y: t }, n), a = i.min(s), c = i.max(s);
    return this.vptCoords = { tl: a, tr: new B(c.x, a.y), bl: new B(a.x, c.y), br: c };
  }
  cancelRequestedRender() {
    this.nextRenderHandle && (Ub(this.nextRenderHandle), this.nextRenderHandle = 0);
  }
  drawControls(e) {
  }
  renderCanvas(e, t) {
    if (this.destroyed) return;
    const n = this.viewportTransform, i = this.clipPath;
    this.calcViewportBoundaries(), this.clearContext(e), e.imageSmoothingEnabled = this.imageSmoothingEnabled, e.patternQuality = "best", this.fire("before:render", { ctx: e }), this._renderBackground(e), e.save(), e.transform(n[0], n[1], n[2], n[3], n[4], n[5]), this._renderObjects(e, t), e.restore(), this.controlsAboveOverlay || this.skipControlsDrawing || this.drawControls(e), i && (i._set("canvas", this), i.shouldCache(), i._transformDone = !0, i.renderCache({ forClipping: !0 }), this.drawClipPathOnCanvas(e, i)), this._renderOverlay(e), this.controlsAboveOverlay && !this.skipControlsDrawing && this.drawControls(e), this.fire("after:render", { ctx: e }), this.__cleanupTask && (this.__cleanupTask(), this.__cleanupTask = void 0);
  }
  drawClipPathOnCanvas(e, t) {
    const n = this.viewportTransform;
    e.save(), e.transform(...n), e.globalCompositeOperation = "destination-in", t.transform(e), e.scale(1 / t.zoomX, 1 / t.zoomY), e.drawImage(t._cacheCanvas, -t.cacheTranslationX, -t.cacheTranslationY), e.restore();
  }
  _renderObjects(e, t) {
    for (let n = 0, i = t.length; n < i; ++n) t[n] && t[n].render(e);
  }
  _renderBackgroundOrOverlay(e, t) {
    const n = this["".concat(t, "Color")], i = this["".concat(t, "Image")], s = this.viewportTransform, a = this["".concat(t, "Vpt")];
    if (!n && !i) return;
    const c = Yr(n);
    if (n) {
      if (e.save(), e.beginPath(), e.moveTo(0, 0), e.lineTo(this.width, 0), e.lineTo(this.width, this.height), e.lineTo(0, this.height), e.closePath(), e.fillStyle = c ? n.toLive(e) : n, a && e.transform(...s), c) {
        e.transform(1, 0, 0, 1, n.offsetX || 0, n.offsetY || 0);
        const u = n.gradientTransform || n.patternTransform;
        u && e.transform(...u);
      }
      e.fill(), e.restore();
    }
    if (i) {
      e.save();
      const { skipOffscreen: u } = this;
      this.skipOffscreen = a, a && e.transform(...s), i.render(e), this.skipOffscreen = u, e.restore();
    }
  }
  _renderBackground(e) {
    this._renderBackgroundOrOverlay(e, "background");
  }
  _renderOverlay(e) {
    this._renderBackgroundOrOverlay(e, "overlay");
  }
  getCenter() {
    return { top: this.height / 2, left: this.width / 2 };
  }
  getCenterPoint() {
    return new B(this.width / 2, this.height / 2);
  }
  centerObjectH(e) {
    return this._centerObject(e, new B(this.getCenterPoint().x, e.getCenterPoint().y));
  }
  centerObjectV(e) {
    return this._centerObject(e, new B(e.getCenterPoint().x, this.getCenterPoint().y));
  }
  centerObject(e) {
    return this._centerObject(e, this.getCenterPoint());
  }
  viewportCenterObject(e) {
    return this._centerObject(e, this.getVpCenter());
  }
  viewportCenterObjectH(e) {
    return this._centerObject(e, new B(this.getVpCenter().x, e.getCenterPoint().y));
  }
  viewportCenterObjectV(e) {
    return this._centerObject(e, new B(e.getCenterPoint().x, this.getVpCenter().y));
  }
  getVpCenter() {
    return qt(this.getCenterPoint(), Pr(this.viewportTransform));
  }
  _centerObject(e, t) {
    e.setXY(t, Pe, Pe), e.setCoords(), this.renderOnAddRemove && this.requestRenderAll();
  }
  toDatalessJSON(e) {
    return this.toDatalessObject(e);
  }
  toObject(e) {
    return this._toObjectMethod("toObject", e);
  }
  toJSON() {
    return this.toObject();
  }
  toDatalessObject(e) {
    return this._toObjectMethod("toDatalessObject", e);
  }
  _toObjectMethod(e, t) {
    const n = this.clipPath, i = n && !n.excludeFromExport ? this._toObject(n, e, t) : null;
    return D(D(D({ version: Wd }, fs(this, t)), {}, { objects: this._objects.filter((s) => !s.excludeFromExport).map((s) => this._toObject(s, e, t)) }, this.__serializeBgOverlay(e, t)), i ? { clipPath: i } : null);
  }
  _toObject(e, t, n) {
    let i;
    this.includeDefaultValues || (i = e.includeDefaultValues, e.includeDefaultValues = !1);
    const s = e[t](n);
    return this.includeDefaultValues || (e.includeDefaultValues = !!i), s;
  }
  __serializeBgOverlay(e, t) {
    const n = {}, i = this.backgroundImage, s = this.overlayImage, a = this.backgroundColor, c = this.overlayColor;
    return Yr(a) ? a.excludeFromExport || (n.background = a.toObject(t)) : a && (n.background = a), Yr(c) ? c.excludeFromExport || (n.overlay = c.toObject(t)) : c && (n.overlay = c), i && !i.excludeFromExport && (n.backgroundImage = this._toObject(i, e, t)), s && !s.excludeFromExport && (n.overlayImage = this._toObject(s, e, t)), n;
  }
  toSVG() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
    e.reviver = t;
    const n = [];
    return this._setSVGPreamble(n, e), this._setSVGHeader(n, e), this.clipPath && n.push('<g clip-path="url(#'.concat(this.clipPath.clipPathId, `)" >
`)), this._setSVGBgOverlayColor(n, "background"), this._setSVGBgOverlayImage(n, "backgroundImage", t), this._setSVGObjects(n, t), this.clipPath && n.push(`</g>
`), this._setSVGBgOverlayColor(n, "overlay"), this._setSVGBgOverlayImage(n, "overlayImage", t), n.push("</svg>"), n.join("");
  }
  _setSVGPreamble(e, t) {
    t.suppressPreamble || e.push('<?xml version="1.0" encoding="', t.encoding || "UTF-8", `" standalone="no" ?>
`, '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', `"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
`);
  }
  _setSVGHeader(e, t) {
    const n = t.width || "".concat(this.width), i = t.height || "".concat(this.height), s = Ue.NUM_FRACTION_DIGITS, a = t.viewBox;
    let c;
    if (a) c = 'viewBox="'.concat(a.x, " ").concat(a.y, " ").concat(a.width, " ").concat(a.height, '" ');
    else if (this.svgViewportTransformation) {
      const u = this.viewportTransform;
      c = 'viewBox="'.concat(ut(-u[4] / u[0], s), " ").concat(ut(-u[5] / u[3], s), " ").concat(ut(this.width / u[0], s), " ").concat(ut(this.height / u[3], s), '" ');
    } else c = 'viewBox="0 0 '.concat(this.width, " ").concat(this.height, '" ');
    e.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', n, '" ', 'height="', i, '" ', c, `xml:space="preserve">
`, "<desc>Created with Fabric.js ", Wd, `</desc>
`, `<defs>
`, this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(t), `</defs>
`);
  }
  createSVGClipPathMarkup(e) {
    const t = this.clipPath;
    return t ? (t.clipPathId = "CLIPPATH_".concat(mi()), '<clipPath id="'.concat(t.clipPathId, `" >
`).concat(t.toClipPathSVG(e.reviver), `</clipPath>
`)) : "";
  }
  createSVGRefElementsMarkup() {
    return ["background", "overlay"].map((e) => {
      const t = this["".concat(e, "Color")];
      if (Yr(t)) {
        const n = this["".concat(e, "Vpt")], i = this.viewportTransform, s = { isType: () => !1, width: this.width / (n ? i[0] : 1), height: this.height / (n ? i[3] : 1) };
        return t.toSVG(s, { additionalTransform: n ? ia(i) : "" });
      }
    }).join("");
  }
  createSVGFontFacesMarkup() {
    const e = [], t = {}, n = Ue.fontPaths;
    this._objects.forEach(function s(a) {
      e.push(a), Jc(a) && a._objects.forEach(s);
    }), e.forEach((s) => {
      if (!(a = s) || typeof a._renderText != "function") return;
      var a;
      const { styles: c, fontFamily: u } = s;
      !t[u] && n[u] && (t[u] = !0, c && Object.values(c).forEach((h) => {
        Object.values(h).forEach((d) => {
          let { fontFamily: p = "" } = d;
          !t[p] && n[p] && (t[p] = !0);
        });
      }));
    });
    const i = Object.keys(t).map((s) => `		@font-face {
			font-family: '`.concat(s, `';
			src: url('`).concat(n[s], `');
		}
`)).join("");
    return i ? `	<style type="text/css"><![CDATA[
`.concat(i, `]]></style>
`) : "";
  }
  _setSVGObjects(e, t) {
    this.forEachObject((n) => {
      n.excludeFromExport || this._setSVGObject(e, n, t);
    });
  }
  _setSVGObject(e, t, n) {
    e.push(t.toSVG(n));
  }
  _setSVGBgOverlayImage(e, t, n) {
    const i = this[t];
    i && !i.excludeFromExport && i.toSVG && e.push(i.toSVG(n));
  }
  _setSVGBgOverlayColor(e, t) {
    const n = this["".concat(t, "Color")];
    if (n) if (Yr(n)) {
      const i = n.repeat || "", s = this.width, a = this.height, c = this["".concat(t, "Vpt")] ? ia(Pr(this.viewportTransform)) : "";
      e.push('<rect transform="'.concat(c, " translate(").concat(s / 2, ",").concat(a / 2, ')" x="').concat(n.offsetX - s / 2, '" y="').concat(n.offsetY - a / 2, '" width="').concat(i !== "repeat-y" && i !== "no-repeat" || !p0(n) ? s : n.source.width, '" height="').concat(i !== "repeat-x" && i !== "no-repeat" || !p0(n) ? a : n.source.height, '" fill="url(#SVGID_').concat(n.id, `)"></rect>
`));
    } else e.push('<rect x="0" y="0" width="100%" height="100%" ', 'fill="', n, '"', `></rect>
`);
  }
  loadFromJSON(e, t) {
    let { signal: n } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return Promise.reject(new xn("`json` is undefined"));
    const i = typeof e == "string" ? JSON.parse(e) : e, { objects: s = [], backgroundImage: a, background: c, overlayImage: u, overlay: h, clipPath: d } = i, p = this.renderOnAddRemove;
    return this.renderOnAddRemove = !1, Promise.all([Xs(s, { reviver: t, signal: n }), _a({ backgroundImage: a, backgroundColor: c, overlayImage: u, overlayColor: h, clipPath: d }, { signal: n })]).then((g) => {
      let [v, y] = g;
      return this.clear(), this.add(...v), this.set(i), this.set(y), this.renderOnAddRemove = p, this;
    });
  }
  clone(e) {
    const t = this.toObject(e);
    return this.cloneWithoutData().loadFromJSON(t);
  }
  cloneWithoutData() {
    const e = un(this);
    return new this.constructor(e);
  }
  toDataURL() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { format: t = "png", quality: n = 1, multiplier: i = 1, enableRetinaScaling: s = !1 } = e, a = i * (s ? this.getRetinaScaling() : 1);
    return tp(this.toCanvasElement(a, e), t, n);
  }
  toCanvasElement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, { width: t, height: n, left: i, top: s, filter: a } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const c = (t || this.width) * e, u = (n || this.height) * e, h = this.getZoom(), d = this.width, p = this.height, g = this.skipControlsDrawing, v = h * e, y = this.viewportTransform, x = [v, 0, 0, v, (y[4] - (i || 0)) * e, (y[5] - (s || 0)) * e], _ = this.enableRetinaScaling, C = un({ width: c, height: u }), E = a ? this._objects.filter((k) => a(k)) : this._objects;
    return this.enableRetinaScaling = !1, this.viewportTransform = x, this.width = c, this.height = u, this.skipControlsDrawing = !0, this.calcViewportBoundaries(), this.renderCanvas(C.getContext("2d"), E), this.viewportTransform = y, this.width = d, this.height = p, this.calcViewportBoundaries(), this.enableRetinaScaling = _, this.skipControlsDrawing = g, C;
  }
  dispose() {
    return !this.disposed && this.elements.cleanupDOM({ width: this.width, height: this.height }), fl.cancelByCanvas(this), this.disposed = !0, new Promise((e, t) => {
      const n = () => {
        this.destroy(), e(!0);
      };
      n.kill = t, this.__cleanupTask && this.__cleanupTask.kill("aborted"), this.destroyed ? e(!1) : this.nextRenderHandle ? this.__cleanupTask = n : n();
    });
  }
  destroy() {
    this.destroyed = !0, this.cancelRequestedRender(), this.forEachObject((e) => e.dispose()), this._objects = [], this.backgroundImage && this.backgroundImage.dispose(), this.backgroundImage = void 0, this.overlayImage && this.overlayImage.dispose(), this.overlayImage = void 0, this.elements.dispose();
  }
  toString() {
    return "#<Canvas (".concat(this.complexity(), "): { objects: ").concat(this._objects.length, " }>");
  }
}
R(Sa, "ownDefaults", B4);
const V4 = ["touchstart", "touchmove", "touchend"], tw = (r) => {
  const e = Zb(r.target), t = function(n) {
    const i = n.changedTouches;
    return i && i[0] ? i[0] : n;
  }(r);
  return new B(t.clientX + e.left, t.clientY + e.top);
}, pl = (r) => V4.includes(r.type) || r.pointerType === "touch", $d = (r) => {
  r.preventDefault(), r.stopPropagation();
}, Cn = (r) => {
  let e = 0, t = 0, n = 0, i = 0;
  for (let s = 0, a = r.length; s < a; s++) {
    const { x: c, y: u } = r[s];
    (c > n || !s) && (n = c), (c < e || !s) && (e = c), (u > i || !s) && (i = u), (u < t || !s) && (t = u);
  }
  return { left: e, top: t, width: n - e, height: i - t };
}, z4 = ["translateX", "translateY", "scaleX", "scaleY"], rw = (r, e) => Gs(r, wt(e, r.calcOwnMatrix())), Gs = (r, e) => {
  const t = Ys(e), { translateX: n, translateY: i, scaleX: s, scaleY: a } = t, c = ht(t, z4), u = new B(n, i);
  r.flipX = !1, r.flipY = !1, Object.assign(r, c), r.set({ scaleX: s, scaleY: a }), r.setPositionByOrigin(u, Pe, Pe);
}, nw = (r) => {
  r.scaleX = 1, r.scaleY = 1, r.skewX = 0, r.skewY = 0, r.flipX = !1, r.flipY = !1, r.rotate(0);
}, sp = (r) => ({ scaleX: r.scaleX, scaleY: r.scaleY, skewX: r.skewX, skewY: r.skewY, angle: r.angle, left: r.left, flipX: r.flipX, flipY: r.flipY, top: r.top }), iu = (r, e, t) => {
  const n = r / 2, i = e / 2, s = [new B(-n, -i), new B(n, -i), new B(-n, i), new B(n, i)].map((c) => c.transform(t)), a = Cn(s);
  return new B(a.width, a.height);
}, Ca = function() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : or;
  return wt(Pr(arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : or), r);
}, $n = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : or, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : or;
  return r.transform(Ca(e, t));
}, iw = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : or, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : or;
  return r.transform(Ca(e, t), !0);
}, Yd = (r, e, t) => {
  const n = Ca(e, t);
  return Gs(r, wt(n, r.calcOwnMatrix())), n;
}, op = (r, e) => {
  var t;
  const { transform: { target: n } } = e;
  (t = n.canvas) === null || t === void 0 || t.fire("object:".concat(r), D(D({}, e), {}, { target: n })), n.fire(r, e);
}, W4 = { left: -0.5, top: -0.5, center: 0, bottom: 0.5, right: 0.5 }, Et = (r) => typeof r == "string" ? W4[r] : r - 0.5, gl = "not-allowed";
function sw(r) {
  return Et(r.originX) === Et(Pe) && Et(r.originY) === Et(Pe);
}
function m0(r) {
  return 0.5 - Et(r);
}
const on = (r, e) => r[e], ap = (r, e, t, n) => ({ e: r, transform: e, pointer: new B(t, n) });
function ow(r, e) {
  const t = r.getTotalAngle() + vi(Math.atan2(e.y, e.x)) + 360;
  return Math.round(t % 360 / 45);
}
function su(r, e, t, n, i) {
  var s;
  let { target: a, corner: c } = r;
  const u = a.controls[c], h = ((s = a.canvas) === null || s === void 0 ? void 0 : s.getZoom()) || 1, d = a.padding / h, p = function(g, v, y, x) {
    const _ = g.getRelativeCenterPoint(), C = y !== void 0 && x !== void 0 ? g.translateToGivenOrigin(_, Pe, Pe, y, x) : new B(g.left, g.top);
    return (g.angle ? v.rotate(-bt(g.angle), _) : v).subtract(C);
  }(a, new B(n, i), e, t);
  return p.x >= d && (p.x -= d), p.x <= -d && (p.x += d), p.y >= d && (p.y -= d), p.y <= d && (p.y += d), p.x -= u.offsetX, p.y -= u.offsetY, p;
}
const aw = (r, e, t, n) => {
  const { target: i, offsetX: s, offsetY: a } = e, c = t - s, u = n - a, h = !on(i, "lockMovementX") && i.left !== c, d = !on(i, "lockMovementY") && i.top !== u;
  return h && i.set(Ke, c), d && i.set(vr, u), (h || d) && op(Nb, ap(r, e, t, n)), h || d;
};
class cw {
  getSvgStyles(e) {
    const t = this.fillRule ? this.fillRule : "nonzero", n = this.strokeWidth ? this.strokeWidth : "0", i = this.strokeDashArray ? this.strokeDashArray.join(" ") : yr, s = this.strokeDashOffset ? this.strokeDashOffset : "0", a = this.strokeLineCap ? this.strokeLineCap : "butt", c = this.strokeLineJoin ? this.strokeLineJoin : "miter", u = this.strokeMiterLimit ? this.strokeMiterLimit : "4", h = this.opacity !== void 0 ? this.opacity : "1", d = this.visible ? "" : " visibility: hidden;", p = e ? "" : this.getSvgFilter(), g = sa(Lt, this.fill);
    return [sa(br, this.stroke), "stroke-width: ", n, "; ", "stroke-dasharray: ", i, "; ", "stroke-linecap: ", a, "; ", "stroke-dashoffset: ", s, "; ", "stroke-linejoin: ", c, "; ", "stroke-miterlimit: ", u, "; ", g, "fill-rule: ", t, "; ", "opacity: ", h, ";", p, d].join("");
  }
  getSvgFilter() {
    return this.shadow ? "filter: url(#SVGID_".concat(this.shadow.id, ");") : "";
  }
  getSvgCommons() {
    return [this.id ? 'id="'.concat(this.id, '" ') : "", this.clipPath ? 'clip-path="url(#'.concat(this.clipPath.clipPathId, ')" ') : ""].join("");
  }
  getSvgTransform(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const n = e ? this.calcTransformMatrix() : this.calcOwnMatrix(), i = 'transform="'.concat(ia(n));
    return "".concat(i).concat(t, '" ');
  }
  _toSVG(e) {
    return [""];
  }
  toSVG(e) {
    return this._createBaseSVGMarkup(this._toSVG(e), { reviver: e });
  }
  toClipPathSVG(e) {
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(e), { reviver: e });
  }
  _createBaseClipPathSVGMarkup(e) {
    let { reviver: t, additionalTransform: n = "" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = [this.getSvgTransform(!0, n), this.getSvgCommons()].join(""), s = e.indexOf("COMMON_PARTS");
    return e[s] = i, t ? t(e.join("")) : e.join("");
  }
  _createBaseSVGMarkup(e) {
    let { noStyle: t, reviver: n, withShadow: i, additionalTransform: s } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const a = t ? "" : 'style="'.concat(this.getSvgStyles(), '" '), c = i ? 'style="'.concat(this.getSvgFilter(), '" ') : "", u = this.clipPath, h = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", d = u && u.absolutePositioned, p = this.stroke, g = this.fill, v = this.shadow, y = [], x = e.indexOf("COMMON_PARTS");
    let _;
    u && (u.clipPathId = "CLIPPATH_".concat(mi()), _ = '<clipPath id="'.concat(u.clipPathId, `" >
`).concat(u.toClipPathSVG(n), `</clipPath>
`)), d && y.push("<g ", c, this.getSvgCommons(), ` >
`), y.push("<g ", this.getSvgTransform(!1), d ? "" : c + this.getSvgCommons(), ` >
`);
    const C = [a, h, t ? "" : this.addPaintOrder(), " ", s ? 'transform="'.concat(s, '" ') : ""].join("");
    return e[x] = C, Yr(g) && y.push(g.toSVG(this)), Yr(p) && y.push(p.toSVG(this)), v && y.push(v.toSVG(this)), u && y.push(_), y.push(e.join("")), y.push(`</g>
`), d && y.push(`</g>
`), n ? n(y.join("")) : y.join("");
  }
  addPaintOrder() {
    return this.paintFirst !== Lt ? ' paint-order="'.concat(this.paintFirst, '" ') : "";
  }
}
function ou(r) {
  return new RegExp("^(" + r.join("|") + ")\\b", "i");
}
var v0;
const es = String.raw(v0 || (v0 = Ci(["(?:[-+]?(?:d*.d+|d+.?)(?:[eE][-+]?d+)?)"], ["(?:[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?)"]))), H4 = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + es + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + es + "))?\\s+(.*)"), U4 = { cx: Ke, x: Ke, r: "radius", cy: vr, y: vr, display: "visible", visibility: "visible", transform: "transformMatrix", "fill-opacity": "fillOpacity", "fill-rule": "fillRule", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "letter-spacing": "charSpacing", "paint-order": "paintFirst", "stroke-dasharray": "strokeDashArray", "stroke-dashoffset": "strokeDashOffset", "stroke-linecap": "strokeLineCap", "stroke-linejoin": "strokeLineJoin", "stroke-miterlimit": "strokeMiterLimit", "stroke-opacity": "strokeOpacity", "stroke-width": "strokeWidth", "text-decoration": "textDecoration", "text-anchor": "textAnchor", opacity: "opacity", "clip-path": "clipPath", "clip-rule": "clipRule", "vector-effect": "strokeUniform", "image-rendering": "imageSmoothing" }, Yh = "font-size", Xh = "clip-path";
ou(["path", "circle", "polygon", "polyline", "ellipse", "rect", "line", "image", "text"]);
ou(["symbol", "image", "marker", "pattern", "view", "svg"]);
const y0 = ou(["symbol", "g", "a", "svg", "clipPath", "defs"]), $4 = new B(1, 0), lw = new B(), cp = (r, e) => r.rotate(e), ml = (r, e) => new B(e).subtract(r), vl = (r) => r.distanceFrom(lw), yl = (r, e) => Math.atan2(Ws(r, e), hw(r, e)), uw = (r) => yl($4, r), au = (r) => r.eq(lw) ? r : r.scalarDivide(vl(r)), lp = function(r) {
  let e = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
  return au(new B(-r.y, r.x).scalarMultiply(e ? 1 : -1));
}, Ws = (r, e) => r.x * e.y - r.y * e.x, hw = (r, e) => r.x * e.x + r.y * e.y, Xd = (r, e, t) => {
  if (r.eq(e) || r.eq(t)) return !0;
  const n = Ws(e, t), i = Ws(e, r), s = Ws(t, r);
  return n >= 0 ? i >= 0 && s <= 0 : !(i <= 0 && s >= 0);
}, b0 = "(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?", w0 = new RegExp("(?:\\s|^)" + b0 + b0 + "(" + es + "?(?:px)?)?(?:\\s?|$)(?:$|\\s)");
class Yn {
  constructor(e) {
    const t = typeof e == "string" ? Yn.parseShadow(e) : e;
    Object.assign(this, Yn.ownDefaults, t), this.id = mi();
  }
  static parseShadow(e) {
    const t = e.trim(), [, n = 0, i = 0, s = 0] = (w0.exec(t) || []).map((a) => parseFloat(a) || 0);
    return { color: (t.replace(w0, "") || "rgb(0,0,0)").trim(), offsetX: n, offsetY: i, blur: s };
  }
  toString() {
    return [this.offsetX, this.offsetY, this.blur, this.color].join("px ");
  }
  toSVG(e) {
    const t = cp(new B(this.offsetX, this.offsetY), bt(-e.angle)), n = new Qe(this.color);
    let i = 40, s = 40;
    return e.width && e.height && (i = 100 * ut((Math.abs(t.x) + this.blur) / e.width, Ue.NUM_FRACTION_DIGITS) + 20, s = 100 * ut((Math.abs(t.y) + this.blur) / e.height, Ue.NUM_FRACTION_DIGITS) + 20), e.flipX && (t.x *= -1), e.flipY && (t.y *= -1), '<filter id="SVGID_'.concat(this.id, '" y="-').concat(s, '%" height="').concat(100 + 2 * s, '%" x="-').concat(i, '%" width="').concat(100 + 2 * i, `%" >
	<feGaussianBlur in="SourceAlpha" stdDeviation="`).concat(ut(this.blur ? this.blur / 2 : 0, Ue.NUM_FRACTION_DIGITS), `"></feGaussianBlur>
	<feOffset dx="`).concat(ut(t.x, Ue.NUM_FRACTION_DIGITS), '" dy="').concat(ut(t.y, Ue.NUM_FRACTION_DIGITS), `" result="oBlur" ></feOffset>
	<feFlood flood-color="`).concat(n.toRgb(), '" flood-opacity="').concat(n.getAlpha(), `"/>
	<feComposite in2="oBlur" operator="in" />
	<feMerge>
		<feMergeNode></feMergeNode>
		<feMergeNode in="SourceGraphic"></feMergeNode>
	</feMerge>
</filter>
`);
  }
  toObject() {
    const e = { color: this.color, blur: this.blur, offsetX: this.offsetX, offsetY: this.offsetY, affectStroke: this.affectStroke, nonScaling: this.nonScaling, type: this.constructor.type }, t = Yn.ownDefaults;
    return this.includeDefaultValues ? e : ip(e, (n, i) => n !== t[i]);
  }
  static async fromObject(e) {
    return new this(e);
  }
}
R(Yn, "ownDefaults", { color: "rgb(0,0,0)", blur: 0, offsetX: 0, offsetY: 0, affectStroke: !1, includeDefaultValues: !0, nonScaling: !1 }), R(Yn, "type", "shadow"), ne.setClass(Yn, "shadow");
const ts = (r, e, t) => Math.max(r, Math.min(e, t)), Y4 = [vr, Ke, ar, Dr, "flipX", "flipY", "originX", "originY", "angle", "opacity", "globalCompositeOperation", "shadow", "visible", lo, uo], Kn = [Lt, br, "strokeWidth", "strokeDashArray", "width", "height", "paintFirst", "strokeUniform", "strokeLineCap", "strokeDashOffset", "strokeLineJoin", "strokeMiterLimit", "backgroundColor", "clipPath"], X4 = { top: 0, left: 0, width: 0, height: 0, angle: 0, flipX: !1, flipY: !1, scaleX: 1, scaleY: 1, minScaleLimit: 0, skewX: 0, skewY: 0, originX: Ke, originY: vr, strokeWidth: 1, strokeUniform: !1, padding: 0, opacity: 1, paintFirst: Lt, fill: "rgb(0,0,0)", fillRule: "nonzero", stroke: null, strokeDashArray: null, strokeDashOffset: 0, strokeLineCap: "butt", strokeLineJoin: "miter", strokeMiterLimit: 4, globalCompositeOperation: "source-over", backgroundColor: "", shadow: null, visible: !0, includeDefaultValues: !0, excludeFromExport: !1, objectCaching: !0, clipPath: void 0, inverted: !1, absolutePositioned: !1, centeredRotation: !0, centeredScaling: !1, dirty: !0 }, Gh = (r, e, t, n) => (r < Math.abs(e) ? (r = e, n = t / 4) : n = e === 0 && r === 0 ? t / qn * Math.asin(1) : t / qn * Math.asin(e / r), { a: r, c: e, p: t, s: n }), x0 = (r, e, t, n, i) => r * Math.pow(2, 10 * (n -= 1)) * Math.sin((n * i - e) * qn / t), dw = (r, e, t, n) => -t * Math.cos(r / n * gi) + t + e, Gd = (r, e, t, n) => (r /= n) < 1 / 2.75 ? t * (7.5625 * r * r) + e : r < 2 / 2.75 ? t * (7.5625 * (r -= 1.5 / 2.75) * r + 0.75) + e : r < 2.5 / 2.75 ? t * (7.5625 * (r -= 2.25 / 2.75) * r + 0.9375) + e : t * (7.5625 * (r -= 2.625 / 2.75) * r + 0.984375) + e, _0 = (r, e, t, n) => t - Gd(n - r, 0, t, n) + e;
var G4 = Object.freeze({ __proto__: null, defaultEasing: dw, easeInBack: function(r, e, t, n) {
  let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1.70158;
  return t * (r /= n) * r * ((i + 1) * r - i) + e;
}, easeInBounce: _0, easeInCirc: (r, e, t, n) => -t * (Math.sqrt(1 - (r /= n) * r) - 1) + e, easeInCubic: (r, e, t, n) => t * (r / n) ** 3 + e, easeInElastic: (r, e, t, n) => {
  const i = t;
  let s = 0;
  if (r === 0) return e;
  if ((r /= n) === 1) return e + t;
  s || (s = 0.3 * n);
  const { a, s: c, p: u } = Gh(i, t, s, 1.70158);
  return -x0(a, c, u, r, n) + e;
}, easeInExpo: (r, e, t, n) => r === 0 ? e : t * 2 ** (10 * (r / n - 1)) + e, easeInOutBack: function(r, e, t, n) {
  let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1.70158;
  return (r /= n / 2) < 1 ? t / 2 * (r * r * ((1 + (i *= 1.525)) * r - i)) + e : t / 2 * ((r -= 2) * r * ((1 + (i *= 1.525)) * r + i) + 2) + e;
}, easeInOutBounce: (r, e, t, n) => r < n / 2 ? 0.5 * _0(2 * r, 0, t, n) + e : 0.5 * Gd(2 * r - n, 0, t, n) + 0.5 * t + e, easeInOutCirc: (r, e, t, n) => (r /= n / 2) < 1 ? -t / 2 * (Math.sqrt(1 - r ** 2) - 1) + e : t / 2 * (Math.sqrt(1 - (r -= 2) * r) + 1) + e, easeInOutCubic: (r, e, t, n) => (r /= n / 2) < 1 ? t / 2 * r ** 3 + e : t / 2 * ((r - 2) ** 3 + 2) + e, easeInOutElastic: (r, e, t, n) => {
  const i = t;
  let s = 0;
  if (r === 0) return e;
  if ((r /= n / 2) === 2) return e + t;
  s || (s = n * (0.3 * 1.5));
  const { a, s: c, p: u, c: h } = Gh(i, t, s, 1.70158);
  return r < 1 ? -0.5 * x0(a, c, u, r, n) + e : a * Math.pow(2, -10 * (r -= 1)) * Math.sin((r * n - c) * qn / u) * 0.5 + h + e;
}, easeInOutExpo: (r, e, t, n) => r === 0 ? e : r === n ? e + t : (r /= n / 2) < 1 ? t / 2 * 2 ** (10 * (r - 1)) + e : t / 2 * -(2 ** (-10 * --r) + 2) + e, easeInOutQuad: (r, e, t, n) => (r /= n / 2) < 1 ? t / 2 * r ** 2 + e : -t / 2 * (--r * (r - 2) - 1) + e, easeInOutQuart: (r, e, t, n) => (r /= n / 2) < 1 ? t / 2 * r ** 4 + e : -t / 2 * ((r -= 2) * r ** 3 - 2) + e, easeInOutQuint: (r, e, t, n) => (r /= n / 2) < 1 ? t / 2 * r ** 5 + e : t / 2 * ((r - 2) ** 5 + 2) + e, easeInOutSine: (r, e, t, n) => -t / 2 * (Math.cos(Math.PI * r / n) - 1) + e, easeInQuad: (r, e, t, n) => t * (r /= n) * r + e, easeInQuart: (r, e, t, n) => t * (r /= n) * r ** 3 + e, easeInQuint: (r, e, t, n) => t * (r / n) ** 5 + e, easeInSine: (r, e, t, n) => -t * Math.cos(r / n * gi) + t + e, easeOutBack: function(r, e, t, n) {
  let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1.70158;
  return t * ((r = r / n - 1) * r * ((i + 1) * r + i) + 1) + e;
}, easeOutBounce: Gd, easeOutCirc: (r, e, t, n) => t * Math.sqrt(1 - (r = r / n - 1) * r) + e, easeOutCubic: (r, e, t, n) => t * ((r / n - 1) ** 3 + 1) + e, easeOutElastic: (r, e, t, n) => {
  const i = t;
  let s = 0;
  if (r === 0) return e;
  if ((r /= n) === 1) return e + t;
  s || (s = 0.3 * n);
  const { a, s: c, p: u, c: h } = Gh(i, t, s, 1.70158);
  return a * 2 ** (-10 * r) * Math.sin((r * n - c) * qn / u) + h + e;
}, easeOutExpo: (r, e, t, n) => r === n ? e + t : t * -(2 ** (-10 * r / n) + 1) + e, easeOutQuad: (r, e, t, n) => -t * (r /= n) * (r - 2) + e, easeOutQuart: (r, e, t, n) => -t * ((r = r / n - 1) * r ** 3 - 1) + e, easeOutQuint: (r, e, t, n) => t * ((r / n - 1) ** 5 + 1) + e, easeOutSine: (r, e, t, n) => t * Math.sin(r / n * gi) + e });
const q4 = () => !1;
class up {
  constructor(e) {
    let { startValue: t, byValue: n, duration: i = 500, delay: s = 0, easing: a = dw, onStart: c = Ki, onChange: u = Ki, onComplete: h = Ki, abort: d = q4, target: p } = e;
    R(this, "_state", "pending"), R(this, "durationProgress", 0), R(this, "valueProgress", 0), this.tick = this.tick.bind(this), this.duration = i, this.delay = s, this.easing = a, this._onStart = c, this._onChange = u, this._onComplete = h, this._abort = d, this.target = p, this.startValue = t, this.byValue = n, this.value = this.startValue, this.endValue = Object.freeze(this.calculate(this.duration).value);
  }
  get state() {
    return this._state;
  }
  isDone() {
    return this._state === "aborted" || this._state === "completed";
  }
  start() {
    const e = (t) => {
      this._state === "pending" && (this.startTime = t || +/* @__PURE__ */ new Date(), this._state = "running", this._onStart(), this.tick(this.startTime));
    };
    this.register(), this.delay > 0 ? setTimeout(() => qo(e), this.delay) : qo(e);
  }
  tick(e) {
    const t = (e || +/* @__PURE__ */ new Date()) - this.startTime, n = Math.min(t, this.duration);
    this.durationProgress = n / this.duration;
    const { value: i, valueProgress: s } = this.calculate(n);
    this.value = Object.freeze(i), this.valueProgress = s, this._state !== "aborted" && (this._abort(this.value, this.valueProgress, this.durationProgress) ? (this._state = "aborted", this.unregister()) : t >= this.duration ? (this.durationProgress = this.valueProgress = 1, this._onChange(this.endValue, this.valueProgress, this.durationProgress), this._state = "completed", this._onComplete(this.endValue, this.valueProgress, this.durationProgress), this.unregister()) : (this._onChange(this.value, this.valueProgress, this.durationProgress), qo(this.tick)));
  }
  register() {
    fl.push(this);
  }
  unregister() {
    fl.remove(this);
  }
  abort() {
    this._state = "aborted", this.unregister();
  }
}
const K4 = ["startValue", "endValue"];
class Z4 extends up {
  constructor(e) {
    let { startValue: t = 0, endValue: n = 100 } = e;
    super(D(D({}, ht(e, K4)), {}, { startValue: t, byValue: n - t }));
  }
  calculate(e) {
    const t = this.easing(e, this.startValue, this.byValue, this.duration);
    return { value: t, valueProgress: Math.abs((t - this.startValue) / this.byValue) };
  }
}
const J4 = ["startValue", "endValue"];
class Q4 extends up {
  constructor(e) {
    let { startValue: t = [0], endValue: n = [100] } = e;
    super(D(D({}, ht(e, J4)), {}, { startValue: t, byValue: n.map((i, s) => i - t[s]) }));
  }
  calculate(e) {
    const t = this.startValue.map((n, i) => this.easing(e, n, this.byValue[i], this.duration, i));
    return { value: t, valueProgress: Math.abs((t[0] - this.startValue[0]) / this.byValue[0]) };
  }
}
const e3 = ["startValue", "endValue", "easing", "onChange", "onComplete", "abort"], t3 = (r, e, t, n) => e + t * (1 - Math.cos(r / n * gi)), qh = (r) => r && ((e, t, n) => r(new Qe(e).toRgba(), t, n));
class r3 extends up {
  constructor(e) {
    let { startValue: t, endValue: n, easing: i = t3, onChange: s, onComplete: a, abort: c } = e, u = ht(e, e3);
    const h = new Qe(t).getSource(), d = new Qe(n).getSource();
    super(D(D({}, u), {}, { startValue: h, byValue: d.map((p, g) => p - h[g]), easing: i, onChange: qh(s), onComplete: qh(a), abort: qh(c) }));
  }
  calculate(e) {
    const [t, n, i, s] = this.startValue.map((c, u) => this.easing(e, c, this.byValue[u], this.duration, u)), a = [...[t, n, i].map(Math.round), ts(0, s, 1)];
    return { value: a, valueProgress: a.map((c, u) => this.byValue[u] !== 0 ? Math.abs((c - this.startValue[u]) / this.byValue[u]) : 0).find((c) => c !== 0) || 0 };
  }
}
function hp(r) {
  const e = ((t) => Array.isArray(t.startValue) || Array.isArray(t.endValue))(r) ? new Q4(r) : new Z4(r);
  return e.start(), e;
}
function fw(r) {
  const e = new r3(r);
  return e.start(), e;
}
class pt {
  constructor(e) {
    this.status = e, this.points = [];
  }
  includes(e) {
    return this.points.some((t) => t.eq(e));
  }
  append() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    return this.points = this.points.concat(t.filter((i) => !this.includes(i))), this;
  }
  static isPointContained(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
    if (t.eq(n)) return e.eq(t);
    if (t.x === n.x) return e.x === t.x && (i || e.y >= Math.min(t.y, n.y) && e.y <= Math.max(t.y, n.y));
    if (t.y === n.y) return e.y === t.y && (i || e.x >= Math.min(t.x, n.x) && e.x <= Math.max(t.x, n.x));
    {
      const s = ml(t, n), a = ml(t, e).divide(s);
      return i ? Math.abs(a.x) === Math.abs(a.y) : a.x === a.y && a.x >= 0 && a.x <= 1;
    }
  }
  static isPointInPolygon(e, t) {
    const n = new B(e).setX(Math.min(e.x - 1, ...t.map((s) => s.x)));
    let i = 0;
    for (let s = 0; s < t.length; s++) {
      const a = this.intersectSegmentSegment(t[s], t[(s + 1) % t.length], e, n);
      if (a.includes(e)) return !0;
      i += +(a.status === "Intersection");
    }
    return i % 2 == 1;
  }
  static intersectLineLine(e, t, n, i) {
    let s = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], a = !(arguments.length > 5 && arguments[5] !== void 0) || arguments[5];
    const c = t.x - e.x, u = t.y - e.y, h = i.x - n.x, d = i.y - n.y, p = e.x - n.x, g = e.y - n.y, v = h * g - d * p, y = c * g - u * p, x = d * c - h * u;
    if (x !== 0) {
      const _ = v / x, C = y / x;
      return (s || 0 <= _ && _ <= 1) && (a || 0 <= C && C <= 1) ? new pt("Intersection").append(new B(e.x + _ * c, e.y + _ * u)) : new pt();
    }
    if (v === 0 || y === 0) {
      const _ = s || a || pt.isPointContained(e, n, i) || pt.isPointContained(t, n, i) || pt.isPointContained(n, e, t) || pt.isPointContained(i, e, t);
      return new pt(_ ? "Coincident" : void 0);
    }
    return new pt("Parallel");
  }
  static intersectSegmentLine(e, t, n, i) {
    return pt.intersectLineLine(e, t, n, i, !1, !0);
  }
  static intersectSegmentSegment(e, t, n, i) {
    return pt.intersectLineLine(e, t, n, i, !1, !1);
  }
  static intersectLinePolygon(e, t, n) {
    let i = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
    const s = new pt(), a = n.length;
    for (let c, u, h, d = 0; d < a; d++) {
      if (c = n[d], u = n[(d + 1) % a], h = pt.intersectLineLine(e, t, c, u, i, !1), h.status === "Coincident") return h;
      s.append(...h.points);
    }
    return s.points.length > 0 && (s.status = "Intersection"), s;
  }
  static intersectSegmentPolygon(e, t, n) {
    return pt.intersectLinePolygon(e, t, n, !1);
  }
  static intersectPolygonPolygon(e, t) {
    const n = new pt(), i = e.length, s = [];
    for (let a = 0; a < i; a++) {
      const c = e[a], u = e[(a + 1) % i], h = pt.intersectSegmentPolygon(c, u, t);
      h.status === "Coincident" ? (s.push(h), n.append(c, u)) : n.append(...h.points);
    }
    return s.length > 0 && s.length === e.length ? new pt("Coincident") : (n.points.length > 0 && (n.status = "Intersection"), n);
  }
  static intersectPolygonRectangle(e, t, n) {
    const i = t.min(n), s = t.max(n), a = new B(s.x, i.y), c = new B(i.x, s.y);
    return pt.intersectPolygonPolygon(e, [i, a, s, c]);
  }
}
class n3 extends Hb {
  getX() {
    return this.getXY().x;
  }
  setX(e) {
    this.setXY(this.getXY().setX(e));
  }
  getY() {
    return this.getXY().y;
  }
  setY(e) {
    this.setXY(this.getXY().setY(e));
  }
  getRelativeX() {
    return this.left;
  }
  setRelativeX(e) {
    this.left = e;
  }
  getRelativeY() {
    return this.top;
  }
  setRelativeY(e) {
    this.top = e;
  }
  getXY() {
    const e = this.getRelativeXY();
    return this.group ? qt(e, this.group.calcTransformMatrix()) : e;
  }
  setXY(e, t, n) {
    this.group && (e = qt(e, Pr(this.group.calcTransformMatrix()))), this.setRelativeXY(e, t, n);
  }
  getRelativeXY() {
    return new B(this.left, this.top);
  }
  setRelativeXY(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.originX, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.originY;
    this.setPositionByOrigin(e, t, n);
  }
  isStrokeAccountedForInDimensions() {
    return !1;
  }
  getCoords() {
    const { tl: e, tr: t, br: n, bl: i } = this.aCoords || (this.aCoords = this.calcACoords()), s = [e, t, n, i];
    if (this.group) {
      const a = this.group.calcTransformMatrix();
      return s.map((c) => qt(c, a));
    }
    return s;
  }
  intersectsWithRect(e, t) {
    return pt.intersectPolygonRectangle(this.getCoords(), e, t).status === "Intersection";
  }
  intersectsWithObject(e) {
    const t = pt.intersectPolygonPolygon(this.getCoords(), e.getCoords());
    return t.status === "Intersection" || t.status === "Coincident" || e.isContainedWithinObject(this) || this.isContainedWithinObject(e);
  }
  isContainedWithinObject(e) {
    return this.getCoords().every((t) => e.containsPoint(t));
  }
  isContainedWithinRect(e, t) {
    const { left: n, top: i, width: s, height: a } = this.getBoundingRect();
    return n >= e.x && n + s <= t.x && i >= e.y && i + a <= t.y;
  }
  isOverlapping(e) {
    return this.intersectsWithObject(e) || this.isContainedWithinObject(e) || e.isContainedWithinObject(this);
  }
  containsPoint(e) {
    return pt.isPointInPolygon(e, this.getCoords());
  }
  isOnScreen() {
    if (!this.canvas) return !1;
    const { tl: e, br: t } = this.canvas.vptCoords;
    return !!this.getCoords().some((n) => n.x <= t.x && n.x >= e.x && n.y <= t.y && n.y >= e.y) || !!this.intersectsWithRect(e, t) || this.containsPoint(e.midPointFrom(t));
  }
  isPartiallyOnScreen() {
    if (!this.canvas) return !1;
    const { tl: e, br: t } = this.canvas.vptCoords;
    return this.intersectsWithRect(e, t) ? !0 : this.getCoords().every((n) => (n.x >= t.x || n.x <= e.x) && (n.y >= t.y || n.y <= e.y)) && this.containsPoint(e.midPointFrom(t));
  }
  getBoundingRect() {
    return Cn(this.getCoords());
  }
  getScaledWidth() {
    return this._getTransformedDimensions().x;
  }
  getScaledHeight() {
    return this._getTransformedDimensions().y;
  }
  scale(e) {
    this._set(ar, e), this._set(Dr, e), this.setCoords();
  }
  scaleToWidth(e) {
    const t = this.getBoundingRect().width / this.getScaledWidth();
    return this.scale(e / this.width / t);
  }
  scaleToHeight(e) {
    const t = this.getBoundingRect().height / this.getScaledHeight();
    return this.scale(e / this.height / t);
  }
  getCanvasRetinaScaling() {
    var e;
    return ((e = this.canvas) === null || e === void 0 ? void 0 : e.getRetinaScaling()) || 1;
  }
  getTotalAngle() {
    return this.group ? vi(Xb(this.calcTransformMatrix())) : this.angle;
  }
  getViewportTransform() {
    var e;
    return ((e = this.canvas) === null || e === void 0 ? void 0 : e.viewportTransform) || or.concat();
  }
  calcACoords() {
    const e = fo({ angle: this.angle }), { x: t, y: n } = this.getRelativeCenterPoint(), i = ho(t, n), s = wt(i, e), a = this._getTransformedDimensions(), c = a.x / 2, u = a.y / 2;
    return { tl: qt({ x: -c, y: -u }, s), tr: qt({ x: c, y: -u }, s), bl: qt({ x: -c, y: u }, s), br: qt({ x: c, y: u }, s) };
  }
  setCoords() {
    this.aCoords = this.calcACoords();
  }
  transformMatrixKey() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], t = [];
    return !e && this.group && (t = this.group.transformMatrixKey(e)), t.push(this.top, this.left, this.width, this.height, this.scaleX, this.scaleY, this.angle, this.strokeWidth, this.skewX, this.skewY, +this.flipX, +this.flipY, Et(this.originX), Et(this.originY)), t;
  }
  calcTransformMatrix() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], t = this.calcOwnMatrix();
    if (e || !this.group) return t;
    const n = this.transformMatrixKey(e), i = this.matrixCache;
    return i && i.key.every((s, a) => s === n[a]) ? i.value : (this.group && (t = wt(this.group.calcTransformMatrix(!1), t)), this.matrixCache = { key: n, value: t }, t);
  }
  calcOwnMatrix() {
    const e = this.transformMatrixKey(!0), t = this.ownMatrixCache;
    if (t && t.key === e) return t.value;
    const n = this.getRelativeCenterPoint(), i = { angle: this.angle, translateX: n.x, translateY: n.y, scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, flipX: this.flipX, flipY: this.flipY }, s = qb(i);
    return this.ownMatrixCache = { key: e, value: s }, s;
  }
  _getNonTransformedDimensions() {
    return new B(this.width, this.height).scalarAdd(this.strokeWidth);
  }
  _calculateCurrentDimensions(e) {
    return this._getTransformedDimensions(e).transform(this.getViewportTransform(), !0).scalarAdd(2 * this.padding);
  }
  _getTransformedDimensions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = D({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, width: this.width, height: this.height, strokeWidth: this.strokeWidth }, e), n = t.strokeWidth;
    let i = n, s = 0;
    this.strokeUniform && (i = 0, s = n);
    const a = t.width + i, c = t.height + i;
    let u;
    return u = t.skewX === 0 && t.skewY === 0 ? new B(a * t.scaleX, c * t.scaleY) : iu(a, c, xa(t)), u.scalarAdd(s);
  }
  translateToGivenOrigin(e, t, n, i, s) {
    let a = e.x, c = e.y;
    const u = Et(i) - Et(t), h = Et(s) - Et(n);
    if (u || h) {
      const d = this._getTransformedDimensions();
      a += u * d.x, c += h * d.y;
    }
    return new B(a, c);
  }
  translateToCenterPoint(e, t, n) {
    if (t === Pe && n === Pe) return e;
    const i = this.translateToGivenOrigin(e, t, n, Pe, Pe);
    return this.angle ? i.rotate(bt(this.angle), e) : i;
  }
  translateToOriginPoint(e, t, n) {
    const i = this.translateToGivenOrigin(e, Pe, Pe, t, n);
    return this.angle ? i.rotate(bt(this.angle), e) : i;
  }
  getCenterPoint() {
    const e = this.getRelativeCenterPoint();
    return this.group ? qt(e, this.group.calcTransformMatrix()) : e;
  }
  getRelativeCenterPoint() {
    return this.translateToCenterPoint(new B(this.left, this.top), this.originX, this.originY);
  }
  getPointByOrigin(e, t) {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), e, t);
  }
  setPositionByOrigin(e, t, n) {
    const i = this.translateToCenterPoint(e, t, n), s = this.translateToOriginPoint(i, this.originX, this.originY);
    this.set({ left: s.x, top: s.y });
  }
  _getLeftTopCoords() {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), Ke, vr);
  }
}
const i3 = ["type"], s3 = ["extraParam"];
let Vn = class Qc extends n3 {
  static getDefaults() {
    return Qc.ownDefaults;
  }
  get type() {
    const e = this.constructor.type;
    return e === "FabricObject" ? "object" : e.toLowerCase();
  }
  set type(e) {
    pi("warn", "Setting type has no effect", e);
  }
  constructor(e) {
    super(), R(this, "_cacheContext", null), Object.assign(this, Qc.ownDefaults), this.setOptions(e);
  }
  _createCacheCanvas() {
    this._cacheCanvas = Gr(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = !0;
  }
  _limitCacheSize(e) {
    const t = e.width, n = e.height, i = Ue.maxCacheSideLimit, s = Ue.minCacheSideLimit;
    if (t <= i && n <= i && t * n <= Ue.perfLimitSizeTotal) return t < s && (e.width = s), n < s && (e.height = s), e;
    const a = t / n, [c, u] = Go.limitDimsByArea(a), h = ts(s, c, i), d = ts(s, u, i);
    return t > h && (e.zoomX /= t / h, e.width = h, e.capped = !0), n > d && (e.zoomY /= n / d, e.height = d, e.capped = !0), e;
  }
  _getCacheCanvasDimensions() {
    const e = this.getTotalObjectScaling(), t = this._getTransformedDimensions({ skewX: 0, skewY: 0 }), n = t.x * e.x / this.scaleX, i = t.y * e.y / this.scaleY;
    return { width: Math.ceil(n + 2), height: Math.ceil(i + 2), zoomX: e.x, zoomY: e.y, x: n, y: i };
  }
  _updateCacheCanvas() {
    const e = this._cacheCanvas, t = this._cacheContext, { width: n, height: i, zoomX: s, zoomY: a, x: c, y: u } = this._limitCacheSize(this._getCacheCanvasDimensions()), h = n !== e.width || i !== e.height, d = this.zoomX !== s || this.zoomY !== a;
    if (!e || !t) return !1;
    if (h || d) {
      n !== e.width || i !== e.height ? (e.width = n, e.height = i) : (t.setTransform(1, 0, 0, 1, 0, 0), t.clearRect(0, 0, e.width, e.height));
      const p = c / 2, g = u / 2;
      return this.cacheTranslationX = Math.round(e.width / 2 - p) + p, this.cacheTranslationY = Math.round(e.height / 2 - g) + g, t.translate(this.cacheTranslationX, this.cacheTranslationY), t.scale(s, a), this.zoomX = s, this.zoomY = a, !0;
    }
    return !1;
  }
  setOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setOptions(e);
  }
  transform(e) {
    const t = this.group && !this.group._transformDone || this.group && this.canvas && e === this.canvas.contextTop, n = this.calcTransformMatrix(!t);
    e.transform(n[0], n[1], n[2], n[3], n[4], n[5]);
  }
  getObjectScaling() {
    if (!this.group) return new B(Math.abs(this.scaleX), Math.abs(this.scaleY));
    const e = Ys(this.calcTransformMatrix());
    return new B(Math.abs(e.scaleX), Math.abs(e.scaleY));
  }
  getTotalObjectScaling() {
    const e = this.getObjectScaling();
    if (this.canvas) {
      const t = this.canvas.getZoom(), n = this.getCanvasRetinaScaling();
      return e.scalarMultiply(t * n);
    }
    return e;
  }
  getObjectOpacity() {
    let e = this.opacity;
    return this.group && (e *= this.group.getObjectOpacity()), e;
  }
  _constrainScale(e) {
    return Math.abs(e) < this.minScaleLimit ? e < 0 ? -this.minScaleLimit : this.minScaleLimit : e === 0 ? 1e-4 : e;
  }
  _set(e, t) {
    e !== ar && e !== Dr || (t = this._constrainScale(t)), e === ar && t < 0 ? (this.flipX = !this.flipX, t *= -1) : e === "scaleY" && t < 0 ? (this.flipY = !this.flipY, t *= -1) : e !== "shadow" || !t || t instanceof Yn || (t = new Yn(t));
    const n = this[e] !== t;
    return this[e] = t, n && this.constructor.cacheProperties.includes(e) && (this.dirty = !0), this.parent && (this.dirty || n && this.constructor.stateProperties.includes(e)) && this.parent._set("dirty", !0), this;
  }
  isNotVisible() {
    return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;
  }
  render(e) {
    this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (e.save(), this._setupCompositeOperation(e), this.drawSelectionBackground(e), this.transform(e), this._setOpacity(e), this._setShadow(e), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(e)) : (this._removeCacheCanvas(), this.drawObject(e, !1, {}), this.dirty = !1), e.restore());
  }
  drawSelectionBackground(e) {
  }
  renderCache(e) {
    if (e = e || {}, this._cacheCanvas && this._cacheContext || this._createCacheCanvas(), this.isCacheDirty() && this._cacheContext) {
      const { zoomX: t, zoomY: n, cacheTranslationX: i, cacheTranslationY: s } = this, { width: a, height: c } = this._cacheCanvas;
      this.drawObject(this._cacheContext, e.forClipping, { zoomX: t, zoomY: n, cacheTranslationX: i, cacheTranslationY: s, width: a, height: c, parentClipPaths: [] }), this.dirty = !1;
    }
  }
  _removeCacheCanvas() {
    this._cacheCanvas = void 0, this._cacheContext = null;
  }
  hasStroke() {
    return this.stroke && this.stroke !== "transparent" && this.strokeWidth !== 0;
  }
  hasFill() {
    return this.fill && this.fill !== "transparent";
  }
  needsItsOwnCache() {
    return !!(this.paintFirst === br && this.hasFill() && this.hasStroke() && this.shadow) || !!this.clipPath;
  }
  shouldCache() {
    return this.ownCaching = this.objectCaching && (!this.parent || !this.parent.isOnACache()) || this.needsItsOwnCache(), this.ownCaching;
  }
  willDrawShadow() {
    return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
  }
  drawClipPathOnCache(e, t, n) {
    e.save(), t.inverted ? e.globalCompositeOperation = "destination-out" : e.globalCompositeOperation = "destination-in", e.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(n, 0, 0), e.restore();
  }
  drawObject(e, t, n) {
    const i = this.fill, s = this.stroke;
    t ? (this.fill = "black", this.stroke = "", this._setClippingProperties(e)) : this._renderBackground(e), this._render(e), this._drawClipPath(e, this.clipPath, n), this.fill = i, this.stroke = s;
  }
  createClipPathLayer(e, t) {
    const n = un(t), i = n.getContext("2d");
    if (i.translate(t.cacheTranslationX, t.cacheTranslationY), i.scale(t.zoomX, t.zoomY), e._cacheCanvas = n, t.parentClipPaths.forEach((s) => {
      s.transform(i);
    }), t.parentClipPaths.push(e), e.absolutePositioned) {
      const s = Pr(this.calcTransformMatrix());
      i.transform(s[0], s[1], s[2], s[3], s[4], s[5]);
    }
    return e.transform(i), e.drawObject(i, !0, t), n;
  }
  _drawClipPath(e, t, n) {
    if (!t) return;
    t._transformDone = !0;
    const i = this.createClipPathLayer(t, n);
    this.drawClipPathOnCache(e, t, i);
  }
  drawCacheOnCanvas(e) {
    e.scale(1 / this.zoomX, 1 / this.zoomY), e.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
  }
  isCacheDirty() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
    if (this.isNotVisible()) return !1;
    const t = this._cacheCanvas, n = this._cacheContext;
    return !(!t || !n || e || !this._updateCacheCanvas()) || !!(this.dirty || this.clipPath && this.clipPath.absolutePositioned) && (t && n && !e && (n.save(), n.setTransform(1, 0, 0, 1, 0, 0), n.clearRect(0, 0, t.width, t.height), n.restore()), !0);
  }
  _renderBackground(e) {
    if (!this.backgroundColor) return;
    const t = this._getNonTransformedDimensions();
    e.fillStyle = this.backgroundColor, e.fillRect(-t.x / 2, -t.y / 2, t.x, t.y), this._removeShadow(e);
  }
  _setOpacity(e) {
    this.group && !this.group._transformDone ? e.globalAlpha = this.getObjectOpacity() : e.globalAlpha *= this.opacity;
  }
  _setStrokeStyles(e, t) {
    const n = t.stroke;
    n && (e.lineWidth = t.strokeWidth, e.lineCap = t.strokeLineCap, e.lineDashOffset = t.strokeDashOffset, e.lineJoin = t.strokeLineJoin, e.miterLimit = t.strokeMiterLimit, Yr(n) ? n.gradientUnits === "percentage" || n.gradientTransform || n.patternTransform ? this._applyPatternForTransformedGradient(e, n) : (e.strokeStyle = n.toLive(e), this._applyPatternGradientTransform(e, n)) : e.strokeStyle = t.stroke);
  }
  _setFillStyles(e, t) {
    let { fill: n } = t;
    n && (Yr(n) ? (e.fillStyle = n.toLive(e), this._applyPatternGradientTransform(e, n)) : e.fillStyle = n);
  }
  _setClippingProperties(e) {
    e.globalAlpha = 1, e.strokeStyle = "transparent", e.fillStyle = "#000000";
  }
  _setLineDash(e, t) {
    t && t.length !== 0 && e.setLineDash(t);
  }
  _setShadow(e) {
    if (!this.shadow) return;
    const t = this.shadow, n = this.canvas, i = this.getCanvasRetinaScaling(), [s, , , a] = n?.viewportTransform || or, c = s * i, u = a * i, h = t.nonScaling ? new B(1, 1) : this.getObjectScaling();
    e.shadowColor = t.color, e.shadowBlur = t.blur * Ue.browserShadowBlurConstant * (c + u) * (h.x + h.y) / 4, e.shadowOffsetX = t.offsetX * c * h.x, e.shadowOffsetY = t.offsetY * u * h.y;
  }
  _removeShadow(e) {
    this.shadow && (e.shadowColor = "", e.shadowBlur = e.shadowOffsetX = e.shadowOffsetY = 0);
  }
  _applyPatternGradientTransform(e, t) {
    if (!Yr(t)) return { offsetX: 0, offsetY: 0 };
    const n = t.gradientTransform || t.patternTransform, i = -this.width / 2 + t.offsetX || 0, s = -this.height / 2 + t.offsetY || 0;
    return t.gradientUnits === "percentage" ? e.transform(this.width, 0, 0, this.height, i, s) : e.transform(1, 0, 0, 1, i, s), n && e.transform(n[0], n[1], n[2], n[3], n[4], n[5]), { offsetX: i, offsetY: s };
  }
  _renderPaintInOrder(e) {
    this.paintFirst === br ? (this._renderStroke(e), this._renderFill(e)) : (this._renderFill(e), this._renderStroke(e));
  }
  _render(e) {
  }
  _renderFill(e) {
    this.fill && (e.save(), this._setFillStyles(e, this), this.fillRule === "evenodd" ? e.fill("evenodd") : e.fill(), e.restore());
  }
  _renderStroke(e) {
    if (this.stroke && this.strokeWidth !== 0) {
      if (this.shadow && !this.shadow.affectStroke && this._removeShadow(e), e.save(), this.strokeUniform) {
        const t = this.getObjectScaling();
        e.scale(1 / t.x, 1 / t.y);
      }
      this._setLineDash(e, this.strokeDashArray), this._setStrokeStyles(e, this), e.stroke(), e.restore();
    }
  }
  _applyPatternForTransformedGradient(e, t) {
    var n;
    const i = this._limitCacheSize(this._getCacheCanvasDimensions()), s = this.getCanvasRetinaScaling(), a = i.x / this.scaleX / s, c = i.y / this.scaleY / s, u = un({ width: Math.ceil(a), height: Math.ceil(c) }), h = u.getContext("2d");
    h && (h.beginPath(), h.moveTo(0, 0), h.lineTo(a, 0), h.lineTo(a, c), h.lineTo(0, c), h.closePath(), h.translate(a / 2, c / 2), h.scale(i.zoomX / this.scaleX / s, i.zoomY / this.scaleY / s), this._applyPatternGradientTransform(h, t), h.fillStyle = t.toLive(e), h.fill(), e.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), e.scale(s * this.scaleX / i.zoomX, s * this.scaleY / i.zoomY), e.strokeStyle = (n = h.createPattern(u, "no-repeat")) !== null && n !== void 0 ? n : "");
  }
  _findCenterFromElement() {
    return new B(this.left + this.width / 2, this.top + this.height / 2);
  }
  clone(e) {
    const t = this.toObject(e);
    return this.constructor.fromObject(t);
  }
  cloneAsImage(e) {
    const t = this.toCanvasElement(e);
    return new (ne.getClass("image"))(t);
  }
  toCanvasElement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = sp(this), n = this.group, i = this.shadow, s = Math.abs, a = e.enableRetinaScaling ? Lb() : 1, c = (e.multiplier || 1) * a, u = e.canvasProvider || ((E) => new Sa(E, { enableRetinaScaling: !1, renderOnAddRemove: !1, skipOffscreen: !1 }));
    delete this.group, e.withoutTransform && nw(this), e.withoutShadow && (this.shadow = null), e.viewportTransform && Yd(this, this.getViewportTransform()), this.setCoords();
    const h = Gr(), d = this.getBoundingRect(), p = this.shadow, g = new B();
    if (p) {
      const E = p.blur, k = p.nonScaling ? new B(1, 1) : this.getObjectScaling();
      g.x = 2 * Math.round(s(p.offsetX) + E) * s(k.x), g.y = 2 * Math.round(s(p.offsetY) + E) * s(k.y);
    }
    const v = d.width + g.x, y = d.height + g.y;
    h.width = Math.ceil(v), h.height = Math.ceil(y);
    const x = u(h);
    e.format === "jpeg" && (x.backgroundColor = "#fff"), this.setPositionByOrigin(new B(x.width / 2, x.height / 2), Pe, Pe);
    const _ = this.canvas;
    x._objects = [this], this.set("canvas", x), this.setCoords();
    const C = x.toCanvasElement(c || 1, e);
    return this.set("canvas", _), this.shadow = i, n && (this.group = n), this.set(t), this.setCoords(), x._objects = [], x.destroy(), C;
  }
  toDataURL() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return tp(this.toCanvasElement(e), e.format || "png", e.quality || 1);
  }
  isType() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    return t.includes(this.constructor.type) || t.includes(this.type);
  }
  complexity() {
    return 1;
  }
  toJSON() {
    return this.toObject();
  }
  rotate(e) {
    const { centeredRotation: t, originX: n, originY: i } = this;
    if (t) {
      const { x: s, y: a } = this.getRelativeCenterPoint();
      this.originX = Pe, this.originY = Pe, this.left = s, this.top = a;
    }
    if (this.set("angle", e), t) {
      const { x: s, y: a } = this.translateToOriginPoint(this.getRelativeCenterPoint(), n, i);
      this.left = s, this.top = a, this.originX = n, this.originY = i;
    }
  }
  setOnGroup() {
  }
  _setupCompositeOperation(e) {
    this.globalCompositeOperation && (e.globalCompositeOperation = this.globalCompositeOperation);
  }
  dispose() {
    fl.cancelByTarget(this), this.off(), this._set("canvas", void 0), this._cacheCanvas && En().dispose(this._cacheCanvas), this._cacheCanvas = void 0, this._cacheContext = null;
  }
  animate(e, t) {
    return Object.entries(e).reduce((n, i) => {
      let [s, a] = i;
      return n[s] = this._animate(s, a, t), n;
    }, {});
  }
  _animate(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = e.split("."), s = this.constructor.colorProperties.includes(i[i.length - 1]), { abort: a, startValue: c, onChange: u, onComplete: h } = n, d = D(D({}, n), {}, { target: this, startValue: c ?? i.reduce((p, g) => p[g], this), endValue: t, abort: a?.bind(this), onChange: (p, g, v) => {
      i.reduce((y, x, _) => (_ === i.length - 1 && (y[x] = p), y[x]), this), u && u(p, g, v);
    }, onComplete: (p, g, v) => {
      this.setCoords(), h && h(p, g, v);
    } });
    return s ? fw(d) : hp(d);
  }
  isDescendantOf(e) {
    const { parent: t, group: n } = this;
    return t === e || n === e || !!t && t.isDescendantOf(e) || !!n && n !== t && n.isDescendantOf(e);
  }
  getAncestors() {
    const e = [];
    let t = this;
    do
      t = t.parent, t && e.push(t);
    while (t);
    return e;
  }
  findCommonAncestors(e) {
    if (this === e) return { fork: [], otherFork: [], common: [this, ...this.getAncestors()] };
    const t = this.getAncestors(), n = e.getAncestors();
    if (t.length === 0 && n.length > 0 && this === n[n.length - 1]) return { fork: [], otherFork: [e, ...n.slice(0, n.length - 1)], common: [this] };
    for (let i, s = 0; s < t.length; s++) {
      if (i = t[s], i === e) return { fork: [this, ...t.slice(0, s)], otherFork: [], common: t.slice(s) };
      for (let a = 0; a < n.length; a++) {
        if (this === n[a]) return { fork: [], otherFork: [e, ...n.slice(0, a)], common: [this, ...t] };
        if (i === n[a]) return { fork: [this, ...t.slice(0, s)], otherFork: [e, ...n.slice(0, a)], common: t.slice(s) };
      }
    }
    return { fork: [this, ...t], otherFork: [e, ...n], common: [] };
  }
  hasCommonAncestors(e) {
    const t = this.findCommonAncestors(e);
    return t && !!t.common.length;
  }
  isInFrontOf(e) {
    if (this === e) return;
    const t = this.findCommonAncestors(e);
    if (t.fork.includes(e)) return !0;
    if (t.otherFork.includes(this)) return !1;
    const n = t.common[0] || this.canvas;
    if (!n) return;
    const i = t.fork.pop(), s = t.otherFork.pop(), a = n._objects.indexOf(i), c = n._objects.indexOf(s);
    return a > -1 && a > c;
  }
  toObject() {
    const e = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).concat(Qc.customProperties, this.constructor.customProperties || []);
    let t;
    const n = Ue.NUM_FRACTION_DIGITS, { clipPath: i, fill: s, stroke: a, shadow: c, strokeDashArray: u, left: h, top: d, originX: p, originY: g, width: v, height: y, strokeWidth: x, strokeLineCap: _, strokeDashOffset: C, strokeLineJoin: E, strokeUniform: k, strokeMiterLimit: O, scaleX: P, scaleY: j, angle: V, flipX: F, flipY: $, opacity: z, visible: G, backgroundColor: H, fillRule: Y, paintFirst: te, globalCompositeOperation: ge, skewX: Z, skewY: de } = this;
    i && !i.excludeFromExport && (t = i.toObject(e.concat("inverted", "absolutePositioned")));
    const oe = (pe) => ut(pe, n), ie = D(D({}, fs(this, e)), {}, { type: this.constructor.type, version: Wd, originX: p, originY: g, left: oe(h), top: oe(d), width: oe(v), height: oe(y), fill: f0(s) ? s.toObject() : s, stroke: f0(a) ? a.toObject() : a, strokeWidth: oe(x), strokeDashArray: u && u.concat(), strokeLineCap: _, strokeDashOffset: C, strokeLineJoin: E, strokeUniform: k, strokeMiterLimit: oe(O), scaleX: oe(P), scaleY: oe(j), angle: oe(V), flipX: F, flipY: $, opacity: oe(z), shadow: c && c.toObject(), visible: G, backgroundColor: H, fillRule: Y, paintFirst: te, globalCompositeOperation: ge, skewX: oe(Z), skewY: oe(de) }, t ? { clipPath: t } : null);
    return this.includeDefaultValues ? ie : this._removeDefaultValues(ie);
  }
  toDatalessObject(e) {
    return this.toObject(e);
  }
  _removeDefaultValues(e) {
    const t = this.constructor.getDefaults(), n = Object.keys(t).length > 0 ? t : Object.getPrototypeOf(this);
    return ip(e, (i, s) => {
      if (s === Ke || s === vr || s === "type") return !0;
      const a = n[s];
      return i !== a && !(Array.isArray(i) && Array.isArray(a) && i.length === 0 && a.length === 0);
    });
  }
  toString() {
    return "#<".concat(this.constructor.type, ">");
  }
  static _fromObject(e) {
    let t = ht(e, i3), n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { extraParam: i } = n, s = ht(n, s3);
    return _a(t, s).then((a) => i ? (delete a[i], new this(t[i], a)) : new this(a));
  }
  static fromObject(e, t) {
    return this._fromObject(e, t);
  }
};
R(Vn, "stateProperties", Y4), R(Vn, "cacheProperties", Kn), R(Vn, "ownDefaults", X4), R(Vn, "type", "FabricObject"), R(Vn, "colorProperties", [Lt, br, "backgroundColor"]), R(Vn, "customProperties", []), ne.setClass(Vn), ne.setClass(Vn, "object");
const Ti = (r, e, t) => (n, i, s, a) => {
  const c = e(n, i, s, a);
  return c && op(r, D(D({}, ap(n, i, s, a)), t)), c;
};
function ps(r) {
  return (e, t, n, i) => {
    const { target: s, originX: a, originY: c } = t, u = s.getRelativeCenterPoint(), h = s.translateToOriginPoint(u, a, c), d = r(e, t, n, i);
    return s.setPositionByOrigin(h, t.originX, t.originY), d;
  };
}
const qd = Ti(na, ps((r, e, t, n) => {
  const i = su(e, e.originX, e.originY, t, n);
  if (Et(e.originX) === Et(Pe) || Et(e.originX) === Et(Ct) && i.x < 0 || Et(e.originX) === Et(Ke) && i.x > 0) {
    const { target: s } = e, a = s.strokeWidth / (s.strokeUniform ? s.scaleX : 1), c = sw(e) ? 2 : 1, u = s.width, h = Math.abs(i.x * c / s.scaleX) - a;
    return s.set("width", Math.max(h, 1)), u !== s.width;
  }
  return !1;
}));
function pw(r, e, t, n, i) {
  n = n || {};
  const s = this.sizeX || n.cornerSize || i.cornerSize, a = this.sizeY || n.cornerSize || i.cornerSize, c = n.transparentCorners !== void 0 ? n.transparentCorners : i.transparentCorners, u = c ? br : Lt, h = !c && (n.cornerStrokeColor || i.cornerStrokeColor);
  let d, p = e, g = t;
  r.save(), r.fillStyle = n.cornerColor || i.cornerColor || "", r.strokeStyle = n.cornerStrokeColor || i.cornerStrokeColor || "", s > a ? (d = s, r.scale(1, a / s), g = t * s / a) : a > s ? (d = a, r.scale(s / a, 1), p = e * a / s) : d = s, r.beginPath(), r.arc(p, g, d / 2, 0, qn, !1), r[u](), h && r.stroke(), r.restore();
}
function gw(r, e, t, n, i) {
  n = n || {};
  const s = this.sizeX || n.cornerSize || i.cornerSize, a = this.sizeY || n.cornerSize || i.cornerSize, c = n.transparentCorners !== void 0 ? n.transparentCorners : i.transparentCorners, u = c ? br : Lt, h = !c && (n.cornerStrokeColor || i.cornerStrokeColor), d = s / 2, p = a / 2;
  r.save(), r.fillStyle = n.cornerColor || i.cornerColor || "", r.strokeStyle = n.cornerStrokeColor || i.cornerStrokeColor || "", r.translate(e, t);
  const g = i.getTotalAngle();
  r.rotate(bt(g)), r["".concat(u, "Rect")](-d, -p, s, a), h && r.strokeRect(-d, -p, s, a), r.restore();
}
class gt {
  constructor(e) {
    R(this, "visible", !0), R(this, "actionName", tu), R(this, "angle", 0), R(this, "x", 0), R(this, "y", 0), R(this, "offsetX", 0), R(this, "offsetY", 0), R(this, "sizeX", 0), R(this, "sizeY", 0), R(this, "touchSizeX", 0), R(this, "touchSizeY", 0), R(this, "cursorStyle", "crosshair"), R(this, "withConnection", !1), Object.assign(this, e);
  }
  shouldActivate(e, t, n, i) {
    var s;
    let { tl: a, tr: c, br: u, bl: h } = i;
    return ((s = t.canvas) === null || s === void 0 ? void 0 : s.getActiveObject()) === t && t.isControlVisible(e) && pt.isPointInPolygon(n, [a, c, u, h]);
  }
  getActionHandler(e, t, n) {
    return this.actionHandler;
  }
  getMouseDownHandler(e, t, n) {
    return this.mouseDownHandler;
  }
  getMouseUpHandler(e, t, n) {
    return this.mouseUpHandler;
  }
  cursorStyleHandler(e, t, n) {
    return t.cursorStyle;
  }
  getActionName(e, t, n) {
    return t.actionName;
  }
  getVisibility(e, t) {
    var n, i;
    return (n = (i = e._controlsVisibility) === null || i === void 0 ? void 0 : i[t]) !== null && n !== void 0 ? n : this.visible;
  }
  setVisibility(e, t, n) {
    this.visible = e;
  }
  positionHandler(e, t, n, i) {
    return new B(this.x * e.x + this.offsetX, this.y * e.y + this.offsetY).transform(t);
  }
  calcCornerCoords(e, t, n, i, s, a) {
    const c = ru([ho(n, i), fo({ angle: e }), nu((s ? this.touchSizeX : this.sizeX) || t, (s ? this.touchSizeY : this.sizeY) || t)]);
    return { tl: new B(-0.5, -0.5).transform(c), tr: new B(0.5, -0.5).transform(c), br: new B(0.5, 0.5).transform(c), bl: new B(-0.5, 0.5).transform(c) };
  }
  render(e, t, n, i, s) {
    ((i = i || {}).cornerStyle || s.cornerStyle) === "circle" ? pw.call(this, e, t, n, i, s) : gw.call(this, e, t, n, i, s);
  }
}
const mw = (r, e, t) => t.lockRotation ? gl : e.cursorStyle, vw = Ti(Bb, ps((r, e, t, n) => {
  let { target: i, ex: s, ey: a, theta: c, originX: u, originY: h } = e;
  const d = i.translateToOriginPoint(i.getRelativeCenterPoint(), u, h);
  if (on(i, "lockRotation")) return !1;
  const p = Math.atan2(a - d.y, s - d.x), g = Math.atan2(n - d.y, t - d.x);
  let v = vi(g - p + c);
  if (i.snapAngle && i.snapAngle > 0) {
    const x = i.snapAngle, _ = i.snapThreshold || x, C = Math.ceil(v / x) * x, E = Math.floor(v / x) * x;
    Math.abs(v - E) < _ ? v = E : Math.abs(v - C) < _ && (v = C);
  }
  v < 0 && (v = 360 + v), v %= 360;
  const y = i.angle !== v;
  return i.angle = v, y;
}));
function yw(r, e) {
  const t = e.canvas, n = r[t.uniScaleKey];
  return t.uniformScaling && !n || !t.uniformScaling && n;
}
function bw(r, e, t) {
  const n = on(r, "lockScalingX"), i = on(r, "lockScalingY");
  if (n && i || !e && (n || i) && t || n && e === "x" || i && e === "y") return !0;
  const { width: s, height: a, strokeWidth: c } = r;
  return s === 0 && c === 0 && e !== "y" || a === 0 && c === 0 && e !== "x";
}
const o3 = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"], Ns = (r, e, t) => {
  const n = yw(r, t);
  if (bw(t, e.x !== 0 && e.y === 0 ? "x" : e.x === 0 && e.y !== 0 ? "y" : "", n)) return gl;
  const i = ow(t, e);
  return "".concat(o3[i], "-resize");
};
function dp(r, e, t, n) {
  let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const s = e.target, a = i.by, c = yw(r, s);
  let u, h, d, p, g, v;
  if (bw(s, a, c)) return !1;
  if (e.gestureScale) h = e.scaleX * e.gestureScale, d = e.scaleY * e.gestureScale;
  else {
    if (u = su(e, e.originX, e.originY, t, n), g = a !== "y" ? Math.sign(u.x || e.signX || 1) : 1, v = a !== "x" ? Math.sign(u.y || e.signY || 1) : 1, e.signX || (e.signX = g), e.signY || (e.signY = v), on(s, "lockScalingFlip") && (e.signX !== g || e.signY !== v)) return !1;
    if (p = s._getTransformedDimensions(), c && !a) {
      const _ = Math.abs(u.x) + Math.abs(u.y), { original: C } = e, E = _ / (Math.abs(p.x * C.scaleX / s.scaleX) + Math.abs(p.y * C.scaleY / s.scaleY));
      h = C.scaleX * E, d = C.scaleY * E;
    } else h = Math.abs(u.x * s.scaleX / p.x), d = Math.abs(u.y * s.scaleY / p.y);
    sw(e) && (h *= 2, d *= 2), e.signX !== g && a !== "y" && (e.originX = m0(e.originX), h *= -1, e.signX = g), e.signY !== v && a !== "x" && (e.originY = m0(e.originY), d *= -1, e.signY = v);
  }
  const y = s.scaleX, x = s.scaleY;
  return a ? (a === "x" && s.set(ar, h), a === "y" && s.set(Dr, d)) : (!on(s, "lockScalingX") && s.set(ar, h), !on(s, "lockScalingY") && s.set(Dr, d)), y !== s.scaleX || x !== s.scaleY;
}
const Ho = Ti(eu, ps((r, e, t, n) => dp(r, e, t, n))), ww = Ti(eu, ps((r, e, t, n) => dp(r, e, t, n, { by: "x" }))), xw = Ti(eu, ps((r, e, t, n) => dp(r, e, t, n, { by: "y" }))), a3 = ["target", "ex", "ey", "skewingSide"], Kh = { x: { counterAxis: "y", scale: ar, skew: lo, lockSkewing: "lockSkewingX", origin: "originX", flip: "flipX" }, y: { counterAxis: "x", scale: Dr, skew: uo, lockSkewing: "lockSkewingY", origin: "originY", flip: "flipY" } }, c3 = ["ns", "nesw", "ew", "nwse"], _w = (r, e, t) => {
  if (e.x !== 0 && on(t, "lockSkewingY") || e.y !== 0 && on(t, "lockSkewingX")) return gl;
  const n = ow(t, e) % 4;
  return "".concat(c3[n], "-resize");
};
function Sw(r, e, t, n, i) {
  const { target: s } = t, { counterAxis: a, origin: c, lockSkewing: u, skew: h, flip: d } = Kh[r];
  if (on(s, u)) return !1;
  const { origin: p, flip: g } = Kh[a], v = Et(t[p]) * (s[g] ? -1 : 1), y = -Math.sign(v) * (s[d] ? -1 : 1), x = 0.5 * -((s[h] === 0 && su(t, Pe, Pe, n, i)[r] > 0 || s[h] > 0 ? 1 : -1) * y) + 0.5;
  return Ti(Vb, ps((C, E, k, O) => function(P, j, V) {
    let { target: F, ex: $, ey: z, skewingSide: G } = j, H = ht(j, a3);
    const { skew: Y } = Kh[P], te = V.subtract(new B($, z)).divide(new B(F.scaleX, F.scaleY))[P], ge = F[Y], Z = H[Y], de = Math.tan(bt(Z)), oe = P === "y" ? F._getTransformedDimensions({ scaleX: 1, scaleY: 1, skewX: 0 }).x : F._getTransformedDimensions({ scaleX: 1, scaleY: 1 }).y, ie = 2 * te * G / Math.max(oe, 1) + de, pe = vi(Math.atan(ie));
    F.set(Y, pe);
    const re = ge !== F[Y];
    if (re && P === "y") {
      const { skewX: Be, scaleX: Ze } = F, ze = F._getTransformedDimensions({ skewY: ge }), Ee = F._getTransformedDimensions(), Ie = Be !== 0 ? ze.x / Ee.x : 1;
      Ie !== 1 && F.set(ar, Ie * Ze);
    }
    return re;
  }(r, E, new B(k, O))))(e, D(D({}, t), {}, { [c]: x, skewingSide: y }), n, i);
}
const Cw = (r, e, t, n) => Sw("x", r, e, t, n), Tw = (r, e, t, n) => Sw("y", r, e, t, n);
function cu(r, e) {
  return r[e.canvas.altActionKey];
}
const Uo = (r, e, t) => {
  const n = cu(r, t);
  return e.x === 0 ? n ? lo : Dr : e.y === 0 ? n ? uo : ar : "";
}, Xi = (r, e, t) => cu(r, t) ? _w(0, e, t) : Ns(r, e, t), Kd = (r, e, t, n) => cu(r, e.target) ? Tw(r, e, t, n) : ww(r, e, t, n), Zd = (r, e, t, n) => cu(r, e.target) ? Cw(r, e, t, n) : xw(r, e, t, n), fp = () => ({ ml: new gt({ x: -0.5, y: 0, cursorStyleHandler: Xi, actionHandler: Kd, getActionName: Uo }), mr: new gt({ x: 0.5, y: 0, cursorStyleHandler: Xi, actionHandler: Kd, getActionName: Uo }), mb: new gt({ x: 0, y: 0.5, cursorStyleHandler: Xi, actionHandler: Zd, getActionName: Uo }), mt: new gt({ x: 0, y: -0.5, cursorStyleHandler: Xi, actionHandler: Zd, getActionName: Uo }), tl: new gt({ x: -0.5, y: -0.5, cursorStyleHandler: Ns, actionHandler: Ho }), tr: new gt({ x: 0.5, y: -0.5, cursorStyleHandler: Ns, actionHandler: Ho }), bl: new gt({ x: -0.5, y: 0.5, cursorStyleHandler: Ns, actionHandler: Ho }), br: new gt({ x: 0.5, y: 0.5, cursorStyleHandler: Ns, actionHandler: Ho }), mtr: new gt({ x: 0, y: -0.5, actionHandler: vw, cursorStyleHandler: mw, offsetY: -40, withConnection: !0, actionName: Qf }) }), Ew = () => ({ mr: new gt({ x: 0.5, y: 0, actionHandler: qd, cursorStyleHandler: Xi, actionName: na }), ml: new gt({ x: -0.5, y: 0, actionHandler: qd, cursorStyleHandler: Xi, actionName: na }) }), kw = () => D(D({}, fp()), Ew());
class oa extends Vn {
  static getDefaults() {
    return D(D({}, super.getDefaults()), oa.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, this.constructor.createControls(), oa.ownDefaults), this.setOptions(e);
  }
  static createControls() {
    return { controls: fp() };
  }
  _updateCacheCanvas() {
    const e = this.canvas;
    if (this.noScaleCache && e && e._currentTransform) {
      const t = e._currentTransform, n = t.target, i = t.action;
      if (this === n && i && i.startsWith(tu)) return !1;
    }
    return super._updateCacheCanvas();
  }
  getActiveControl() {
    const e = this.__corner;
    return e ? { key: e, control: this.controls[e], coord: this.oCoords[e] } : void 0;
  }
  findControl(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    if (!this.hasControls || !this.canvas) return;
    this.__corner = void 0;
    const n = Object.entries(this.oCoords);
    for (let i = n.length - 1; i >= 0; i--) {
      const [s, a] = n[i], c = this.controls[s];
      if (c.shouldActivate(s, this, e, t ? a.touchCorner : a.corner)) return this.__corner = s, { key: s, control: c, coord: this.oCoords[s] };
    }
  }
  calcOCoords() {
    const e = this.getViewportTransform(), t = this.getCenterPoint(), n = ho(t.x, t.y), i = fo({ angle: this.getTotalAngle() - (this.group && this.flipX ? 180 : 0) }), s = wt(n, i), a = wt(e, s), c = wt(a, [1 / e[0], 0, 0, 1 / e[3], 0, 0]), u = this.group ? Ys(this.calcTransformMatrix()) : void 0;
    u && (u.scaleX = Math.abs(u.scaleX), u.scaleY = Math.abs(u.scaleY));
    const h = this._calculateCurrentDimensions(u), d = {};
    return this.forEachControl((p, g) => {
      const v = p.positionHandler(h, c, this, p);
      d[g] = Object.assign(v, this._calcCornerCoords(p, v));
    }), d;
  }
  _calcCornerCoords(e, t) {
    const n = this.getTotalAngle();
    return { corner: e.calcCornerCoords(n, this.cornerSize, t.x, t.y, !1, this), touchCorner: e.calcCornerCoords(n, this.touchCornerSize, t.x, t.y, !0, this) };
  }
  setCoords() {
    super.setCoords(), this.canvas && (this.oCoords = this.calcOCoords());
  }
  forEachControl(e) {
    for (const t in this.controls) e(this.controls[t], t, this);
  }
  drawSelectionBackground(e) {
    if (!this.selectionBackgroundColor || this.canvas && this.canvas._activeObject !== this) return;
    e.save();
    const t = this.getRelativeCenterPoint(), n = this._calculateCurrentDimensions(), i = this.getViewportTransform();
    e.translate(t.x, t.y), e.scale(1 / i[0], 1 / i[3]), e.rotate(bt(this.angle)), e.fillStyle = this.selectionBackgroundColor, e.fillRect(-n.x / 2, -n.y / 2, n.x, n.y), e.restore();
  }
  strokeBorders(e, t) {
    e.strokeRect(-t.x / 2, -t.y / 2, t.x, t.y);
  }
  _drawBorders(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = D({ hasControls: this.hasControls, borderColor: this.borderColor, borderDashArray: this.borderDashArray }, n);
    e.save(), e.strokeStyle = i.borderColor, this._setLineDash(e, i.borderDashArray), this.strokeBorders(e, t), i.hasControls && this.drawControlsConnectingLines(e, t), e.restore();
  }
  _renderControls(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { hasBorders: n, hasControls: i } = this, s = D({ hasBorders: n, hasControls: i }, t), a = this.getViewportTransform(), c = s.hasBorders, u = s.hasControls, h = wt(a, this.calcTransformMatrix()), d = Ys(h);
    e.save(), e.translate(d.translateX, d.translateY), e.lineWidth = this.borderScaleFactor, this.group === this.parent && (e.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (d.angle -= 180), e.rotate(bt(this.group ? d.angle : this.angle)), c && this.drawBorders(e, d, t), u && this.drawControls(e, t), e.restore();
  }
  drawBorders(e, t, n) {
    let i;
    if (n && n.forActiveSelection || this.group) {
      const s = iu(this.width, this.height, xa(t)), a = this.isStrokeAccountedForInDimensions() ? ep : (this.strokeUniform ? new B().scalarAdd(this.canvas ? this.canvas.getZoom() : 1) : new B(t.scaleX, t.scaleY)).scalarMultiply(this.strokeWidth);
      i = s.add(a).scalarAdd(this.borderScaleFactor).scalarAdd(2 * this.padding);
    } else i = this._calculateCurrentDimensions().scalarAdd(this.borderScaleFactor);
    this._drawBorders(e, i, n);
  }
  drawControlsConnectingLines(e, t) {
    let n = !1;
    e.beginPath(), this.forEachControl((i, s) => {
      i.withConnection && i.getVisibility(this, s) && (n = !0, e.moveTo(i.x * t.x, i.y * t.y), e.lineTo(i.x * t.x + i.offsetX, i.y * t.y + i.offsetY));
    }), n && e.stroke();
  }
  drawControls(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e.save();
    const n = this.getCanvasRetinaScaling(), { cornerStrokeColor: i, cornerDashArray: s, cornerColor: a } = this, c = D({ cornerStrokeColor: i, cornerDashArray: s, cornerColor: a }, t);
    e.setTransform(n, 0, 0, n, 0, 0), e.strokeStyle = e.fillStyle = c.cornerColor, this.transparentCorners || (e.strokeStyle = c.cornerStrokeColor), this._setLineDash(e, c.cornerDashArray), this.forEachControl((u, h) => {
      if (u.getVisibility(this, h)) {
        const d = this.oCoords[h];
        u.render(e, d.x, d.y, c, this);
      }
    }), e.restore();
  }
  isControlVisible(e) {
    return this.controls[e] && this.controls[e].getVisibility(this, e);
  }
  setControlVisible(e, t) {
    this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[e] = t;
  }
  setControlsVisibility() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.entries(e).forEach((t) => {
      let [n, i] = t;
      return this.setControlVisible(n, i);
    });
  }
  clearContextTop(e) {
    if (!this.canvas) return;
    const t = this.canvas.contextTop;
    if (!t) return;
    const n = this.canvas.viewportTransform;
    t.save(), t.transform(n[0], n[1], n[2], n[3], n[4], n[5]), this.transform(t);
    const i = this.width + 4, s = this.height + 4;
    return t.clearRect(-i / 2, -s / 2, i, s), e || t.restore(), t;
  }
  onDeselect(e) {
    return !1;
  }
  onSelect(e) {
    return !1;
  }
  shouldStartDragging(e) {
    return !1;
  }
  onDragStart(e) {
    return !1;
  }
  canDrop(e) {
    return !1;
  }
  renderDragSourceEffect(e) {
  }
  renderDropTargetEffect(e) {
  }
}
function Ow(r, e) {
  return e.forEach((t) => {
    Object.getOwnPropertyNames(t.prototype).forEach((n) => {
      n !== "constructor" && Object.defineProperty(r.prototype, n, Object.getOwnPropertyDescriptor(t.prototype, n) || /* @__PURE__ */ Object.create(null));
    });
  }), r;
}
R(oa, "ownDefaults", { noScaleCache: !0, lockMovementX: !1, lockMovementY: !1, lockRotation: !1, lockScalingX: !1, lockScalingY: !1, lockSkewingX: !1, lockSkewingY: !1, lockScalingFlip: !1, cornerSize: 13, touchCornerSize: 24, transparentCorners: !0, cornerColor: "rgb(178,204,255)", cornerStrokeColor: "", cornerStyle: "rect", cornerDashArray: null, hasControls: !0, borderColor: "rgb(178,204,255)", borderDashArray: null, borderOpacityWhenMoving: 0.4, borderScaleFactor: 1, hasBorders: !0, selectionBackgroundColor: "", selectable: !0, evented: !0, perPixelTargetFind: !1, activeOn: "down", hoverCursor: null, moveCursor: null });
class rt extends oa {
}
Ow(rt, [cw]), ne.setClass(rt), ne.setClass(rt, "object");
const Iw = (r, e, t, n) => {
  const i = 2 * (n = Math.round(n)) + 1, { data: s } = r.getImageData(e - n, t - n, i, i);
  for (let a = 3; a < s.length; a += 4)
    if (s[a] > 0) return !1;
  return !0;
};
class Aw {
  constructor(e) {
    this.options = e, this.strokeProjectionMagnitude = this.options.strokeWidth / 2, this.scale = new B(this.options.scaleX, this.options.scaleY), this.strokeUniformScalar = this.options.strokeUniform ? new B(1 / this.options.scaleX, 1 / this.options.scaleY) : new B(1, 1);
  }
  createSideVector(e, t) {
    const n = ml(e, t);
    return this.options.strokeUniform ? n.multiply(this.scale) : n;
  }
  projectOrthogonally(e, t, n) {
    return this.applySkew(e.add(this.calcOrthogonalProjection(e, t, n)));
  }
  isSkewed() {
    return this.options.skewX !== 0 || this.options.skewY !== 0;
  }
  applySkew(e) {
    const t = new B(e);
    return t.y += t.x * Math.tan(bt(this.options.skewY)), t.x += t.y * Math.tan(bt(this.options.skewX)), t;
  }
  scaleUnitVector(e, t) {
    return e.multiply(this.strokeUniformScalar).scalarMultiply(t);
  }
}
const l3 = new B();
class Hs extends Aw {
  static getOrthogonalRotationFactor(e, t) {
    const n = t ? yl(e, t) : uw(e);
    return Math.abs(n) < gi ? -1 : 1;
  }
  constructor(e, t, n, i) {
    super(i), R(this, "AB", void 0), R(this, "AC", void 0), R(this, "alpha", void 0), R(this, "bisector", void 0), this.A = new B(e), this.B = new B(t), this.C = new B(n), this.AB = this.createSideVector(this.A, this.B), this.AC = this.createSideVector(this.A, this.C), this.alpha = yl(this.AB, this.AC), this.bisector = au(cp(this.AB.eq(l3) ? this.AC : this.AB, this.alpha / 2));
  }
  calcOrthogonalProjection(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;
    const i = this.createSideVector(e, t), s = lp(i), a = Hs.getOrthogonalRotationFactor(s, this.bisector);
    return this.scaleUnitVector(s, n * a);
  }
  projectBevel() {
    const e = [];
    return (this.alpha % qn == 0 ? [this.B] : [this.B, this.C]).forEach((t) => {
      e.push(this.projectOrthogonally(this.A, t)), e.push(this.projectOrthogonally(this.A, t, -this.strokeProjectionMagnitude));
    }), e;
  }
  projectMiter() {
    const e = [], t = Math.abs(this.alpha), n = 1 / Math.sin(t / 2), i = this.scaleUnitVector(this.bisector, -this.strokeProjectionMagnitude * n), s = this.options.strokeUniform ? vl(this.scaleUnitVector(this.bisector, this.options.strokeMiterLimit)) : this.options.strokeMiterLimit;
    return vl(i) / this.strokeProjectionMagnitude <= s && e.push(this.applySkew(this.A.add(i))), e.push(...this.projectBevel()), e;
  }
  projectRoundNoSkew(e, t) {
    const n = [], i = new B(Hs.getOrthogonalRotationFactor(this.bisector), Hs.getOrthogonalRotationFactor(new B(this.bisector.y, this.bisector.x)));
    return [new B(1, 0).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(i), new B(0, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(i)].forEach((s) => {
      Xd(s, e, t) && n.push(this.A.add(s));
    }), n;
  }
  projectRoundWithSkew(e, t) {
    const n = [], { skewX: i, skewY: s, scaleX: a, scaleY: c, strokeUniform: u } = this.options, h = new B(Math.tan(bt(i)), Math.tan(bt(s))), d = this.strokeProjectionMagnitude, p = u ? d / c / Math.sqrt(1 / c ** 2 + 1 / a ** 2 * h.y ** 2) : d / Math.sqrt(1 + h.y ** 2), g = new B(Math.sqrt(Math.max(d ** 2 - p ** 2, 0)), p), v = u ? d / Math.sqrt(1 + h.x ** 2 * (1 / c) ** 2 / (1 / a + 1 / a * h.x * h.y) ** 2) : d / Math.sqrt(1 + h.x ** 2 / (1 + h.x * h.y) ** 2), y = new B(v, Math.sqrt(Math.max(d ** 2 - v ** 2, 0)));
    return [y, y.scalarMultiply(-1), g, g.scalarMultiply(-1)].map((x) => this.applySkew(u ? x.multiply(this.strokeUniformScalar) : x)).forEach((x) => {
      Xd(x, e, t) && n.push(this.applySkew(this.A).add(x));
    }), n;
  }
  projectRound() {
    const e = [];
    e.push(...this.projectBevel());
    const t = this.alpha % qn == 0, n = this.applySkew(this.A), i = e[t ? 0 : 2].subtract(n), s = e[t ? 1 : 0].subtract(n), a = t ? this.applySkew(this.AB.scalarMultiply(-1)) : this.applySkew(this.bisector.multiply(this.strokeUniformScalar).scalarMultiply(-1)), c = Ws(i, a) > 0, u = c ? i : s, h = c ? s : i;
    return this.isSkewed() ? e.push(...this.projectRoundWithSkew(u, h)) : e.push(...this.projectRoundNoSkew(u, h)), e;
  }
  projectPoints() {
    switch (this.options.strokeLineJoin) {
      case "miter":
        return this.projectMiter();
      case "round":
        return this.projectRound();
      default:
        return this.projectBevel();
    }
  }
  project() {
    return this.projectPoints().map((e) => ({ originPoint: this.A, projectedPoint: e, angle: this.alpha, bisector: this.bisector }));
  }
}
class S0 extends Aw {
  constructor(e, t, n) {
    super(n), this.A = new B(e), this.T = new B(t);
  }
  calcOrthogonalProjection(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;
    const i = this.createSideVector(e, t);
    return this.scaleUnitVector(lp(i), n);
  }
  projectButt() {
    return [this.projectOrthogonally(this.A, this.T, this.strokeProjectionMagnitude), this.projectOrthogonally(this.A, this.T, -this.strokeProjectionMagnitude)];
  }
  projectRound() {
    const e = [];
    if (!this.isSkewed() && this.A.eq(this.T)) {
      const t = new B(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      e.push(this.applySkew(this.A.add(t)), this.applySkew(this.A.subtract(t)));
    } else e.push(...new Hs(this.A, this.T, this.T, this.options).projectRound());
    return e;
  }
  projectSquare() {
    const e = [];
    if (this.A.eq(this.T)) {
      const t = new B(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      e.push(this.A.add(t), this.A.subtract(t));
    } else {
      const t = this.calcOrthogonalProjection(this.A, this.T, this.strokeProjectionMagnitude), n = this.scaleUnitVector(au(this.createSideVector(this.A, this.T)), -this.strokeProjectionMagnitude), i = this.A.add(n);
      e.push(i.add(t), i.subtract(t));
    }
    return e.map((t) => this.applySkew(t));
  }
  projectPoints() {
    switch (this.options.strokeLineCap) {
      case "round":
        return this.projectRound();
      case "square":
        return this.projectSquare();
      default:
        return this.projectButt();
    }
  }
  project() {
    return this.projectPoints().map((e) => ({ originPoint: this.A, projectedPoint: e }));
  }
}
const Mw = function(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
  const n = [];
  if (r.length === 0) return n;
  const i = r.reduce((s, a) => (s[s.length - 1].eq(a) || s.push(new B(a)), s), [new B(r[0])]);
  if (i.length === 1) t = !0;
  else if (!t) {
    const s = i[0], a = ((c, u) => {
      for (let h = c.length - 1; h >= 0; h--) if (u(c[h], h, c)) return h;
      return -1;
    })(i, (c) => !c.eq(s));
    i.splice(a + 1);
  }
  return i.forEach((s, a, c) => {
    let u, h;
    a === 0 ? (h = c[1], u = t ? s : c[c.length - 1]) : a === c.length - 1 ? (u = c[a - 1], h = t ? s : c[0]) : (u = c[a - 1], h = c[a + 1]), t && c.length === 1 ? n.push(...new S0(s, s, e).project()) : !t || a !== 0 && a !== c.length - 1 ? n.push(...new Hs(s, u, h, e).project()) : n.push(...new S0(s, a === 0 ? h : u, e).project());
  }), n;
}, pp = (r) => {
  const e = {};
  return Object.keys(r).forEach((t) => {
    e[t] = {}, Object.keys(r[t]).forEach((n) => {
      e[t][n] = D({}, r[t][n]);
    });
  }), e;
}, Pw = (r) => r.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), lu = (r) => {
  const e = [];
  for (let t, n = 0; n < r.length; n++) (t = u3(r, n)) !== !1 && e.push(t);
  return e;
}, u3 = (r, e) => {
  const t = r.charCodeAt(e);
  if (isNaN(t)) return "";
  if (t < 55296 || t > 57343) return r.charAt(e);
  if (55296 <= t && t <= 56319) {
    if (r.length <= e + 1) throw "High surrogate without following low surrogate";
    const i = r.charCodeAt(e + 1);
    if (56320 > i || i > 57343) throw "High surrogate without following low surrogate";
    return r.charAt(e) + r.charAt(e + 1);
  }
  if (e === 0) throw "Low surrogate without preceding high surrogate";
  const n = r.charCodeAt(e - 1);
  if (55296 > n || n > 56319) throw "Low surrogate without preceding high surrogate";
  return !1;
};
var h3 = Object.freeze({ __proto__: null, capitalize: function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
  return "".concat(r.charAt(0).toUpperCase()).concat(e ? r.slice(1) : r.slice(1).toLowerCase());
}, escapeXml: Pw, graphemeSplit: lu });
const uu = function(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
  return r.fill !== e.fill || r.stroke !== e.stroke || r.strokeWidth !== e.strokeWidth || r.fontSize !== e.fontSize || r.fontFamily !== e.fontFamily || r.fontWeight !== e.fontWeight || r.fontStyle !== e.fontStyle || r.textBackgroundColor !== e.textBackgroundColor || r.deltaY !== e.deltaY || t && (r.overline !== e.overline || r.underline !== e.underline || r.linethrough !== e.linethrough);
}, Dw = (r, e) => {
  const t = e.split(`
`), n = [];
  let i = -1, s = {};
  r = pp(r);
  for (let a = 0; a < t.length; a++) {
    const c = lu(t[a]);
    if (r[a]) for (let u = 0; u < c.length; u++) {
      i++;
      const h = r[a][u];
      h && Object.keys(h).length > 0 && (uu(s, h, !0) ? n.push({ start: i, end: i + 1, style: h }) : n[n.length - 1].end++), s = h || {};
    }
    else i += c.length, s = {};
  }
  return n;
}, Rw = (r, e) => {
  if (!Array.isArray(r)) return pp(r);
  const t = e.split(Jf), n = {};
  let i = -1, s = 0;
  for (let a = 0; a < t.length; a++) {
    const c = lu(t[a]);
    for (let u = 0; u < c.length; u++) i++, r[s] && r[s].start <= i && i < r[s].end && (n[a] = n[a] || {}, n[a][u] = D({}, r[s].style), i === r[s].end - 1 && s++);
  }
  return n;
}, Ei = ["display", "transform", Lt, "fill-opacity", "fill-rule", "opacity", br, "stroke-dasharray", "stroke-linecap", "stroke-dashoffset", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id", "paint-order", "vector-effect", "instantiated_by_use", "clip-path"];
function C0(r, e) {
  const t = r.nodeName, n = r.getAttribute("class"), i = r.getAttribute("id"), s = "(?![a-zA-Z\\-]+)";
  let a;
  if (a = new RegExp("^" + t, "i"), e = e.replace(a, ""), i && e.length && (a = new RegExp("#" + i + s, "i"), e = e.replace(a, "")), n && e.length) {
    const c = n.split(" ");
    for (let u = c.length; u--; ) a = new RegExp("\\." + c[u] + s, "i"), e = e.replace(a, "");
  }
  return e.length === 0;
}
function d3(r, e) {
  let t = !0;
  const n = C0(r, e.pop());
  return n && e.length && (t = function(i, s) {
    let a, c = !0;
    for (; i.parentElement && i.parentElement.nodeType === 1 && s.length; ) c && (a = s.pop()), c = C0(i = i.parentElement, a);
    return s.length === 0;
  }(r, e)), n && t && e.length === 0;
}
const f3 = (r) => {
  var e;
  return (e = U4[r]) !== null && e !== void 0 ? e : r;
}, p3 = new RegExp("(".concat(es, ")"), "gi"), g3 = (r) => r.replace(p3, " $1 ").replace(/,/gi, " ").replace(/\s+/gi, " ");
var T0, E0, k0, O0, I0, A0, M0;
const ir = "(".concat(es, ")"), m3 = String.raw(T0 || (T0 = Ci(["(skewX)(", ")"], ["(skewX)\\(", "\\)"])), ir), v3 = String.raw(E0 || (E0 = Ci(["(skewY)(", ")"], ["(skewY)\\(", "\\)"])), ir), y3 = String.raw(k0 || (k0 = Ci(["(rotate)(", "(?: ", " ", ")?)"], ["(rotate)\\(", "(?: ", " ", ")?\\)"])), ir, ir, ir), b3 = String.raw(O0 || (O0 = Ci(["(scale)(", "(?: ", ")?)"], ["(scale)\\(", "(?: ", ")?\\)"])), ir, ir), w3 = String.raw(I0 || (I0 = Ci(["(translate)(", "(?: ", ")?)"], ["(translate)\\(", "(?: ", ")?\\)"])), ir, ir), x3 = String.raw(A0 || (A0 = Ci(["(matrix)(", " ", " ", " ", " ", " ", ")"], ["(matrix)\\(", " ", " ", " ", " ", " ", "\\)"])), ir, ir, ir, ir, ir, ir), gp = "(?:".concat(x3, "|").concat(w3, "|").concat(y3, "|").concat(b3, "|").concat(m3, "|").concat(v3, ")"), _3 = "(?:".concat(gp, "*)"), S3 = String.raw(M0 || (M0 = Ci(["^s*(?:", "?)s*$"], ["^\\s*(?:", "?)\\s*$"])), _3), C3 = new RegExp(S3), T3 = new RegExp(gp), E3 = new RegExp(gp, "g");
function Jd(r) {
  const e = [];
  if (!(r = g3(r).replace(/\s*([()])\s*/gi, "$1")) || r && !C3.test(r)) return [...or];
  for (const t of r.matchAll(E3)) {
    const n = T3.exec(t[0]);
    if (!n) continue;
    let i = or;
    const s = n.filter((y) => !!y), [, a, ...c] = s, [u, h, d, p, g, v] = c.map((y) => parseFloat(y));
    switch (a) {
      case "translate":
        i = ho(u, h);
        break;
      case Qf:
        i = fo({ angle: u }, { x: h, y: d });
        break;
      case tu:
        i = nu(u, h);
        break;
      case lo:
        i = rp(u);
        break;
      case uo:
        i = np(u);
        break;
      case "matrix":
        i = [u, h, d, p, g, v];
    }
    e.push(i);
  }
  return ru(e);
}
function k3(r, e, t, n) {
  const i = Array.isArray(e);
  let s, a = e;
  if (r !== Lt && r !== br || e !== yr) {
    if (r === "strokeUniform") return e === "non-scaling-stroke";
    if (r === "strokeDashArray") a = e === yr ? null : e.replace(/,/g, " ").split(/\s+/).map(parseFloat);
    else if (r === "transformMatrix") a = t && t.transformMatrix ? wt(t.transformMatrix, Jd(e)) : Jd(e);
    else if (r === "visible") a = e !== yr && e !== "hidden", t && t.visible === !1 && (a = !1);
    else if (r === "opacity") a = parseFloat(e), t && t.opacity !== void 0 && (a *= t.opacity);
    else if (r === "textAnchor") a = e === "start" ? Ke : e === "end" ? Ct : Pe;
    else if (r === "charSpacing") s = Zi(e, n) / n * 1e3;
    else if (r === "paintFirst") {
      const c = e.indexOf(Lt), u = e.indexOf(br);
      a = Lt, (c > -1 && u > -1 && u < c || c === -1 && u > -1) && (a = br);
    } else {
      if (r === "href" || r === "xlink:href" || r === "font" || r === "id") return e;
      if (r === "imageSmoothing") return e === "optimizeQuality";
      s = i ? e.map(Zi) : Zi(e, n);
    }
  } else a = "";
  return !i && isNaN(s) ? a : s;
}
function O3(r, e) {
  const t = r.match(H4);
  if (!t) return;
  const n = t[1], i = t[3], s = t[4], a = t[5], c = t[6];
  n && (e.fontStyle = n), i && (e.fontWeight = isNaN(parseFloat(i)) ? i : parseFloat(i)), s && (e.fontSize = Zi(s)), c && (e.fontFamily = c), a && (e.lineHeight = a === "normal" ? 1 : a);
}
function I3(r, e) {
  r.replace(/;\s*$/, "").split(";").forEach((t) => {
    if (!t) return;
    const [n, i] = t.split(":");
    e[n.trim().toLowerCase()] = i.trim();
  });
}
function A3(r) {
  const e = {}, t = r.getAttribute("style");
  return t && (typeof t == "string" ? I3(t, e) : function(n, i) {
    Object.entries(n).forEach((s) => {
      let [a, c] = s;
      c !== void 0 && (i[a.toLowerCase()] = c);
    });
  }(t, e)), e;
}
const M3 = { stroke: "strokeOpacity", fill: "fillOpacity" };
function Zn(r, e, t) {
  if (!r) return {};
  let n, i = {}, s = Zf;
  r.parentNode && y0.test(r.parentNode.nodeName) && (i = Zn(r.parentElement, e, t), i.fontSize && (n = s = Zi(i.fontSize)));
  const a = D(D(D({}, e.reduce((h, d) => {
    const p = r.getAttribute(d);
    return p && (h[d] = p), h;
  }, {})), function(h) {
    let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = {};
    for (const g in d) d3(h, g.split(" ")) && (p = D(D({}, p), d[g]));
    return p;
  }(r, t)), A3(r));
  a[Xh] && r.setAttribute(Xh, a[Xh]), a[Yh] && (n = Zi(a[Yh], s), a[Yh] = "".concat(n));
  const c = {};
  for (const h in a) {
    const d = f3(h), p = k3(d, a[h], i, n);
    c[d] = p;
  }
  c && c.font && O3(c.font, c);
  const u = D(D({}, i), c);
  return y0.test(r.nodeName) ? u : function(h) {
    const d = rt.getDefaults();
    return Object.entries(M3).forEach((p) => {
      let [g, v] = p;
      if (h[v] === void 0 || h[g] === "") return;
      if (h[g] === void 0) {
        if (!d[g]) return;
        h[g] = d[g];
      }
      if (h[g].indexOf("url(") === 0) return;
      const y = new Qe(h[g]);
      h[g] = y.setAlpha(ut(y.getAlpha() * h[v], 2)).toRgba();
    }), h;
  }(u);
}
const P3 = ["left", "top", "width", "height", "visible"], jw = ["rx", "ry"];
class kt extends rt {
  static getDefaults() {
    return D(D({}, super.getDefaults()), kt.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, kt.ownDefaults), this.setOptions(e), this._initRxRy();
  }
  _initRxRy() {
    const { rx: e, ry: t } = this;
    e && !t ? this.ry = e : t && !e && (this.rx = t);
  }
  _render(e) {
    const { width: t, height: n } = this, i = -t / 2, s = -n / 2, a = this.rx ? Math.min(this.rx, t / 2) : 0, c = this.ry ? Math.min(this.ry, n / 2) : 0, u = a !== 0 || c !== 0;
    e.beginPath(), e.moveTo(i + a, s), e.lineTo(i + t - a, s), u && e.bezierCurveTo(i + t - ui * a, s, i + t, s + ui * c, i + t, s + c), e.lineTo(i + t, s + n - c), u && e.bezierCurveTo(i + t, s + n - ui * c, i + t - ui * a, s + n, i + t - a, s + n), e.lineTo(i + a, s + n), u && e.bezierCurveTo(i + ui * a, s + n, i, s + n - ui * c, i, s + n - c), e.lineTo(i, s + c), u && e.bezierCurveTo(i, s + ui * c, i + ui * a, s, i + a, s), e.closePath(), this._renderPaintInOrder(e);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...jw, ...e]);
  }
  _toSVG() {
    const { width: e, height: t, rx: n, ry: i } = this;
    return ["<rect ", "COMMON_PARTS", 'x="'.concat(-e / 2, '" y="').concat(-t / 2, '" rx="').concat(n, '" ry="').concat(i, '" width="').concat(e, '" height="').concat(t, `" />
`)];
  }
  static async fromElement(e, t, n) {
    const i = Zn(e, this.ATTRIBUTE_NAMES, n), { left: s = 0, top: a = 0, width: c = 0, height: u = 0, visible: h = !0 } = i, d = ht(i, P3);
    return new this(D(D(D({}, t), d), {}, { left: s, top: a, width: c, height: u, visible: !!(h && c && u) }));
  }
}
R(kt, "type", "Rect"), R(kt, "cacheProperties", [...Kn, ...jw]), R(kt, "ownDefaults", { rx: 0, ry: 0 }), R(kt, "ATTRIBUTE_NAMES", [...Ei, "x", "y", "rx", "ry", "width", "height"]), ne.setClass(kt), ne.setSVGClass(kt);
const Hn = "initialization", bl = "added", mp = "removed", wl = "imperative", Fw = (r, e) => {
  const { strokeUniform: t, strokeWidth: n, width: i, height: s, group: a } = e, c = a && a !== r ? Ca(a.calcTransformMatrix(), r.calcTransformMatrix()) : null, u = c ? e.getRelativeCenterPoint().transform(c) : e.getRelativeCenterPoint(), h = !e.isStrokeAccountedForInDimensions(), d = t && h ? iw(new B(n, n), void 0, r.calcTransformMatrix()) : ep, p = !t && h ? n : 0, g = iu(i + p, s + p, ru([c, e.calcOwnMatrix()], !0)).add(d).scalarDivide(2);
  return [u.subtract(g), u.add(g)];
};
class hu {
  calcLayoutResult(e, t) {
    if (this.shouldPerformLayout(e)) return this.calcBoundingBox(t, e);
  }
  shouldPerformLayout(e) {
    let { type: t, prevStrategy: n, strategy: i } = e;
    return t === Hn || t === wl || !!n && i !== n;
  }
  shouldLayoutClipPath(e) {
    let { type: t, target: { clipPath: n } } = e;
    return t !== Hn && n && !n.absolutePositioned;
  }
  getInitialSize(e, t) {
    return t.size;
  }
  calcBoundingBox(e, t) {
    const { type: n, target: i } = t;
    if (n === wl && t.overrides) return t.overrides;
    if (e.length === 0) return;
    const { left: s, top: a, width: c, height: u } = Cn(e.map((p) => Fw(i, p)).reduce((p, g) => p.concat(g), [])), h = new B(c, u), d = new B(s, a).add(h.scalarDivide(2));
    if (n === Hn) {
      const p = this.getInitialSize(t, { size: h, center: d });
      return { center: d, relativeCorrection: new B(0, 0), size: p };
    }
    return { center: d.transform(i.calcOwnMatrix()), size: h };
  }
}
R(hu, "type", "strategy");
class Qd extends hu {
  shouldPerformLayout(e) {
    return !0;
  }
}
R(Qd, "type", "fit-content"), ne.setClass(Qd);
const D3 = ["strategy"], R3 = ["target", "strategy", "bubbles", "prevStrategy"], Lw = "layoutManager";
class aa {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Qd();
    R(this, "strategy", void 0), this.strategy = e, this._subscriptions = /* @__PURE__ */ new Map();
  }
  performLayout(e) {
    const t = D(D({ bubbles: !0, strategy: this.strategy }, e), {}, { prevStrategy: this._prevLayoutStrategy, stopPropagation() {
      this.bubbles = !1;
    } });
    this.onBeforeLayout(t);
    const n = this.getLayoutResult(t);
    n && this.commitLayout(t, n), this.onAfterLayout(t, n), this._prevLayoutStrategy = t.strategy;
  }
  attachHandlers(e, t) {
    const { target: n } = t;
    return [dl, Nb, na, Bb, eu, Vb, hl, zb, F4].map((i) => e.on(i, (s) => this.performLayout(i === dl ? { type: "object_modified", trigger: i, e: s, target: n } : { type: "object_modifying", trigger: i, e: s, target: n })));
  }
  subscribe(e, t) {
    this.unsubscribe(e, t);
    const n = this.attachHandlers(e, t);
    this._subscriptions.set(e, n);
  }
  unsubscribe(e, t) {
    (this._subscriptions.get(e) || []).forEach((n) => n()), this._subscriptions.delete(e);
  }
  unsubscribeTargets(e) {
    e.targets.forEach((t) => this.unsubscribe(t, e));
  }
  subscribeTargets(e) {
    e.targets.forEach((t) => this.subscribe(t, e));
  }
  onBeforeLayout(e) {
    const { target: t, type: n } = e, { canvas: i } = t;
    if (n === Hn || n === bl ? this.subscribeTargets(e) : n === mp && this.unsubscribeTargets(e), t.fire("layout:before", { context: e }), i && i.fire("object:layout:before", { target: t, context: e }), n === wl && e.deep) {
      const s = ht(e, D3);
      t.forEachObject((a) => a.layoutManager && a.layoutManager.performLayout(D(D({}, s), {}, { bubbles: !1, target: a })));
    }
  }
  getLayoutResult(e) {
    const { target: t, strategy: n, type: i } = e, s = n.calcLayoutResult(e, t.getObjects());
    if (!s) return;
    const a = i === Hn ? new B() : t.getRelativeCenterPoint(), { center: c, correction: u = new B(), relativeCorrection: h = new B() } = s, d = a.subtract(c).add(u).transform(i === Hn ? or : Pr(t.calcOwnMatrix()), !0).add(h);
    return { result: s, prevCenter: a, nextCenter: c, offset: d };
  }
  commitLayout(e, t) {
    const { target: n } = e, { result: { size: i }, nextCenter: s } = t;
    var a, c;
    n.set({ width: i.x, height: i.y }), this.layoutObjects(e, t), e.type === Hn ? n.set({ left: (a = e.x) !== null && a !== void 0 ? a : s.x + i.x * Et(n.originX), top: (c = e.y) !== null && c !== void 0 ? c : s.y + i.y * Et(n.originY) }) : (n.setPositionByOrigin(s, Pe, Pe), n.setCoords(), n.set("dirty", !0));
  }
  layoutObjects(e, t) {
    const { target: n } = e;
    n.forEachObject((i) => {
      i.group === n && this.layoutObject(e, t, i);
    }), e.strategy.shouldLayoutClipPath(e) && this.layoutObject(e, t, n.clipPath);
  }
  layoutObject(e, t, n) {
    let { offset: i } = t;
    n.set({ left: n.left + i.x, top: n.top + i.y });
  }
  onAfterLayout(e, t) {
    const { target: n, strategy: i, bubbles: s, prevStrategy: a } = e, c = ht(e, R3), { canvas: u } = n;
    n.fire("layout:after", { context: e, result: t }), u && u.fire("object:layout:after", { context: e, result: t, target: n });
    const h = n.parent;
    s && h != null && h.layoutManager && ((c.path || (c.path = [])).push(n), h.layoutManager.performLayout(D(D({}, c), {}, { target: h }))), n.set("dirty", !0);
  }
  dispose() {
    const { _subscriptions: e } = this;
    e.forEach((t) => t.forEach((n) => n())), e.clear();
  }
  toObject() {
    return { type: Lw, strategy: this.strategy.constructor.type };
  }
  toJSON() {
    return this.toObject();
  }
}
ne.setClass(aa, Lw);
const j3 = ["type", "objects", "layoutManager"];
class F3 extends aa {
  performLayout() {
  }
}
class Xr extends Wb(rt) {
  static getDefaults() {
    return D(D({}, super.getDefaults()), Xr.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), R(this, "_activeObjects", []), R(this, "__objectSelectionTracker", void 0), R(this, "__objectSelectionDisposer", void 0), Object.assign(this, Xr.ownDefaults), this.setOptions(t), this.groupInit(e, t);
  }
  groupInit(e, t) {
    var n;
    this._objects = [...e], this.__objectSelectionTracker = this.__objectSelectionMonitor.bind(this, !0), this.__objectSelectionDisposer = this.__objectSelectionMonitor.bind(this, !1), this.forEachObject((i) => {
      this.enterGroup(i, !1);
    }), this.layoutManager = (n = t.layoutManager) !== null && n !== void 0 ? n : new aa(), this.layoutManager.performLayout({ type: Hn, target: this, targets: [...e], x: t.left, y: t.top });
  }
  canEnterGroup(e) {
    return e === this || this.isDescendantOf(e) ? (pi("error", "Group: circular object trees are not supported, this call has no effect"), !1) : this._objects.indexOf(e) === -1 || (pi("error", "Group: duplicate objects are not supported inside group, this call has no effect"), !1);
  }
  _filterObjectsBeforeEnteringGroup(e) {
    return e.filter((t, n, i) => this.canEnterGroup(t) && i.indexOf(t) === n);
  }
  add() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    const i = this._filterObjectsBeforeEnteringGroup(t), s = super.add(...i);
    return this._onAfterObjectsChange(bl, i), s;
  }
  insertAt(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
    const s = this._filterObjectsBeforeEnteringGroup(n), a = super.insertAt(e, ...s);
    return this._onAfterObjectsChange(bl, s), a;
  }
  remove() {
    const e = super.remove(...arguments);
    return this._onAfterObjectsChange(mp, e), e;
  }
  _onObjectAdded(e) {
    this.enterGroup(e, !0), this.fire("object:added", { target: e }), e.fire("added", { target: this });
  }
  _onObjectRemoved(e, t) {
    this.exitGroup(e, t), this.fire("object:removed", { target: e }), e.fire("removed", { target: this });
  }
  _onAfterObjectsChange(e, t) {
    this.layoutManager.performLayout({ type: e, targets: t, target: this });
  }
  _onStackOrderChanged() {
    this._set("dirty", !0);
  }
  _set(e, t) {
    const n = this[e];
    return super._set(e, t), e === "canvas" && n !== t && (this._objects || []).forEach((i) => {
      i._set(e, t);
    }), this;
  }
  _shouldSetNestedCoords() {
    return this.subTargetCheck;
  }
  removeAll() {
    return this._activeObjects = [], this.remove(...this._objects);
  }
  __objectSelectionMonitor(e, t) {
    let { target: n } = t;
    const i = this._activeObjects;
    if (e) i.push(n), this._set("dirty", !0);
    else if (i.length > 0) {
      const s = i.indexOf(n);
      s > -1 && (i.splice(s, 1), this._set("dirty", !0));
    }
  }
  _watchObject(e, t) {
    e && this._watchObject(!1, t), e ? (t.on("selected", this.__objectSelectionTracker), t.on("deselected", this.__objectSelectionDisposer)) : (t.off("selected", this.__objectSelectionTracker), t.off("deselected", this.__objectSelectionDisposer));
  }
  enterGroup(e, t) {
    e.group && e.group.remove(e), e._set("parent", this), this._enterGroup(e, t);
  }
  _enterGroup(e, t) {
    t && Gs(e, wt(Pr(this.calcTransformMatrix()), e.calcTransformMatrix())), this._shouldSetNestedCoords() && e.setCoords(), e._set("group", this), e._set("canvas", this.canvas), this._watchObject(!0, e);
    const n = this.canvas && this.canvas.getActiveObject && this.canvas.getActiveObject();
    n && (n === e || e.isDescendantOf(n)) && this._activeObjects.push(e);
  }
  exitGroup(e, t) {
    this._exitGroup(e, t), e._set("parent", void 0), e._set("canvas", void 0);
  }
  _exitGroup(e, t) {
    e._set("group", void 0), t || (Gs(e, wt(this.calcTransformMatrix(), e.calcTransformMatrix())), e.setCoords()), this._watchObject(!1, e);
    const n = this._activeObjects.length > 0 ? this._activeObjects.indexOf(e) : -1;
    n > -1 && this._activeObjects.splice(n, 1);
  }
  shouldCache() {
    const e = rt.prototype.shouldCache.call(this);
    if (e) {
      for (let t = 0; t < this._objects.length; t++) if (this._objects[t].willDrawShadow()) return this.ownCaching = !1, !1;
    }
    return e;
  }
  willDrawShadow() {
    if (super.willDrawShadow()) return !0;
    for (let e = 0; e < this._objects.length; e++) if (this._objects[e].willDrawShadow()) return !0;
    return !1;
  }
  isOnACache() {
    return this.ownCaching || !!this.parent && this.parent.isOnACache();
  }
  drawObject(e, t, n) {
    this._renderBackground(e);
    for (let s = 0; s < this._objects.length; s++) {
      var i;
      const a = this._objects[s];
      (i = this.canvas) !== null && i !== void 0 && i.preserveObjectStacking && a.group !== this ? (e.save(), e.transform(...Pr(this.calcTransformMatrix())), a.render(e), e.restore()) : a.group === this && a.render(e);
    }
    this._drawClipPath(e, this.clipPath, n);
  }
  setCoords() {
    super.setCoords(), this._shouldSetNestedCoords() && this.forEachObject((e) => e.setCoords());
  }
  triggerLayout() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.layoutManager.performLayout(D({ target: this, type: wl }, e));
  }
  render(e) {
    this._transformDone = !0, super.render(e), this._transformDone = !1;
  }
  __serializeObjects(e, t) {
    const n = this.includeDefaultValues;
    return this._objects.filter(function(i) {
      return !i.excludeFromExport;
    }).map(function(i) {
      const s = i.includeDefaultValues;
      i.includeDefaultValues = n;
      const a = i[e || "toObject"](t);
      return i.includeDefaultValues = s, a;
    });
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = this.layoutManager.toObject();
    return D(D(D({}, super.toObject(["subTargetCheck", "interactive", ...e])), t.strategy !== "fit-content" || this.includeDefaultValues ? { layoutManager: t } : {}), {}, { objects: this.__serializeObjects("toObject", e) });
  }
  toString() {
    return "#<Group: (".concat(this.complexity(), ")>");
  }
  dispose() {
    this.layoutManager.unsubscribeTargets({ targets: this.getObjects(), target: this }), this._activeObjects = [], this.forEachObject((e) => {
      this._watchObject(!1, e), e.dispose();
    }), super.dispose();
  }
  _createSVGBgRect(e) {
    if (!this.backgroundColor) return "";
    const t = kt.prototype._toSVG.call(this), n = t.indexOf("COMMON_PARTS");
    t[n] = 'for="group" ';
    const i = t.join("");
    return e ? e(i) : i;
  }
  _toSVG(e) {
    const t = ["<g ", "COMMON_PARTS", ` >
`], n = this._createSVGBgRect(e);
    n && t.push("		", n);
    for (let i = 0; i < this._objects.length; i++) t.push("		", this._objects[i].toSVG(e));
    return t.push(`</g>
`), t;
  }
  getSvgStyles() {
    const e = this.opacity !== void 0 && this.opacity !== 1 ? "opacity: ".concat(this.opacity, ";") : "", t = this.visible ? "" : " visibility: hidden;";
    return [e, this.getSvgFilter(), t].join("");
  }
  toClipPathSVG(e) {
    const t = [], n = this._createSVGBgRect(e);
    n && t.push("	", n);
    for (let i = 0; i < this._objects.length; i++) t.push("	", this._objects[i].toClipPathSVG(e));
    return this._createBaseClipPathSVGMarkup(t, { reviver: e });
  }
  static fromObject(e, t) {
    let { type: n, objects: i = [], layoutManager: s } = e, a = ht(e, j3);
    return Promise.all([Xs(i, t), _a(a, t)]).then((c) => {
      let [u, h] = c;
      const d = new this(u, D(D(D({}, a), h), {}, { layoutManager: new F3() }));
      if (s) {
        const p = ne.getClass(s.type), g = ne.getClass(s.strategy);
        d.layoutManager = new p(new g());
      } else d.layoutManager = new aa();
      return d.layoutManager.subscribeTargets({ type: Hn, target: d, targets: d.getObjects() }), d.setCoords(), d;
    });
  }
}
R(Xr, "type", "Group"), R(Xr, "ownDefaults", { strokeWidth: 0, subTargetCheck: !1, interactive: !1 }), ne.setClass(Xr);
const Nw = (r, e) => Math.min(e.width / r.width, e.height / r.height), Bw = (r, e) => Math.max(e.width / r.width, e.height / r.height), ef = "\\s*,?\\s*", Vo = "".concat(ef, "(").concat(es, ")"), L3 = "".concat(Vo).concat(Vo).concat(Vo).concat(ef, "([01])").concat(ef, "([01])").concat(Vo).concat(Vo), N3 = { m: "l", M: "L" }, B3 = (r, e, t, n, i, s, a, c, u, h, d) => {
  const p = cn(r), g = ln(r), v = cn(e), y = ln(e), x = t * i * v - n * s * y + a, _ = n * i * v + t * s * y + c;
  return ["C", h + u * (-t * i * g - n * s * p), d + u * (-n * i * g + t * s * p), x + u * (t * i * y + n * s * v), _ + u * (n * i * y - t * s * v), x, _];
}, P0 = (r, e, t, n) => {
  const i = Math.atan2(e, r), s = Math.atan2(n, t);
  return s >= i ? s - i : 2 * Math.PI - (i - s);
};
function tf(r, e, t, n, i, s, a, c) {
  let u;
  if (Ue.cachesBoundsOfCurve && (u = [...arguments].join(), Go.boundsOfCurveCache[u])) return Go.boundsOfCurveCache[u];
  const h = Math.sqrt, d = Math.abs, p = [], g = [[0, 0], [0, 0]];
  let v = 6 * r - 12 * t + 6 * i, y = -3 * r + 9 * t - 9 * i + 3 * a, x = 3 * t - 3 * r;
  for (let O = 0; O < 2; ++O) {
    if (O > 0 && (v = 6 * e - 12 * n + 6 * s, y = -3 * e + 9 * n - 9 * s + 3 * c, x = 3 * n - 3 * e), d(y) < 1e-12) {
      if (d(v) < 1e-12) continue;
      const $ = -x / v;
      0 < $ && $ < 1 && p.push($);
      continue;
    }
    const P = v * v - 4 * x * y;
    if (P < 0) continue;
    const j = h(P), V = (-v + j) / (2 * y);
    0 < V && V < 1 && p.push(V);
    const F = (-v - j) / (2 * y);
    0 < F && F < 1 && p.push(F);
  }
  let _ = p.length;
  const C = _, E = zw(r, e, t, n, i, s, a, c);
  for (; _--; ) {
    const { x: O, y: P } = E(p[_]);
    g[0][_] = O, g[1][_] = P;
  }
  g[0][C] = r, g[1][C] = e, g[0][C + 1] = a, g[1][C + 1] = c;
  const k = [new B(Math.min(...g[0]), Math.min(...g[1])), new B(Math.max(...g[0]), Math.max(...g[1]))];
  return Ue.cachesBoundsOfCurve && (Go.boundsOfCurveCache[u] = k), k;
}
const V3 = (r, e, t) => {
  let [n, i, s, a, c, u, h, d] = t;
  const p = ((g, v, y, x, _, C, E) => {
    if (y === 0 || x === 0) return [];
    let k = 0, O = 0, P = 0;
    const j = Math.PI, V = E * Kf, F = ln(V), $ = cn(V), z = 0.5 * (-$ * g - F * v), G = 0.5 * (-$ * v + F * g), H = y ** 2, Y = x ** 2, te = G ** 2, ge = z ** 2, Z = H * Y - H * te - Y * ge;
    let de = Math.abs(y), oe = Math.abs(x);
    if (Z < 0) {
      const Mt = Math.sqrt(1 - Z / (H * Y));
      de *= Mt, oe *= Mt;
    } else P = (_ === C ? -1 : 1) * Math.sqrt(Z / (H * te + Y * ge));
    const ie = P * de * G / oe, pe = -P * oe * z / de, re = $ * ie - F * pe + 0.5 * g, Be = F * ie + $ * pe + 0.5 * v;
    let Ze = P0(1, 0, (z - ie) / de, (G - pe) / oe), ze = P0((z - ie) / de, (G - pe) / oe, (-z - ie) / de, (-G - pe) / oe);
    C === 0 && ze > 0 ? ze -= 2 * j : C === 1 && ze < 0 && (ze += 2 * j);
    const Ee = Math.ceil(Math.abs(ze / j * 2)), Ie = [], dt = ze / Ee, lr = 8 / 3 * Math.sin(dt / 4) * Math.sin(dt / 4) / Math.sin(dt / 2);
    let Wt = Ze + dt;
    for (let Mt = 0; Mt < Ee; Mt++) Ie[Mt] = B3(Ze, Wt, $, F, de, oe, re, Be, lr, k, O), k = Ie[Mt][5], O = Ie[Mt][6], Ze = Wt, Wt += dt;
    return Ie;
  })(h - r, d - e, i, s, c, u, a);
  for (let g = 0, v = p.length; g < v; g++) p[g][1] += r, p[g][2] += e, p[g][3] += r, p[g][4] += e, p[g][5] += r, p[g][6] += e;
  return p;
}, Vw = (r) => {
  let e = 0, t = 0, n = 0, i = 0;
  const s = [];
  let a, c = 0, u = 0;
  for (const h of r) {
    const d = [...h];
    let p;
    switch (d[0]) {
      case "l":
        d[1] += e, d[2] += t;
      case "L":
        e = d[1], t = d[2], p = ["L", e, t];
        break;
      case "h":
        d[1] += e;
      case "H":
        e = d[1], p = ["L", e, t];
        break;
      case "v":
        d[1] += t;
      case "V":
        t = d[1], p = ["L", e, t];
        break;
      case "m":
        d[1] += e, d[2] += t;
      case "M":
        e = d[1], t = d[2], n = d[1], i = d[2], p = ["M", e, t];
        break;
      case "c":
        d[1] += e, d[2] += t, d[3] += e, d[4] += t, d[5] += e, d[6] += t;
      case "C":
        c = d[3], u = d[4], e = d[5], t = d[6], p = ["C", d[1], d[2], c, u, e, t];
        break;
      case "s":
        d[1] += e, d[2] += t, d[3] += e, d[4] += t;
      case "S":
        a === "C" ? (c = 2 * e - c, u = 2 * t - u) : (c = e, u = t), e = d[3], t = d[4], p = ["C", c, u, d[1], d[2], e, t], c = p[3], u = p[4];
        break;
      case "q":
        d[1] += e, d[2] += t, d[3] += e, d[4] += t;
      case "Q":
        c = d[1], u = d[2], e = d[3], t = d[4], p = ["Q", c, u, e, t];
        break;
      case "t":
        d[1] += e, d[2] += t;
      case "T":
        a === "Q" ? (c = 2 * e - c, u = 2 * t - u) : (c = e, u = t), e = d[1], t = d[2], p = ["Q", c, u, e, t];
        break;
      case "a":
        d[6] += e, d[7] += t;
      case "A":
        V3(e, t, d).forEach((g) => s.push(g)), e = d[6], t = d[7];
        break;
      case "z":
      case "Z":
        e = n, t = i, p = ["Z"];
    }
    p ? (s.push(p), a = p[0]) : a = "";
  }
  return s;
}, xl = (r, e, t, n) => Math.sqrt((t - r) ** 2 + (n - e) ** 2), zw = (r, e, t, n, i, s, a, c) => (u) => {
  const h = u ** 3, d = ((v) => 3 * v ** 2 * (1 - v))(u), p = ((v) => 3 * v * (1 - v) ** 2)(u), g = ((v) => (1 - v) ** 3)(u);
  return new B(a * h + i * d + t * p + r * g, c * h + s * d + n * p + e * g);
}, Ww = (r) => r ** 2, Hw = (r) => 2 * r * (1 - r), Uw = (r) => (1 - r) ** 2, z3 = (r, e, t, n, i, s, a, c) => (u) => {
  const h = Ww(u), d = Hw(u), p = Uw(u), g = 3 * (p * (t - r) + d * (i - t) + h * (a - i)), v = 3 * (p * (n - e) + d * (s - n) + h * (c - s));
  return Math.atan2(v, g);
}, W3 = (r, e, t, n, i, s) => (a) => {
  const c = Ww(a), u = Hw(a), h = Uw(a);
  return new B(i * c + t * u + r * h, s * c + n * u + e * h);
}, H3 = (r, e, t, n, i, s) => (a) => {
  const c = 1 - a, u = 2 * (c * (t - r) + a * (i - t)), h = 2 * (c * (n - e) + a * (s - n));
  return Math.atan2(h, u);
}, D0 = (r, e, t) => {
  let n = new B(e, t), i = 0;
  for (let s = 1; s <= 100; s += 1) {
    const a = r(s / 100);
    i += xl(n.x, n.y, a.x, a.y), n = a;
  }
  return i;
}, U3 = (r, e) => {
  let t, n = 0, i = 0, s = { x: r.x, y: r.y }, a = D({}, s), c = 0.01, u = 0;
  const h = r.iterator, d = r.angleFinder;
  for (; i < e && c > 1e-4; ) a = h(n), u = n, t = xl(s.x, s.y, a.x, a.y), t + i > e ? (n -= c, c /= 2) : (s = a, n += c, i += t);
  return D(D({}, a), {}, { angle: d(u) });
}, vp = (r) => {
  let e, t, n = 0, i = 0, s = 0, a = 0, c = 0;
  const u = [];
  for (const h of r) {
    const d = { x: i, y: s, command: h[0], length: 0 };
    switch (h[0]) {
      case "M":
        t = d, t.x = a = i = h[1], t.y = c = s = h[2];
        break;
      case "L":
        t = d, t.length = xl(i, s, h[1], h[2]), i = h[1], s = h[2];
        break;
      case "C":
        e = zw(i, s, h[1], h[2], h[3], h[4], h[5], h[6]), t = d, t.iterator = e, t.angleFinder = z3(i, s, h[1], h[2], h[3], h[4], h[5], h[6]), t.length = D0(e, i, s), i = h[5], s = h[6];
        break;
      case "Q":
        e = W3(i, s, h[1], h[2], h[3], h[4]), t = d, t.iterator = e, t.angleFinder = H3(i, s, h[1], h[2], h[3], h[4]), t.length = D0(e, i, s), i = h[3], s = h[4];
        break;
      case "Z":
        t = d, t.destX = a, t.destY = c, t.length = xl(i, s, a, c), i = a, s = c;
    }
    n += t.length, u.push(t);
  }
  return u.push({ length: n, x: i, y: s }), u;
}, $w = function(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : vp(r), n = 0;
  for (; e - t[n].length > 0 && n < t.length - 2; ) e -= t[n].length, n++;
  const i = t[n], s = e / i.length, a = r[n];
  switch (i.command) {
    case "M":
      return { x: i.x, y: i.y, angle: 0 };
    case "Z":
      return D(D({}, new B(i.x, i.y).lerp(new B(i.destX, i.destY), s)), {}, { angle: Math.atan2(i.destY - i.y, i.destX - i.x) });
    case "L":
      return D(D({}, new B(i.x, i.y).lerp(new B(a[1], a[2]), s)), {}, { angle: Math.atan2(a[2] - i.y, a[1] - i.x) });
    case "C":
    case "Q":
      return U3(i, e);
  }
}, $3 = new RegExp("[mzlhvcsqta][^mzlhvcsqta]*", "gi"), R0 = new RegExp(L3, "g"), Y3 = new RegExp(es, "gi"), X3 = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, Yw = (r) => {
  var e;
  const t = [], n = (e = r.match($3)) !== null && e !== void 0 ? e : [];
  for (const i of n) {
    const s = i[0];
    if (s === "z" || s === "Z") {
      t.push([s]);
      continue;
    }
    const a = X3[s.toLowerCase()];
    let c = [];
    if (s === "a" || s === "A") {
      R0.lastIndex = 0;
      for (let u = null; u = R0.exec(i); ) c.push(...u.slice(1));
    } else c = i.match(Y3) || [];
    for (let u = 0; u < c.length; u += a) {
      const h = new Array(a), d = N3[s];
      h[0] = u > 0 && d ? d : s;
      for (let p = 0; p < a; p++) h[p + 1] = parseFloat(c[u + p]);
      t.push(h);
    }
  }
  return t;
}, G3 = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = new B(r[0]), n = new B(r[1]), i = 1, s = 0;
  const a = [], c = r.length, u = c > 2;
  let h;
  for (u && (i = r[2].x < n.x ? -1 : r[2].x === n.x ? 0 : 1, s = r[2].y < n.y ? -1 : r[2].y === n.y ? 0 : 1), a.push(["M", t.x - i * e, t.y - s * e]), h = 1; h < c; h++) {
    if (!t.eq(n)) {
      const d = t.midPointFrom(n);
      a.push(["Q", t.x, t.y, d.x, d.y]);
    }
    t = r[h], h + 1 < r.length && (n = r[h + 1]);
  }
  return u && (i = t.x > r[h - 2].x ? 1 : t.x === r[h - 2].x ? 0 : -1, s = t.y > r[h - 2].y ? 1 : t.y === r[h - 2].y ? 0 : -1), a.push(["L", t.x + i * e, t.y + s * e]), a;
}, Xw = (r, e) => r.map((t) => t.map((n, i) => i === 0 || e === void 0 ? n : ut(n, e)).join(" ")).join(" ");
function _l(r, e) {
  const t = r.style;
  t && e && (typeof e == "string" ? t.cssText += ";" + e : Object.entries(e).forEach((n) => {
    let [i, s] = n;
    return t.setProperty(i, s);
  }));
}
const q3 = (r, e) => Math.floor(Math.random() * (e - r + 1)) + r;
function K3(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = e.onComplete || Ki, n = new (Ql()).XMLHttpRequest(), i = e.signal, s = function() {
    n.abort();
  }, a = function() {
    i && i.removeEventListener("abort", s), n.onerror = n.ontimeout = Ki;
  };
  if (i && i.aborted) throw new Fb("request");
  return i && i.addEventListener("abort", s, { once: !0 }), n.onreadystatechange = function() {
    n.readyState === 4 && (a(), t(n), n.onreadystatechange = Ki);
  }, n.onerror = n.ontimeout = a, n.open("get", r, !0), n.send(), n;
}
const Z3 = (r, e) => {
  let t = r._findCenterFromElement();
  r.transformMatrix && (((n) => {
    if (n.transformMatrix) {
      const { scaleX: i, scaleY: s, angle: a, skewX: c } = Ys(n.transformMatrix);
      n.flipX = !1, n.flipY = !1, n.set(ar, i), n.set(Dr, s), n.angle = a, n.skewX = c, n.skewY = 0;
    }
  })(r), t = t.transform(r.transformMatrix)), delete r.transformMatrix, e && (r.scaleX *= e.scaleX, r.scaleY *= e.scaleY, r.cropX = e.cropX, r.cropY = e.cropY, t.x += e.offsetLeft, t.y += e.offsetTop, r.width = e.width, r.height = e.height), r.setPositionByOrigin(t, Pe, Pe);
};
var Gw = Object.freeze({ __proto__: null, addTransformToObject: rw, animate: hp, animateColor: fw, applyTransformToObject: Gs, calcAngleBetweenVectors: yl, calcDimensionsMatrix: xa, calcPlaneChangeMatrix: Ca, calcVectorRotation: uw, cancelAnimFrame: Ub, capValue: ts, composeMatrix: qb, copyCanvasElement: (r) => {
  var e;
  const t = un(r);
  return (e = t.getContext("2d")) === null || e === void 0 || e.drawImage(r, 0, 0), t;
}, cos: cn, createCanvasElement: Gr, createImage: $b, createRotateMatrix: fo, createScaleMatrix: nu, createSkewXMatrix: rp, createSkewYMatrix: np, createTranslateMatrix: ho, createVector: ml, crossProduct: Ws, degreesToRadians: bt, dotProduct: hw, ease: G4, enlivenObjectEnlivables: _a, enlivenObjects: Xs, findScaleToCover: Bw, findScaleToFit: Nw, getBoundsOfCurve: tf, getOrthonormalVector: lp, getPathSegmentsInfo: vp, getPointOnPath: $w, getPointer: tw, getRandomInt: q3, getRegularPolygonPath: (r, e) => {
  const t = 2 * Math.PI / r;
  let n = -gi;
  r % 2 == 0 && (n += t / 2);
  const i = new Array(r + 1);
  for (let s = 0; s < r; s++) {
    const a = s * t + n, { x: c, y: u } = new B(cn(a), ln(a)).scalarMultiply(e);
    i[s] = [s === 0 ? "M" : "L", c, u];
  }
  return i[r] = ["Z"], i;
}, getSmoothPathFromPoints: G3, getSvgAttributes: (r) => {
  const e = ["instantiated_by_use", "style", "id", "class"];
  switch (r) {
    case "linearGradient":
      return e.concat(["x1", "y1", "x2", "y2", "gradientUnits", "gradientTransform"]);
    case "radialGradient":
      return e.concat(["gradientUnits", "gradientTransform", "cx", "cy", "r", "fx", "fy", "fr"]);
    case "stop":
      return e.concat(["offset", "stop-color", "stop-opacity"]);
  }
  return e;
}, getUnitVector: au, groupSVGElements: (r, e) => r && r.length === 1 ? r[0] : new Xr(r, e), hasStyleChanged: uu, invertTransform: Pr, isBetweenVectors: Xd, isIdentityMatrix: Yb, isTouchEvent: pl, isTransparent: Iw, joinPath: Xw, loadImage: Ko, magnitude: vl, makeBoundingBoxFromPoints: Cn, makePathSimpler: Vw, matrixToSVG: ia, mergeClipPaths: (r, e) => {
  var t;
  let n = r, i = e;
  n.inverted && !i.inverted && (n = e, i = r), Yd(i, (t = i.group) === null || t === void 0 ? void 0 : t.calcTransformMatrix(), n.calcTransformMatrix());
  const s = n.inverted && i.inverted;
  return s && (n.inverted = i.inverted = !1), new Xr([n], { clipPath: i, inverted: s });
}, multiplyTransformMatrices: wt, multiplyTransformMatrixArray: ru, parsePath: Yw, parsePreserveAspectRatioAttribute: Kb, parseUnit: Zi, pick: fs, projectStrokeOnPoints: Mw, qrDecompose: Ys, radiansToDegrees: vi, removeFromArray: zi, removeTransformFromObject: (r, e) => {
  const t = Pr(e), n = wt(t, r.calcOwnMatrix());
  Gs(r, n);
}, removeTransformMatrixForSvgParsing: Z3, request: K3, requestAnimFrame: qo, resetObjectTransform: nw, rotatePoint: (r, e, t) => r.rotate(t, e), rotateVector: cp, saveObjectTransform: sp, sendObjectToPlane: Yd, sendPointToPlane: $n, sendVectorToPlane: iw, setStyle: _l, sin: ln, sizeAfterTransform: iu, string: h3, stylesFromArray: Rw, stylesToArray: Dw, toDataURL: tp, toFixed: ut, transformPath: (r, e, t) => (t && (e = wt(e, [1, 0, 0, 1, -t.x, -t.y])), r.map((n) => {
  const i = [...n];
  for (let s = 1; s < n.length - 1; s += 2) {
    const { x: a, y: c } = qt({ x: n[s], y: n[s + 1] }, e);
    i[s] = a, i[s + 1] = c;
  }
  return i;
})), transformPoint: qt });
class J3 extends ew {
  constructor(e) {
    let { allowTouchScrolling: t = !1, containerClass: n = "" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e), R(this, "upper", void 0), R(this, "container", void 0);
    const { el: i } = this.lower, s = this.createUpperCanvas();
    this.upper = { el: s, ctx: s.getContext("2d") }, this.applyCanvasStyle(i, { allowTouchScrolling: t }), this.applyCanvasStyle(s, { allowTouchScrolling: t, styles: { position: "absolute", left: "0", top: "0" } });
    const a = this.createContainerElement();
    a.classList.add(n), i.parentNode && i.parentNode.replaceChild(a, i), a.append(i, s), this.container = a;
  }
  createUpperCanvas() {
    const { el: e } = this.lower, t = Gr();
    return t.className = e.className, t.classList.remove("lower-canvas"), t.classList.add("upper-canvas"), t.setAttribute("data-fabric", "top"), t.style.cssText = e.style.cssText, t.setAttribute("draggable", "true"), t;
  }
  createContainerElement() {
    const e = co().createElement("div");
    return e.setAttribute("data-fabric", "wrapper"), _l(e, { position: "relative" }), g0(e), e;
  }
  applyCanvasStyle(e, t) {
    const { styles: n, allowTouchScrolling: i } = t;
    _l(e, D(D({}, n), {}, { "touch-action": i ? "manipulation" : yr })), g0(e);
  }
  setDimensions(e, t) {
    super.setDimensions(e, t);
    const { el: n, ctx: i } = this.upper;
    Qb(n, i, e, t);
  }
  setCSSDimensions(e) {
    super.setCSSDimensions(e), Ud(this.upper.el, e), Ud(this.container, e);
  }
  cleanupDOM(e) {
    const t = this.container, { el: n } = this.lower, { el: i } = this.upper;
    super.cleanupDOM(e), t.removeChild(i), t.removeChild(n), t.parentNode && t.parentNode.replaceChild(n, t);
  }
  dispose() {
    super.dispose(), En().dispose(this.upper.el), delete this.upper, delete this.container;
  }
}
class du extends Sa {
  constructor() {
    super(...arguments), R(this, "targets", []), R(this, "_hoveredTargets", []), R(this, "_objectsToRender", void 0), R(this, "_currentTransform", null), R(this, "_groupSelector", null), R(this, "contextTopDirty", !1);
  }
  static getDefaults() {
    return D(D({}, super.getDefaults()), du.ownDefaults);
  }
  get upperCanvasEl() {
    var e;
    return (e = this.elements.upper) === null || e === void 0 ? void 0 : e.el;
  }
  get contextTop() {
    var e;
    return (e = this.elements.upper) === null || e === void 0 ? void 0 : e.ctx;
  }
  get wrapperEl() {
    return this.elements.container;
  }
  initElements(e) {
    this.elements = new J3(e, { allowTouchScrolling: this.allowTouchScrolling, containerClass: this.containerClass }), this._createCacheCanvas();
  }
  _onObjectAdded(e) {
    this._objectsToRender = void 0, super._onObjectAdded(e);
  }
  _onObjectRemoved(e) {
    this._objectsToRender = void 0, e === this._activeObject && (this.fire("before:selection:cleared", { deselected: [e] }), this._discardActiveObject(), this.fire("selection:cleared", { deselected: [e] }), e.fire("deselected", { target: e })), e === this._hoveredTarget && (this._hoveredTarget = void 0, this._hoveredTargets = []), super._onObjectRemoved(e);
  }
  _onStackOrderChanged() {
    this._objectsToRender = void 0, super._onStackOrderChanged();
  }
  _chooseObjectsToRender() {
    const e = this._activeObject;
    return !this.preserveObjectStacking && e ? this._objects.filter((t) => !t.group && t !== e).concat(e) : this._objects;
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || (!this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = !1), !this._objectsToRender && (this._objectsToRender = this._chooseObjectsToRender()), this.renderCanvas(this.getContext(), this._objectsToRender));
  }
  renderTopLayer(e) {
    e.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(e), this.contextTopDirty = !0), e.restore();
  }
  renderTop() {
    const e = this.contextTop;
    this.clearContext(e), this.renderTopLayer(e), this.fire("after:render", { ctx: e });
  }
  setTargetFindTolerance(e) {
    e = Math.round(e), this.targetFindTolerance = e;
    const t = this.getRetinaScaling(), n = Math.ceil((2 * e + 1) * t);
    this.pixelFindCanvasEl.width = this.pixelFindCanvasEl.height = n, this.pixelFindContext.scale(t, t);
  }
  isTargetTransparent(e, t, n) {
    const i = this.targetFindTolerance, s = this.pixelFindContext;
    this.clearContext(s), s.save(), s.translate(-t + i, -n + i), s.transform(...this.viewportTransform);
    const a = e.selectionBackgroundColor;
    e.selectionBackgroundColor = "", e.render(s), e.selectionBackgroundColor = a, s.restore();
    const c = Math.round(i * this.getRetinaScaling());
    return Iw(s, c, c, c);
  }
  _isSelectionKeyPressed(e) {
    const t = this.selectionKey;
    return !!t && (Array.isArray(t) ? !!t.find((n) => !!n && e[n] === !0) : e[t]);
  }
  _shouldClearSelection(e, t) {
    const n = this.getActiveObjects(), i = this._activeObject;
    return !!(!t || t && i && n.length > 1 && n.indexOf(t) === -1 && i !== t && !this._isSelectionKeyPressed(e) || t && !t.evented || t && !t.selectable && i && i !== t);
  }
  _shouldCenterTransform(e, t, n) {
    if (!e) return;
    let i;
    return t === tu || t === ar || t === Dr || t === na ? i = this.centeredScaling || e.centeredScaling : t === Qf && (i = this.centeredRotation || e.centeredRotation), i ? !n : n;
  }
  _getOriginFromCorner(e, t) {
    const n = { x: e.originX, y: e.originY };
    return t && (["ml", "tl", "bl"].includes(t) ? n.x = Ct : ["mr", "tr", "br"].includes(t) && (n.x = Ke), ["tl", "mt", "tr"].includes(t) ? n.y = Hd : ["bl", "mb", "br"].includes(t) && (n.y = vr)), n;
  }
  _setupCurrentTransform(e, t, n) {
    var i;
    const s = t.group ? $n(this.getScenePoint(e), void 0, t.group.calcTransformMatrix()) : this.getScenePoint(e), { key: a = "", control: c } = t.getActiveControl() || {}, u = n && c ? (i = c.getActionHandler(e, t, c)) === null || i === void 0 ? void 0 : i.bind(c) : aw, h = ((v, y, x, _) => {
      if (!y || !v) return "drag";
      const C = _.controls[y];
      return C.getActionName(x, C, _);
    })(n, a, e, t), d = e[this.centeredKey], p = this._shouldCenterTransform(t, h, d) ? { x: Pe, y: Pe } : this._getOriginFromCorner(t, a), g = { target: t, action: h, actionHandler: u, actionPerformed: !1, corner: a, scaleX: t.scaleX, scaleY: t.scaleY, skewX: t.skewX, skewY: t.skewY, offsetX: s.x - t.left, offsetY: s.y - t.top, originX: p.x, originY: p.y, ex: s.x, ey: s.y, lastX: s.x, lastY: s.y, theta: bt(t.angle), width: t.width, height: t.height, shiftKey: e.shiftKey, altKey: d, original: D(D({}, sp(t)), {}, { originX: p.x, originY: p.y }) };
    this._currentTransform = g, this.fire("before:transform", { e, transform: g });
  }
  setCursor(e) {
    this.upperCanvasEl.style.cursor = e;
  }
  _drawSelection(e) {
    const { x: t, y: n, deltaX: i, deltaY: s } = this._groupSelector, a = new B(t, n).transform(this.viewportTransform), c = new B(t + i, n + s).transform(this.viewportTransform), u = this.selectionLineWidth / 2;
    let h = Math.min(a.x, c.x), d = Math.min(a.y, c.y), p = Math.max(a.x, c.x), g = Math.max(a.y, c.y);
    this.selectionColor && (e.fillStyle = this.selectionColor, e.fillRect(h, d, p - h, g - d)), this.selectionLineWidth && this.selectionBorderColor && (e.lineWidth = this.selectionLineWidth, e.strokeStyle = this.selectionBorderColor, h += u, d += u, p -= u, g -= u, rt.prototype._setLineDash.call(this, e, this.selectionDashArray), e.strokeRect(h, d, p - h, g - d));
  }
  findTarget(e) {
    if (this.skipTargetFind) return;
    const t = this.getViewportPoint(e), n = this._activeObject, i = this.getActiveObjects();
    if (this.targets = [], n && i.length >= 1) {
      if (n.findControl(t, pl(e)) || i.length > 1 && this.searchPossibleTargets([n], t)) return n;
      if (n === this.searchPossibleTargets([n], t)) {
        if (this.preserveObjectStacking) {
          const s = this.targets;
          this.targets = [];
          const a = this.searchPossibleTargets(this._objects, t);
          return e[this.altSelectionKey] && a && a !== n ? (this.targets = s, n) : a;
        }
        return n;
      }
    }
    return this.searchPossibleTargets(this._objects, t);
  }
  _pointIsInObjectSelectionArea(e, t) {
    let n = e.getCoords();
    const i = this.getZoom(), s = e.padding / i;
    if (s) {
      const [a, c, u, h] = n, d = Math.atan2(c.y - a.y, c.x - a.x), p = cn(d) * s, g = ln(d) * s, v = p + g, y = p - g;
      n = [new B(a.x - y, a.y - v), new B(c.x + v, c.y - y), new B(u.x + y, u.y + v), new B(h.x - v, h.y + y)];
    }
    return pt.isPointInPolygon(t, n);
  }
  _checkTarget(e, t) {
    return !!(e && e.visible && e.evented && this._pointIsInObjectSelectionArea(e, $n(t, void 0, this.viewportTransform)) && (!this.perPixelTargetFind && !e.perPixelTargetFind || e.isEditing || !this.isTargetTransparent(e, t.x, t.y)));
  }
  _searchPossibleTargets(e, t) {
    let n = e.length;
    for (; n--; ) {
      const i = e[n];
      if (this._checkTarget(i, t)) {
        if (Jc(i) && i.subTargetCheck) {
          const s = this._searchPossibleTargets(i._objects, t);
          s && this.targets.push(s);
        }
        return i;
      }
    }
  }
  searchPossibleTargets(e, t) {
    const n = this._searchPossibleTargets(e, t);
    if (n && Jc(n) && n.interactive && this.targets[0]) {
      const i = this.targets;
      for (let s = i.length - 1; s > 0; s--) {
        const a = i[s];
        if (!Jc(a) || !a.interactive) return a;
      }
      return i[0];
    }
    return n;
  }
  getViewportPoint(e) {
    return this._pointer ? this._pointer : this.getPointer(e, !0);
  }
  getScenePoint(e) {
    return this._absolutePointer ? this._absolutePointer : this.getPointer(e);
  }
  getPointer(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    const n = this.upperCanvasEl, i = n.getBoundingClientRect();
    let s = tw(e), a = i.width || 0, c = i.height || 0;
    a && c || (vr in i && Hd in i && (c = Math.abs(i.top - i.bottom)), Ct in i && Ke in i && (a = Math.abs(i.right - i.left))), this.calcOffset(), s.x = s.x - this._offset.left, s.y = s.y - this._offset.top, t || (s = $n(s, void 0, this.viewportTransform));
    const u = this.getRetinaScaling();
    u !== 1 && (s.x /= u, s.y /= u);
    const h = a === 0 || c === 0 ? new B(1, 1) : new B(n.width / a, n.height / c);
    return s.multiply(h);
  }
  _setDimensionsImpl(e, t) {
    this._resetTransformEventData(), super._setDimensionsImpl(e, t), this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);
  }
  _createCacheCanvas() {
    this.pixelFindCanvasEl = Gr(), this.pixelFindContext = this.pixelFindCanvasEl.getContext("2d", { willReadFrequently: !0 }), this.setTargetFindTolerance(this.targetFindTolerance);
  }
  getTopContext() {
    return this.elements.upper.ctx;
  }
  getSelectionContext() {
    return this.elements.upper.ctx;
  }
  getSelectionElement() {
    return this.elements.upper.el;
  }
  getActiveObject() {
    return this._activeObject;
  }
  getActiveObjects() {
    const e = this._activeObject;
    return Wi(e) ? e.getObjects() : e ? [e] : [];
  }
  _fireSelectionEvents(e, t) {
    let n = !1, i = !1;
    const s = this.getActiveObjects(), a = [], c = [];
    e.forEach((u) => {
      s.includes(u) || (n = !0, u.fire("deselected", { e: t, target: u }), c.push(u));
    }), s.forEach((u) => {
      e.includes(u) || (n = !0, u.fire("selected", { e: t, target: u }), a.push(u));
    }), e.length > 0 && s.length > 0 ? (i = !0, n && this.fire("selection:updated", { e: t, selected: a, deselected: c })) : s.length > 0 ? (i = !0, this.fire("selection:created", { e: t, selected: a })) : e.length > 0 && (i = !0, this.fire("selection:cleared", { e: t, deselected: c })), i && (this._objectsToRender = void 0);
  }
  setActiveObject(e, t) {
    const n = this.getActiveObjects(), i = this._setActiveObject(e, t);
    return this._fireSelectionEvents(n, t), i;
  }
  _setActiveObject(e, t) {
    const n = this._activeObject;
    return n !== e && !(!this._discardActiveObject(t, e) && this._activeObject) && !e.onSelect({ e: t }) && (this._activeObject = e, Wi(e) && n !== e && e.set("canvas", this), e.setCoords(), !0);
  }
  _discardActiveObject(e, t) {
    const n = this._activeObject;
    return !!n && !n.onDeselect({ e, object: t }) && (this._currentTransform && this._currentTransform.target === n && this.endCurrentTransform(e), Wi(n) && n === this._hoveredTarget && (this._hoveredTarget = void 0), this._activeObject = void 0, !0);
  }
  discardActiveObject(e) {
    const t = this.getActiveObjects(), n = this.getActiveObject();
    t.length && this.fire("before:selection:cleared", { e, deselected: [n] });
    const i = this._discardActiveObject(e);
    return this._fireSelectionEvents(t, e), i;
  }
  endCurrentTransform(e) {
    const t = this._currentTransform;
    this._finalizeCurrentTransform(e), t && t.target && (t.target.isMoving = !1), this._currentTransform = null;
  }
  _finalizeCurrentTransform(e) {
    const t = this._currentTransform, n = t.target, i = { e, target: n, transform: t, action: t.action };
    n._scaling && (n._scaling = !1), n.setCoords(), t.actionPerformed && (this.fire("object:modified", i), n.fire(dl, i));
  }
  setViewportTransform(e) {
    super.setViewportTransform(e);
    const t = this._activeObject;
    t && t.setCoords();
  }
  destroy() {
    const e = this._activeObject;
    Wi(e) && (e.removeAll(), e.dispose()), delete this._activeObject, super.destroy(), this.pixelFindContext = null, this.pixelFindCanvasEl = void 0;
  }
  clear() {
    this.discardActiveObject(), this._activeObject = void 0, this.clearContext(this.contextTop), super.clear();
  }
  drawControls(e) {
    const t = this._activeObject;
    t && t._renderControls(e);
  }
  _toObject(e, t, n) {
    const i = this._realizeGroupTransformOnObject(e), s = super._toObject(e, t, n);
    return e.set(i), s;
  }
  _realizeGroupTransformOnObject(e) {
    const { group: t } = e;
    if (t && Wi(t) && this._activeObject === t) {
      const n = fs(e, ["angle", "flipX", "flipY", Ke, ar, Dr, lo, uo, vr]);
      return rw(e, t.calcOwnMatrix()), n;
    }
    return {};
  }
  _setSVGObject(e, t, n) {
    const i = this._realizeGroupTransformOnObject(t);
    super._setSVGObject(e, t, n), t.set(i);
  }
}
R(du, "ownDefaults", { uniformScaling: !0, uniScaleKey: "shiftKey", centeredScaling: !1, centeredRotation: !1, centeredKey: "altKey", altActionKey: "shiftKey", selection: !0, selectionKey: "shiftKey", selectionColor: "rgba(100, 100, 255, 0.3)", selectionDashArray: [], selectionBorderColor: "rgba(255, 255, 255, 0.3)", selectionLineWidth: 1, selectionFullyContained: !1, hoverCursor: "move", moveCursor: "move", defaultCursor: "default", freeDrawingCursor: "crosshair", notAllowedCursor: "not-allowed", perPixelTargetFind: !1, targetFindTolerance: 0, skipTargetFind: !1, stopContextMenu: !1, fireRightClick: !1, fireMiddleClick: !1, enablePointerEvents: !1, containerClass: "canvas-container", preserveObjectStacking: !1 });
class Q3 {
  constructor(e) {
    R(this, "targets", []), R(this, "__disposer", void 0);
    const t = () => {
      const { hiddenTextarea: i } = e.getActiveObject() || {};
      i && i.focus();
    }, n = e.upperCanvasEl;
    n.addEventListener("click", t), this.__disposer = () => n.removeEventListener("click", t);
  }
  exitTextEditing() {
    this.target = void 0, this.targets.forEach((e) => {
      e.isEditing && e.exitEditing();
    });
  }
  add(e) {
    this.targets.push(e);
  }
  remove(e) {
    this.unregister(e), zi(this.targets, e);
  }
  register(e) {
    this.target = e;
  }
  unregister(e) {
    e === this.target && (this.target = void 0);
  }
  onMouseMove(e) {
    var t;
    !((t = this.target) === null || t === void 0) && t.isEditing && this.target.updateSelectionOnMouseMove(e);
  }
  clear() {
    this.targets = [], this.target = void 0;
  }
  dispose() {
    this.clear(), this.__disposer(), delete this.__disposer;
  }
}
const eR = ["target", "oldTarget", "fireCanvas", "e"], Mr = { passive: !1 }, js = (r, e) => {
  const t = r.getViewportPoint(e), n = r.getScenePoint(e);
  return { viewportPoint: t, scenePoint: n, pointer: t, absolutePointer: n };
}, hi = function(r) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) t[n - 1] = arguments[n];
  return r.addEventListener(...t);
}, Ur = function(r) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) t[n - 1] = arguments[n];
  return r.removeEventListener(...t);
}, tR = { mouse: { in: "over", out: "out", targetIn: "mouseover", targetOut: "mouseout", canvasIn: "mouse:over", canvasOut: "mouse:out" }, drag: { in: "enter", out: "leave", targetIn: "dragenter", targetOut: "dragleave", canvasIn: "drag:enter", canvasOut: "drag:leave" } };
class rf extends du {
  constructor(e) {
    super(e, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}), R(this, "_isClick", void 0), R(this, "textEditingManager", new Q3(this)), ["_onMouseDown", "_onTouchStart", "_onMouseMove", "_onMouseUp", "_onTouchEnd", "_onResize", "_onMouseWheel", "_onMouseOut", "_onMouseEnter", "_onContextMenu", "_onDoubleClick", "_onDragStart", "_onDragEnd", "_onDragProgress", "_onDragOver", "_onDragEnter", "_onDragLeave", "_onDrop"].forEach((t) => {
      this[t] = this[t].bind(this);
    }), this.addOrRemove(hi, "add");
  }
  _getEventPrefix() {
    return this.enablePointerEvents ? "pointer" : "mouse";
  }
  addOrRemove(e, t) {
    const n = this.upperCanvasEl, i = this._getEventPrefix();
    e(Jb(n), "resize", this._onResize), e(n, i + "down", this._onMouseDown), e(n, "".concat(i, "move"), this._onMouseMove, Mr), e(n, "".concat(i, "out"), this._onMouseOut), e(n, "".concat(i, "enter"), this._onMouseEnter), e(n, "wheel", this._onMouseWheel), e(n, "contextmenu", this._onContextMenu), e(n, "dblclick", this._onDoubleClick), e(n, "dragstart", this._onDragStart), e(n, "dragend", this._onDragEnd), e(n, "dragover", this._onDragOver), e(n, "dragenter", this._onDragEnter), e(n, "dragleave", this._onDragLeave), e(n, "drop", this._onDrop), this.enablePointerEvents || e(n, "touchstart", this._onTouchStart, Mr);
  }
  removeListeners() {
    this.addOrRemove(Ur, "remove");
    const e = this._getEventPrefix(), t = sn(this.upperCanvasEl);
    Ur(t, "".concat(e, "up"), this._onMouseUp), Ur(t, "touchend", this._onTouchEnd, Mr), Ur(t, "".concat(e, "move"), this._onMouseMove, Mr), Ur(t, "touchmove", this._onMouseMove, Mr), clearTimeout(this._willAddMouseDown);
  }
  _onMouseWheel(e) {
    this.__onMouseWheel(e);
  }
  _onMouseOut(e) {
    const t = this._hoveredTarget, n = D({ e }, js(this, e));
    this.fire("mouse:out", D(D({}, n), {}, { target: t })), this._hoveredTarget = void 0, t && t.fire("mouseout", D({}, n)), this._hoveredTargets.forEach((i) => {
      this.fire("mouse:out", D(D({}, n), {}, { target: i })), i && i.fire("mouseout", D({}, n));
    }), this._hoveredTargets = [];
  }
  _onMouseEnter(e) {
    this._currentTransform || this.findTarget(e) || (this.fire("mouse:over", D({ e }, js(this, e))), this._hoveredTarget = void 0, this._hoveredTargets = []);
  }
  _onDragStart(e) {
    this._isClick = !1;
    const t = this.getActiveObject();
    if (t && t.onDragStart(e)) {
      this._dragSource = t;
      const n = { e, target: t };
      return this.fire("dragstart", n), t.fire("dragstart", n), void hi(this.upperCanvasEl, "drag", this._onDragProgress);
    }
    $d(e);
  }
  _renderDragEffects(e, t, n) {
    let i = !1;
    const s = this._dropTarget;
    s && s !== t && s !== n && (s.clearContextTop(), i = !0), t?.clearContextTop(), n !== t && n?.clearContextTop();
    const a = this.contextTop;
    a.save(), a.transform(...this.viewportTransform), t && (a.save(), t.transform(a), t.renderDragSourceEffect(e), a.restore(), i = !0), n && (a.save(), n.transform(a), n.renderDropTargetEffect(e), a.restore(), i = !0), a.restore(), i && (this.contextTopDirty = !0);
  }
  _onDragEnd(e) {
    const t = !!e.dataTransfer && e.dataTransfer.dropEffect !== yr, n = t ? this._activeObject : void 0, i = { e, target: this._dragSource, subTargets: this.targets, dragSource: this._dragSource, didDrop: t, dropTarget: n };
    Ur(this.upperCanvasEl, "drag", this._onDragProgress), this.fire("dragend", i), this._dragSource && this._dragSource.fire("dragend", i), delete this._dragSource, this._onMouseUp(e);
  }
  _onDragProgress(e) {
    const t = { e, target: this._dragSource, dragSource: this._dragSource, dropTarget: this._draggedoverTarget };
    this.fire("drag", t), this._dragSource && this._dragSource.fire("drag", t);
  }
  findDragTargets(e) {
    return this.targets = [], { target: this._searchPossibleTargets(this._objects, this.getViewportPoint(e)), targets: [...this.targets] };
  }
  _onDragOver(e) {
    const t = "dragover", { target: n, targets: i } = this.findDragTargets(e), s = this._dragSource, a = { e, target: n, subTargets: i, dragSource: s, canDrop: !1, dropTarget: void 0 };
    let c;
    this.fire(t, a), this._fireEnterLeaveEvents(n, a), n && (n.canDrop(e) && (c = n), n.fire(t, a));
    for (let u = 0; u < i.length; u++) {
      const h = i[u];
      h.canDrop(e) && (c = h), h.fire(t, a);
    }
    this._renderDragEffects(e, s, c), this._dropTarget = c;
  }
  _onDragEnter(e) {
    const { target: t, targets: n } = this.findDragTargets(e), i = { e, target: t, subTargets: n, dragSource: this._dragSource };
    this.fire("dragenter", i), this._fireEnterLeaveEvents(t, i);
  }
  _onDragLeave(e) {
    const t = { e, target: this._draggedoverTarget, subTargets: this.targets, dragSource: this._dragSource };
    this.fire("dragleave", t), this._fireEnterLeaveEvents(void 0, t), this._renderDragEffects(e, this._dragSource), this._dropTarget = void 0, this.targets = [], this._hoveredTargets = [];
  }
  _onDrop(e) {
    const { target: t, targets: n } = this.findDragTargets(e), i = this._basicEventHandler("drop:before", D({ e, target: t, subTargets: n, dragSource: this._dragSource }, js(this, e)));
    i.didDrop = !1, i.dropTarget = void 0, this._basicEventHandler("drop", i), this.fire("drop:after", i);
  }
  _onContextMenu(e) {
    const t = this.findTarget(e), n = this.targets || [], i = this._basicEventHandler("contextmenu:before", { e, target: t, subTargets: n });
    return this.stopContextMenu && $d(e), this._basicEventHandler("contextmenu", i), !1;
  }
  _onDoubleClick(e) {
    this._cacheTransformEventData(e), this._handleEvent(e, "dblclick"), this._resetTransformEventData();
  }
  getPointerId(e) {
    const t = e.changedTouches;
    return t ? t[0] && t[0].identifier : this.enablePointerEvents ? e.pointerId : -1;
  }
  _isMainEvent(e) {
    return e.isPrimary === !0 || e.isPrimary !== !1 && (e.type === "touchend" && e.touches.length === 0 || !e.changedTouches || e.changedTouches[0].identifier === this.mainTouchId);
  }
  _onTouchStart(e) {
    let t = !this.allowTouchScrolling;
    const n = this._activeObject;
    this.mainTouchId === void 0 && (this.mainTouchId = this.getPointerId(e)), this.__onMouseDown(e), (this.isDrawingMode || n && this._target === n) && (t = !0), t && e.preventDefault(), this._resetTransformEventData();
    const i = this.upperCanvasEl, s = this._getEventPrefix(), a = sn(i);
    hi(a, "touchend", this._onTouchEnd, Mr), t && hi(a, "touchmove", this._onMouseMove, Mr), Ur(i, "".concat(s, "down"), this._onMouseDown);
  }
  _onMouseDown(e) {
    this.__onMouseDown(e), this._resetTransformEventData();
    const t = this.upperCanvasEl, n = this._getEventPrefix();
    Ur(t, "".concat(n, "move"), this._onMouseMove, Mr);
    const i = sn(t);
    hi(i, "".concat(n, "up"), this._onMouseUp), hi(i, "".concat(n, "move"), this._onMouseMove, Mr);
  }
  _onTouchEnd(e) {
    if (e.touches.length > 0) return;
    this.__onMouseUp(e), this._resetTransformEventData(), delete this.mainTouchId;
    const t = this._getEventPrefix(), n = sn(this.upperCanvasEl);
    Ur(n, "touchend", this._onTouchEnd, Mr), Ur(n, "touchmove", this._onMouseMove, Mr), this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(() => {
      hi(this.upperCanvasEl, "".concat(t, "down"), this._onMouseDown), this._willAddMouseDown = 0;
    }, 400);
  }
  _onMouseUp(e) {
    this.__onMouseUp(e), this._resetTransformEventData();
    const t = this.upperCanvasEl, n = this._getEventPrefix();
    if (this._isMainEvent(e)) {
      const i = sn(this.upperCanvasEl);
      Ur(i, "".concat(n, "up"), this._onMouseUp), Ur(i, "".concat(n, "move"), this._onMouseMove, Mr), hi(t, "".concat(n, "move"), this._onMouseMove, Mr);
    }
  }
  _onMouseMove(e) {
    const t = this.getActiveObject();
    !this.allowTouchScrolling && (!t || !t.shouldStartDragging(e)) && e.preventDefault && e.preventDefault(), this.__onMouseMove(e);
  }
  _onResize() {
    this.calcOffset(), this._resetTransformEventData();
  }
  _shouldRender(e) {
    const t = this.getActiveObject();
    return !!t != !!e || t && e && t !== e;
  }
  __onMouseUp(e) {
    var t;
    this._cacheTransformEventData(e), this._handleEvent(e, "up:before");
    const n = this._currentTransform, i = this._isClick, s = this._target, { button: a } = e;
    if (a) return (this.fireMiddleClick && a === 1 || this.fireRightClick && a === 2) && this._handleEvent(e, "up"), void this._resetTransformEventData();
    if (this.isDrawingMode && this._isCurrentlyDrawing) return void this._onMouseUpInDrawingMode(e);
    if (!this._isMainEvent(e)) return;
    let c, u, h = !1;
    if (n && (this._finalizeCurrentTransform(e), h = n.actionPerformed), !i) {
      const d = s === this._activeObject;
      this.handleSelection(e), h || (h = this._shouldRender(s) || !d && s === this._activeObject);
    }
    if (s) {
      const d = s.findControl(this.getViewportPoint(e), pl(e)), { key: p, control: g } = d || {};
      if (u = p, s.selectable && s !== this._activeObject && s.activeOn === "up") this.setActiveObject(s, e), h = !0;
      else if (g) {
        const v = g.getMouseUpHandler(e, s, g);
        v && (c = this.getScenePoint(e), v.call(g, e, n, c.x, c.y));
      }
      s.isMoving = !1;
    }
    if (n && (n.target !== s || n.corner !== u)) {
      const d = n.target && n.target.controls[n.corner], p = d && d.getMouseUpHandler(e, n.target, d);
      c = c || this.getScenePoint(e), p && p.call(d, e, n, c.x, c.y);
    }
    this._setCursorFromEvent(e, s), this._handleEvent(e, "up"), this._groupSelector = null, this._currentTransform = null, s && (s.__corner = void 0), h ? this.requestRenderAll() : i || (t = this._activeObject) !== null && t !== void 0 && t.isEditing || this.renderTop();
  }
  _basicEventHandler(e, t) {
    const { target: n, subTargets: i = [] } = t;
    this.fire(e, t), n && n.fire(e, t);
    for (let s = 0; s < i.length; s++) i[s] !== n && i[s].fire(e, t);
    return t;
  }
  _handleEvent(e, t) {
    const n = this._target, i = this.targets || [], s = D(D({ e, target: n, subTargets: i }, js(this, e)), {}, { transform: this._currentTransform }, t === "up:before" || t === "up" ? { isClick: this._isClick, currentTarget: this.findTarget(e), currentSubTargets: this.targets } : {});
    this.fire("mouse:".concat(t), s), n && n.fire("mouse".concat(t), s);
    for (let a = 0; a < i.length; a++) i[a] !== n && i[a].fire("mouse".concat(t), s);
  }
  _onMouseDownInDrawingMode(e) {
    this._isCurrentlyDrawing = !0, this.getActiveObject() && (this.discardActiveObject(e), this.requestRenderAll());
    const t = this.getScenePoint(e);
    this.freeDrawingBrush && this.freeDrawingBrush.onMouseDown(t, { e, pointer: t }), this._handleEvent(e, "down");
  }
  _onMouseMoveInDrawingMode(e) {
    if (this._isCurrentlyDrawing) {
      const t = this.getScenePoint(e);
      this.freeDrawingBrush && this.freeDrawingBrush.onMouseMove(t, { e, pointer: t });
    }
    this.setCursor(this.freeDrawingCursor), this._handleEvent(e, "move");
  }
  _onMouseUpInDrawingMode(e) {
    const t = this.getScenePoint(e);
    this.freeDrawingBrush ? this._isCurrentlyDrawing = !!this.freeDrawingBrush.onMouseUp({ e, pointer: t }) : this._isCurrentlyDrawing = !1, this._handleEvent(e, "up");
  }
  __onMouseDown(e) {
    this._isClick = !0, this._cacheTransformEventData(e), this._handleEvent(e, "down:before");
    let t = this._target;
    const { button: n } = e;
    if (n) return (this.fireMiddleClick && n === 1 || this.fireRightClick && n === 2) && this._handleEvent(e, "down"), void this._resetTransformEventData();
    if (this.isDrawingMode) return void this._onMouseDownInDrawingMode(e);
    if (!this._isMainEvent(e) || this._currentTransform) return;
    let i = this._shouldRender(t), s = !1;
    if (this.handleMultiSelection(e, t) ? (t = this._activeObject, s = !0, i = !0) : this._shouldClearSelection(e, t) && this.discardActiveObject(e), this.selection && (!t || !t.selectable && !t.isEditing && t !== this._activeObject)) {
      const a = this.getScenePoint(e);
      this._groupSelector = { x: a.x, y: a.y, deltaY: 0, deltaX: 0 };
    }
    if (t) {
      const a = t === this._activeObject;
      t.selectable && t.activeOn === "down" && this.setActiveObject(t, e);
      const c = t.findControl(this.getViewportPoint(e), pl(e));
      if (t === this._activeObject && (c || !s)) {
        this._setupCurrentTransform(e, t, a);
        const u = c ? c.control : void 0, h = this.getScenePoint(e), d = u && u.getMouseDownHandler(e, t, u);
        d && d.call(u, e, this._currentTransform, h.x, h.y);
      }
    }
    i && (this._objectsToRender = void 0), this._handleEvent(e, "down"), i && this.requestRenderAll();
  }
  _resetTransformEventData() {
    this._target = this._pointer = this._absolutePointer = void 0;
  }
  _cacheTransformEventData(e) {
    this._resetTransformEventData(), this._pointer = this.getViewportPoint(e), this._absolutePointer = $n(this._pointer, void 0, this.viewportTransform), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e);
  }
  __onMouseMove(e) {
    if (this._isClick = !1, this._cacheTransformEventData(e), this._handleEvent(e, "move:before"), this.isDrawingMode) return void this._onMouseMoveInDrawingMode(e);
    if (!this._isMainEvent(e)) return;
    const t = this._groupSelector;
    if (t) {
      const n = this.getScenePoint(e);
      t.deltaX = n.x - t.x, t.deltaY = n.y - t.y, this.renderTop();
    } else if (this._currentTransform) this._transformObject(e);
    else {
      const n = this.findTarget(e);
      this._setCursorFromEvent(e, n), this._fireOverOutEvents(e, n);
    }
    this.textEditingManager.onMouseMove(e), this._handleEvent(e, "move"), this._resetTransformEventData();
  }
  _fireOverOutEvents(e, t) {
    const n = this._hoveredTarget, i = this._hoveredTargets, s = this.targets, a = Math.max(i.length, s.length);
    this.fireSyntheticInOutEvents("mouse", { e, target: t, oldTarget: n, fireCanvas: !0 });
    for (let c = 0; c < a; c++) this.fireSyntheticInOutEvents("mouse", { e, target: s[c], oldTarget: i[c] });
    this._hoveredTarget = t, this._hoveredTargets = this.targets.concat();
  }
  _fireEnterLeaveEvents(e, t) {
    const n = this._draggedoverTarget, i = this._hoveredTargets, s = this.targets, a = Math.max(i.length, s.length);
    this.fireSyntheticInOutEvents("drag", D(D({}, t), {}, { target: e, oldTarget: n, fireCanvas: !0 }));
    for (let c = 0; c < a; c++) this.fireSyntheticInOutEvents("drag", D(D({}, t), {}, { target: s[c], oldTarget: i[c] }));
    this._draggedoverTarget = e;
  }
  fireSyntheticInOutEvents(e, t) {
    let { target: n, oldTarget: i, fireCanvas: s, e: a } = t, c = ht(t, eR);
    const { targetIn: u, targetOut: h, canvasIn: d, canvasOut: p } = tR[e], g = i !== n;
    if (i && g) {
      const v = D(D({}, c), {}, { e: a, target: i, nextTarget: n }, js(this, a));
      s && this.fire(p, v), i.fire(h, v);
    }
    if (n && g) {
      const v = D(D({}, c), {}, { e: a, target: n, previousTarget: i }, js(this, a));
      s && this.fire(d, v), n.fire(u, v);
    }
  }
  __onMouseWheel(e) {
    this._cacheTransformEventData(e), this._handleEvent(e, "wheel"), this._resetTransformEventData();
  }
  _transformObject(e) {
    const t = this.getScenePoint(e), n = this._currentTransform, i = n.target, s = i.group ? $n(t, void 0, i.group.calcTransformMatrix()) : t;
    n.shiftKey = e.shiftKey, n.altKey = !!this.centeredKey && e[this.centeredKey], this._performTransformAction(e, n, s), n.actionPerformed && this.requestRenderAll();
  }
  _performTransformAction(e, t, n) {
    const { action: i, actionHandler: s, target: a } = t, c = !!s && s(e, t, n.x, n.y);
    c && a.setCoords(), i === "drag" && c && (t.target.isMoving = !0, this.setCursor(t.target.moveCursor || this.moveCursor)), t.actionPerformed = t.actionPerformed || c;
  }
  _setCursorFromEvent(e, t) {
    if (!t) return void this.setCursor(this.defaultCursor);
    let n = t.hoverCursor || this.hoverCursor;
    const i = Wi(this._activeObject) ? this._activeObject : null, s = (!i || t.group !== i) && t.findControl(this.getViewportPoint(e));
    if (s) {
      const a = s.control;
      this.setCursor(a.cursorStyleHandler(e, a, t));
    } else t.subTargetCheck && this.targets.concat().reverse().map((a) => {
      n = a.hoverCursor || n;
    }), this.setCursor(n);
  }
  handleMultiSelection(e, t) {
    const n = this._activeObject, i = Wi(n);
    if (n && this._isSelectionKeyPressed(e) && this.selection && t && t.selectable && (n !== t || i) && (i || !t.isDescendantOf(n) && !n.isDescendantOf(t)) && !t.onSelect({ e }) && !n.getActiveControl()) {
      if (i) {
        const s = n.getObjects();
        if (t === n) {
          const a = this.getViewportPoint(e);
          if (!(t = this.searchPossibleTargets(s, a) || this.searchPossibleTargets(this._objects, a)) || !t.selectable) return !1;
        }
        t.group === n ? (n.remove(t), this._hoveredTarget = t, this._hoveredTargets = [...this.targets], n.size() === 1 && this._setActiveObject(n.item(0), e)) : (n.multiSelectAdd(t), this._hoveredTarget = n, this._hoveredTargets = [...this.targets]), this._fireSelectionEvents(s, e);
      } else {
        n.isEditing && n.exitEditing();
        const s = new (ne.getClass("ActiveSelection"))([], { canvas: this });
        s.multiSelectAdd(n, t), this._hoveredTarget = s, this._setActiveObject(s, e), this._fireSelectionEvents([n], e);
      }
      return !0;
    }
    return !1;
  }
  handleSelection(e) {
    if (!this.selection || !this._groupSelector) return !1;
    const { x: t, y: n, deltaX: i, deltaY: s } = this._groupSelector, a = new B(t, n), c = a.add(new B(i, s)), u = a.min(c), h = a.max(c).subtract(u), d = this.collectObjects({ left: u.x, top: u.y, width: h.x, height: h.y }, { includeIntersecting: !this.selectionFullyContained }), p = a.eq(c) ? d[0] ? [d[0]] : [] : d.length > 1 ? d.filter((g) => !g.onSelect({ e })).reverse() : d;
    if (p.length === 1) this.setActiveObject(p[0], e);
    else if (p.length > 1) {
      const g = ne.getClass("ActiveSelection");
      this.setActiveObject(new g(p, { canvas: this }), e);
    }
    return this._groupSelector = null, !0;
  }
  clear() {
    this.textEditingManager.clear(), super.clear();
  }
  destroy() {
    this.removeListeners(), this.textEditingManager.dispose(), super.destroy();
  }
}
const qw = { x1: 0, y1: 0, x2: 0, y2: 0 }, rR = D(D({}, qw), {}, { r1: 0, r2: 0 }), Bs = (r, e) => isNaN(r) && typeof e == "number" ? e : r, nR = /^(\d+\.\d+)%|(\d+)%$/;
function Kw(r) {
  return r && nR.test(r);
}
function Zw(r, e) {
  const t = typeof r == "number" ? r : typeof r == "string" ? parseFloat(r) / (Kw(r) ? 100 : 1) : NaN;
  return ts(0, Bs(t, e), 1);
}
const iR = /\s*;\s*/, sR = /\s*:\s*/;
function oR(r, e) {
  let t, n;
  const i = r.getAttribute("style");
  if (i) {
    const a = i.split(iR);
    a[a.length - 1] === "" && a.pop();
    for (let c = a.length; c--; ) {
      const [u, h] = a[c].split(sR).map((d) => d.trim());
      u === "stop-color" ? t = h : u === "stop-opacity" && (n = h);
    }
  }
  const s = new Qe(t || r.getAttribute("stop-color") || "rgb(0,0,0)");
  return { offset: Zw(r.getAttribute("offset"), 0), color: s.toRgb(), opacity: Bs(parseFloat(n || r.getAttribute("stop-opacity") || ""), 1) * s.getAlpha() * e };
}
function aR(r, e) {
  const t = [], n = r.getElementsByTagName("stop"), i = Zw(e, 1);
  for (let s = n.length; s--; ) t.push(oR(n[s], i));
  return t;
}
function Jw(r) {
  return r.nodeName === "linearGradient" || r.nodeName === "LINEARGRADIENT" ? "linear" : "radial";
}
function Qw(r) {
  return r.getAttribute("gradientUnits") === "userSpaceOnUse" ? "pixels" : "percentage";
}
function rn(r, e) {
  return r.getAttribute(e);
}
function cR(r, e) {
  return function(t, n) {
    let i, { width: s, height: a, gradientUnits: c } = n;
    return Object.keys(t).reduce((u, h) => {
      const d = t[h];
      return d === "Infinity" ? i = 1 : d === "-Infinity" ? i = 0 : (i = typeof d == "string" ? parseFloat(d) : d, typeof d == "string" && Kw(d) && (i *= 0.01, c === "pixels" && (h !== "x1" && h !== "x2" && h !== "r2" || (i *= s), h !== "y1" && h !== "y2" || (i *= a)))), u[h] = i, u;
    }, {});
  }(Jw(r) === "linear" ? function(t) {
    return { x1: rn(t, "x1") || 0, y1: rn(t, "y1") || 0, x2: rn(t, "x2") || "100%", y2: rn(t, "y2") || 0 };
  }(r) : function(t) {
    return { x1: rn(t, "fx") || rn(t, "cx") || "50%", y1: rn(t, "fy") || rn(t, "cy") || "50%", r1: 0, x2: rn(t, "cx") || "50%", y2: rn(t, "cy") || "50%", r2: rn(t, "r") || "50%" };
  }(r), D(D({}, e), {}, { gradientUnits: Qw(r) }));
}
class Ec {
  constructor(e) {
    const { type: t = "linear", gradientUnits: n = "pixels", coords: i = {}, colorStops: s = [], offsetX: a = 0, offsetY: c = 0, gradientTransform: u, id: h } = e || {};
    Object.assign(this, { type: t, gradientUnits: n, coords: D(D({}, t === "radial" ? rR : qw), i), colorStops: s, offsetX: a, offsetY: c, gradientTransform: u, id: h ? "".concat(h, "_").concat(mi()) : mi() });
  }
  addColorStop(e) {
    for (const t in e) {
      const n = new Qe(e[t]);
      this.colorStops.push({ offset: parseFloat(t), color: n.toRgb(), opacity: n.getAlpha() });
    }
    return this;
  }
  toObject(e) {
    return D(D({}, fs(this, e)), {}, { type: this.type, coords: D({}, this.coords), colorStops: this.colorStops.map((t) => D({}, t)), offsetX: this.offsetX, offsetY: this.offsetY, gradientUnits: this.gradientUnits, gradientTransform: this.gradientTransform ? [...this.gradientTransform] : void 0 });
  }
  toSVG(e) {
    let { additionalTransform: t } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = [], i = this.gradientTransform ? this.gradientTransform.concat() : or.concat(), s = this.gradientUnits === "pixels" ? "userSpaceOnUse" : "objectBoundingBox", a = this.colorStops.map((p) => D({}, p)).sort((p, g) => p.offset - g.offset);
    let c = -this.offsetX, u = -this.offsetY;
    var h;
    s === "objectBoundingBox" ? (c /= e.width, u /= e.height) : (c += e.width / 2, u += e.height / 2), (h = e) && typeof h._renderPathCommands == "function" && this.gradientUnits !== "percentage" && (c -= e.pathOffset.x, u -= e.pathOffset.y), i[4] -= c, i[5] -= u;
    const d = ['id="SVGID_'.concat(this.id, '"'), 'gradientUnits="'.concat(s, '"'), 'gradientTransform="'.concat(t ? t + " " : "").concat(ia(i), '"'), ""].join(" ");
    if (this.type === "linear") {
      const { x1: p, y1: g, x2: v, y2: y } = this.coords;
      n.push("<linearGradient ", d, ' x1="', p, '" y1="', g, '" x2="', v, '" y2="', y, `">
`);
    } else if (this.type === "radial") {
      const { x1: p, y1: g, x2: v, y2: y, r1: x, r2: _ } = this.coords, C = x > _;
      n.push("<radialGradient ", d, ' cx="', C ? p : v, '" cy="', C ? g : y, '" r="', C ? x : _, '" fx="', C ? v : p, '" fy="', C ? y : g, `">
`), C && (a.reverse(), a.forEach((k) => {
        k.offset = 1 - k.offset;
      }));
      const E = Math.min(x, _);
      if (E > 0) {
        const k = E / Math.max(x, _);
        a.forEach((O) => {
          O.offset += k * (1 - O.offset);
        });
      }
    }
    return a.forEach((p) => {
      let { color: g, offset: v, opacity: y } = p;
      n.push("<stop ", 'offset="', 100 * v + "%", '" style="stop-color:', g, y !== void 0 ? ";stop-opacity: " + y : ";", `"/>
`);
    }), n.push(this.type === "linear" ? "</linearGradient>" : "</radialGradient>", `
`), n.join("");
  }
  toLive(e) {
    const { x1: t, y1: n, x2: i, y2: s, r1: a, r2: c } = this.coords, u = this.type === "linear" ? e.createLinearGradient(t, n, i, s) : e.createRadialGradient(t, n, a, i, s, c);
    return this.colorStops.forEach((h) => {
      let { color: d, opacity: p, offset: g } = h;
      u.addColorStop(g, p !== void 0 ? new Qe(d).setAlpha(p).toRgba() : d);
    }), u;
  }
  static async fromObject(e) {
    const { colorStops: t, gradientTransform: n } = e;
    return new this(D(D({}, e), {}, { colorStops: t ? t.map((i) => D({}, i)) : void 0, gradientTransform: n ? [...n] : void 0 }));
  }
  static fromElement(e, t, n) {
    const i = Qw(e), s = t._findCenterFromElement();
    return new this(D({ id: e.getAttribute("id") || void 0, type: Jw(e), coords: cR(e, { width: n.viewBoxWidth || n.width, height: n.viewBoxHeight || n.height }), colorStops: aR(e, n.opacity), gradientUnits: i, gradientTransform: Jd(e.getAttribute("gradientTransform") || "") }, i === "pixels" ? { offsetX: t.width / 2 - s.x, offsetY: t.height / 2 - s.y } : { offsetX: 0, offsetY: 0 }));
  }
}
R(Ec, "type", "Gradient"), ne.setClass(Ec, "gradient"), ne.setClass(Ec, "linear"), ne.setClass(Ec, "radial");
const lR = ["type", "source", "patternTransform"];
class Zh {
  get type() {
    return "pattern";
  }
  set type(e) {
    pi("warn", "Setting type has no effect", e);
  }
  constructor(e) {
    R(this, "repeat", "repeat"), R(this, "offsetX", 0), R(this, "offsetY", 0), R(this, "crossOrigin", ""), this.id = mi(), Object.assign(this, e);
  }
  isImageSource() {
    return !!this.source && typeof this.source.src == "string";
  }
  isCanvasSource() {
    return !!this.source && !!this.source.toDataURL;
  }
  sourceToString() {
    return this.isImageSource() ? this.source.src : this.isCanvasSource() ? this.source.toDataURL() : "";
  }
  toLive(e) {
    return this.source && (!this.isImageSource() || this.source.complete && this.source.naturalWidth !== 0 && this.source.naturalHeight !== 0) ? e.createPattern(this.source, this.repeat) : null;
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const { repeat: t, crossOrigin: n } = this;
    return D(D({}, fs(this, e)), {}, { type: "pattern", source: this.sourceToString(), repeat: t, crossOrigin: n, offsetX: ut(this.offsetX, Ue.NUM_FRACTION_DIGITS), offsetY: ut(this.offsetY, Ue.NUM_FRACTION_DIGITS), patternTransform: this.patternTransform ? [...this.patternTransform] : null });
  }
  toSVG(e) {
    let { width: t, height: n } = e;
    const { source: i, repeat: s, id: a } = this, c = Bs(this.offsetX / t, 0), u = Bs(this.offsetY / n, 0), h = s === "repeat-y" || s === "no-repeat" ? 1 + Math.abs(c || 0) : Bs(i.width / t, 0), d = s === "repeat-x" || s === "no-repeat" ? 1 + Math.abs(u || 0) : Bs(i.height / n, 0);
    return ['<pattern id="SVGID_'.concat(a, '" x="').concat(c, '" y="').concat(u, '" width="').concat(h, '" height="').concat(d, '">'), '<image x="0" y="0" width="'.concat(i.width, '" height="').concat(i.height, '" xlink:href="').concat(this.sourceToString(), '"></image>'), "</pattern>", ""].join(`
`);
  }
  static async fromObject(e, t) {
    let { type: n, source: i, patternTransform: s } = e, a = ht(e, lR);
    const c = await Ko(i, D(D({}, t), {}, { crossOrigin: a.crossOrigin }));
    return new this(D(D({}, a), {}, { patternTransform: s && s.slice(0), source: c }));
  }
}
R(Zh, "type", "Pattern"), ne.setClass(Zh), ne.setClass(Zh, "pattern");
const uR = ["path", "left", "top"], hR = ["d"];
class Hi extends rt {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { path: n, left: i, top: s } = t, a = ht(t, uR);
    super(), Object.assign(this, Hi.ownDefaults), this.setOptions(a), this._setPath(e || [], !0), typeof i == "number" && this.set(Ke, i), typeof s == "number" && this.set(vr, s);
  }
  _setPath(e, t) {
    this.path = Vw(Array.isArray(e) ? e : Yw(e)), this.setBoundingBox(t);
  }
  _findCenterFromElement() {
    const e = this._calcBoundsFromPath();
    return new B(e.left + e.width / 2, e.top + e.height / 2);
  }
  _renderPathCommands(e) {
    const t = -this.pathOffset.x, n = -this.pathOffset.y;
    e.beginPath();
    for (const i of this.path) switch (i[0]) {
      case "L":
        e.lineTo(i[1] + t, i[2] + n);
        break;
      case "M":
        e.moveTo(i[1] + t, i[2] + n);
        break;
      case "C":
        e.bezierCurveTo(i[1] + t, i[2] + n, i[3] + t, i[4] + n, i[5] + t, i[6] + n);
        break;
      case "Q":
        e.quadraticCurveTo(i[1] + t, i[2] + n, i[3] + t, i[4] + n);
        break;
      case "Z":
        e.closePath();
    }
  }
  _render(e) {
    this._renderPathCommands(e), this._renderPaintInOrder(e);
  }
  toString() {
    return "#<Path (".concat(this.complexity(), '): { "top": ').concat(this.top, ', "left": ').concat(this.left, " }>");
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return D(D({}, super.toObject(e)), {}, { path: this.path.map((t) => t.slice()) });
  }
  toDatalessObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = this.toObject(e);
    return this.sourcePath && (delete t.path, t.sourcePath = this.sourcePath), t;
  }
  _toSVG() {
    const e = Xw(this.path, Ue.NUM_FRACTION_DIGITS);
    return ["<path ", "COMMON_PARTS", 'd="'.concat(e, `" stroke-linecap="round" />
`)];
  }
  _getOffsetTransform() {
    const e = Ue.NUM_FRACTION_DIGITS;
    return " translate(".concat(ut(-this.pathOffset.x, e), ", ").concat(ut(-this.pathOffset.y, e), ")");
  }
  toClipPathSVG(e) {
    const t = this._getOffsetTransform();
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(), { reviver: e, additionalTransform: t });
  }
  toSVG(e) {
    const t = this._getOffsetTransform();
    return this._createBaseSVGMarkup(this._toSVG(), { reviver: e, additionalTransform: t });
  }
  complexity() {
    return this.path.length;
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(e) {
    const { width: t, height: n, pathOffset: i } = this._calcDimensions();
    this.set({ width: t, height: n, pathOffset: i }), e && this.setPositionByOrigin(i, Pe, Pe);
  }
  _calcBoundsFromPath() {
    const e = [];
    let t = 0, n = 0, i = 0, s = 0;
    for (const a of this.path) switch (a[0]) {
      case "L":
        i = a[1], s = a[2], e.push({ x: t, y: n }, { x: i, y: s });
        break;
      case "M":
        i = a[1], s = a[2], t = i, n = s;
        break;
      case "C":
        e.push(...tf(i, s, a[1], a[2], a[3], a[4], a[5], a[6])), i = a[5], s = a[6];
        break;
      case "Q":
        e.push(...tf(i, s, a[1], a[2], a[1], a[2], a[3], a[4])), i = a[3], s = a[4];
        break;
      case "Z":
        i = t, s = n;
    }
    return Cn(e);
  }
  _calcDimensions() {
    const e = this._calcBoundsFromPath();
    return D(D({}, e), {}, { pathOffset: new B(e.left + e.width / 2, e.top + e.height / 2) });
  }
  static fromObject(e) {
    return this._fromObject(e, { extraParam: "path" });
  }
  static async fromElement(e, t, n) {
    const i = Zn(e, this.ATTRIBUTE_NAMES, n), { d: s } = i;
    return new this(s, D(D(D({}, ht(i, hR)), t), {}, { left: void 0, top: void 0 }));
  }
}
R(Hi, "type", "Path"), R(Hi, "cacheProperties", [...Kn, "path", "fillRule"]), R(Hi, "ATTRIBUTE_NAMES", [...Ei, "d"]), ne.setClass(Hi), ne.setSVGClass(Hi);
const dR = ["left", "top", "radius"], ex = ["radius", "startAngle", "endAngle", "counterClockwise"];
class zn extends rt {
  static getDefaults() {
    return D(D({}, super.getDefaults()), zn.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, zn.ownDefaults), this.setOptions(e);
  }
  _set(e, t) {
    return super._set(e, t), e === "radius" && this.setRadius(t), this;
  }
  _render(e) {
    e.beginPath(), e.arc(0, 0, this.radius, bt(this.startAngle), bt(this.endAngle), this.counterClockwise), this._renderPaintInOrder(e);
  }
  getRadiusX() {
    return this.get("radius") * this.get(ar);
  }
  getRadiusY() {
    return this.get("radius") * this.get(Dr);
  }
  setRadius(e) {
    this.radius = e, this.set({ width: 2 * e, height: 2 * e });
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...ex, ...e]);
  }
  _toSVG() {
    const e = (this.endAngle - this.startAngle) % 360;
    if (e === 0) return ["<circle ", "COMMON_PARTS", 'cx="0" cy="0" ', 'r="', "".concat(this.radius), `" />
`];
    {
      const { radius: t } = this, n = bt(this.startAngle), i = bt(this.endAngle), s = cn(n) * t, a = ln(n) * t, c = cn(i) * t, u = ln(i) * t, h = e > 180 ? 1 : 0, d = this.counterClockwise ? 0 : 1;
      return ['<path d="M '.concat(s, " ").concat(a, " A ").concat(t, " ").concat(t, " 0 ").concat(h, " ").concat(d, " ").concat(c, " ").concat(u, '" '), "COMMON_PARTS", ` />
`];
    }
  }
  static async fromElement(e, t, n) {
    const i = Zn(e, this.ATTRIBUTE_NAMES, n), { left: s = 0, top: a = 0, radius: c = 0 } = i;
    return new this(D(D({}, ht(i, dR)), {}, { radius: c, left: s - c, top: a - c }));
  }
  static fromObject(e) {
    return super._fromObject(e);
  }
}
R(zn, "type", "Circle"), R(zn, "cacheProperties", [...Kn, ...ex]), R(zn, "ownDefaults", { radius: 0, startAngle: 0, endAngle: 360, counterClockwise: !1 }), R(zn, "ATTRIBUTE_NAMES", ["cx", "cy", "r", ...Ei]), ne.setClass(zn), ne.setSVGClass(zn);
const fR = ["x1", "y1", "x2", "y2"], pR = ["x1", "y1", "x2", "y2"], nf = ["x1", "x2", "y1", "y2"];
class Ui extends rt {
  constructor() {
    let [e, t, n, i] = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0, 0], s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, Ui.ownDefaults), this.setOptions(s), this.x1 = e, this.x2 = n, this.y1 = t, this.y2 = i, this._setWidthHeight();
    const { left: a, top: c } = s;
    typeof a == "number" && this.set(Ke, a), typeof c == "number" && this.set(vr, c);
  }
  _setWidthHeight() {
    const { x1: e, y1: t, x2: n, y2: i } = this;
    this.width = Math.abs(n - e), this.height = Math.abs(i - t);
    const { left: s, top: a, width: c, height: u } = Cn([{ x: e, y: t }, { x: n, y: i }]), h = new B(s + c / 2, a + u / 2);
    this.setPositionByOrigin(h, Pe, Pe);
  }
  _set(e, t) {
    return super._set(e, t), nf.includes(e) && this._setWidthHeight(), this;
  }
  _render(e) {
    e.beginPath();
    const t = this.calcLinePoints();
    e.moveTo(t.x1, t.y1), e.lineTo(t.x2, t.y2), e.lineWidth = this.strokeWidth;
    const n = e.strokeStyle;
    var i;
    Yr(this.stroke) ? e.strokeStyle = this.stroke.toLive(e) : e.strokeStyle = (i = this.stroke) !== null && i !== void 0 ? i : e.fillStyle, this.stroke && this._renderStroke(e), e.strokeStyle = n;
  }
  _findCenterFromElement() {
    return new B((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return D(D({}, super.toObject(e)), this.calcLinePoints());
  }
  _getNonTransformedDimensions() {
    const e = super._getNonTransformedDimensions();
    return this.strokeLineCap === "butt" && (this.width === 0 && (e.y -= this.strokeWidth), this.height === 0 && (e.x -= this.strokeWidth)), e;
  }
  calcLinePoints() {
    const { x1: e, x2: t, y1: n, y2: i, width: s, height: a } = this, c = e <= t ? -1 : 1, u = n <= i ? -1 : 1;
    return { x1: c * s / 2, x2: c * -s / 2, y1: u * a / 2, y2: u * -a / 2 };
  }
  _toSVG() {
    const { x1: e, x2: t, y1: n, y2: i } = this.calcLinePoints();
    return ["<line ", "COMMON_PARTS", 'x1="'.concat(e, '" y1="').concat(n, '" x2="').concat(t, '" y2="').concat(i, `" />
`)];
  }
  static async fromElement(e, t, n) {
    const i = Zn(e, this.ATTRIBUTE_NAMES, n), { x1: s = 0, y1: a = 0, x2: c = 0, y2: u = 0 } = i;
    return new this([s, a, c, u], ht(i, fR));
  }
  static fromObject(e) {
    let { x1: t, y1: n, x2: i, y2: s } = e, a = ht(e, pR);
    return this._fromObject(D(D({}, a), {}, { points: [t, n, i, s] }), { extraParam: "points" });
  }
}
R(Ui, "type", "Line"), R(Ui, "cacheProperties", [...Kn, ...nf]), R(Ui, "ATTRIBUTE_NAMES", Ei.concat(nf)), ne.setClass(Ui), ne.setSVGClass(Ui);
class Gi extends rt {
  static getDefaults() {
    return D(D({}, super.getDefaults()), Gi.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, Gi.ownDefaults), this.setOptions(e);
  }
  _render(e) {
    const t = this.width / 2, n = this.height / 2;
    e.beginPath(), e.moveTo(-t, n), e.lineTo(0, -n), e.lineTo(t, n), e.closePath(), this._renderPaintInOrder(e);
  }
  _toSVG() {
    const e = this.width / 2, t = this.height / 2;
    return ["<polygon ", "COMMON_PARTS", 'points="', "".concat(-e, " ").concat(t, ",0 ").concat(-t, ",").concat(e, " ").concat(t), '" />'];
  }
}
R(Gi, "type", "Triangle"), R(Gi, "ownDefaults", { width: 100, height: 100 }), ne.setClass(Gi), ne.setSVGClass(Gi);
const tx = ["rx", "ry"];
class Wn extends rt {
  static getDefaults() {
    return D(D({}, super.getDefaults()), Wn.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, Wn.ownDefaults), this.setOptions(e);
  }
  _set(e, t) {
    switch (super._set(e, t), e) {
      case "rx":
        this.rx = t, this.set("width", 2 * t);
        break;
      case "ry":
        this.ry = t, this.set("height", 2 * t);
    }
    return this;
  }
  getRx() {
    return this.get("rx") * this.get(ar);
  }
  getRy() {
    return this.get("ry") * this.get(Dr);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...tx, ...e]);
  }
  _toSVG() {
    return ["<ellipse ", "COMMON_PARTS", 'cx="0" cy="0" rx="'.concat(this.rx, '" ry="').concat(this.ry, `" />
`)];
  }
  _render(e) {
    e.beginPath(), e.save(), e.transform(1, 0, 0, this.ry / this.rx, 0, 0), e.arc(0, 0, this.rx, 0, qn, !1), e.restore(), this._renderPaintInOrder(e);
  }
  static async fromElement(e, t, n) {
    const i = Zn(e, this.ATTRIBUTE_NAMES, n);
    return i.left = (i.left || 0) - i.rx, i.top = (i.top || 0) - i.ry, new this(i);
  }
}
function gR(r) {
  if (!r) return [];
  const e = r.replace(/,/g, " ").trim().split(/\s+/), t = [];
  for (let n = 0; n < e.length; n += 2) t.push({ x: parseFloat(e[n]), y: parseFloat(e[n + 1]) });
  return t;
}
R(Wn, "type", "Ellipse"), R(Wn, "cacheProperties", [...Kn, ...tx]), R(Wn, "ownDefaults", { rx: 0, ry: 0 }), R(Wn, "ATTRIBUTE_NAMES", [...Ei, "cx", "cy", "rx", "ry"]), ne.setClass(Wn), ne.setSVGClass(Wn);
const mR = ["left", "top"], rx = { exactBoundingBox: !1 };
class nn extends rt {
  static getDefaults() {
    return D(D({}, super.getDefaults()), nn.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), R(this, "strokeDiff", void 0), Object.assign(this, nn.ownDefaults), this.setOptions(t), this.points = e;
    const { left: n, top: i } = t;
    this.initialized = !0, this.setBoundingBox(!0), typeof n == "number" && this.set(Ke, n), typeof i == "number" && this.set(vr, i);
  }
  isOpen() {
    return !0;
  }
  _projectStrokeOnPoints(e) {
    return Mw(this.points, e, this.isOpen());
  }
  _calcDimensions(e) {
    e = D({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, strokeLineCap: this.strokeLineCap, strokeLineJoin: this.strokeLineJoin, strokeMiterLimit: this.strokeMiterLimit, strokeUniform: this.strokeUniform, strokeWidth: this.strokeWidth }, e || {});
    const t = this.exactBoundingBox ? this._projectStrokeOnPoints(e).map((h) => h.projectedPoint) : this.points;
    if (t.length === 0) return { left: 0, top: 0, width: 0, height: 0, pathOffset: new B(), strokeOffset: new B(), strokeDiff: new B() };
    const n = Cn(t), i = xa(D(D({}, e), {}, { scaleX: 1, scaleY: 1 })), s = Cn(this.points.map((h) => qt(h, i, !0))), a = new B(this.scaleX, this.scaleY);
    let c = n.left + n.width / 2, u = n.top + n.height / 2;
    return this.exactBoundingBox && (c -= u * Math.tan(bt(this.skewX)), u -= c * Math.tan(bt(this.skewY))), D(D({}, n), {}, { pathOffset: new B(c, u), strokeOffset: new B(s.left, s.top).subtract(new B(n.left, n.top)).multiply(a), strokeDiff: new B(n.width, n.height).subtract(new B(s.width, s.height)).multiply(a) });
  }
  _findCenterFromElement() {
    const e = Cn(this.points);
    return new B(e.left + e.width / 2, e.top + e.height / 2);
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(e) {
    const { left: t, top: n, width: i, height: s, pathOffset: a, strokeOffset: c, strokeDiff: u } = this._calcDimensions();
    this.set({ width: i, height: s, pathOffset: a, strokeOffset: c, strokeDiff: u }), e && this.setPositionByOrigin(new B(t + i / 2, n + s / 2), Pe, Pe);
  }
  isStrokeAccountedForInDimensions() {
    return this.exactBoundingBox;
  }
  _getNonTransformedDimensions() {
    return this.exactBoundingBox ? new B(this.width, this.height) : super._getNonTransformedDimensions();
  }
  _getTransformedDimensions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this.exactBoundingBox) {
      let a;
      if (Object.keys(e).some((c) => this.strokeUniform || this.constructor.layoutProperties.includes(c))) {
        var t, n;
        const { width: c, height: u } = this._calcDimensions(e);
        a = new B((t = e.width) !== null && t !== void 0 ? t : c, (n = e.height) !== null && n !== void 0 ? n : u);
      } else {
        var i, s;
        a = new B((i = e.width) !== null && i !== void 0 ? i : this.width, (s = e.height) !== null && s !== void 0 ? s : this.height);
      }
      return a.multiply(new B(e.scaleX || this.scaleX, e.scaleY || this.scaleY));
    }
    return super._getTransformedDimensions(e);
  }
  _set(e, t) {
    const n = this.initialized && this[e] !== t, i = super._set(e, t);
    return this.exactBoundingBox && n && ((e === ar || e === Dr) && this.strokeUniform && this.constructor.layoutProperties.includes("strokeUniform") || this.constructor.layoutProperties.includes(e)) && this.setDimensions(), i;
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return D(D({}, super.toObject(e)), {}, { points: this.points.map((t) => {
      let { x: n, y: i } = t;
      return { x: n, y: i };
    }) });
  }
  _toSVG() {
    const e = [], t = this.pathOffset.x, n = this.pathOffset.y, i = Ue.NUM_FRACTION_DIGITS;
    for (let s = 0, a = this.points.length; s < a; s++) e.push(ut(this.points[s].x - t, i), ",", ut(this.points[s].y - n, i), " ");
    return ["<".concat(this.constructor.type.toLowerCase(), " "), "COMMON_PARTS", 'points="'.concat(e.join(""), `" />
`)];
  }
  _render(e) {
    const t = this.points.length, n = this.pathOffset.x, i = this.pathOffset.y;
    if (t && !isNaN(this.points[t - 1].y)) {
      e.beginPath(), e.moveTo(this.points[0].x - n, this.points[0].y - i);
      for (let s = 0; s < t; s++) {
        const a = this.points[s];
        e.lineTo(a.x - n, a.y - i);
      }
      !this.isOpen() && e.closePath(), this._renderPaintInOrder(e);
    }
  }
  complexity() {
    return this.points.length;
  }
  static async fromElement(e, t, n) {
    return new this(gR(e.getAttribute("points")), D(D({}, ht(Zn(e, this.ATTRIBUTE_NAMES, n), mR)), t));
  }
  static fromObject(e) {
    return this._fromObject(e, { extraParam: "points" });
  }
}
R(nn, "ownDefaults", rx), R(nn, "type", "Polyline"), R(nn, "layoutProperties", [lo, uo, "strokeLineCap", "strokeLineJoin", "strokeMiterLimit", "strokeWidth", "strokeUniform", "points"]), R(nn, "cacheProperties", [...Kn, "points"]), R(nn, "ATTRIBUTE_NAMES", [...Ei]), ne.setClass(nn), ne.setSVGClass(nn);
class kc extends nn {
  isOpen() {
    return !1;
  }
}
R(kc, "ownDefaults", rx), R(kc, "type", "Polygon"), ne.setClass(kc), ne.setSVGClass(kc);
const nx = ["fontSize", "fontWeight", "fontFamily", "fontStyle"], ix = ["underline", "overline", "linethrough"], sx = [...nx, "lineHeight", "text", "charSpacing", "textAlign", "styles", "path", "pathStartOffset", "pathSide", "pathAlign"], ox = [...sx, ...ix, "textBackgroundColor", "direction"], vR = [...nx, ...ix, br, "strokeWidth", Lt, "deltaY", "textBackgroundColor"], yR = { _reNewline: Jf, _reSpacesAndTabs: /[ \t\r]/g, _reSpaceAndTab: /[ \t\r]/, _reWords: /\S+/g, fontSize: 40, fontWeight: "normal", fontFamily: "Times New Roman", underline: !1, overline: !1, linethrough: !1, textAlign: Ke, fontStyle: "normal", lineHeight: 1.16, superscript: { size: 0.6, baseline: -0.35 }, subscript: { size: 0.6, baseline: 0.11 }, textBackgroundColor: "", stroke: null, shadow: null, path: void 0, pathStartOffset: 0, pathSide: Ke, pathAlign: "baseline", _fontSizeFraction: 0.222, offsets: { underline: 0.1, linethrough: -0.315, overline: -0.88 }, _fontSizeMult: 1.13, charSpacing: 0, deltaY: 0, direction: "ltr", CACHE_FONT_SIZE: 400, MIN_TEXT_WIDTH: 2 }, bn = "justify", Sl = "justify-left", Zo = "justify-right", Jo = "justify-center";
class ax extends rt {
  isEmptyStyles(e) {
    if (!this.styles || e !== void 0 && !this.styles[e]) return !0;
    const t = e === void 0 ? this.styles : { line: this.styles[e] };
    for (const n in t) for (const i in t[n]) for (const s in t[n][i]) return !1;
    return !0;
  }
  styleHas(e, t) {
    if (!this.styles || t !== void 0 && !this.styles[t]) return !1;
    const n = t === void 0 ? this.styles : { 0: this.styles[t] };
    for (const i in n) for (const s in n[i]) if (n[i][s][e] !== void 0) return !0;
    return !1;
  }
  cleanStyle(e) {
    if (!this.styles) return !1;
    const t = this.styles;
    let n, i, s = 0, a = !0, c = 0;
    for (const u in t) {
      n = 0;
      for (const h in t[u]) {
        const d = t[u][h] || {};
        s++, d[e] !== void 0 ? (i ? d[e] !== i && (a = !1) : i = d[e], d[e] === this[e] && delete d[e]) : a = !1, Object.keys(d).length !== 0 ? n++ : delete t[u][h];
      }
      n === 0 && delete t[u];
    }
    for (let u = 0; u < this._textLines.length; u++) c += this._textLines[u].length;
    a && s === c && (this[e] = i, this.removeStyle(e));
  }
  removeStyle(e) {
    if (!this.styles) return;
    const t = this.styles;
    let n, i, s;
    for (i in t) {
      for (s in n = t[i], n) delete n[s][e], Object.keys(n[s]).length === 0 && delete n[s];
      Object.keys(n).length === 0 && delete t[i];
    }
  }
  _extendStyles(e, t) {
    const { lineIndex: n, charIndex: i } = this.get2DCursorLocation(e);
    this._getLineStyle(n) || this._setLineStyle(n);
    const s = ip(D(D({}, this._getStyleDeclaration(n, i)), t), (a) => a !== void 0);
    this._setStyleDeclaration(n, i, s);
  }
  getSelectionStyles(e, t, n) {
    const i = [];
    for (let s = e; s < (t || e); s++) i.push(this.getStyleAtPosition(s, n));
    return i;
  }
  getStyleAtPosition(e, t) {
    const { lineIndex: n, charIndex: i } = this.get2DCursorLocation(e);
    return t ? this.getCompleteStyleDeclaration(n, i) : this._getStyleDeclaration(n, i);
  }
  setSelectionStyles(e, t, n) {
    for (let i = t; i < (n || t); i++) this._extendStyles(i, e);
    this._forceClearCache = !0;
  }
  _getStyleDeclaration(e, t) {
    var n;
    const i = this.styles && this.styles[e];
    return i && (n = i[t]) !== null && n !== void 0 ? n : {};
  }
  getCompleteStyleDeclaration(e, t) {
    return D(D({}, fs(this, this.constructor._styleProperties)), this._getStyleDeclaration(e, t));
  }
  _setStyleDeclaration(e, t, n) {
    this.styles[e][t] = n;
  }
  _deleteStyleDeclaration(e, t) {
    delete this.styles[e][t];
  }
  _getLineStyle(e) {
    return !!this.styles[e];
  }
  _setLineStyle(e) {
    this.styles[e] = {};
  }
  _deleteLineStyle(e) {
    delete this.styles[e];
  }
}
R(ax, "_styleProperties", vR);
const bR = /  +/g, wR = /"/g;
function Jh(r, e, t, n, i) {
  return "		".concat(function(s, a) {
    let { left: c, top: u, width: h, height: d } = a, p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ue.NUM_FRACTION_DIGITS;
    const g = sa(Lt, s, !1), [v, y, x, _] = [c, u, h, d].map((C) => ut(C, p));
    return "<rect ".concat(g, ' x="').concat(v, '" y="').concat(y, '" width="').concat(x, '" height="').concat(_, '"></rect>');
  }(r, { left: e, top: t, width: n, height: i }), `
`);
}
const xR = ["textAnchor", "textDecoration", "dx", "dy", "top", "left", "fontSize", "strokeWidth"];
let Qh;
class rr extends ax {
  static getDefaults() {
    return D(D({}, super.getDefaults()), rr.ownDefaults);
  }
  constructor(e, t) {
    super(), R(this, "__charBounds", []), Object.assign(this, rr.ownDefaults), this.setOptions(t), this.styles || (this.styles = {}), this.text = e, this.initialized = !0, this.path && this.setPathInfo(), this.initDimensions(), this.setCoords();
  }
  setPathInfo() {
    const e = this.path;
    e && (e.segmentsInfo = vp(e.path));
  }
  _splitText() {
    const e = this._splitTextIntoLines(this.text);
    return this.textLines = e.lines, this._textLines = e.graphemeLines, this._unwrappedTextLines = e._unwrappedLines, this._text = e.graphemeText, e;
  }
  initDimensions() {
    this._splitText(), this._clearCache(), this.dirty = !0, this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), this.textAlign.includes(bn) && this.enlargeSpaces();
  }
  enlargeSpaces() {
    let e, t, n, i, s, a, c;
    for (let u = 0, h = this._textLines.length; u < h; u++) if ((this.textAlign === bn || u !== h - 1 && !this.isEndOfWrapping(u)) && (i = 0, s = this._textLines[u], t = this.getLineWidth(u), t < this.width && (c = this.textLines[u].match(this._reSpacesAndTabs)))) {
      n = c.length, e = (this.width - t) / n;
      for (let d = 0; d <= s.length; d++) a = this.__charBounds[u][d], this._reSpaceAndTab.test(s[d]) ? (a.width += e, a.kernedWidth += e, a.left += i, i += e) : a.left += i;
    }
  }
  isEndOfWrapping(e) {
    return e === this._textLines.length - 1;
  }
  missingNewlineOffset(e) {
    return 1;
  }
  get2DCursorLocation(e, t) {
    const n = t ? this._unwrappedTextLines : this._textLines;
    let i;
    for (i = 0; i < n.length; i++) {
      if (e <= n[i].length) return { lineIndex: i, charIndex: e };
      e -= n[i].length + this.missingNewlineOffset(i, t);
    }
    return { lineIndex: i - 1, charIndex: n[i - 1].length < e ? n[i - 1].length : e };
  }
  toString() {
    return "#<Text (".concat(this.complexity(), '): { "text": "').concat(this.text, '", "fontFamily": "').concat(this.fontFamily, '" }>');
  }
  _getCacheCanvasDimensions() {
    const e = super._getCacheCanvasDimensions(), t = this.fontSize;
    return e.width += t * e.zoomX, e.height += t * e.zoomY, e;
  }
  _render(e) {
    const t = this.path;
    t && !t.isNotVisible() && t._render(e), this._setTextStyles(e), this._renderTextLinesBackground(e), this._renderTextDecoration(e, "underline"), this._renderText(e), this._renderTextDecoration(e, "overline"), this._renderTextDecoration(e, "linethrough");
  }
  _renderText(e) {
    this.paintFirst === br ? (this._renderTextStroke(e), this._renderTextFill(e)) : (this._renderTextFill(e), this._renderTextStroke(e));
  }
  _setTextStyles(e, t, n) {
    if (e.textBaseline = "alphabetic", this.path) switch (this.pathAlign) {
      case Pe:
        e.textBaseline = "middle";
        break;
      case "ascender":
        e.textBaseline = vr;
        break;
      case "descender":
        e.textBaseline = Hd;
    }
    e.font = this._getFontDeclaration(t, n);
  }
  calcTextWidth() {
    let e = this.getLineWidth(0);
    for (let t = 1, n = this._textLines.length; t < n; t++) {
      const i = this.getLineWidth(t);
      i > e && (e = i);
    }
    return e;
  }
  _renderTextLine(e, t, n, i, s, a) {
    this._renderChars(e, t, n, i, s, a);
  }
  _renderTextLinesBackground(e) {
    if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor")) return;
    const t = e.fillStyle, n = this._getLeftOffset();
    let i = this._getTopOffset();
    for (let s = 0, a = this._textLines.length; s < a; s++) {
      const c = this.getHeightOfLine(s);
      if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor", s)) {
        i += c;
        continue;
      }
      const u = this._textLines[s].length, h = this._getLineLeftOffset(s);
      let d, p, g = 0, v = 0, y = this.getValueOfPropertyAt(s, 0, "textBackgroundColor");
      for (let x = 0; x < u; x++) {
        const _ = this.__charBounds[s][x];
        p = this.getValueOfPropertyAt(s, x, "textBackgroundColor"), this.path ? (e.save(), e.translate(_.renderLeft, _.renderTop), e.rotate(_.angle), e.fillStyle = p, p && e.fillRect(-_.width / 2, -c / this.lineHeight * (1 - this._fontSizeFraction), _.width, c / this.lineHeight), e.restore()) : p !== y ? (d = n + h + v, this.direction === "rtl" && (d = this.width - d - g), e.fillStyle = y, y && e.fillRect(d, i, g, c / this.lineHeight), v = _.left, g = _.width, y = p) : g += _.kernedWidth;
      }
      p && !this.path && (d = n + h + v, this.direction === "rtl" && (d = this.width - d - g), e.fillStyle = p, e.fillRect(d, i, g, c / this.lineHeight)), i += c;
    }
    e.fillStyle = t, this._removeShadow(e);
  }
  _measureChar(e, t, n, i) {
    const s = Go.getFontCache(t), a = this._getFontDeclaration(t), c = n + e, u = n && a === this._getFontDeclaration(i), h = t.fontSize / this.CACHE_FONT_SIZE;
    let d, p, g, v;
    if (n && s[n] !== void 0 && (g = s[n]), s[e] !== void 0 && (v = d = s[e]), u && s[c] !== void 0 && (p = s[c], v = p - g), d === void 0 || g === void 0 || p === void 0) {
      const y = function() {
        return Qh || (Qh = un({ width: 0, height: 0 }).getContext("2d")), Qh;
      }();
      this._setTextStyles(y, t, !0), d === void 0 && (v = d = y.measureText(e).width, s[e] = d), g === void 0 && u && n && (g = y.measureText(n).width, s[n] = g), u && p === void 0 && (p = y.measureText(c).width, s[c] = p, v = p - g);
    }
    return { width: d * h, kernedWidth: v * h };
  }
  getHeightOfChar(e, t) {
    return this.getValueOfPropertyAt(e, t, "fontSize");
  }
  measureLine(e) {
    const t = this._measureLine(e);
    return this.charSpacing !== 0 && (t.width -= this._getWidthOfCharSpacing()), t.width < 0 && (t.width = 0), t;
  }
  _measureLine(e) {
    let t, n, i = 0;
    const s = this.pathSide === Ct, a = this.path, c = this._textLines[e], u = c.length, h = new Array(u);
    this.__charBounds[e] = h;
    for (let d = 0; d < u; d++) {
      const p = c[d];
      n = this._getGraphemeBox(p, e, d, t), h[d] = n, i += n.kernedWidth, t = p;
    }
    if (h[u] = { left: n ? n.left + n.width : 0, width: 0, kernedWidth: 0, height: this.fontSize, deltaY: 0 }, a && a.segmentsInfo) {
      let d = 0;
      const p = a.segmentsInfo[a.segmentsInfo.length - 1].length;
      switch (this.textAlign) {
        case Ke:
          d = s ? p - i : 0;
          break;
        case Pe:
          d = (p - i) / 2;
          break;
        case Ct:
          d = s ? 0 : p - i;
      }
      d += this.pathStartOffset * (s ? -1 : 1);
      for (let g = s ? u - 1 : 0; s ? g >= 0 : g < u; s ? g-- : g++) n = h[g], d > p ? d %= p : d < 0 && (d += p), this._setGraphemeOnPath(d, n), d += n.kernedWidth;
    }
    return { width: i, numOfSpaces: 0 };
  }
  _setGraphemeOnPath(e, t) {
    const n = e + t.kernedWidth / 2, i = this.path, s = $w(i.path, n, i.segmentsInfo);
    t.renderLeft = s.x - i.pathOffset.x, t.renderTop = s.y - i.pathOffset.y, t.angle = s.angle + (this.pathSide === Ct ? Math.PI : 0);
  }
  _getGraphemeBox(e, t, n, i, s) {
    const a = this.getCompleteStyleDeclaration(t, n), c = i ? this.getCompleteStyleDeclaration(t, n - 1) : {}, u = this._measureChar(e, a, i, c);
    let h, d = u.kernedWidth, p = u.width;
    this.charSpacing !== 0 && (h = this._getWidthOfCharSpacing(), p += h, d += h);
    const g = { width: p, left: 0, height: a.fontSize, kernedWidth: d, deltaY: a.deltaY };
    if (n > 0 && !s) {
      const v = this.__charBounds[t][n - 1];
      g.left = v.left + v.width + u.kernedWidth - u.width;
    }
    return g;
  }
  getHeightOfLine(e) {
    if (this.__lineHeights[e]) return this.__lineHeights[e];
    let t = this.getHeightOfChar(e, 0);
    for (let n = 1, i = this._textLines[e].length; n < i; n++) t = Math.max(this.getHeightOfChar(e, n), t);
    return this.__lineHeights[e] = t * this.lineHeight * this._fontSizeMult;
  }
  calcTextHeight() {
    let e, t = 0;
    for (let n = 0, i = this._textLines.length; n < i; n++) e = this.getHeightOfLine(n), t += n === i - 1 ? e / this.lineHeight : e;
    return t;
  }
  _getLeftOffset() {
    return this.direction === "ltr" ? -this.width / 2 : this.width / 2;
  }
  _getTopOffset() {
    return -this.height / 2;
  }
  _renderTextCommon(e, t) {
    e.save();
    let n = 0;
    const i = this._getLeftOffset(), s = this._getTopOffset();
    for (let a = 0, c = this._textLines.length; a < c; a++) {
      const u = this.getHeightOfLine(a), h = u / this.lineHeight, d = this._getLineLeftOffset(a);
      this._renderTextLine(t, e, this._textLines[a], i + d, s + n + h, a), n += u;
    }
    e.restore();
  }
  _renderTextFill(e) {
    (this.fill || this.styleHas(Lt)) && this._renderTextCommon(e, "fillText");
  }
  _renderTextStroke(e) {
    (this.stroke && this.strokeWidth !== 0 || !this.isEmptyStyles()) && (this.shadow && !this.shadow.affectStroke && this._removeShadow(e), e.save(), this._setLineDash(e, this.strokeDashArray), e.beginPath(), this._renderTextCommon(e, "strokeText"), e.closePath(), e.restore());
  }
  _renderChars(e, t, n, i, s, a) {
    const c = this.getHeightOfLine(a), u = this.textAlign.includes(bn), h = this.path, d = !u && this.charSpacing === 0 && this.isEmptyStyles(a) && !h, p = this.direction === "ltr", g = this.direction === "ltr" ? 1 : -1, v = t.direction;
    let y, x, _, C, E, k = "", O = 0;
    if (t.save(), v !== this.direction && (t.canvas.setAttribute("dir", p ? "ltr" : "rtl"), t.direction = p ? "ltr" : "rtl", t.textAlign = p ? Ke : Ct), s -= c * this._fontSizeFraction / this.lineHeight, d) return this._renderChar(e, t, a, 0, n.join(""), i, s), void t.restore();
    for (let P = 0, j = n.length - 1; P <= j; P++) C = P === j || this.charSpacing || h, k += n[P], _ = this.__charBounds[a][P], O === 0 ? (i += g * (_.kernedWidth - _.width), O += _.width) : O += _.kernedWidth, u && !C && this._reSpaceAndTab.test(n[P]) && (C = !0), C || (y = y || this.getCompleteStyleDeclaration(a, P), x = this.getCompleteStyleDeclaration(a, P + 1), C = uu(y, x, !1)), C && (h ? (t.save(), t.translate(_.renderLeft, _.renderTop), t.rotate(_.angle), this._renderChar(e, t, a, P, k, -O / 2, 0), t.restore()) : (E = i, this._renderChar(e, t, a, P, k, E, s)), k = "", y = x, i += g * O, O = 0);
    t.restore();
  }
  _applyPatternGradientTransformText(e) {
    const t = this.width + this.strokeWidth, n = this.height + this.strokeWidth, i = un({ width: t, height: n }), s = i.getContext("2d");
    return i.width = t, i.height = n, s.beginPath(), s.moveTo(0, 0), s.lineTo(t, 0), s.lineTo(t, n), s.lineTo(0, n), s.closePath(), s.translate(t / 2, n / 2), s.fillStyle = e.toLive(s), this._applyPatternGradientTransform(s, e), s.fill(), s.createPattern(i, "no-repeat");
  }
  handleFiller(e, t, n) {
    let i, s;
    return Yr(n) ? n.gradientUnits === "percentage" || n.gradientTransform || n.patternTransform ? (i = -this.width / 2, s = -this.height / 2, e.translate(i, s), e[t] = this._applyPatternGradientTransformText(n), { offsetX: i, offsetY: s }) : (e[t] = n.toLive(e), this._applyPatternGradientTransform(e, n)) : (e[t] = n, { offsetX: 0, offsetY: 0 });
  }
  _setStrokeStyles(e, t) {
    let { stroke: n, strokeWidth: i } = t;
    return e.lineWidth = i, e.lineCap = this.strokeLineCap, e.lineDashOffset = this.strokeDashOffset, e.lineJoin = this.strokeLineJoin, e.miterLimit = this.strokeMiterLimit, this.handleFiller(e, "strokeStyle", n);
  }
  _setFillStyles(e, t) {
    let { fill: n } = t;
    return this.handleFiller(e, "fillStyle", n);
  }
  _renderChar(e, t, n, i, s, a, c) {
    const u = this._getStyleDeclaration(n, i), h = this.getCompleteStyleDeclaration(n, i), d = e === "fillText" && h.fill, p = e === "strokeText" && h.stroke && h.strokeWidth;
    if (p || d) {
      if (t.save(), t.font = this._getFontDeclaration(h), u.textBackgroundColor && this._removeShadow(t), u.deltaY && (c += u.deltaY), d) {
        const g = this._setFillStyles(t, h);
        t.fillText(s, a - g.offsetX, c - g.offsetY);
      }
      if (p) {
        const g = this._setStrokeStyles(t, h);
        t.strokeText(s, a - g.offsetX, c - g.offsetY);
      }
      t.restore();
    }
  }
  setSuperscript(e, t) {
    this._setScript(e, t, this.superscript);
  }
  setSubscript(e, t) {
    this._setScript(e, t, this.subscript);
  }
  _setScript(e, t, n) {
    const i = this.get2DCursorLocation(e, !0), s = this.getValueOfPropertyAt(i.lineIndex, i.charIndex, "fontSize"), a = this.getValueOfPropertyAt(i.lineIndex, i.charIndex, "deltaY"), c = { fontSize: s * n.size, deltaY: a + s * n.baseline };
    this.setSelectionStyles(c, e, t);
  }
  _getLineLeftOffset(e) {
    const t = this.getLineWidth(e), n = this.width - t, i = this.textAlign, s = this.direction, a = this.isEndOfWrapping(e);
    let c = 0;
    return i === bn || i === Jo && !a || i === Zo && !a || i === Sl && !a ? 0 : (i === Pe && (c = n / 2), i === Ct && (c = n), i === Jo && (c = n / 2), i === Zo && (c = n), s === "rtl" && (i === Ct || i === bn || i === Zo ? c = 0 : i === Ke || i === Sl ? c = -n : i !== Pe && i !== Jo || (c = -n / 2)), c);
  }
  _clearCache() {
    this._forceClearCache = !1, this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [];
  }
  getLineWidth(e) {
    if (this.__lineWidths[e] !== void 0) return this.__lineWidths[e];
    const { width: t } = this.measureLine(e);
    return this.__lineWidths[e] = t, t;
  }
  _getWidthOfCharSpacing() {
    return this.charSpacing !== 0 ? this.fontSize * this.charSpacing / 1e3 : 0;
  }
  getValueOfPropertyAt(e, t, n) {
    var i;
    return (i = this._getStyleDeclaration(e, t)[n]) !== null && i !== void 0 ? i : this[n];
  }
  _renderTextDecoration(e, t) {
    if (!this[t] && !this.styleHas(t)) return;
    let n = this._getTopOffset();
    const i = this._getLeftOffset(), s = this.path, a = this._getWidthOfCharSpacing(), c = this.offsets[t];
    for (let u = 0, h = this._textLines.length; u < h; u++) {
      const d = this.getHeightOfLine(u);
      if (!this[t] && !this.styleHas(t, u)) {
        n += d;
        continue;
      }
      const p = this._textLines[u], g = d / this.lineHeight, v = this._getLineLeftOffset(u);
      let y, x, _ = 0, C = 0, E = this.getValueOfPropertyAt(u, 0, t), k = this.getValueOfPropertyAt(u, 0, Lt);
      const O = n + g * (1 - this._fontSizeFraction);
      let P = this.getHeightOfChar(u, 0), j = this.getValueOfPropertyAt(u, 0, "deltaY");
      for (let F = 0, $ = p.length; F < $; F++) {
        const z = this.__charBounds[u][F];
        y = this.getValueOfPropertyAt(u, F, t), x = this.getValueOfPropertyAt(u, F, Lt);
        const G = this.getHeightOfChar(u, F), H = this.getValueOfPropertyAt(u, F, "deltaY");
        if (s && y && x) e.save(), e.fillStyle = k, e.translate(z.renderLeft, z.renderTop), e.rotate(z.angle), e.fillRect(-z.kernedWidth / 2, c * G + H, z.kernedWidth, this.fontSize / 15), e.restore();
        else if ((y !== E || x !== k || G !== P || H !== j) && C > 0) {
          let Y = i + v + _;
          this.direction === "rtl" && (Y = this.width - Y - C), E && k && (e.fillStyle = k, e.fillRect(Y, O + c * P + j, C, this.fontSize / 15)), _ = z.left, C = z.width, E = y, k = x, P = G, j = H;
        } else C += z.kernedWidth;
      }
      let V = i + v + _;
      this.direction === "rtl" && (V = this.width - V - C), e.fillStyle = x, y && x && e.fillRect(V, O + c * P + j, C - a, this.fontSize / 15), n += d;
    }
    this._removeShadow(e);
  }
  _getFontDeclaration() {
    let { fontFamily: e = this.fontFamily, fontStyle: t = this.fontStyle, fontWeight: n = this.fontWeight, fontSize: i = this.fontSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = arguments.length > 1 ? arguments[1] : void 0;
    const a = e.includes("'") || e.includes('"') || e.includes(",") || rr.genericFonts.includes(e.toLowerCase()) ? e : '"'.concat(e, '"');
    return [t, n, "".concat(s ? this.CACHE_FONT_SIZE : i, "px"), a].join(" ");
  }
  render(e) {
    this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._forceClearCache && this.initDimensions(), super.render(e)));
  }
  graphemeSplit(e) {
    return lu(e);
  }
  _splitTextIntoLines(e) {
    const t = e.split(this._reNewline), n = new Array(t.length), i = [`
`];
    let s = [];
    for (let a = 0; a < t.length; a++) n[a] = this.graphemeSplit(t[a]), s = s.concat(n[a], i);
    return s.pop(), { _unwrappedLines: n, lines: t, graphemeText: s, graphemeLines: n };
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return D(D({}, super.toObject([...ox, ...e])), {}, { styles: Dw(this.styles, this.text) }, this.path ? { path: this.path.toObject() } : {});
  }
  set(e, t) {
    const { textLayoutProperties: n } = this.constructor;
    super.set(e, t);
    let i = !1, s = !1;
    if (typeof e == "object") for (const a in e) a === "path" && this.setPathInfo(), i = i || n.includes(a), s = s || a === "path";
    else i = n.includes(e), s = e === "path";
    return s && this.setPathInfo(), i && this.initialized && (this.initDimensions(), this.setCoords()), this;
  }
  complexity() {
    return 1;
  }
  static async fromElement(e, t, n) {
    const i = Zn(e, rr.ATTRIBUTE_NAMES, n), s = D(D({}, t), i), { textAnchor: a = Ke, textDecoration: c = "", dx: u = 0, dy: h = 0, top: d = 0, left: p = 0, fontSize: g = Zf, strokeWidth: v = 1 } = s, y = ht(s, xR), x = new this((e.textContent || "").replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " "), D({ left: p + u, top: d + h, underline: c.includes("underline"), overline: c.includes("overline"), linethrough: c.includes("line-through"), strokeWidth: 0, fontSize: g }, y)), _ = x.getScaledHeight() / x.height, C = ((x.height + x.strokeWidth) * x.lineHeight - x.height) * _, E = x.getScaledHeight() + C;
    let k = 0;
    return a === Pe && (k = x.getScaledWidth() / 2), a === Ct && (k = x.getScaledWidth()), x.set({ left: x.left - k, top: x.top - (E - x.fontSize * (0.07 + x._fontSizeFraction)) / x.lineHeight, strokeWidth: v }), x;
  }
  static fromObject(e) {
    return this._fromObject(D(D({}, e), {}, { styles: Rw(e.styles || {}, e.text) }), { extraParam: "text" });
  }
}
R(rr, "textLayoutProperties", sx), R(rr, "cacheProperties", [...Kn, ...ox]), R(rr, "ownDefaults", yR), R(rr, "type", "Text"), R(rr, "genericFonts", ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]), R(rr, "ATTRIBUTE_NAMES", Ei.concat("x", "y", "dx", "dy", "font-family", "font-style", "font-weight", "font-size", "letter-spacing", "text-decoration", "text-anchor")), Ow(rr, [class extends cw {
  _toSVG() {
    const r = this._getSVGLeftTopOffsets(), e = this._getSVGTextAndBg(r.textTop, r.textLeft);
    return this._wrapSVGTextAndBg(e);
  }
  toSVG(r) {
    return this._createBaseSVGMarkup(this._toSVG(), { reviver: r, noStyle: !0, withShadow: !0 });
  }
  _getSVGLeftTopOffsets() {
    return { textLeft: -this.width / 2, textTop: -this.height / 2, lineTop: this.getHeightOfLine(0) };
  }
  _wrapSVGTextAndBg(r) {
    let { textBgRects: e, textSpans: t } = r;
    const n = this.getSvgTextDecoration(this);
    return [e.join(""), '		<text xml:space="preserve" ', this.fontFamily ? 'font-family="'.concat(this.fontFamily.replace(wR, "'"), '" ') : "", this.fontSize ? 'font-size="'.concat(this.fontSize, '" ') : "", this.fontStyle ? 'font-style="'.concat(this.fontStyle, '" ') : "", this.fontWeight ? 'font-weight="'.concat(this.fontWeight, '" ') : "", n ? 'text-decoration="'.concat(n, '" ') : "", this.direction === "rtl" ? 'direction="'.concat(this.direction, '" ') : "", 'style="', this.getSvgStyles(!0), '"', this.addPaintOrder(), " >", t.join(""), `</text>
`];
  }
  _getSVGTextAndBg(r, e) {
    const t = [], n = [];
    let i, s = r;
    this.backgroundColor && n.push(...Jh(this.backgroundColor, -this.width / 2, -this.height / 2, this.width, this.height));
    for (let a = 0, c = this._textLines.length; a < c; a++) i = this._getLineLeftOffset(a), this.direction === "rtl" && (i += this.width), (this.textBackgroundColor || this.styleHas("textBackgroundColor", a)) && this._setSVGTextLineBg(n, a, e + i, s), this._setSVGTextLineText(t, a, e + i, s), s += this.getHeightOfLine(a);
    return { textSpans: t, textBgRects: n };
  }
  _createTextCharSpan(r, e, t, n) {
    const i = this.getSvgSpanStyles(e, r !== r.trim() || !!r.match(bR)), s = i ? 'style="'.concat(i, '"') : "", a = e.deltaY, c = a ? ' dy="'.concat(ut(a, Ue.NUM_FRACTION_DIGITS), '" ') : "";
    return '<tspan x="'.concat(ut(t, Ue.NUM_FRACTION_DIGITS), '" y="').concat(ut(n, Ue.NUM_FRACTION_DIGITS), '" ').concat(c).concat(s, ">").concat(Pw(r), "</tspan>");
  }
  _setSVGTextLineText(r, e, t, n) {
    const i = this.getHeightOfLine(e), s = this.textAlign.includes(bn), a = this._textLines[e];
    let c, u, h, d, p, g = "", v = 0;
    n += i * (1 - this._fontSizeFraction) / this.lineHeight;
    for (let y = 0, x = a.length - 1; y <= x; y++) p = y === x || this.charSpacing, g += a[y], h = this.__charBounds[e][y], v === 0 ? (t += h.kernedWidth - h.width, v += h.width) : v += h.kernedWidth, s && !p && this._reSpaceAndTab.test(a[y]) && (p = !0), p || (c = c || this.getCompleteStyleDeclaration(e, y), u = this.getCompleteStyleDeclaration(e, y + 1), p = uu(c, u, !0)), p && (d = this._getStyleDeclaration(e, y), r.push(this._createTextCharSpan(g, d, t, n)), g = "", c = u, this.direction === "rtl" ? t -= v : t += v, v = 0);
  }
  _setSVGTextLineBg(r, e, t, n) {
    const i = this._textLines[e], s = this.getHeightOfLine(e) / this.lineHeight;
    let a, c = 0, u = 0, h = this.getValueOfPropertyAt(e, 0, "textBackgroundColor");
    for (let d = 0; d < i.length; d++) {
      const { left: p, width: g, kernedWidth: v } = this.__charBounds[e][d];
      a = this.getValueOfPropertyAt(e, d, "textBackgroundColor"), a !== h ? (h && r.push(...Jh(h, t + u, n, c, s)), u = p, c = g, h = a) : c += v;
    }
    a && r.push(...Jh(h, t + u, n, c, s));
  }
  _getSVGLineTopOffset(r) {
    let e, t = 0;
    for (e = 0; e < r; e++) t += this.getHeightOfLine(e);
    const n = this.getHeightOfLine(e);
    return { lineTop: t, offset: (this._fontSizeMult - this._fontSizeFraction) * n / (this.lineHeight * this._fontSizeMult) };
  }
  getSvgStyles(r) {
    return "".concat(super.getSvgStyles(r), " white-space: pre;");
  }
  getSvgSpanStyles(r, e) {
    const { fontFamily: t, strokeWidth: n, stroke: i, fill: s, fontSize: a, fontStyle: c, fontWeight: u, deltaY: h } = r, d = this.getSvgTextDecoration(r);
    return [i ? sa(br, i) : "", n ? "stroke-width: ".concat(n, "; ") : "", t ? "font-family: ".concat(t.includes("'") || t.includes('"') ? t : "'".concat(t, "'"), "; ") : "", a ? "font-size: ".concat(a, "px; ") : "", c ? "font-style: ".concat(c, "; ") : "", u ? "font-weight: ".concat(u, "; ") : "", d && "text-decoration: ".concat(d, "; "), s ? sa(Lt, s) : "", h ? "baseline-shift: ".concat(-h, "; ") : "", e ? "white-space: pre; " : ""].join("");
  }
  getSvgTextDecoration(r) {
    return ["overline", "underline", "line-through"].filter((e) => r[e.replace("-", "")]).join(" ");
  }
}]), ne.setClass(rr), ne.setSVGClass(rr);
class _R {
  constructor(e) {
    R(this, "target", void 0), R(this, "__mouseDownInPlace", !1), R(this, "__dragStartFired", !1), R(this, "__isDraggingOver", !1), R(this, "__dragStartSelection", void 0), R(this, "__dragImageDisposer", void 0), R(this, "_dispose", void 0), this.target = e;
    const t = [this.target.on("dragenter", this.dragEnterHandler.bind(this)), this.target.on("dragover", this.dragOverHandler.bind(this)), this.target.on("dragleave", this.dragLeaveHandler.bind(this)), this.target.on("dragend", this.dragEndHandler.bind(this)), this.target.on("drop", this.dropHandler.bind(this))];
    this._dispose = () => {
      t.forEach((n) => n()), this._dispose = void 0;
    };
  }
  isPointerOverSelection(e) {
    const t = this.target, n = t.getSelectionStartFromPointer(e);
    return t.isEditing && n >= t.selectionStart && n <= t.selectionEnd && t.selectionStart < t.selectionEnd;
  }
  start(e) {
    return this.__mouseDownInPlace = this.isPointerOverSelection(e);
  }
  isActive() {
    return this.__mouseDownInPlace;
  }
  end(e) {
    const t = this.isActive();
    return t && !this.__dragStartFired && (this.target.setCursorByClick(e), this.target.initDelayedCursor(!0)), this.__mouseDownInPlace = !1, this.__dragStartFired = !1, this.__isDraggingOver = !1, t;
  }
  getDragStartSelection() {
    return this.__dragStartSelection;
  }
  setDragImage(e, t) {
    var n;
    let { selectionStart: i, selectionEnd: s } = t;
    const a = this.target, c = a.canvas, u = new B(a.flipX ? -1 : 1, a.flipY ? -1 : 1), h = a._getCursorBoundaries(i), d = new B(h.left + h.leftOffset, h.top + h.topOffset).multiply(u).transform(a.calcTransformMatrix()), p = c.getScenePoint(e).subtract(d), g = a.getCanvasRetinaScaling(), v = a.getBoundingRect(), y = d.subtract(new B(v.left, v.top)), x = c.viewportTransform, _ = y.add(p).transform(x, !0), C = a.backgroundColor, E = pp(a.styles);
    a.backgroundColor = "";
    const k = { stroke: "transparent", fill: "transparent", textBackgroundColor: "transparent" };
    a.setSelectionStyles(k, 0, i), a.setSelectionStyles(k, s, a.text.length), a.dirty = !0;
    const O = a.toCanvasElement({ enableRetinaScaling: c.enableRetinaScaling, viewportTransform: !0 });
    a.backgroundColor = C, a.styles = E, a.dirty = !0, _l(O, { position: "fixed", left: "".concat(-O.width, "px"), border: yr, width: "".concat(O.width / g, "px"), height: "".concat(O.height / g, "px") }), this.__dragImageDisposer && this.__dragImageDisposer(), this.__dragImageDisposer = () => {
      O.remove();
    }, sn(e.target || this.target.hiddenTextarea).body.appendChild(O), (n = e.dataTransfer) === null || n === void 0 || n.setDragImage(O, _.x, _.y);
  }
  onDragStart(e) {
    this.__dragStartFired = !0;
    const t = this.target, n = this.isActive();
    if (n && e.dataTransfer) {
      const i = this.__dragStartSelection = { selectionStart: t.selectionStart, selectionEnd: t.selectionEnd }, s = t._text.slice(i.selectionStart, i.selectionEnd).join(""), a = D({ text: t.text, value: s }, i);
      e.dataTransfer.setData("text/plain", s), e.dataTransfer.setData("application/fabric", JSON.stringify({ value: s, styles: t.getSelectionStyles(i.selectionStart, i.selectionEnd, !0) })), e.dataTransfer.effectAllowed = "copyMove", this.setDragImage(e, a);
    }
    return t.abortCursorAnimation(), n;
  }
  canDrop(e) {
    if (this.target.editable && !this.target.getActiveControl() && !e.defaultPrevented) {
      if (this.isActive() && this.__dragStartSelection) {
        const t = this.target.getSelectionStartFromPointer(e), n = this.__dragStartSelection;
        return t < n.selectionStart || t > n.selectionEnd;
      }
      return !0;
    }
    return !1;
  }
  targetCanDrop(e) {
    return this.target.canDrop(e);
  }
  dragEnterHandler(e) {
    let { e: t } = e;
    const n = this.targetCanDrop(t);
    !this.__isDraggingOver && n && (this.__isDraggingOver = !0);
  }
  dragOverHandler(e) {
    const { e: t } = e, n = this.targetCanDrop(t);
    !this.__isDraggingOver && n ? this.__isDraggingOver = !0 : this.__isDraggingOver && !n && (this.__isDraggingOver = !1), this.__isDraggingOver && (t.preventDefault(), e.canDrop = !0, e.dropTarget = this.target);
  }
  dragLeaveHandler() {
    (this.__isDraggingOver || this.isActive()) && (this.__isDraggingOver = !1);
  }
  dropHandler(e) {
    var t;
    const { e: n } = e, i = n.defaultPrevented;
    this.__isDraggingOver = !1, n.preventDefault();
    let s = (t = n.dataTransfer) === null || t === void 0 ? void 0 : t.getData("text/plain");
    if (s && !i) {
      const a = this.target, c = a.canvas;
      let u = a.getSelectionStartFromPointer(n);
      const { styles: h } = n.dataTransfer.types.includes("application/fabric") ? JSON.parse(n.dataTransfer.getData("application/fabric")) : {}, d = s[Math.max(0, s.length - 1)], p = 0;
      if (this.__dragStartSelection) {
        const g = this.__dragStartSelection.selectionStart, v = this.__dragStartSelection.selectionEnd;
        u > g && u <= v ? u = g : u > v && (u -= v - g), a.removeChars(g, v), delete this.__dragStartSelection;
      }
      a._reNewline.test(d) && (a._reNewline.test(a._text[u]) || u === a._text.length) && (s = s.trimEnd()), e.didDrop = !0, e.dropTarget = a, a.insertChars(s, h, u), c.setActiveObject(a), a.enterEditing(n), a.selectionStart = Math.min(u + p, a._text.length), a.selectionEnd = Math.min(a.selectionStart + s.length, a._text.length), a.hiddenTextarea.value = a.text, a._updateTextarea(), a.hiddenTextarea.focus(), a.fire(hl, { index: u + p, action: "drop" }), c.fire("text:changed", { target: a }), c.contextTopDirty = !0, c.requestRenderAll();
    }
  }
  dragEndHandler(e) {
    let { e: t } = e;
    if (this.isActive() && this.__dragStartFired && this.__dragStartSelection) {
      var n;
      const i = this.target, s = this.target.canvas, { selectionStart: a, selectionEnd: c } = this.__dragStartSelection, u = ((n = t.dataTransfer) === null || n === void 0 ? void 0 : n.dropEffect) || yr;
      u === yr ? (i.selectionStart = a, i.selectionEnd = c, i._updateTextarea(), i.hiddenTextarea.focus()) : (i.clearContextTop(), u === "move" && (i.removeChars(a, c), i.selectionStart = i.selectionEnd = a, i.hiddenTextarea && (i.hiddenTextarea.value = i.text), i._updateTextarea(), i.fire(hl, { index: a, action: "dragend" }), s.fire("text:changed", { target: i }), s.requestRenderAll()), i.exitEditing());
    }
    this.__dragImageDisposer && this.__dragImageDisposer(), delete this.__dragImageDisposer, delete this.__dragStartSelection, this.__isDraggingOver = !1;
  }
  dispose() {
    this._dispose && this._dispose();
  }
}
const j0 = /[ \n\.,;!\?\-]/;
class SR extends rr {
  constructor() {
    super(...arguments), R(this, "_currentCursorOpacity", 1);
  }
  initBehavior() {
    this._tick = this._tick.bind(this), this._onTickComplete = this._onTickComplete.bind(this), this.updateSelectionOnMouseMove = this.updateSelectionOnMouseMove.bind(this);
  }
  onDeselect(e) {
    return this.isEditing && this.exitEditing(), this.selected = !1, super.onDeselect(e);
  }
  _animateCursor(e) {
    let { toValue: t, duration: n, delay: i, onComplete: s } = e;
    return hp({ startValue: this._currentCursorOpacity, endValue: t, duration: n, delay: i, onComplete: s, abort: () => !this.canvas || this.selectionStart !== this.selectionEnd, onChange: (a) => {
      this._currentCursorOpacity = a, this.renderCursorOrSelection();
    } });
  }
  _tick(e) {
    this._currentTickState = this._animateCursor({ toValue: 0, duration: this.cursorDuration / 2, delay: Math.max(e || 0, 100), onComplete: this._onTickComplete });
  }
  _onTickComplete() {
    var e;
    (e = this._currentTickCompleteState) === null || e === void 0 || e.abort(), this._currentTickCompleteState = this._animateCursor({ toValue: 1, duration: this.cursorDuration, onComplete: this._tick });
  }
  initDelayedCursor(e) {
    this.abortCursorAnimation(), this._tick(e ? 0 : this.cursorDelay);
  }
  abortCursorAnimation() {
    let e = !1;
    [this._currentTickState, this._currentTickCompleteState].forEach((t) => {
      t && !t.isDone() && (e = !0, t.abort());
    }), this._currentCursorOpacity = 1, e && this.clearContextTop();
  }
  restartCursorIfNeeded() {
    [this._currentTickState, this._currentTickCompleteState].some((e) => !e || e.isDone()) && this.initDelayedCursor();
  }
  selectAll() {
    return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this;
  }
  getSelectedText() {
    return this._text.slice(this.selectionStart, this.selectionEnd).join("");
  }
  findWordBoundaryLeft(e) {
    let t = 0, n = e - 1;
    if (this._reSpace.test(this._text[n])) for (; this._reSpace.test(this._text[n]); ) t++, n--;
    for (; /\S/.test(this._text[n]) && n > -1; ) t++, n--;
    return e - t;
  }
  findWordBoundaryRight(e) {
    let t = 0, n = e;
    if (this._reSpace.test(this._text[n])) for (; this._reSpace.test(this._text[n]); ) t++, n++;
    for (; /\S/.test(this._text[n]) && n < this._text.length; ) t++, n++;
    return e + t;
  }
  findLineBoundaryLeft(e) {
    let t = 0, n = e - 1;
    for (; !/\n/.test(this._text[n]) && n > -1; ) t++, n--;
    return e - t;
  }
  findLineBoundaryRight(e) {
    let t = 0, n = e;
    for (; !/\n/.test(this._text[n]) && n < this._text.length; ) t++, n++;
    return e + t;
  }
  searchWordBoundary(e, t) {
    const n = this._text;
    let i = e > 0 && this._reSpace.test(n[e]) && (t === -1 || !Jf.test(n[e - 1])) ? e - 1 : e, s = n[i];
    for (; i > 0 && i < n.length && !j0.test(s); ) i += t, s = n[i];
    return t === -1 && j0.test(s) && i++, i;
  }
  selectWord(e) {
    e = e || this.selectionStart;
    const t = this.searchWordBoundary(e, -1), n = Math.max(t, this.searchWordBoundary(e, 1));
    this.selectionStart = t, this.selectionEnd = n, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection();
  }
  selectLine(e) {
    e = e || this.selectionStart;
    const t = this.findLineBoundaryLeft(e), n = this.findLineBoundaryRight(e);
    return this.selectionStart = t, this.selectionEnd = n, this._fireSelectionChanged(), this._updateTextarea(), this;
  }
  enterEditing(e) {
    !this.isEditing && this.editable && (this.enterEditingImpl(), this.fire("editing:entered", e ? { e } : void 0), this._fireSelectionChanged(), this.canvas && (this.canvas.fire("text:editing:entered", { target: this, e }), this.canvas.requestRenderAll()));
  }
  enterEditingImpl() {
    this.canvas && (this.canvas.calcOffset(), this.canvas.textEditingManager.exitTextEditing()), this.isEditing = !0, this.initHiddenTextarea(), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick();
  }
  updateSelectionOnMouseMove(e) {
    if (this.getActiveControl()) return;
    const t = this.hiddenTextarea;
    sn(t).activeElement !== t && t.focus();
    const n = this.getSelectionStartFromPointer(e), i = this.selectionStart, s = this.selectionEnd;
    (n === this.__selectionStartOnMouseDown && i !== s || i !== n && s !== n) && (n > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = n) : (this.selectionStart = n, this.selectionEnd = this.__selectionStartOnMouseDown), this.selectionStart === i && this.selectionEnd === s || (this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()));
  }
  _setEditingProps() {
    this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0;
  }
  fromStringToGraphemeSelection(e, t, n) {
    const i = n.slice(0, e), s = this.graphemeSplit(i).length;
    if (e === t) return { selectionStart: s, selectionEnd: s };
    const a = n.slice(e, t);
    return { selectionStart: s, selectionEnd: s + this.graphemeSplit(a).length };
  }
  fromGraphemeToStringSelection(e, t, n) {
    const i = n.slice(0, e).join("").length;
    return e === t ? { selectionStart: i, selectionEnd: i } : { selectionStart: i, selectionEnd: i + n.slice(e, t).join("").length };
  }
  _updateTextarea() {
    if (this.cursorOffsetCache = {}, this.hiddenTextarea) {
      if (!this.inCompositionMode) {
        const e = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
        this.hiddenTextarea.selectionStart = e.selectionStart, this.hiddenTextarea.selectionEnd = e.selectionEnd;
      }
      this.updateTextareaPosition();
    }
  }
  updateFromTextArea() {
    if (!this.hiddenTextarea) return;
    this.cursorOffsetCache = {};
    const e = this.hiddenTextarea;
    this.text = e.value, this.set("dirty", !0), this.initDimensions(), this.setCoords();
    const t = this.fromStringToGraphemeSelection(e.selectionStart, e.selectionEnd, e.value);
    this.selectionEnd = this.selectionStart = t.selectionEnd, this.inCompositionMode || (this.selectionStart = t.selectionStart), this.updateTextareaPosition();
  }
  updateTextareaPosition() {
    if (this.selectionStart === this.selectionEnd) {
      const e = this._calcTextareaPosition();
      this.hiddenTextarea.style.left = e.left, this.hiddenTextarea.style.top = e.top;
    }
  }
  _calcTextareaPosition() {
    if (!this.canvas) return { left: "1px", top: "1px" };
    const e = this.inCompositionMode ? this.compositionStart : this.selectionStart, t = this._getCursorBoundaries(e), n = this.get2DCursorLocation(e), i = n.lineIndex, s = n.charIndex, a = this.getValueOfPropertyAt(i, s, "fontSize") * this.lineHeight, c = t.leftOffset, u = this.getCanvasRetinaScaling(), h = this.canvas.upperCanvasEl, d = h.width / u, p = h.height / u, g = d - a, v = p - a, y = new B(t.left + c, t.top + t.topOffset + a).transform(this.calcTransformMatrix()).transform(this.canvas.viewportTransform).multiply(new B(h.clientWidth / d, h.clientHeight / p));
    return y.x < 0 && (y.x = 0), y.x > g && (y.x = g), y.y < 0 && (y.y = 0), y.y > v && (y.y = v), y.x += this.canvas._offset.left, y.y += this.canvas._offset.top, { left: "".concat(y.x, "px"), top: "".concat(y.y, "px"), fontSize: "".concat(a, "px"), charHeight: a };
  }
  _saveEditingProps() {
    this._savedProps = { hasControls: this.hasControls, borderColor: this.borderColor, lockMovementX: this.lockMovementX, lockMovementY: this.lockMovementY, hoverCursor: this.hoverCursor, selectable: this.selectable, defaultCursor: this.canvas && this.canvas.defaultCursor, moveCursor: this.canvas && this.canvas.moveCursor };
  }
  _restoreEditingProps() {
    this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor || this.canvas.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor || this.canvas.moveCursor), delete this._savedProps);
  }
  _exitEditing() {
    const e = this.hiddenTextarea;
    this.selected = !1, this.isEditing = !1, e && (e.blur && e.blur(), e.parentNode && e.parentNode.removeChild(e)), this.hiddenTextarea = null, this.abortCursorAnimation(), this.selectionStart !== this.selectionEnd && this.clearContextTop();
  }
  exitEditingImpl() {
    this._exitEditing(), this.selectionEnd = this.selectionStart, this._restoreEditingProps(), this._forceClearCache && (this.initDimensions(), this.setCoords());
  }
  exitEditing() {
    const e = this._textBeforeEdit !== this.text;
    return this.exitEditingImpl(), this.fire("editing:exited"), e && this.fire(dl), this.canvas && (this.canvas.fire("text:editing:exited", { target: this }), e && this.canvas.fire("object:modified", { target: this })), this;
  }
  _removeExtraneousStyles() {
    for (const e in this.styles) this._textLines[e] || delete this.styles[e];
  }
  removeStyleFromTo(e, t) {
    const { lineIndex: n, charIndex: i } = this.get2DCursorLocation(e, !0), { lineIndex: s, charIndex: a } = this.get2DCursorLocation(t, !0);
    if (n !== s) {
      if (this.styles[n]) for (let c = i; c < this._unwrappedTextLines[n].length; c++) delete this.styles[n][c];
      if (this.styles[s]) for (let c = a; c < this._unwrappedTextLines[s].length; c++) {
        const u = this.styles[s][c];
        u && (this.styles[n] || (this.styles[n] = {}), this.styles[n][i + c - a] = u);
      }
      for (let c = n + 1; c <= s; c++) delete this.styles[c];
      this.shiftLineStyles(s, n - s);
    } else if (this.styles[n]) {
      const c = this.styles[n], u = a - i;
      for (let h = i; h < a; h++) delete c[h];
      for (const h in this.styles[n]) {
        const d = parseInt(h, 10);
        d >= a && (c[d - u] = c[h], delete c[h]);
      }
    }
  }
  shiftLineStyles(e, t) {
    const n = Object.assign({}, this.styles);
    for (const i in this.styles) {
      const s = parseInt(i, 10);
      s > e && (this.styles[s + t] = n[s], n[s - t] || delete this.styles[s]);
    }
  }
  insertNewlineStyleObject(e, t, n, i) {
    const s = {}, a = this._unwrappedTextLines[e].length, c = a === t;
    let u = !1;
    n || (n = 1), this.shiftLineStyles(e, n);
    const h = this.styles[e] ? this.styles[e][t === 0 ? t : t - 1] : void 0;
    for (const p in this.styles[e]) {
      const g = parseInt(p, 10);
      g >= t && (u = !0, s[g - t] = this.styles[e][p], c && t === 0 || delete this.styles[e][p]);
    }
    let d = !1;
    for (u && !c && (this.styles[e + n] = s, d = !0), (d || a > t) && n--; n > 0; ) i && i[n - 1] ? this.styles[e + n] = { 0: D({}, i[n - 1]) } : h ? this.styles[e + n] = { 0: D({}, h) } : delete this.styles[e + n], n--;
    this._forceClearCache = !0;
  }
  insertCharStyleObject(e, t, n, i) {
    this.styles || (this.styles = {});
    const s = this.styles[e], a = s ? D({}, s) : {};
    n || (n = 1);
    for (const u in a) {
      const h = parseInt(u, 10);
      h >= t && (s[h + n] = a[h], a[h - n] || delete s[h]);
    }
    if (this._forceClearCache = !0, i) {
      for (; n--; ) Object.keys(i[n]).length && (this.styles[e] || (this.styles[e] = {}), this.styles[e][t + n] = D({}, i[n]));
      return;
    }
    if (!s) return;
    const c = s[t ? t - 1 : 1];
    for (; c && n--; ) this.styles[e][t + n] = D({}, c);
  }
  insertNewStyleBlock(e, t, n) {
    const i = this.get2DCursorLocation(t, !0), s = [0];
    let a, c = 0;
    for (let u = 0; u < e.length; u++) e[u] === `
` ? (c++, s[c] = 0) : s[c]++;
    for (s[0] > 0 && (this.insertCharStyleObject(i.lineIndex, i.charIndex, s[0], n), n = n && n.slice(s[0] + 1)), c && this.insertNewlineStyleObject(i.lineIndex, i.charIndex + s[0], c), a = 1; a < c; a++) s[a] > 0 ? this.insertCharStyleObject(i.lineIndex + a, 0, s[a], n) : n && this.styles[i.lineIndex + a] && n[0] && (this.styles[i.lineIndex + a][0] = n[0]), n = n && n.slice(s[a] + 1);
    s[a] > 0 && this.insertCharStyleObject(i.lineIndex + a, 0, s[a], n);
  }
  removeChars(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e + 1;
    this.removeStyleFromTo(e, t), this._text.splice(e, t - e), this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  insertChars(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : n;
    i > n && this.removeStyleFromTo(n, i);
    const s = this.graphemeSplit(e);
    this.insertNewStyleBlock(s, n, t), this._text = [...this._text.slice(0, n), ...s, ...this._text.slice(i)], this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  setSelectionStartEndWithShift(e, t, n) {
    n <= e ? (t === e ? this._selectionDirection = Ke : this._selectionDirection === Ct && (this._selectionDirection = Ke, this.selectionEnd = e), this.selectionStart = n) : n > e && n < t ? this._selectionDirection === Ct ? this.selectionEnd = n : this.selectionStart = n : (t === e ? this._selectionDirection = Ct : this._selectionDirection === Ke && (this._selectionDirection = Ct, this.selectionStart = t), this.selectionEnd = n);
  }
}
class CR extends SR {
  initHiddenTextarea() {
    const e = this.canvas && sn(this.canvas.getElement()) || co(), t = e.createElement("textarea");
    Object.entries({ autocapitalize: "off", autocorrect: "off", autocomplete: "off", spellcheck: "false", "data-fabric": "textarea", wrap: "off" }).map((a) => {
      let [c, u] = a;
      return t.setAttribute(c, u);
    });
    const { top: n, left: i, fontSize: s } = this._calcTextareaPosition();
    t.style.cssText = "position: absolute; top: ".concat(n, "; left: ").concat(i, "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: ").concat(s, ";"), (this.hiddenTextareaContainer || e.body).appendChild(t), Object.entries({ blur: "blur", keydown: "onKeyDown", keyup: "onKeyUp", input: "onInput", copy: "copy", cut: "copy", paste: "paste", compositionstart: "onCompositionStart", compositionupdate: "onCompositionUpdate", compositionend: "onCompositionEnd" }).map((a) => {
      let [c, u] = a;
      return t.addEventListener(c, this[u].bind(this));
    }), this.hiddenTextarea = t;
  }
  blur() {
    this.abortCursorAnimation();
  }
  onKeyDown(e) {
    if (!this.isEditing) return;
    const t = this.direction === "rtl" ? this.keysMapRtl : this.keysMap;
    if (e.keyCode in t) this[t[e.keyCode]](e);
    else {
      if (!(e.keyCode in this.ctrlKeysMapDown) || !e.ctrlKey && !e.metaKey) return;
      this[this.ctrlKeysMapDown[e.keyCode]](e);
    }
    e.stopImmediatePropagation(), e.preventDefault(), e.keyCode >= 33 && e.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll();
  }
  onKeyUp(e) {
    !this.isEditing || this._copyDone || this.inCompositionMode ? this._copyDone = !1 : e.keyCode in this.ctrlKeysMapUp && (e.ctrlKey || e.metaKey) && (this[this.ctrlKeysMapUp[e.keyCode]](e), e.stopImmediatePropagation(), e.preventDefault(), this.canvas && this.canvas.requestRenderAll());
  }
  onInput(e) {
    const t = this.fromPaste;
    if (this.fromPaste = !1, e && e.stopPropagation(), !this.isEditing) return;
    const n = () => {
      this.updateFromTextArea(), this.fire(hl), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll());
    };
    if (this.hiddenTextarea.value === "") return this.styles = {}, void n();
    const i = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, s = this._text.length, a = i.length, c = this.selectionStart, u = this.selectionEnd, h = c !== u;
    let d, p, g, v, y = a - s;
    const x = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value), _ = c > x.selectionStart;
    h ? (p = this._text.slice(c, u), y += u - c) : a < s && (p = _ ? this._text.slice(u + y, u) : this._text.slice(c, c - y));
    const C = i.slice(x.selectionEnd - y, x.selectionEnd);
    if (p && p.length && (C.length && (d = this.getSelectionStyles(c, c + 1, !1), d = C.map(() => d[0])), h ? (g = c, v = u) : _ ? (g = u - p.length, v = u) : (g = u, v = u + p.length), this.removeStyleFromTo(g, v)), C.length) {
      const { copyPasteData: E } = En();
      t && C.join("") === E.copiedText && !Ue.disableStyleCopyPaste && (d = E.copiedTextStyle), this.insertNewStyleBlock(C, c, d);
    }
    n();
  }
  onCompositionStart() {
    this.inCompositionMode = !0;
  }
  onCompositionEnd() {
    this.inCompositionMode = !1;
  }
  onCompositionUpdate(e) {
    let { target: t } = e;
    const { selectionStart: n, selectionEnd: i } = t;
    this.compositionStart = n, this.compositionEnd = i, this.updateTextareaPosition();
  }
  copy() {
    if (this.selectionStart === this.selectionEnd) return;
    const { copyPasteData: e } = En();
    e.copiedText = this.getSelectedText(), Ue.disableStyleCopyPaste ? e.copiedTextStyle = void 0 : e.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0;
  }
  paste() {
    this.fromPaste = !0;
  }
  _getWidthBeforeCursor(e, t) {
    let n, i = this._getLineLeftOffset(e);
    return t > 0 && (n = this.__charBounds[e][t - 1], i += n.left + n.width), i;
  }
  getDownCursorOffset(e, t) {
    const n = this._getSelectionForOffset(e, t), i = this.get2DCursorLocation(n), s = i.lineIndex;
    if (s === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) return this._text.length - n;
    const a = i.charIndex, c = this._getWidthBeforeCursor(s, a), u = this._getIndexOnLine(s + 1, c);
    return this._textLines[s].slice(a).length + u + 1 + this.missingNewlineOffset(s);
  }
  _getSelectionForOffset(e, t) {
    return e.shiftKey && this.selectionStart !== this.selectionEnd && t ? this.selectionEnd : this.selectionStart;
  }
  getUpCursorOffset(e, t) {
    const n = this._getSelectionForOffset(e, t), i = this.get2DCursorLocation(n), s = i.lineIndex;
    if (s === 0 || e.metaKey || e.keyCode === 33) return -n;
    const a = i.charIndex, c = this._getWidthBeforeCursor(s, a), u = this._getIndexOnLine(s - 1, c), h = this._textLines[s].slice(0, a), d = this.missingNewlineOffset(s - 1);
    return -this._textLines[s - 1].length + u - h.length + (1 - d);
  }
  _getIndexOnLine(e, t) {
    const n = this._textLines[e];
    let i, s, a = this._getLineLeftOffset(e), c = 0;
    for (let u = 0, h = n.length; u < h; u++) if (i = this.__charBounds[e][u].width, a += i, a > t) {
      s = !0;
      const d = a - i, p = a, g = Math.abs(d - t);
      c = Math.abs(p - t) < g ? u : u - 1;
      break;
    }
    return s || (c = n.length - 1), c;
  }
  moveCursorDown(e) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", e);
  }
  moveCursorUp(e) {
    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorUpOrDown("Up", e);
  }
  _moveCursorUpOrDown(e, t) {
    const n = this["get".concat(e, "CursorOffset")](t, this._selectionDirection === Ct);
    if (t.shiftKey ? this.moveCursorWithShift(n) : this.moveCursorWithoutShift(n), n !== 0) {
      const i = this.text.length;
      this.selectionStart = ts(0, this.selectionStart, i), this.selectionEnd = ts(0, this.selectionEnd, i), this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea();
    }
  }
  moveCursorWithShift(e) {
    const t = this._selectionDirection === Ke ? this.selectionStart + e : this.selectionEnd + e;
    return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, t), e !== 0;
  }
  moveCursorWithoutShift(e) {
    return e < 0 ? (this.selectionStart += e, this.selectionEnd = this.selectionStart) : (this.selectionEnd += e, this.selectionStart = this.selectionEnd), e !== 0;
  }
  moveCursorLeft(e) {
    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorLeftOrRight("Left", e);
  }
  _move(e, t, n) {
    let i;
    if (e.altKey) i = this["findWordBoundary".concat(n)](this[t]);
    else {
      if (!e.metaKey && e.keyCode !== 35 && e.keyCode !== 36) return this[t] += n === "Left" ? -1 : 1, !0;
      i = this["findLineBoundary".concat(n)](this[t]);
    }
    return i !== void 0 && this[t] !== i && (this[t] = i, !0);
  }
  _moveLeft(e, t) {
    return this._move(e, t, "Left");
  }
  _moveRight(e, t) {
    return this._move(e, t, "Right");
  }
  moveCursorLeftWithoutShift(e) {
    let t = !0;
    return this._selectionDirection = Ke, this.selectionEnd === this.selectionStart && this.selectionStart !== 0 && (t = this._moveLeft(e, "selectionStart")), this.selectionEnd = this.selectionStart, t;
  }
  moveCursorLeftWithShift(e) {
    return this._selectionDirection === Ct && this.selectionStart !== this.selectionEnd ? this._moveLeft(e, "selectionEnd") : this.selectionStart !== 0 ? (this._selectionDirection = Ke, this._moveLeft(e, "selectionStart")) : void 0;
  }
  moveCursorRight(e) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", e);
  }
  _moveCursorLeftOrRight(e, t) {
    const n = "moveCursor".concat(e).concat(t.shiftKey ? "WithShift" : "WithoutShift");
    this._currentCursorOpacity = 1, this[n](t) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());
  }
  moveCursorRightWithShift(e) {
    return this._selectionDirection === Ke && this.selectionStart !== this.selectionEnd ? this._moveRight(e, "selectionStart") : this.selectionEnd !== this._text.length ? (this._selectionDirection = Ct, this._moveRight(e, "selectionEnd")) : void 0;
  }
  moveCursorRightWithoutShift(e) {
    let t = !0;
    return this._selectionDirection = Ct, this.selectionStart === this.selectionEnd ? (t = this._moveRight(e, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, t;
  }
}
const ed = (r) => !!r.button;
class TR extends CR {
  constructor() {
    super(...arguments), R(this, "draggableTextDelegate", void 0);
  }
  initBehavior() {
    this.on("mousedown", this._mouseDownHandler), this.on("mousedown:before", this._mouseDownHandlerBefore), this.on("mouseup", this.mouseUpHandler), this.on("mousedblclick", this.doubleClickHandler), this.on("tripleclick", this.tripleClickHandler), this.__lastClickTime = +/* @__PURE__ */ new Date(), this.__lastLastClickTime = +/* @__PURE__ */ new Date(), this.__lastPointer = {}, this.on("mousedown", this.onMouseDown), this.draggableTextDelegate = new _R(this), super.initBehavior();
  }
  shouldStartDragging() {
    return this.draggableTextDelegate.isActive();
  }
  onDragStart(e) {
    return this.draggableTextDelegate.onDragStart(e);
  }
  canDrop(e) {
    return this.draggableTextDelegate.canDrop(e);
  }
  onMouseDown(e) {
    if (!this.canvas) return;
    this.__newClickTime = +/* @__PURE__ */ new Date();
    const t = e.pointer;
    this.isTripleClick(t) && (this.fire("tripleclick", e), $d(e.e)), this.__lastLastClickTime = this.__lastClickTime, this.__lastClickTime = this.__newClickTime, this.__lastPointer = t, this.__lastSelected = this.selected && !this.getActiveControl();
  }
  isTripleClick(e) {
    return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === e.x && this.__lastPointer.y === e.y;
  }
  doubleClickHandler(e) {
    this.isEditing && this.selectWord(this.getSelectionStartFromPointer(e.e));
  }
  tripleClickHandler(e) {
    this.isEditing && this.selectLine(this.getSelectionStartFromPointer(e.e));
  }
  _mouseDownHandler(e) {
    let { e: t } = e;
    this.canvas && this.editable && !ed(t) && !this.getActiveControl() && (this.draggableTextDelegate.start(t) || (this.canvas.textEditingManager.register(this), this.selected && (this.inCompositionMode = !1, this.setCursorByClick(t)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection())));
  }
  _mouseDownHandlerBefore(e) {
    let { e: t } = e;
    this.canvas && this.editable && !ed(t) && (this.selected = this === this.canvas._activeObject);
  }
  mouseUpHandler(e) {
    let { e: t, transform: n } = e;
    const i = this.draggableTextDelegate.end(t);
    if (this.canvas) {
      this.canvas.textEditingManager.unregister(this);
      const s = this.canvas._activeObject;
      if (s && s !== this) return;
    }
    !this.editable || this.group && !this.group.interactive || n && n.actionPerformed || ed(t) || i || (this.__lastSelected && !this.getActiveControl() ? (this.selected = !1, this.__lastSelected = !1, this.enterEditing(t), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection()) : this.selected = !0);
  }
  setCursorByClick(e) {
    const t = this.getSelectionStartFromPointer(e), n = this.selectionStart, i = this.selectionEnd;
    e.shiftKey ? this.setSelectionStartEndWithShift(n, i, t) : (this.selectionStart = t, this.selectionEnd = t), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea());
  }
  getSelectionStartFromPointer(e) {
    const t = this.canvas.getScenePoint(e).transform(Pr(this.calcTransformMatrix())).add(new B(-this._getLeftOffset(), -this._getTopOffset()));
    let n = 0, i = 0, s = 0;
    for (let h = 0; h < this._textLines.length && n <= t.y; h++) n += this.getHeightOfLine(h), s = h, h > 0 && (i += this._textLines[h - 1].length + this.missingNewlineOffset(h - 1));
    let a = Math.abs(this._getLineLeftOffset(s));
    const c = this._textLines[s].length, u = this.__charBounds[s];
    for (let h = 0; h < c; h++) {
      const d = a + u[h].kernedWidth;
      if (t.x <= d) {
        Math.abs(t.x - d) <= Math.abs(t.x - a) && i++;
        break;
      }
      a = d, i++;
    }
    return Math.min(this.flipX ? c - i : i, this._text.length);
  }
}
const Oc = "moveCursorUp", Ic = "moveCursorDown", Ac = "moveCursorLeft", Mc = "moveCursorRight", Pc = "exitEditing", ER = D({ selectionStart: 0, selectionEnd: 0, selectionColor: "rgba(17,119,255,0.3)", isEditing: !1, editable: !0, editingBorderColor: "rgba(102,153,255,0.25)", cursorWidth: 2, cursorColor: "", cursorDelay: 1e3, cursorDuration: 600, caching: !0, hiddenTextareaContainer: null, keysMap: { 9: Pc, 27: Pc, 33: Oc, 34: Ic, 35: Mc, 36: Ac, 37: Ac, 38: Oc, 39: Mc, 40: Ic }, keysMapRtl: { 9: Pc, 27: Pc, 33: Oc, 34: Ic, 35: Ac, 36: Mc, 37: Mc, 38: Oc, 39: Ac, 40: Ic }, ctrlKeysMapDown: { 65: "selectAll" }, ctrlKeysMapUp: { 67: "copy", 88: "cut" } }, { _selectionDirection: null, _reSpace: /\s|\r?\n/, inCompositionMode: !1 });
class Un extends TR {
  static getDefaults() {
    return D(D({}, super.getDefaults()), Un.ownDefaults);
  }
  get type() {
    const e = super.type;
    return e === "itext" ? "i-text" : e;
  }
  constructor(e, t) {
    super(e, D(D({}, Un.ownDefaults), t)), this.initBehavior();
  }
  _set(e, t) {
    return this.isEditing && this._savedProps && e in this._savedProps ? (this._savedProps[e] = t, this) : (e === "canvas" && (this.canvas instanceof rf && this.canvas.textEditingManager.remove(this), t instanceof rf && t.textEditingManager.add(this)), super._set(e, t));
  }
  setSelectionStart(e) {
    e = Math.max(e, 0), this._updateAndFire("selectionStart", e);
  }
  setSelectionEnd(e) {
    e = Math.min(e, this.text.length), this._updateAndFire("selectionEnd", e);
  }
  _updateAndFire(e, t) {
    this[e] !== t && (this._fireSelectionChanged(), this[e] = t), this._updateTextarea();
  }
  _fireSelectionChanged() {
    this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this });
  }
  initDimensions() {
    this.isEditing && this.initDelayedCursor(), super.initDimensions();
  }
  getSelectionStyles() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart || 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionEnd, n = arguments.length > 2 ? arguments[2] : void 0;
    return super.getSelectionStyles(e, t, n);
  }
  setSelectionStyles(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionStart || 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.selectionEnd;
    return super.setSelectionStyles(e, t, n);
  }
  get2DCursorLocation() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, t = arguments.length > 1 ? arguments[1] : void 0;
    return super.get2DCursorLocation(e, t);
  }
  render(e) {
    super.render(e), this.cursorOffsetCache = {}, this.renderCursorOrSelection();
  }
  toCanvasElement(e) {
    const t = this.isEditing;
    this.isEditing = !1;
    const n = super.toCanvasElement(e);
    return this.isEditing = t, n;
  }
  renderCursorOrSelection() {
    if (!this.isEditing) return;
    const e = this.clearContextTop(!0);
    if (!e) return;
    const t = this._getCursorBoundaries();
    this.selectionStart !== this.selectionEnd || this.inCompositionMode ? this.renderSelection(e, t) : this.renderCursor(e, t), this.canvas.contextTopDirty = !0, e.restore();
  }
  _getCursorBoundaries() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, t = arguments.length > 1 ? arguments[1] : void 0;
    const n = this._getLeftOffset(), i = this._getTopOffset(), s = this._getCursorBoundariesOffsets(e, t);
    return { left: n, top: i, leftOffset: s.left, topOffset: s.top };
  }
  _getCursorBoundariesOffsets(e, t) {
    return t ? this.__getCursorBoundariesOffsets(e) : this.cursorOffsetCache && "top" in this.cursorOffsetCache ? this.cursorOffsetCache : this.cursorOffsetCache = this.__getCursorBoundariesOffsets(e);
  }
  __getCursorBoundariesOffsets(e) {
    let t = 0, n = 0;
    const { charIndex: i, lineIndex: s } = this.get2DCursorLocation(e);
    for (let h = 0; h < s; h++) t += this.getHeightOfLine(h);
    const a = this._getLineLeftOffset(s), c = this.__charBounds[s][i];
    c && (n = c.left), this.charSpacing !== 0 && i === this._textLines[s].length && (n -= this._getWidthOfCharSpacing());
    const u = { top: t, left: a + (n > 0 ? n : 0) };
    return this.direction === "rtl" && (this.textAlign === Ct || this.textAlign === bn || this.textAlign === Zo ? u.left *= -1 : this.textAlign === Ke || this.textAlign === Sl ? u.left = a - (n > 0 ? n : 0) : this.textAlign !== Pe && this.textAlign !== Jo || (u.left = a - (n > 0 ? n : 0))), u;
  }
  renderCursorAt(e) {
    this._renderCursor(this.canvas.contextTop, this._getCursorBoundaries(e, !0), e);
  }
  renderCursor(e, t) {
    this._renderCursor(e, t, this.selectionStart);
  }
  getCursorRenderingData() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getCursorBoundaries(e);
    const n = this.get2DCursorLocation(e), i = n.lineIndex, s = n.charIndex > 0 ? n.charIndex - 1 : 0, a = this.getValueOfPropertyAt(i, s, "fontSize"), c = this.getObjectScaling().x * this.canvas.getZoom(), u = this.cursorWidth / c, h = this.getValueOfPropertyAt(i, s, "deltaY"), d = t.topOffset + (1 - this._fontSizeFraction) * this.getHeightOfLine(i) / this.lineHeight - a * (1 - this._fontSizeFraction);
    return { color: this.cursorColor || this.getValueOfPropertyAt(i, s, "fill"), opacity: this._currentCursorOpacity, left: t.left + t.leftOffset - u / 2, top: d + t.top + h, width: u, height: a };
  }
  _renderCursor(e, t, n) {
    const { color: i, opacity: s, left: a, top: c, width: u, height: h } = this.getCursorRenderingData(n, t);
    e.fillStyle = i, e.globalAlpha = s, e.fillRect(a, c, u, h);
  }
  renderSelection(e, t) {
    const n = { selectionStart: this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd: this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd };
    this._renderSelection(e, n, t);
  }
  renderDragSourceEffect() {
    const e = this.draggableTextDelegate.getDragStartSelection();
    this._renderSelection(this.canvas.contextTop, e, this._getCursorBoundaries(e.selectionStart, !0));
  }
  renderDropTargetEffect(e) {
    const t = this.getSelectionStartFromPointer(e);
    this.renderCursorAt(t);
  }
  _renderSelection(e, t, n) {
    const i = t.selectionStart, s = t.selectionEnd, a = this.textAlign.includes(bn), c = this.get2DCursorLocation(i), u = this.get2DCursorLocation(s), h = c.lineIndex, d = u.lineIndex, p = c.charIndex < 0 ? 0 : c.charIndex, g = u.charIndex < 0 ? 0 : u.charIndex;
    for (let v = h; v <= d; v++) {
      const y = this._getLineLeftOffset(v) || 0;
      let x = this.getHeightOfLine(v), _ = 0, C = 0, E = 0;
      if (v === h && (C = this.__charBounds[h][p].left), v >= h && v < d) E = a && !this.isEndOfWrapping(v) ? this.width : this.getLineWidth(v) || 5;
      else if (v === d) if (g === 0) E = this.__charBounds[d][g].left;
      else {
        const V = this._getWidthOfCharSpacing();
        E = this.__charBounds[d][g - 1].left + this.__charBounds[d][g - 1].width - V;
      }
      _ = x, (this.lineHeight < 1 || v === d && this.lineHeight > 1) && (x /= this.lineHeight);
      let k = n.left + y + C, O = x, P = 0;
      const j = E - C;
      this.inCompositionMode ? (e.fillStyle = this.compositionColor || "black", O = 1, P = x) : e.fillStyle = this.selectionColor, this.direction === "rtl" && (this.textAlign === Ct || this.textAlign === bn || this.textAlign === Zo ? k = this.width - k - j : this.textAlign === Ke || this.textAlign === Sl ? k = n.left + y - E : this.textAlign !== Pe && this.textAlign !== Jo || (k = n.left + y - E)), e.fillRect(k, n.top + n.topOffset + P, j, O), n.topOffset += _;
    }
  }
  getCurrentCharFontSize() {
    const e = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(e.l, e.c, "fontSize");
  }
  getCurrentCharColor() {
    const e = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(e.l, e.c, Lt);
  }
  _getCurrentCharIndex() {
    const e = this.get2DCursorLocation(this.selectionStart, !0), t = e.charIndex > 0 ? e.charIndex - 1 : 0;
    return { l: e.lineIndex, c: t };
  }
  dispose() {
    this.exitEditingImpl(), this.draggableTextDelegate.dispose(), super.dispose();
  }
}
R(Un, "ownDefaults", ER), R(Un, "type", "IText"), ne.setClass(Un), ne.setClass(Un, "i-text");
class qi extends Un {
  static getDefaults() {
    return D(D({}, super.getDefaults()), qi.ownDefaults);
  }
  constructor(e, t) {
    super(e, D(D({}, qi.ownDefaults), t));
  }
  static createControls() {
    return { controls: kw() };
  }
  initDimensions() {
    this.initialized && (this.isEditing && this.initDelayedCursor(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), this.textAlign.includes(bn) && this.enlargeSpaces(), this.height = this.calcTextHeight());
  }
  _generateStyleMap(e) {
    let t = 0, n = 0, i = 0;
    const s = {};
    for (let a = 0; a < e.graphemeLines.length; a++) e.graphemeText[i] === `
` && a > 0 ? (n = 0, i++, t++) : !this.splitByGrapheme && this._reSpaceAndTab.test(e.graphemeText[i]) && a > 0 && (n++, i++), s[a] = { line: t, offset: n }, i += e.graphemeLines[a].length, n += e.graphemeLines[a].length;
    return s;
  }
  styleHas(e, t) {
    if (this._styleMap && !this.isWrapping) {
      const n = this._styleMap[t];
      n && (t = n.line);
    }
    return super.styleHas(e, t);
  }
  isEmptyStyles(e) {
    if (!this.styles) return !0;
    let t, n = 0, i = e + 1, s = !1;
    const a = this._styleMap[e], c = this._styleMap[e + 1];
    a && (e = a.line, n = a.offset), c && (i = c.line, s = i === e, t = c.offset);
    const u = e === void 0 ? this.styles : { line: this.styles[e] };
    for (const h in u) for (const d in u[h]) {
      const p = parseInt(d, 10);
      if (p >= n && (!s || p < t)) for (const g in u[h][d]) return !1;
    }
    return !0;
  }
  _getStyleDeclaration(e, t) {
    if (this._styleMap && !this.isWrapping) {
      const n = this._styleMap[e];
      if (!n) return {};
      e = n.line, t = n.offset + t;
    }
    return super._getStyleDeclaration(e, t);
  }
  _setStyleDeclaration(e, t, n) {
    const i = this._styleMap[e];
    super._setStyleDeclaration(i.line, i.offset + t, n);
  }
  _deleteStyleDeclaration(e, t) {
    const n = this._styleMap[e];
    super._deleteStyleDeclaration(n.line, n.offset + t);
  }
  _getLineStyle(e) {
    const t = this._styleMap[e];
    return !!this.styles[t.line];
  }
  _setLineStyle(e) {
    const t = this._styleMap[e];
    super._setLineStyle(t.line);
  }
  _wrapText(e, t) {
    this.isWrapping = !0;
    const n = this.getGraphemeDataForRender(e), i = [];
    for (let s = 0; s < n.wordsData.length; s++) i.push(...this._wrapLine(s, t, n));
    return this.isWrapping = !1, i;
  }
  getGraphemeDataForRender(e) {
    const t = this.splitByGrapheme, n = t ? "" : " ";
    let i = 0;
    return { wordsData: e.map((s, a) => {
      let c = 0;
      const u = t ? this.graphemeSplit(s) : this.wordSplit(s);
      return u.length === 0 ? [{ word: [], width: 0 }] : u.map((h) => {
        const d = t ? [h] : this.graphemeSplit(h), p = this._measureWord(d, a, c);
        return i = Math.max(p, i), c += d.length + n.length, { word: d, width: p };
      });
    }), largestWordWidth: i };
  }
  _measureWord(e, t) {
    let n, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, s = 0;
    for (let a = 0, c = e.length; a < c; a++)
      s += this._getGraphemeBox(e[a], t, a + i, n, !0).kernedWidth, n = e[a];
    return s;
  }
  wordSplit(e) {
    return e.split(this._wordJoiners);
  }
  _wrapLine(e, t, n) {
    let { largestWordWidth: i, wordsData: s } = n, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    const c = this._getWidthOfCharSpacing(), u = this.splitByGrapheme, h = [], d = u ? "" : " ";
    let p = 0, g = [], v = 0, y = 0, x = !0;
    t -= a;
    const _ = Math.max(t, i, this.dynamicMinWidth), C = s[e];
    let E;
    for (v = 0, E = 0; E < C.length; E++) {
      const { word: k, width: O } = C[E];
      v += k.length, p += y + O - c, p > _ && !x ? (h.push(g), g = [], p = O, x = !0) : p += c, x || u || g.push(d), g = g.concat(k), y = u ? 0 : this._measureWord([d], e, v), v++, x = !1;
    }
    return E && h.push(g), i + a > this.dynamicMinWidth && (this.dynamicMinWidth = i - c + a), h;
  }
  isEndOfWrapping(e) {
    return !this._styleMap[e + 1] || this._styleMap[e + 1].line !== this._styleMap[e].line;
  }
  missingNewlineOffset(e, t) {
    return this.splitByGrapheme && !t ? this.isEndOfWrapping(e) ? 1 : 0 : 1;
  }
  _splitTextIntoLines(e) {
    const t = super._splitTextIntoLines(e), n = this._wrapText(t.lines, this.width), i = new Array(n.length);
    for (let s = 0; s < n.length; s++) i[s] = n[s].join("");
    return t.lines = i, t.graphemeLines = n, t;
  }
  getMinWidth() {
    return Math.max(this.minWidth, this.dynamicMinWidth);
  }
  _removeExtraneousStyles() {
    const e = /* @__PURE__ */ new Map();
    for (const t in this._styleMap) {
      const n = parseInt(t, 10);
      if (this._textLines[n]) {
        const i = this._styleMap[t].line;
        e.set("".concat(i), !0);
      }
    }
    for (const t in this.styles) e.has(t) || delete this.styles[t];
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject(["minWidth", "splitByGrapheme", ...e]);
  }
}
R(qi, "type", "Textbox"), R(qi, "textLayoutProperties", [...Un.textLayoutProperties, "width"]), R(qi, "ownDefaults", { minWidth: 20, dynamicMinWidth: 2, lockScalingFlip: !0, noScaleCache: !1, _wordJoiners: /[ \t\r]/, splitByGrapheme: !1 }), ne.setClass(qi);
class F0 extends hu {
  shouldPerformLayout(e) {
    return !!e.target.clipPath && super.shouldPerformLayout(e);
  }
  shouldLayoutClipPath() {
    return !1;
  }
  calcLayoutResult(e, t) {
    const { target: n } = e, { clipPath: i, group: s } = n;
    if (!i || !this.shouldPerformLayout(e)) return;
    const { width: a, height: c } = Cn(Fw(n, i)), u = new B(a, c);
    if (i.absolutePositioned)
      return { center: $n(i.getRelativeCenterPoint(), void 0, s ? s.calcTransformMatrix() : void 0), size: u };
    {
      const h = i.getRelativeCenterPoint().transform(n.calcOwnMatrix(), !0);
      if (this.shouldPerformLayout(e)) {
        const { center: d = new B(), correction: p = new B() } = this.calcBoundingBox(t, e) || {};
        return { center: d.add(h), correction: p.subtract(h), size: u };
      }
      return { center: n.getRelativeCenterPoint().add(h), size: u };
    }
  }
}
R(F0, "type", "clip-path"), ne.setClass(F0);
class L0 extends hu {
  getInitialSize(e, t) {
    let { target: n } = e, { size: i } = t;
    return new B(n.width || i.x, n.height || i.y);
  }
}
R(L0, "type", "fixed"), ne.setClass(L0);
class kR extends aa {
  subscribeTargets(e) {
    const t = e.target;
    e.targets.reduce((n, i) => (i.parent && n.add(i.parent), n), /* @__PURE__ */ new Set()).forEach((n) => {
      n.layoutManager.subscribeTargets({ target: n, targets: [t] });
    });
  }
  unsubscribeTargets(e) {
    const t = e.target, n = t.getObjects();
    e.targets.reduce((i, s) => (s.parent && i.add(s.parent), i), /* @__PURE__ */ new Set()).forEach((i) => {
      !n.some((s) => s.parent === i) && i.layoutManager.unsubscribeTargets({ target: i, targets: [t] });
    });
  }
}
class _n extends Xr {
  static getDefaults() {
    return D(D({}, super.getDefaults()), _n.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, _n.ownDefaults), this.setOptions(t);
    const { left: n, top: i, layoutManager: s } = t;
    this.groupInit(e, { left: n, top: i, layoutManager: s ?? new kR() });
  }
  _shouldSetNestedCoords() {
    return !0;
  }
  __objectSelectionMonitor() {
  }
  multiSelectAdd() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    this.multiSelectionStacking === "selection-order" ? this.add(...t) : t.forEach((i) => {
      const s = this._objects.findIndex((c) => c.isInFrontOf(i)), a = s === -1 ? this.size() : s;
      this.insertAt(a, i);
    });
  }
  canEnterGroup(e) {
    return this.getObjects().some((t) => t.isDescendantOf(e) || e.isDescendantOf(t)) ? (pi("error", "ActiveSelection: circular object trees are not supported, this call has no effect"), !1) : super.canEnterGroup(e);
  }
  enterGroup(e, t) {
    e.parent && e.parent === e.group ? e.parent._exitGroup(e) : e.group && e.parent !== e.group && e.group.remove(e), this._enterGroup(e, t);
  }
  exitGroup(e, t) {
    this._exitGroup(e, t), e.parent && e.parent._enterGroup(e, !0);
  }
  _onAfterObjectsChange(e, t) {
    super._onAfterObjectsChange(e, t);
    const n = /* @__PURE__ */ new Set();
    t.forEach((i) => {
      const { parent: s } = i;
      s && n.add(s);
    }), e === mp ? n.forEach((i) => {
      i._onAfterObjectsChange(bl, t);
    }) : n.forEach((i) => {
      i._set("dirty", !0);
    });
  }
  onDeselect() {
    return this.removeAll(), !1;
  }
  toString() {
    return "#<ActiveSelection: (".concat(this.complexity(), ")>");
  }
  shouldCache() {
    return !1;
  }
  isOnACache() {
    return !1;
  }
  _renderControls(e, t, n) {
    e.save(), e.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
    const i = D(D({ hasControls: !1 }, n), {}, { forActiveSelection: !0 });
    for (let s = 0; s < this._objects.length; s++) this._objects[s]._renderControls(e, i);
    super._renderControls(e, t), e.restore();
  }
}
R(_n, "type", "ActiveSelection"), R(_n, "ownDefaults", { multiSelectionStacking: "canvas-stacking" }), ne.setClass(_n), ne.setClass(_n, "activeSelection");
class OR {
  constructor() {
    R(this, "resources", {});
  }
  applyFilters(e, t, n, i, s) {
    const a = s.getContext("2d");
    if (!a) return;
    a.drawImage(t, 0, 0, n, i);
    const c = { sourceWidth: n, sourceHeight: i, imageData: a.getImageData(0, 0, n, i), originalEl: t, originalImageData: a.getImageData(0, 0, n, i), canvasEl: s, ctx: a, filterBackend: this };
    e.forEach((h) => {
      h.applyTo(c);
    });
    const { imageData: u } = c;
    return u.width === n && u.height === i || (s.width = u.width, s.height = u.height), a.putImageData(u, 0, 0), c;
  }
}
class cx {
  constructor() {
    let { tileSize: e = Ue.textureSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    R(this, "aPosition", new Float32Array([0, 0, 0, 1, 1, 0, 1, 1])), R(this, "resources", {}), this.tileSize = e, this.setupGLContext(e, e), this.captureGPUInfo();
  }
  setupGLContext(e, t) {
    this.dispose(), this.createWebGLCanvas(e, t);
  }
  createWebGLCanvas(e, t) {
    const n = un({ width: e, height: t }), i = n.getContext("webgl", { alpha: !0, premultipliedAlpha: !1, depth: !1, stencil: !1, antialias: !1 });
    i && (i.clearColor(0, 0, 0, 0), this.canvas = n, this.gl = i);
  }
  applyFilters(e, t, n, i, s, a) {
    const c = this.gl, u = s.getContext("2d");
    if (!c || !u) return;
    let h;
    a && (h = this.getCachedTexture(a, t));
    const d = { originalWidth: t.width || t.naturalWidth || 0, originalHeight: t.height || t.naturalHeight || 0, sourceWidth: n, sourceHeight: i, destinationWidth: n, destinationHeight: i, context: c, sourceTexture: this.createTexture(c, n, i, h ? void 0 : t), targetTexture: this.createTexture(c, n, i), originalTexture: h || this.createTexture(c, n, i, h ? void 0 : t), passes: e.length, webgl: !0, aPosition: this.aPosition, programCache: this.programCache, pass: 0, filterBackend: this, targetCanvas: s }, p = c.createFramebuffer();
    return c.bindFramebuffer(c.FRAMEBUFFER, p), e.forEach((g) => {
      g && g.applyTo(d);
    }), function(g) {
      const v = g.targetCanvas, y = v.width, x = v.height, _ = g.destinationWidth, C = g.destinationHeight;
      y === _ && x === C || (v.width = _, v.height = C);
    }(d), this.copyGLTo2D(c, d), c.bindTexture(c.TEXTURE_2D, null), c.deleteTexture(d.sourceTexture), c.deleteTexture(d.targetTexture), c.deleteFramebuffer(p), u.setTransform(1, 0, 0, 1, 0, 0), d;
  }
  dispose() {
    this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches();
  }
  clearWebGLCaches() {
    this.programCache = {}, this.textureCache = {};
  }
  createTexture(e, t, n, i, s) {
    const { NEAREST: a, TEXTURE_2D: c, RGBA: u, UNSIGNED_BYTE: h, CLAMP_TO_EDGE: d, TEXTURE_MAG_FILTER: p, TEXTURE_MIN_FILTER: g, TEXTURE_WRAP_S: v, TEXTURE_WRAP_T: y } = e, x = e.createTexture();
    return e.bindTexture(c, x), e.texParameteri(c, p, s || a), e.texParameteri(c, g, s || a), e.texParameteri(c, v, d), e.texParameteri(c, y, d), i ? e.texImage2D(c, 0, u, u, h, i) : e.texImage2D(c, 0, u, t, n, 0, u, h, null), x;
  }
  getCachedTexture(e, t, n) {
    const { textureCache: i } = this;
    if (i[e]) return i[e];
    {
      const s = this.createTexture(this.gl, t.width, t.height, t, n);
      return s && (i[e] = s), s;
    }
  }
  evictCachesForKey(e) {
    this.textureCache[e] && (this.gl.deleteTexture(this.textureCache[e]), delete this.textureCache[e]);
  }
  copyGLTo2D(e, t) {
    const n = e.canvas, i = t.targetCanvas, s = i.getContext("2d");
    if (!s) return;
    s.translate(0, i.height), s.scale(1, -1);
    const a = n.height - i.height;
    s.drawImage(n, 0, a, i.width, i.height, 0, 0, i.width, i.height);
  }
  copyGLTo2DPutImageData(e, t) {
    const n = t.targetCanvas.getContext("2d"), i = t.destinationWidth, s = t.destinationHeight, a = i * s * 4;
    if (!n) return;
    const c = new Uint8Array(this.imageBuffer, 0, a), u = new Uint8ClampedArray(this.imageBuffer, 0, a);
    e.readPixels(0, 0, i, s, e.RGBA, e.UNSIGNED_BYTE, c);
    const h = new ImageData(u, i, s);
    n.putImageData(h, 0, 0);
  }
  captureGPUInfo() {
    if (this.gpuInfo) return this.gpuInfo;
    const e = this.gl, t = { renderer: "", vendor: "" };
    if (!e) return t;
    const n = e.getExtension("WEBGL_debug_renderer_info");
    if (n) {
      const i = e.getParameter(n.UNMASKED_RENDERER_WEBGL), s = e.getParameter(n.UNMASKED_VENDOR_WEBGL);
      i && (t.renderer = i.toLowerCase()), s && (t.vendor = s.toLowerCase());
    }
    return this.gpuInfo = t, t;
  }
}
let td;
function IR() {
  const { WebGLProbe: r } = En();
  return r.queryWebGL(Gr()), Ue.enableGLFiltering && r.isSupported(Ue.textureSize) ? new cx({ tileSize: Ue.textureSize }) : new OR();
}
function rd() {
  return !td && (!(arguments.length > 0 && arguments[0] !== void 0) || arguments[0]) && (td = IR()), td;
}
const AR = ["filters", "resizeFilter", "src", "crossOrigin", "type"], lx = ["cropX", "cropY"];
class $r extends rt {
  static getDefaults() {
    return D(D({}, super.getDefaults()), $r.ownDefaults);
  }
  constructor(e, t) {
    super(), R(this, "_lastScaleX", 1), R(this, "_lastScaleY", 1), R(this, "_filterScalingX", 1), R(this, "_filterScalingY", 1), this.filters = [], Object.assign(this, $r.ownDefaults), this.setOptions(t), this.cacheKey = "texture".concat(mi()), this.setElement(typeof e == "string" ? (this.canvas && sn(this.canvas.getElement()) || co()).getElementById(e) : e, t);
  }
  getElement() {
    return this._element;
  }
  setElement(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._element = e, this._originalElement = e, this._setWidthHeight(t), e.classList.add($r.CSS_CANVAS), this.filters.length !== 0 && this.applyFilters(), this.resizeFilter && this.applyResizeFilters();
  }
  removeTexture(e) {
    const t = rd(!1);
    t instanceof cx && t.evictCachesForKey(e);
  }
  dispose() {
    super.dispose(), this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._cacheContext = null, ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach((e) => {
      const t = this[e];
      t && En().dispose(t), this[e] = void 0;
    });
  }
  getCrossOrigin() {
    return this._originalElement && (this._originalElement.crossOrigin || null);
  }
  getOriginalSize() {
    const e = this.getElement();
    return e ? { width: e.naturalWidth || e.width, height: e.naturalHeight || e.height } : { width: 0, height: 0 };
  }
  _stroke(e) {
    if (!this.stroke || this.strokeWidth === 0) return;
    const t = this.width / 2, n = this.height / 2;
    e.beginPath(), e.moveTo(-t, -n), e.lineTo(t, -n), e.lineTo(t, n), e.lineTo(-t, n), e.lineTo(-t, -n), e.closePath();
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = [];
    return this.filters.forEach((n) => {
      n && t.push(n.toObject());
    }), D(D({}, super.toObject([...lx, ...e])), {}, { src: this.getSrc(), crossOrigin: this.getCrossOrigin(), filters: t }, this.resizeFilter ? { resizeFilter: this.resizeFilter.toObject() } : {});
  }
  hasCrop() {
    return !!this.cropX || !!this.cropY || this.width < this._element.width || this.height < this._element.height;
  }
  _toSVG() {
    const e = [], t = this._element, n = -this.width / 2, i = -this.height / 2;
    let s = [], a = [], c = "", u = "";
    if (!t) return [];
    if (this.hasCrop()) {
      const h = mi();
      s.push('<clipPath id="imageCrop_' + h + `">
`, '	<rect x="' + n + '" y="' + i + '" width="' + this.width + '" height="' + this.height + `" />
`, `</clipPath>
`), c = ' clip-path="url(#imageCrop_' + h + ')" ';
    }
    if (this.imageSmoothing || (u = ' image-rendering="optimizeSpeed"'), e.push("	<image ", "COMMON_PARTS", 'xlink:href="'.concat(this.getSvgSrc(!0), '" x="').concat(n - this.cropX, '" y="').concat(i - this.cropY, '" width="').concat(t.width || t.naturalWidth, '" height="').concat(t.height || t.naturalHeight, '"').concat(u).concat(c, `></image>
`)), this.stroke || this.strokeDashArray) {
      const h = this.fill;
      this.fill = null, a = ['	<rect x="'.concat(n, '" y="').concat(i, '" width="').concat(this.width, '" height="').concat(this.height, '" style="').concat(this.getSvgStyles(), `" />
`)], this.fill = h;
    }
    return s = this.paintFirst !== Lt ? s.concat(a, e) : s.concat(e, a), s;
  }
  getSrc(e) {
    const t = e ? this._element : this._originalElement;
    return t ? t.toDataURL ? t.toDataURL() : this.srcFromAttribute ? t.getAttribute("src") || "" : t.src : this.src || "";
  }
  getSvgSrc(e) {
    return this.getSrc(e);
  }
  setSrc(e) {
    let { crossOrigin: t, signal: n } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Ko(e, { crossOrigin: t, signal: n }).then((i) => {
      t !== void 0 && this.set({ crossOrigin: t }), this.setElement(i);
    });
  }
  toString() {
    return '#<Image: { src: "'.concat(this.getSrc(), '" }>');
  }
  applyResizeFilters() {
    const e = this.resizeFilter, t = this.minimumScaleTrigger, n = this.getTotalObjectScaling(), i = n.x, s = n.y, a = this._filteredEl || this._originalElement;
    if (this.group && this.set("dirty", !0), !e || i > t && s > t) return this._element = a, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = i, void (this._lastScaleY = s);
    const c = un(a), { width: u, height: h } = a;
    this._element = c, this._lastScaleX = e.scaleX = i, this._lastScaleY = e.scaleY = s, rd().applyFilters([e], a, u, h, this._element), this._filterScalingX = c.width / this._originalElement.width, this._filterScalingY = c.height / this._originalElement.height;
  }
  applyFilters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.filters || [];
    if (e = e.filter((s) => s && !s.isNeutralState()), this.set("dirty", !0), this.removeTexture("".concat(this.cacheKey, "_filtered")), e.length === 0) return this._element = this._originalElement, this._filteredEl = void 0, this._filterScalingX = 1, void (this._filterScalingY = 1);
    const t = this._originalElement, n = t.naturalWidth || t.width, i = t.naturalHeight || t.height;
    if (this._element === this._originalElement) {
      const s = un({ width: n, height: i });
      this._element = s, this._filteredEl = s;
    } else this._filteredEl && (this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, n, i), this._lastScaleX = 1, this._lastScaleY = 1);
    rd().applyFilters(e, this._originalElement, n, i, this._element), this._originalElement.width === this._element.width && this._originalElement.height === this._element.height || (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height);
  }
  _render(e) {
    e.imageSmoothingEnabled = this.imageSmoothing, this.isMoving !== !0 && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(e), this._renderPaintInOrder(e);
  }
  drawCacheOnCanvas(e) {
    e.imageSmoothingEnabled = this.imageSmoothing, super.drawCacheOnCanvas(e);
  }
  shouldCache() {
    return this.needsItsOwnCache();
  }
  _renderFill(e) {
    const t = this._element;
    if (!t) return;
    const n = this._filterScalingX, i = this._filterScalingY, s = this.width, a = this.height, c = Math.max(this.cropX, 0), u = Math.max(this.cropY, 0), h = t.naturalWidth || t.width, d = t.naturalHeight || t.height, p = c * n, g = u * i, v = Math.min(s * n, h - p), y = Math.min(a * i, d - g), x = -s / 2, _ = -a / 2, C = Math.min(s, h / n - c), E = Math.min(a, d / i - u);
    t && e.drawImage(t, p, g, v, y, x, _, C, E);
  }
  _needsResize() {
    const e = this.getTotalObjectScaling();
    return e.x !== this._lastScaleX || e.y !== this._lastScaleY;
  }
  _resetWidthHeight() {
    this.set(this.getOriginalSize());
  }
  _setWidthHeight() {
    let { width: e, height: t } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = this.getOriginalSize();
    this.width = e || n.width, this.height = t || n.height;
  }
  parsePreserveAspectRatioAttribute() {
    const e = Kb(this.preserveAspectRatio || ""), t = this.width, n = this.height, i = { width: t, height: n };
    let s, a = this._element.width, c = this._element.height, u = 1, h = 1, d = 0, p = 0, g = 0, v = 0;
    return !e || e.alignX === yr && e.alignY === yr ? (u = t / a, h = n / c) : (e.meetOrSlice === "meet" && (u = h = Nw(this._element, i), s = (t - a * u) / 2, e.alignX === "Min" && (d = -s), e.alignX === "Max" && (d = s), s = (n - c * h) / 2, e.alignY === "Min" && (p = -s), e.alignY === "Max" && (p = s)), e.meetOrSlice === "slice" && (u = h = Bw(this._element, i), s = a - t / u, e.alignX === "Mid" && (g = s / 2), e.alignX === "Max" && (g = s), s = c - n / h, e.alignY === "Mid" && (v = s / 2), e.alignY === "Max" && (v = s), a = t / u, c = n / h)), { width: a, height: c, scaleX: u, scaleY: h, offsetLeft: d, offsetTop: p, cropX: g, cropY: v };
  }
  static fromObject(e, t) {
    let { filters: n, resizeFilter: i, src: s, crossOrigin: a, type: c } = e, u = ht(e, AR);
    return Promise.all([Ko(s, D(D({}, t), {}, { crossOrigin: a })), n && Xs(n, t), i && Xs([i], t), _a(u, t)]).then((h) => {
      let [d, p = [], [g] = [], v = {}] = h;
      return new this(d, D(D({}, u), {}, { src: s, filters: p, resizeFilter: g }, v));
    });
  }
  static fromURL(e) {
    let { crossOrigin: t = null, signal: n } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = arguments.length > 2 ? arguments[2] : void 0;
    return Ko(e, { crossOrigin: t, signal: n }).then((s) => new this(s, i));
  }
  static async fromElement(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;
    const i = Zn(e, this.ATTRIBUTE_NAMES, n);
    return this.fromURL(i["xlink:href"], t, i).catch((s) => (pi("log", "Unable to parse Image", s), null));
  }
}
R($r, "type", "Image"), R($r, "cacheProperties", [...Kn, ...lx]), R($r, "ownDefaults", { strokeWidth: 0, srcFromAttribute: !1, minimumScaleTrigger: 0.5, cropX: 0, cropY: 0, imageSmoothing: !0 }), R($r, "CSS_CANVAS", "canvas-img"), R($r, "ATTRIBUTE_NAMES", [...Ei, "x", "y", "width", "height", "preserveAspectRatio", "xlink:href", "crossOrigin", "image-rendering"]), ne.setClass($r), ne.setSVGClass($r);
ou(["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"]);
const ux = zb, N0 = (r) => function(e, t, n) {
  const { points: i, pathOffset: s } = n;
  return new B(i[r]).subtract(s).transform(wt(n.getViewportTransform(), n.calcTransformMatrix()));
}, hx = (r, e, t, n) => {
  const { target: i, pointIndex: s } = e, a = i, c = $n(new B(t, n), void 0, a.calcOwnMatrix());
  return a.points[s] = c.add(a.pathOffset), a.setDimensions(), !0;
}, dx = (r, e) => function(t, n, i, s) {
  const a = n.target, c = new B(a.points[(r > 0 ? r : a.points.length) - 1]), u = c.subtract(a.pathOffset).transform(a.calcOwnMatrix()), h = e(t, D(D({}, n), {}, { pointIndex: r }), i, s), d = c.subtract(a.pathOffset).transform(a.calcOwnMatrix()).subtract(u);
  return a.left -= d.x, a.top -= d.y, h;
}, B0 = (r) => Ti(ux, dx(r, hx)), sf = (r, e, t) => {
  const { path: n, pathOffset: i } = r, s = n[e];
  return new B(s[t] - i.x, s[t + 1] - i.y).transform(wt(r.getViewportTransform(), r.calcTransformMatrix()));
};
function MR(r, e, t) {
  const { commandIndex: n, pointIndex: i } = this;
  return sf(t, n, i);
}
function PR(r, e, t, n) {
  const { target: i } = e, { commandIndex: s, pointIndex: a } = this, c = ((u, h, d, p, g) => {
    const { path: v, pathOffset: y } = u, x = v[(p > 0 ? p : v.length) - 1], _ = new B(x[g], x[g + 1]), C = _.subtract(y).transform(u.calcOwnMatrix()), E = $n(new B(h, d), void 0, u.calcOwnMatrix());
    v[p][g] = E.x + y.x, v[p][g + 1] = E.y + y.y, u.setDimensions();
    const k = _.subtract(u.pathOffset).transform(u.calcOwnMatrix()).subtract(C);
    return u.left -= k.x, u.top -= k.y, u.set("dirty", !0), !0;
  })(i, t, n, s, a);
  return op(this.actionName, D(D({}, ap(r, e, t, n)), {}, { commandIndex: s, pointIndex: a })), c;
}
class fx extends gt {
  constructor(e) {
    super(e);
  }
  render(e, t, n, i, s) {
    const a = D(D({}, i), {}, { cornerColor: this.controlFill, cornerStrokeColor: this.controlStroke, transparentCorners: !this.controlFill });
    super.render(e, t, n, a, s);
  }
}
class DR extends fx {
  constructor(e) {
    super(e);
  }
  render(e, t, n, i, s) {
    const { path: a } = s, { commandIndex: c, pointIndex: u, connectToCommandIndex: h, connectToPointIndex: d } = this;
    e.save(), e.strokeStyle = this.controlStroke, this.connectionDashArray && e.setLineDash(this.connectionDashArray);
    const [p] = a[c], g = sf(s, h, d);
    if (p === "Q") {
      const v = sf(s, c, u + 2);
      e.moveTo(v.x, v.y), e.lineTo(t, n);
    } else e.moveTo(t, n);
    e.lineTo(g.x, g.y), e.stroke(), e.restore(), super.render(e, t, n, i, s);
  }
}
const Dc = (r, e, t, n, i, s) => new (t ? DR : fx)(D(D({ commandIndex: r, pointIndex: e, actionName: "modifyPath", positionHandler: MR, actionHandler: PR, connectToCommandIndex: i, connectToPointIndex: s }, n), t ? n.controlPointStyle : n.pointStyle));
var Kt = Object.freeze({ __proto__: null, changeWidth: qd, createObjectDefaultControls: fp, createPathControls: function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = {};
  let n = "M";
  return r.path.forEach((i, s) => {
    const a = i[0];
    switch (a !== "Z" && (t["c_".concat(s, "_").concat(a)] = Dc(s, i.length - 2, !1, e)), a) {
      case "C":
        t["c_".concat(s, "_C_CP_1")] = Dc(s, 1, !0, e, s - 1, /* @__PURE__ */ ((c) => c === "C" ? 5 : c === "Q" ? 3 : 1)(n)), t["c_".concat(s, "_C_CP_2")] = Dc(s, 3, !0, e, s, 5);
        break;
      case "Q":
        t["c_".concat(s, "_Q_CP_1")] = Dc(s, 1, !0, e, s, 3);
    }
    n = a;
  }), t;
}, createPolyActionHandler: B0, createPolyControls: function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = {};
  for (let n = 0; n < (typeof r == "number" ? r : r.points.length); n++) t["p".concat(n)] = new gt(D({ actionName: ux, positionHandler: N0(n), actionHandler: B0(n) }, e));
  return t;
}, createPolyPositionHandler: N0, createResizeControls: Ew, createTextboxDefaultControls: kw, dragHandler: aw, factoryPolyActionHandler: dx, getLocalPoint: su, polyActionHandler: hx, renderCircleControl: pw, renderSquareControl: gw, rotationStyleHandler: mw, rotationWithSnapping: vw, scaleCursorStyleHandler: Ns, scaleOrSkewActionName: Uo, scaleSkewCursorStyleHandler: Xi, scalingEqually: Ho, scalingX: ww, scalingXOrSkewingY: Kd, scalingY: xw, scalingYOrSkewingX: Zd, skewCursorStyleHandler: _w, skewHandlerX: Cw, skewHandlerY: Tw, wrapWithFireEvent: Ti, wrapWithFixedAnchor: ps });
const fu = (r) => r.webgl !== void 0, yp = "precision highp float", RR = `
    `.concat(yp, `;
    varying vec2 vTexCoord;
    uniform sampler2D uTexture;
    void main() {
      gl_FragColor = texture2D(uTexture, vTexCoord);
    }`), jR = ["type"], FR = ["type"], LR = new RegExp(yp, "g");
class Nt {
  get type() {
    return this.constructor.type;
  }
  constructor() {
    let e = ht(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, jR);
    Object.assign(this, this.constructor.defaults, e);
  }
  getFragmentSource() {
    return RR;
  }
  getVertexSource() {
    return `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    void main() {
      vTexCoord = aPosition;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }`;
  }
  createProgram(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getFragmentSource(), n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.getVertexSource();
    const { WebGLProbe: { GLPrecision: i = "highp" } } = En();
    i !== "highp" && (t = t.replace(LR, yp.replace("highp", i)));
    const s = e.createShader(e.VERTEX_SHADER), a = e.createShader(e.FRAGMENT_SHADER), c = e.createProgram();
    if (!s || !a || !c) throw new xn("Vertex, fragment shader or program creation error");
    if (e.shaderSource(s, n), e.compileShader(s), !e.getShaderParameter(s, e.COMPILE_STATUS)) throw new xn("Vertex shader compile error for ".concat(this.type, ": ").concat(e.getShaderInfoLog(s)));
    if (e.shaderSource(a, t), e.compileShader(a), !e.getShaderParameter(a, e.COMPILE_STATUS)) throw new xn("Fragment shader compile error for ".concat(this.type, ": ").concat(e.getShaderInfoLog(a)));
    if (e.attachShader(c, s), e.attachShader(c, a), e.linkProgram(c), !e.getProgramParameter(c, e.LINK_STATUS)) throw new xn('Shader link error for "'.concat(this.type, '" ').concat(e.getProgramInfoLog(c)));
    const u = this.getUniformLocations(e, c) || {};
    return u.uStepW = e.getUniformLocation(c, "uStepW"), u.uStepH = e.getUniformLocation(c, "uStepH"), { program: c, attributeLocations: this.getAttributeLocations(e, c), uniformLocations: u };
  }
  getAttributeLocations(e, t) {
    return { aPosition: e.getAttribLocation(t, "aPosition") };
  }
  getUniformLocations(e, t) {
    const n = this.constructor.uniformLocations, i = {};
    for (let s = 0; s < n.length; s++) i[n[s]] = e.getUniformLocation(t, n[s]);
    return i;
  }
  sendAttributeData(e, t, n) {
    const i = t.aPosition, s = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, s), e.enableVertexAttribArray(i), e.vertexAttribPointer(i, 2, e.FLOAT, !1, 0, 0), e.bufferData(e.ARRAY_BUFFER, n, e.STATIC_DRAW);
  }
  _setupFrameBuffer(e) {
    const t = e.context;
    if (e.passes > 1) {
      const n = e.destinationWidth, i = e.destinationHeight;
      e.sourceWidth === n && e.sourceHeight === i || (t.deleteTexture(e.targetTexture), e.targetTexture = e.filterBackend.createTexture(t, n, i)), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e.targetTexture, 0);
    } else t.bindFramebuffer(t.FRAMEBUFFER, null), t.finish();
  }
  _swapTextures(e) {
    e.passes--, e.pass++;
    const t = e.targetTexture;
    e.targetTexture = e.sourceTexture, e.sourceTexture = t;
  }
  isNeutralState(e) {
    return !1;
  }
  applyTo(e) {
    fu(e) ? (this._setupFrameBuffer(e), this.applyToWebGL(e), this._swapTextures(e)) : this.applyTo2d(e);
  }
  applyTo2d(e) {
  }
  getCacheKey() {
    return this.type;
  }
  retrieveShader(e) {
    const t = this.getCacheKey();
    return e.programCache[t] || (e.programCache[t] = this.createProgram(e.context)), e.programCache[t];
  }
  applyToWebGL(e) {
    const t = e.context, n = this.retrieveShader(e);
    e.pass === 0 && e.originalTexture ? t.bindTexture(t.TEXTURE_2D, e.originalTexture) : t.bindTexture(t.TEXTURE_2D, e.sourceTexture), t.useProgram(n.program), this.sendAttributeData(t, n.attributeLocations, e.aPosition), t.uniform1f(n.uniformLocations.uStepW, 1 / e.sourceWidth), t.uniform1f(n.uniformLocations.uStepH, 1 / e.sourceHeight), this.sendUniformData(t, n.uniformLocations), t.viewport(0, 0, e.destinationWidth, e.destinationHeight), t.drawArrays(t.TRIANGLE_STRIP, 0, 4);
  }
  bindAdditionalTexture(e, t, n) {
    e.activeTexture(n), e.bindTexture(e.TEXTURE_2D, t), e.activeTexture(e.TEXTURE0);
  }
  unbindAdditionalTexture(e, t) {
    e.activeTexture(t), e.bindTexture(e.TEXTURE_2D, null), e.activeTexture(e.TEXTURE0);
  }
  sendUniformData(e, t) {
  }
  createHelpLayer(e) {
    if (!e.helpLayer) {
      const { sourceWidth: t, sourceHeight: n } = e, i = un({ width: t, height: n });
      e.helpLayer = i;
    }
  }
  toObject() {
    const e = Object.keys(this.constructor.defaults || {});
    return D({ type: this.type }, e.reduce((t, n) => (t[n] = this[n], t), {}));
  }
  toJSON() {
    return this.toObject();
  }
  static async fromObject(e, t) {
    return new this(ht(e, FR));
  }
}
R(Nt, "type", "BaseFilter"), R(Nt, "uniformLocations", []);
const NR = { multiply: `gl_FragColor.rgb *= uColor.rgb;
`, screen: `gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);
`, add: `gl_FragColor.rgb += uColor.rgb;
`, difference: `gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);
`, subtract: `gl_FragColor.rgb -= uColor.rgb;
`, lighten: `gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);
`, darken: `gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);
`, exclusion: `gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);
`, overlay: `
    if (uColor.r < 0.5) {
      gl_FragColor.r *= 2.0 * uColor.r;
    } else {
      gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);
    }
    if (uColor.g < 0.5) {
      gl_FragColor.g *= 2.0 * uColor.g;
    } else {
      gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);
    }
    if (uColor.b < 0.5) {
      gl_FragColor.b *= 2.0 * uColor.b;
    } else {
      gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);
    }
    `, tint: `
    gl_FragColor.rgb *= (1.0 - uColor.a);
    gl_FragColor.rgb += uColor.rgb;
    ` };
class Rc extends Nt {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return `
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec4 uColor;
      varying vec2 vTexCoord;
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        gl_FragColor = color;
        if (color.a > 0.0) {
          `.concat(NR[this.mode], `
        }
      }
      `);
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = new Qe(this.color).getSource(), i = this.alpha, s = n[0] * i, a = n[1] * i, c = n[2] * i, u = 1 - i;
    for (let h = 0; h < t.length; h += 4) {
      const d = t[h], p = t[h + 1], g = t[h + 2];
      let v, y, x;
      switch (this.mode) {
        case "multiply":
          v = d * s / 255, y = p * a / 255, x = g * c / 255;
          break;
        case "screen":
          v = 255 - (255 - d) * (255 - s) / 255, y = 255 - (255 - p) * (255 - a) / 255, x = 255 - (255 - g) * (255 - c) / 255;
          break;
        case "add":
          v = d + s, y = p + a, x = g + c;
          break;
        case "difference":
          v = Math.abs(d - s), y = Math.abs(p - a), x = Math.abs(g - c);
          break;
        case "subtract":
          v = d - s, y = p - a, x = g - c;
          break;
        case "darken":
          v = Math.min(d, s), y = Math.min(p, a), x = Math.min(g, c);
          break;
        case "lighten":
          v = Math.max(d, s), y = Math.max(p, a), x = Math.max(g, c);
          break;
        case "overlay":
          v = s < 128 ? 2 * d * s / 255 : 255 - 2 * (255 - d) * (255 - s) / 255, y = a < 128 ? 2 * p * a / 255 : 255 - 2 * (255 - p) * (255 - a) / 255, x = c < 128 ? 2 * g * c / 255 : 255 - 2 * (255 - g) * (255 - c) / 255;
          break;
        case "exclusion":
          v = s + d - 2 * s * d / 255, y = a + p - 2 * a * p / 255, x = c + g - 2 * c * g / 255;
          break;
        case "tint":
          v = s + d * u, y = a + p * u, x = c + g * u;
      }
      t[h] = v, t[h + 1] = y, t[h + 2] = x;
    }
  }
  sendUniformData(e, t) {
    const n = new Qe(this.color).getSource();
    n[0] = this.alpha * n[0] / 255, n[1] = this.alpha * n[1] / 255, n[2] = this.alpha * n[2] / 255, n[3] = this.alpha, e.uniform4fv(t.uColor, n);
  }
}
R(Rc, "defaults", { color: "#F95C63", mode: "multiply", alpha: 1 }), R(Rc, "type", "BlendColor"), R(Rc, "uniformLocations", ["uColor"]), ne.setClass(Rc);
const BR = { multiply: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.rgba *= color2.rgba;
      gl_FragColor = color;
    }
    `, mask: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.a = color2.a;
      gl_FragColor = color;
    }
    ` }, VR = ["type", "image"];
class jc extends Nt {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return BR[this.mode];
  }
  getVertexSource() {
    return `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    uniform mat3 uTransformMatrix;
    void main() {
      vTexCoord = aPosition;
      vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }
    `;
  }
  applyToWebGL(e) {
    const t = e.context, n = this.createTexture(e.filterBackend, this.image);
    this.bindAdditionalTexture(t, n, t.TEXTURE1), super.applyToWebGL(e), this.unbindAdditionalTexture(t, t.TEXTURE1);
  }
  createTexture(e, t) {
    return e.getCachedTexture(t.cacheKey, t.getElement());
  }
  calculateMatrix() {
    const e = this.image, { width: t, height: n } = e.getElement();
    return [1 / e.scaleX, 0, 0, 0, 1 / e.scaleY, 0, -e.left / t, -e.top / n, 1];
  }
  applyTo2d(e) {
    let { imageData: { data: t, width: n, height: i }, filterBackend: { resources: s } } = e;
    const a = this.image;
    s.blendImage || (s.blendImage = Gr());
    const c = s.blendImage, u = c.getContext("2d");
    c.width !== n || c.height !== i ? (c.width = n, c.height = i) : u.clearRect(0, 0, n, i), u.setTransform(a.scaleX, 0, 0, a.scaleY, a.left, a.top), u.drawImage(a.getElement(), 0, 0, n, i);
    const h = u.getImageData(0, 0, n, i).data;
    for (let d = 0; d < t.length; d += 4) {
      const p = t[d], g = t[d + 1], v = t[d + 2], y = t[d + 3], x = h[d], _ = h[d + 1], C = h[d + 2], E = h[d + 3];
      switch (this.mode) {
        case "multiply":
          t[d] = p * x / 255, t[d + 1] = g * _ / 255, t[d + 2] = v * C / 255, t[d + 3] = y * E / 255;
          break;
        case "mask":
          t[d + 3] = E;
      }
    }
  }
  sendUniformData(e, t) {
    const n = this.calculateMatrix();
    e.uniform1i(t.uImage, 1), e.uniformMatrix3fv(t.uTransformMatrix, !1, n);
  }
  toObject() {
    return D(D({}, super.toObject()), {}, { image: this.image && this.image.toObject() });
  }
  static async fromObject(e, t) {
    let { type: n, image: i } = e, s = ht(e, VR);
    return $r.fromObject(i, t).then((a) => new this(D(D({}, s), {}, { image: a })));
  }
}
R(jc, "type", "BlendImage"), R(jc, "defaults", { mode: "multiply", alpha: 1 }), R(jc, "uniformLocations", ["uTransformMatrix", "uImage"]), ne.setClass(jc);
class Fc extends Nt {
  getFragmentSource() {
    return `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uDelta;
    varying vec2 vTexCoord;
    const float nSamples = 15.0;
    vec3 v3offset = vec3(12.9898, 78.233, 151.7182);
    float random(vec3 scale) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);
    }
    void main() {
      vec4 color = vec4(0.0);
      float total = 0.0;
      float offset = random(v3offset);
      for (float t = -nSamples; t <= nSamples; t++) {
        float percent = (t + offset - 0.5) / nSamples;
        float weight = 1.0 - abs(percent);
        color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;
        total += weight;
      }
      gl_FragColor = color / total;
    }
  `;
  }
  applyTo(e) {
    fu(e) ? (this.aspectRatio = e.sourceWidth / e.sourceHeight, e.passes++, this._setupFrameBuffer(e), this.horizontal = !0, this.applyToWebGL(e), this._swapTextures(e), this._setupFrameBuffer(e), this.horizontal = !1, this.applyToWebGL(e), this._swapTextures(e)) : this.applyTo2d(e);
  }
  applyTo2d(e) {
    e.imageData = this.simpleBlur(e);
  }
  simpleBlur(e) {
    let { ctx: t, imageData: n, filterBackend: { resources: i } } = e;
    const { width: s, height: a } = n;
    i.blurLayer1 || (i.blurLayer1 = Gr(), i.blurLayer2 = Gr());
    const c = i.blurLayer1, u = i.blurLayer2;
    c.width === s && c.height === a || (u.width = c.width = s, u.height = c.height = a);
    const h = c.getContext("2d"), d = u.getContext("2d"), p = 15, g = 0.06 * this.blur * 0.5;
    let v, y, x, _;
    for (h.putImageData(n, 0, 0), d.clearRect(0, 0, s, a), _ = -15; _ <= p; _++) v = (Math.random() - 0.5) / 4, y = _ / p, x = g * y * s + v, d.globalAlpha = 1 - Math.abs(y), d.drawImage(c, x, v), h.drawImage(u, 0, 0), d.globalAlpha = 1, d.clearRect(0, 0, u.width, u.height);
    for (_ = -15; _ <= p; _++) v = (Math.random() - 0.5) / 4, y = _ / p, x = g * y * a + v, d.globalAlpha = 1 - Math.abs(y), d.drawImage(c, v, x), h.drawImage(u, 0, 0), d.globalAlpha = 1, d.clearRect(0, 0, u.width, u.height);
    t.drawImage(c, 0, 0);
    const C = t.getImageData(0, 0, c.width, c.height);
    return h.globalAlpha = 1, h.clearRect(0, 0, c.width, c.height), C;
  }
  sendUniformData(e, t) {
    const n = this.chooseRightDelta();
    e.uniform2fv(t.uDelta, n);
  }
  isNeutralState() {
    return this.blur === 0;
  }
  chooseRightDelta() {
    let e = 1;
    const t = [0, 0];
    this.horizontal ? this.aspectRatio > 1 && (e = 1 / this.aspectRatio) : this.aspectRatio < 1 && (e = this.aspectRatio);
    const n = e * this.blur * 0.12;
    return this.horizontal ? t[0] = n : t[1] = n, t;
  }
}
R(Fc, "type", "Blur"), R(Fc, "defaults", { blur: 0 }), R(Fc, "uniformLocations", ["uDelta"]), ne.setClass(Fc);
class Lc extends Nt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBrightness;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += uBrightness;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = Math.round(255 * this.brightness);
    for (let i = 0; i < t.length; i += 4) t[i] += n, t[i + 1] += n, t[i + 2] += n;
  }
  isNeutralState() {
    return this.brightness === 0;
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uBrightness, this.brightness);
  }
}
R(Lc, "type", "Brightness"), R(Lc, "defaults", { brightness: 0 }), R(Lc, "uniformLocations", ["uBrightness"]), ne.setClass(Lc);
const px = { matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], colorsOnly: !0 };
class Vs extends Nt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  varying vec2 vTexCoord;
  uniform mat4 uColorMatrix;
  uniform vec4 uConstants;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color *= uColorMatrix;
    color += uConstants;
    gl_FragColor = color;
  }`;
  }
  applyTo2d(e) {
    const t = e.imageData.data, n = this.matrix, i = this.colorsOnly;
    for (let s = 0; s < t.length; s += 4) {
      const a = t[s], c = t[s + 1], u = t[s + 2];
      if (t[s] = a * n[0] + c * n[1] + u * n[2] + 255 * n[4], t[s + 1] = a * n[5] + c * n[6] + u * n[7] + 255 * n[9], t[s + 2] = a * n[10] + c * n[11] + u * n[12] + 255 * n[14], !i) {
        const h = t[s + 3];
        t[s] += h * n[3], t[s + 1] += h * n[8], t[s + 2] += h * n[13], t[s + 3] = a * n[15] + c * n[16] + u * n[17] + h * n[18] + 255 * n[19];
      }
    }
  }
  sendUniformData(e, t) {
    const n = this.matrix, i = [n[0], n[1], n[2], n[3], n[5], n[6], n[7], n[8], n[10], n[11], n[12], n[13], n[15], n[16], n[17], n[18]], s = [n[4], n[9], n[14], n[19]];
    e.uniformMatrix4fv(t.uColorMatrix, !1, i), e.uniform4fv(t.uConstants, s);
  }
  toObject() {
    return D(D({}, super.toObject()), {}, { matrix: [...this.matrix] });
  }
}
function gs(r, e) {
  var t;
  const n = (R(t = class extends Vs {
    toObject() {
      return { type: this.type, colorsOnly: this.colorsOnly };
    }
  }, "type", r), R(t, "defaults", { colorsOnly: !1, matrix: e }), t);
  return ne.setClass(n, r), n;
}
R(Vs, "type", "ColorMatrix"), R(Vs, "defaults", px), R(Vs, "uniformLocations", ["uColorMatrix", "uConstants"]), ne.setClass(Vs);
gs("Brownie", [0.5997, 0.34553, -0.27082, 0, 0.186, -0.0377, 0.86095, 0.15059, 0, -0.1449, 0.24113, -0.07441, 0.44972, 0, -0.02965, 0, 0, 0, 1, 0]);
gs("Vintage", [0.62793, 0.32021, -0.03965, 0, 0.03784, 0.02578, 0.64411, 0.03259, 0, 0.02926, 0.0466, -0.08512, 0.52416, 0, 0.02023, 0, 0, 0, 1, 0]);
gs("Kodachrome", [1.12855, -0.39673, -0.03992, 0, 0.24991, -0.16404, 1.08352, -0.05498, 0, 0.09698, -0.16786, -0.56034, 1.60148, 0, 0.13972, 0, 0, 0, 1, 0]);
gs("Technicolor", [1.91252, -0.85453, -0.09155, 0, 0.04624, -0.30878, 1.76589, -0.10601, 0, -0.27589, -0.2311, -0.75018, 1.84759, 0, 0.12137, 0, 0, 0, 1, 0]);
gs("Polaroid", [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0]);
gs("Sepia", [0.393, 0.769, 0.189, 0, 0, 0.349, 0.686, 0.168, 0, 0, 0.272, 0.534, 0.131, 0, 0, 0, 0, 0, 1, 0]);
gs("BlackWhite", [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0]);
class V0 extends Nt {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e), this.subFilters = e.subFilters || [];
  }
  applyTo(e) {
    fu(e) && (e.passes += this.subFilters.length - 1), this.subFilters.forEach((t) => {
      t.applyTo(e);
    });
  }
  toObject() {
    return { type: this.type, subFilters: this.subFilters.map((e) => e.toObject()) };
  }
  isNeutralState() {
    return !this.subFilters.some((e) => !e.isNeutralState());
  }
  static fromObject(e, t) {
    return Promise.all((e.subFilters || []).map((n) => ne.getClass(n.type).fromObject(n, t))).then((n) => new this({ subFilters: n }));
  }
}
R(V0, "type", "Composed"), ne.setClass(V0);
class Nc extends Nt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uContrast;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));
    color.rgb = contrastF * (color.rgb - 0.5) + 0.5;
    gl_FragColor = color;
  }`;
  }
  isNeutralState() {
    return this.contrast === 0;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = Math.floor(255 * this.contrast), i = 259 * (n + 255) / (255 * (259 - n));
    for (let s = 0; s < t.length; s += 4) t[s] = i * (t[s] - 128) + 128, t[s + 1] = i * (t[s + 1] - 128) + 128, t[s + 2] = i * (t[s + 2] - 128) + 128;
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uContrast, this.contrast);
  }
}
R(Nc, "type", "Contrast"), R(Nc, "defaults", { contrast: 0 }), R(Nc, "uniformLocations", ["uContrast"]), ne.setClass(Nc);
const zR = { Convolute_3_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_3_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_5_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_5_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_7_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_7_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_9_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_9_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    ` };
class Bc extends Nt {
  getCacheKey() {
    return "".concat(this.type, "_").concat(Math.sqrt(this.matrix.length), "_").concat(this.opaque ? 1 : 0);
  }
  getFragmentSource() {
    return zR[this.getCacheKey()];
  }
  applyTo2d(e) {
    const t = e.imageData, n = t.data, i = this.matrix, s = Math.round(Math.sqrt(i.length)), a = Math.floor(s / 2), c = t.width, u = t.height, h = e.ctx.createImageData(c, u), d = h.data, p = this.opaque ? 1 : 0;
    let g, v, y, x, _, C, E, k, O, P, j, V, F;
    for (j = 0; j < u; j++) for (P = 0; P < c; P++) {
      for (_ = 4 * (j * c + P), g = 0, v = 0, y = 0, x = 0, F = 0; F < s; F++) for (V = 0; V < s; V++) E = j + F - a, C = P + V - a, E < 0 || E >= u || C < 0 || C >= c || (k = 4 * (E * c + C), O = i[F * s + V], g += n[k] * O, v += n[k + 1] * O, y += n[k + 2] * O, p || (x += n[k + 3] * O));
      d[_] = g, d[_ + 1] = v, d[_ + 2] = y, d[_ + 3] = p ? n[_ + 3] : x;
    }
    e.imageData = h;
  }
  sendUniformData(e, t) {
    e.uniform1fv(t.uMatrix, this.matrix);
  }
  toObject() {
    return D(D({}, super.toObject()), {}, { opaque: this.opaque, matrix: [...this.matrix] });
  }
}
R(Bc, "type", "Convolute"), R(Bc, "defaults", { opaque: !1, matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0] }), R(Bc, "uniformLocations", ["uMatrix", "uOpaque", "uHalfSize", "uSize"]), ne.setClass(Bc);
const gx = "Gamma";
class Vc extends Nt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform vec3 uGamma;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    vec3 correction = (1.0 / uGamma);
    color.r = pow(color.r, correction.r);
    color.g = pow(color.g, correction.g);
    color.b = pow(color.b, correction.b);
    gl_FragColor = color;
    gl_FragColor.rgb *= color.a;
  }
`;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e), this.gamma = e.gamma || this.constructor.defaults.gamma.concat();
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = this.gamma, i = 1 / n[0], s = 1 / n[1], a = 1 / n[2];
    this.rgbValues || (this.rgbValues = { r: new Uint8Array(256), g: new Uint8Array(256), b: new Uint8Array(256) });
    const c = this.rgbValues;
    for (let u = 0; u < 256; u++) c.r[u] = 255 * Math.pow(u / 255, i), c.g[u] = 255 * Math.pow(u / 255, s), c.b[u] = 255 * Math.pow(u / 255, a);
    for (let u = 0; u < t.length; u += 4) t[u] = c.r[t[u]], t[u + 1] = c.g[t[u + 1]], t[u + 2] = c.b[t[u + 2]];
  }
  sendUniformData(e, t) {
    e.uniform3fv(t.uGamma, this.gamma);
  }
  isNeutralState() {
    const { gamma: e } = this;
    return e[0] === 1 && e[1] === 1 && e[2] === 1;
  }
  toObject() {
    return { type: gx, gamma: this.gamma.concat() };
  }
}
R(Vc, "type", gx), R(Vc, "defaults", { gamma: [1, 1, 1] }), R(Vc, "uniformLocations", ["uGamma"]), ne.setClass(Vc);
const WR = { average: `
    precision highp float;
    uniform sampler2D uTexture;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      float average = (color.r + color.b + color.g) / 3.0;
      gl_FragColor = vec4(average, average, average, color.a);
    }
    `, lightness: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    `, luminosity: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    ` };
class zc extends Nt {
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    for (let n, i = 0; i < t.length; i += 4) {
      const s = t[i], a = t[i + 1], c = t[i + 2];
      switch (this.mode) {
        case "average":
          n = (s + a + c) / 3;
          break;
        case "lightness":
          n = (Math.min(s, a, c) + Math.max(s, a, c)) / 2;
          break;
        case "luminosity":
          n = 0.21 * s + 0.72 * a + 0.07 * c;
      }
      t[i + 2] = t[i + 1] = t[i] = n;
    }
  }
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return WR[this.mode];
  }
  sendUniformData(e, t) {
    e.uniform1i(t.uMode, 1);
  }
  isNeutralState() {
    return !1;
  }
}
R(zc, "type", "Grayscale"), R(zc, "defaults", { mode: "average" }), R(zc, "uniformLocations", ["uMode"]), ne.setClass(zc);
const HR = D(D({}, px), {}, { rotation: 0 });
class nd extends Vs {
  calculateMatrix() {
    const e = this.rotation * Math.PI, t = cn(e), n = ln(e), i = 1 / 3, s = Math.sqrt(i) * n, a = 1 - t;
    this.matrix = [t + a / 3, i * a - s, i * a + s, 0, 0, i * a + s, t + i * a, i * a - s, 0, 0, i * a - s, i * a + s, t + i * a, 0, 0, 0, 0, 0, 1, 0];
  }
  isNeutralState() {
    return this.rotation === 0;
  }
  applyTo(e) {
    this.calculateMatrix(), super.applyTo(e);
  }
  toObject() {
    return { type: this.type, rotation: this.rotation };
  }
}
R(nd, "type", "HueRotation"), R(nd, "defaults", HR), ne.setClass(nd);
class Wc extends Nt {
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    for (let n = 0; n < t.length; n += 4) t[n] = 255 - t[n], t[n + 1] = 255 - t[n + 1], t[n + 2] = 255 - t[n + 2], this.alpha && (t[n + 3] = 255 - t[n + 3]);
  }
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform int uInvert;
  uniform int uAlpha;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    if (uInvert == 1) {
      if (uAlpha == 1) {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,1.0 -color.a);
      } else {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);
      }
    } else {
      gl_FragColor = color;
    }
  }
`;
  }
  isNeutralState() {
    return !this.invert;
  }
  sendUniformData(e, t) {
    e.uniform1i(t.uInvert, Number(this.invert)), e.uniform1i(t.uAlpha, Number(this.alpha));
  }
}
R(Wc, "type", "Invert"), R(Wc, "defaults", { alpha: !1, invert: !0 }), R(Wc, "uniformLocations", ["uInvert", "uAlpha"]), ne.setClass(Wc);
class Hc extends Nt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uStepH;
  uniform float uNoise;
  uniform float uSeed;
  varying vec2 vTexCoord;
  float rand(vec2 co, float seed, float vScale) {
    return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);
  }
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = this.noise;
    for (let i = 0; i < t.length; i += 4) {
      const s = (0.5 - Math.random()) * n;
      t[i] += s, t[i + 1] += s, t[i + 2] += s;
    }
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uNoise, this.noise / 255), e.uniform1f(t.uSeed, Math.random());
  }
  isNeutralState() {
    return this.noise === 0;
  }
}
R(Hc, "type", "Noise"), R(Hc, "defaults", { noise: 0 }), R(Hc, "uniformLocations", ["uNoise", "uSeed"]), ne.setClass(Hc);
class Uc extends Nt {
  applyTo2d(e) {
    let { imageData: { data: t, width: n, height: i } } = e;
    for (let s = 0; s < i; s += this.blocksize) for (let a = 0; a < n; a += this.blocksize) {
      const c = 4 * s * n + 4 * a, u = t[c], h = t[c + 1], d = t[c + 2], p = t[c + 3];
      for (let g = s; g < Math.min(s + this.blocksize, i); g++) for (let v = a; v < Math.min(a + this.blocksize, n); v++) {
        const y = 4 * g * n + 4 * v;
        t[y] = u, t[y + 1] = h, t[y + 2] = d, t[y + 3] = p;
      }
    }
  }
  isNeutralState() {
    return this.blocksize === 1;
  }
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBlocksize;
  uniform float uStepW;
  uniform float uStepH;
  varying vec2 vTexCoord;
  void main() {
    float blockW = uBlocksize * uStepW;
    float blockH = uBlocksize * uStepH;
    int posX = int(vTexCoord.x / blockW);
    int posY = int(vTexCoord.y / blockH);
    float fposX = float(posX);
    float fposY = float(posY);
    vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);
    vec4 color = texture2D(uTexture, squareCoords);
    gl_FragColor = color;
  }
`;
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uBlocksize, this.blocksize);
  }
}
R(Uc, "type", "Pixelate"), R(Uc, "defaults", { blocksize: 4 }), R(Uc, "uniformLocations", ["uBlocksize"]), ne.setClass(Uc);
class $c extends Nt {
  getFragmentSource() {
    return `
precision highp float;
uniform sampler2D uTexture;
uniform vec4 uLow;
uniform vec4 uHigh;
varying vec2 vTexCoord;
void main() {
  gl_FragColor = texture2D(uTexture, vTexCoord);
  if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {
    gl_FragColor.a = 0.0;
  }
}
`;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = 255 * this.distance, i = new Qe(this.color).getSource(), s = [i[0] - n, i[1] - n, i[2] - n], a = [i[0] + n, i[1] + n, i[2] + n];
    for (let c = 0; c < t.length; c += 4) {
      const u = t[c], h = t[c + 1], d = t[c + 2];
      u > s[0] && h > s[1] && d > s[2] && u < a[0] && h < a[1] && d < a[2] && (t[c + 3] = 0);
    }
  }
  sendUniformData(e, t) {
    const n = new Qe(this.color).getSource(), i = this.distance, s = [0 + n[0] / 255 - i, 0 + n[1] / 255 - i, 0 + n[2] / 255 - i, 1], a = [n[0] / 255 + i, n[1] / 255 + i, n[2] / 255 + i, 1];
    e.uniform4fv(t.uLow, s), e.uniform4fv(t.uHigh, a);
  }
}
R($c, "type", "RemoveColor"), R($c, "defaults", { color: "#FFFFFF", distance: 0.02, useAlpha: !1 }), R($c, "uniformLocations", ["uLow", "uHigh"]), ne.setClass($c);
class Yc extends Nt {
  sendUniformData(e, t) {
    e.uniform2fv(t.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), e.uniform1fv(t.uTaps, this.taps);
  }
  getFilterWindow() {
    const e = this.tempScale;
    return Math.ceil(this.lanczosLobes / e);
  }
  getCacheKey() {
    const e = this.getFilterWindow();
    return "".concat(this.type, "_").concat(e);
  }
  getFragmentSource() {
    const e = this.getFilterWindow();
    return this.generateShader(e);
  }
  getTaps() {
    const e = this.lanczosCreate(this.lanczosLobes), t = this.tempScale, n = this.getFilterWindow(), i = new Array(n);
    for (let s = 1; s <= n; s++) i[s - 1] = e(s * t);
    return i;
  }
  generateShader(e) {
    const t = new Array(e);
    for (let n = 1; n <= e; n++) t[n - 1] = "".concat(n, ".0 * uDelta");
    return `
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec2 uDelta;
      varying vec2 vTexCoord;
      uniform float uTaps[`.concat(e, `];
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        float sum = 1.0;
        `).concat(t.map((n, i) => `
              color += texture2D(uTexture, vTexCoord + `.concat(n, ") * uTaps[").concat(i, "] + texture2D(uTexture, vTexCoord - ").concat(n, ") * uTaps[").concat(i, `];
              sum += 2.0 * uTaps[`).concat(i, `];
            `)).join(`
`), `
        gl_FragColor = color / sum;
      }
    `);
  }
  applyToForWebgl(e) {
    e.passes++, this.width = e.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = e.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), e.destinationWidth = this.dW, super.applyTo(e), e.sourceWidth = e.destinationWidth, this.height = e.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), e.destinationHeight = this.dH, super.applyTo(e), e.sourceHeight = e.destinationHeight;
  }
  applyTo(e) {
    fu(e) ? this.applyToForWebgl(e) : this.applyTo2d(e);
  }
  isNeutralState() {
    return this.scaleX === 1 && this.scaleY === 1;
  }
  lanczosCreate(e) {
    return (t) => {
      if (t >= e || t <= -e) return 0;
      if (t < 11920929e-14 && t > -11920929e-14) return 1;
      const n = (t *= Math.PI) / e;
      return Math.sin(t) / t * Math.sin(n) / n;
    };
  }
  applyTo2d(e) {
    const t = e.imageData, n = this.scaleX, i = this.scaleY;
    this.rcpScaleX = 1 / n, this.rcpScaleY = 1 / i;
    const s = t.width, a = t.height, c = Math.round(s * n), u = Math.round(a * i);
    let h;
    h = this.resizeType === "sliceHack" ? this.sliceByTwo(e, s, a, c, u) : this.resizeType === "hermite" ? this.hermiteFastResize(e, s, a, c, u) : this.resizeType === "bilinear" ? this.bilinearFiltering(e, s, a, c, u) : this.resizeType === "lanczos" ? this.lanczosResize(e, s, a, c, u) : new ImageData(c, u), e.imageData = h;
  }
  sliceByTwo(e, t, n, i, s) {
    const a = e.imageData, c = 0.5;
    let u = !1, h = !1, d = t * c, p = n * c;
    const g = e.filterBackend.resources;
    let v = 0, y = 0;
    const x = t;
    let _ = 0;
    g.sliceByTwo || (g.sliceByTwo = Gr());
    const C = g.sliceByTwo;
    (C.width < 1.5 * t || C.height < n) && (C.width = 1.5 * t, C.height = n);
    const E = C.getContext("2d");
    for (E.clearRect(0, 0, 1.5 * t, n), E.putImageData(a, 0, 0), i = Math.floor(i), s = Math.floor(s); !u || !h; ) t = d, n = p, i < Math.floor(d * c) ? d = Math.floor(d * c) : (d = i, u = !0), s < Math.floor(p * c) ? p = Math.floor(p * c) : (p = s, h = !0), E.drawImage(C, v, y, t, n, x, _, d, p), v = x, y = _, _ += p;
    return E.getImageData(v, y, i, s);
  }
  lanczosResize(e, t, n, i, s) {
    const a = e.imageData.data, c = e.ctx.createImageData(i, s), u = c.data, h = this.lanczosCreate(this.lanczosLobes), d = this.rcpScaleX, p = this.rcpScaleY, g = 2 / this.rcpScaleX, v = 2 / this.rcpScaleY, y = Math.ceil(d * this.lanczosLobes / 2), x = Math.ceil(p * this.lanczosLobes / 2), _ = {}, C = { x: 0, y: 0 }, E = { x: 0, y: 0 };
    return function k(O) {
      let P, j, V, F, $, z, G, H, Y, te, ge;
      for (C.x = (O + 0.5) * d, E.x = Math.floor(C.x), P = 0; P < s; P++) {
        for (C.y = (P + 0.5) * p, E.y = Math.floor(C.y), $ = 0, z = 0, G = 0, H = 0, Y = 0, j = E.x - y; j <= E.x + y; j++) if (!(j < 0 || j >= t)) {
          te = Math.floor(1e3 * Math.abs(j - C.x)), _[te] || (_[te] = {});
          for (let Z = E.y - x; Z <= E.y + x; Z++) Z < 0 || Z >= n || (ge = Math.floor(1e3 * Math.abs(Z - C.y)), _[te][ge] || (_[te][ge] = h(Math.sqrt(Math.pow(te * g, 2) + Math.pow(ge * v, 2)) / 1e3)), V = _[te][ge], V > 0 && (F = 4 * (Z * t + j), $ += V, z += V * a[F], G += V * a[F + 1], H += V * a[F + 2], Y += V * a[F + 3]));
        }
        F = 4 * (P * i + O), u[F] = z / $, u[F + 1] = G / $, u[F + 2] = H / $, u[F + 3] = Y / $;
      }
      return ++O < i ? k(O) : c;
    }(0);
  }
  bilinearFiltering(e, t, n, i, s) {
    let a, c, u, h, d, p, g, v, y, x, _, C, E, k = 0;
    const O = this.rcpScaleX, P = this.rcpScaleY, j = 4 * (t - 1), V = e.imageData.data, F = e.ctx.createImageData(i, s), $ = F.data;
    for (g = 0; g < s; g++) for (v = 0; v < i; v++) for (d = Math.floor(O * v), p = Math.floor(P * g), y = O * v - d, x = P * g - p, E = 4 * (p * t + d), _ = 0; _ < 4; _++) a = V[E + _], c = V[E + 4 + _], u = V[E + j + _], h = V[E + j + 4 + _], C = a * (1 - y) * (1 - x) + c * y * (1 - x) + u * x * (1 - y) + h * y * x, $[k++] = C;
    return F;
  }
  hermiteFastResize(e, t, n, i, s) {
    const a = this.rcpScaleX, c = this.rcpScaleY, u = Math.ceil(a / 2), h = Math.ceil(c / 2), d = e.imageData.data, p = e.ctx.createImageData(i, s), g = p.data;
    for (let v = 0; v < s; v++) for (let y = 0; y < i; y++) {
      const x = 4 * (y + v * i);
      let _ = 0, C = 0, E = 0, k = 0, O = 0, P = 0, j = 0;
      const V = (v + 0.5) * c;
      for (let F = Math.floor(v * c); F < (v + 1) * c; F++) {
        const $ = Math.abs(V - (F + 0.5)) / h, z = (y + 0.5) * a, G = $ * $;
        for (let H = Math.floor(y * a); H < (y + 1) * a; H++) {
          let Y = Math.abs(z - (H + 0.5)) / u;
          const te = Math.sqrt(G + Y * Y);
          te > 1 && te < -1 || (_ = 2 * te * te * te - 3 * te * te + 1, _ > 0 && (Y = 4 * (H + F * t), j += _ * d[Y + 3], E += _, d[Y + 3] < 255 && (_ = _ * d[Y + 3] / 250), k += _ * d[Y], O += _ * d[Y + 1], P += _ * d[Y + 2], C += _));
        }
      }
      g[x] = k / C, g[x + 1] = O / C, g[x + 2] = P / C, g[x + 3] = j / E;
    }
    return p;
  }
}
R(Yc, "type", "Resize"), R(Yc, "defaults", { resizeType: "hermite", scaleX: 1, scaleY: 1, lanczosLobes: 3 }), R(Yc, "uniformLocations", ["uDelta", "uTaps"]), ne.setClass(Yc);
class Xc extends Nt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uSaturation;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float rgMax = max(color.r, color.g);
    float rgbMax = max(rgMax, color.b);
    color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;
    color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;
    color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = -this.saturation;
    for (let i = 0; i < t.length; i += 4) {
      const s = t[i], a = t[i + 1], c = t[i + 2], u = Math.max(s, a, c);
      t[i] += u !== s ? (u - s) * n : 0, t[i + 1] += u !== a ? (u - a) * n : 0, t[i + 2] += u !== c ? (u - c) * n : 0;
    }
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uSaturation, -this.saturation);
  }
  isNeutralState() {
    return this.saturation === 0;
  }
}
R(Xc, "type", "Saturation"), R(Xc, "defaults", { saturation: 0 }), R(Xc, "uniformLocations", ["uSaturation"]), ne.setClass(Xc);
class Gc extends Nt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uVibrance;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float max = max(color.r, max(color.g, color.b));
    float avg = (color.r + color.g + color.b) / 3.0;
    float amt = (abs(max - avg) * 2.0) * uVibrance;
    color.r += max != color.r ? (max - color.r) * amt : 0.00;
    color.g += max != color.g ? (max - color.g) * amt : 0.00;
    color.b += max != color.b ? (max - color.b) * amt : 0.00;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: t } } = e;
    const n = -this.vibrance;
    for (let i = 0; i < t.length; i += 4) {
      const s = t[i], a = t[i + 1], c = t[i + 2], u = Math.max(s, a, c), h = (s + a + c) / 3, d = 2 * Math.abs(u - h) / 255 * n;
      t[i] += u !== s ? (u - s) * d : 0, t[i + 1] += u !== a ? (u - a) * d : 0, t[i + 2] += u !== c ? (u - c) * d : 0;
    }
  }
  sendUniformData(e, t) {
    e.uniform1f(t.uVibrance, -this.vibrance);
  }
  isNeutralState() {
    return this.vibrance === 0;
  }
}
R(Gc, "type", "Vibrance"), R(Gc, "defaults", { vibrance: 0 }), R(Gc, "uniformLocations", ["uVibrance"]), ne.setClass(Gc);
class UR {
  ___eventListeners;
  ___activeObjects;
  constructor() {
    this.___activeObjects = [], this.___eventListeners = {};
  }
  pauseEventListeners() {
    this.___eventListeners = this.__eventListeners, this.__eventListeners = {};
    const e = this.getActiveObjects();
    this.discardActiveObject(), this.___activeObjects = e;
  }
  resumeEventListeners() {
    this.__eventListeners = this.___eventListeners, this.___eventListeners = {};
    const e = this.___activeObjects;
    if (!e.length)
      return this.requestRenderAll(), !1;
    if (e.length === 1)
      this.setActiveObject(e[0]);
    else {
      const t = new _n(e);
      this.setActiveObject(t);
    }
    this.requestRenderAll();
  }
}
class qs extends kt {
  isSelected = !1;
  text;
  tScale;
  display;
  id;
  backgroundColor;
  static ownDefaults = {
    rx: 6,
    ry: 6,
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 0,
    fill: "#27272a",
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    fontSize: 16,
    fontFamily: "Arial",
    fontColor: "#ffffff",
    textAlign: "center"
  };
  static type = "Text";
  constructor(e) {
    super(e), Object.assign(this, qs.ownDefaults), this.id = e.id, this.tScale = e.tScale, this.display = e.display, this.text = e.text || "", this.backgroundColor = e.backgroundColor || "transparent";
  }
  static createControls() {
    return {
      controls: mx()
    };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...qs.ownDefaults
    };
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      6
    ), e.lineWidth = 2, e.strokeStyle = "rgba(0, 216, 214,1.0)", e.stroke(), e.restore());
  }
}
function yi(r, e, t, n, i) {
  r.save(), r.translate(e, t), r.rotate(Gw.degreesToRadians(90 + i.angle)), r.beginPath(), r.lineWidth = 4, r.lineCap = "round", r.strokeStyle = "#dfe2e8", r.moveTo(-6, 0), r.lineTo(6, 0), r.stroke(), r.restore();
}
function mx() {
  return {
    mr: new gt({
      x: 0.5,
      y: 0,
      actionHandler: Cl,
      cursorStyleHandler: Kt.scaleSkewCursorStyleHandler,
      actionName: "resizing",
      render: yi
    }),
    ml: new gt({
      x: -0.5,
      y: 0,
      actionHandler: Cl,
      cursorStyleHandler: Kt.scaleSkewCursorStyleHandler,
      actionName: "resizing",
      render: yi
    })
  };
}
const Cl = Kt.wrapWithFireEvent(
  "resizing",
  Kt.wrapWithFixedAnchor((r, e, t, n) => {
    const i = Kt.getLocalPoint(
      e,
      e.originX,
      e.originY,
      t,
      n
    );
    if (YR(e.originX) || GR(e.originX) && i.x < 0 || XR(e.originX) && i.x > 0) {
      const s = e.target, a = s.strokeWidth / (s.strokeUniform ? s.scaleX : 1), c = qR(e) ? 2 : 1, u = s.width, h = Math.ceil(
        Math.abs(i.x * c / s.scaleX) - a
      );
      if (e.corner === "ml") {
        const p = u - h;
        if (s.left + p < 0)
          return s.set("width", s.width + s.left), !0;
      }
      return s.set("width", Math.max(h, 0)), u !== s.width;
    }
    return !1;
  })
), $R = {
  left: -0.5,
  top: -0.5,
  center: 0,
  bottom: 0.5,
  right: 0.5
}, Ne = (r) => typeof r == "string" ? $R[r] : r - 0.5, YR = (r) => Ne(r) === Ne("center"), XR = (r) => Ne(r) === Ne("left"), GR = (r) => Ne(r) === Ne("right");
function qR(r) {
  return Ne(r.originX) === Ne("center") && Ne(r.originY) === Ne("center");
}
ne.setClass(qs, "Text");
class hn extends kt {
  static type = "Transition";
  id;
  duration;
  fromId;
  toId;
  static ownDefaults = {
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 1.5,
    fill: "rgba(0, 0, 0, 0.5)",
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    lockMovementX: !0,
    lockMovementY: !0,
    duration: 1500,
    rx: 8,
    ry: 8
  };
  isSelected = !1;
  constructor(e) {
    super(e), this.id = e.id, this.fromId = e.fromId, this.toId = e.toId, Object.assign(this, {
      duration: e.duration,
      fromId: e.fromId,
      toId: e.toId,
      kind: e.kind,
      tScale: e.tScale,
      strokeDashArray: e.strokeDashArray || [],
      isSelected: !1,
      centeredScaling: !0,
      strokeWidth: 0
    }), Object.assign(this, hn.ownDefaults);
  }
  static createControls() {
    return {
      controls: KR()
    };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...hn.ownDefaults
    };
  }
  updateCoords() {
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  updateSelected(e) {
    e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = 2, this.strokeDashArray && e.setLineDash(this.strokeDashArray), e.strokeStyle = this.isSelected ? "rgba(255, 255, 255,1.0)" : "rgba(255, 255, 255,0.15)", e.stroke(), e.restore();
  }
}
ne.setClass(hn, "Transition");
const KR = () => ({
  mr: new gt({
    x: 0.5,
    y: 0,
    actionHandler: z0,
    cursorStyleHandler: Kt.scaleSkewCursorStyleHandler,
    actionName: "resizing",
    render: yi
  }),
  ml: new gt({
    x: -0.5,
    y: 0,
    actionHandler: z0,
    cursorStyleHandler: Kt.scaleSkewCursorStyleHandler,
    actionName: "resizing",
    render: yi
  })
});
ne.setClass(hn, "Transition");
const { wrapWithFireEvent: ZR, getLocalPoint: JR } = Kt, of = "center", QR = "left", e6 = "right";
function t6(r) {
  return (e, t, n, i) => {
    const { target: s, originX: a, originY: c } = t, u = s.getRelativeCenterPoint(), h = s.translateToOriginPoint(
      u,
      a,
      c
    ), d = r(e, t, n, i);
    return s.setPositionByOrigin(h, a, c), d;
  };
}
const r6 = (r, e, t, n) => {
  const i = JR(
    e,
    e.originX,
    e.originY,
    t,
    n
  );
  if (Ne(e.originX) === Ne(of) || Ne(e.originX) === Ne(e6) && i.x < 0 || Ne(e.originX) === Ne(QR) && i.x > 0) {
    const { target: s } = e, a = s.strokeWidth / (s.strokeUniform ? s.scaleX : 1), c = n6(e) ? 2 : 1, u = s.width, h = Math.ceil(
      Math.abs(i.x * c / s.scaleX) - a
    ), d = Ji(h, s.tScale);
    return d >= 1500 || d < 500 ? !1 : (s.set("width", Math.max(h, 0)), s.set("duration", d), s.setCoords(), s.canvas && s.canvas.renderAll(), u !== s.width);
  }
  return !1;
};
function n6(r) {
  return Ne(r.originX) === Ne(of) && Ne(r.originY) === Ne(of);
}
const z0 = ZR(
  "resizing",
  t6(r6)
);
class ca extends kt {
  static type = "Placeholder";
  guideItemId;
  distXToActCenter;
  trackItemType;
  defaultPos;
  draggedObject = null;
  for;
  id;
  static ownDefaults = {
    rx: 6,
    ry: 6,
    objectCaching: !1,
    borderColor: "transparent",
    strokeWidth: 0,
    fill: "rgba(255, 211, 42, 0.1)",
    stroke: "rgba(255, 211, 42, 1.0)",
    selectable: !1,
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    strokeDashArray: [5, 1],
    evented: !1
  };
  constructor(e) {
    super(e), this.id = e.id, this.for = e.for, Object.assign(this, ca.ownDefaults);
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...ca.ownDefaults
    };
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = 2, this.strokeDashArray && e.setLineDash(this.strokeDashArray), e.strokeStyle = "rgba(0, 216, 214,1.0)", e.stroke(), e.restore();
  }
}
ne.setClass(ca, "Placeholder");
const i6 = {
  top: { top: 35, guideHeight: 2, bottom: 3 },
  center: { top: 3, guideHeight: 2, bottom: 3 },
  bottom: { top: 3, guideHeight: 2, bottom: 35 }
}, pu = "rgba(0, 216, 214, 1.0)", id = (r, e, t) => new kt({
  top: r,
  left: 0,
  strokeWidth: 0,
  fill: "transparent",
  selectable: !0,
  height: t,
  width: e
});
class Qo extends Xr {
  static type = "Helper";
  static defaultSettings = {
    selectable: !1,
    evented: !1
  };
  static ownDefaults = { ...Qo.defaultSettings };
  guide;
  topGuide;
  bottomGuide;
  id;
  metadata = {};
  tScale;
  kind;
  constructor(e) {
    const t = i6[e.kind], n = id(0, e.width, t.top), i = id(t.top, e.width, t.guideHeight), s = id(
      t.top + t.guideHeight,
      e.width,
      t.bottom
    );
    super([n, i, s], {
      ...Qo.defaultSettings,
      ...e
    }), this.topGuide = n, this.guide = i, this.bottomGuide = s, this.id = e.id, this.metadata = e.metadata ?? {}, this.tScale = e.tScale, this.kind = e.kind;
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...Qo.defaultSettings
    };
  }
  updateCoords(e) {
    this.scaleToWidth(e), this.set("scaleY", 1);
  }
  setSelected(e) {
    this.guide.set("fill", e ? pu : "transparent");
  }
}
const Ta = Qo;
ne.setClass(Ta, "Helper");
class rs extends kt {
  static ownDefaults = {
    selectable: !1,
    evented: !1,
    strokeWidth: 0,
    stroke: "transparent"
  };
  static type = "Track";
  id;
  accepts;
  metadata;
  items;
  borderColor = "transparent";
  stroke = "transparent";
  strokeWidth = 0;
  constructor(e) {
    super(e), Object.assign(this, rs.ownDefaults), this.id = e.id, this.accepts = e.accepts || ["audio", "video", "image", "text"], this.items = e.items || [], this.metadata = e.metadata;
  }
  static getDefaults() {
    return { ...super.getDefaults(), ...rs.ownDefaults };
  }
  updateCoords(e) {
    this.width = e;
  }
}
ne.setClass(rs, "Track");
class Tl extends kt {
  isSelected;
  tScale;
  display;
  id;
  src;
  itemType;
  static ownDefaults = {
    rx: 8,
    ry: 8,
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 0,
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    fill: "#27272a"
  };
  static type = "Image";
  constructor(e) {
    super(e), this.itemType = "image", this.isSelected = !1, Object.assign(this, Tl.ownDefaults), this.id = e.id, this.src = e.src, this.display = e.display, this.tScale = e.tScale;
  }
  static createControls() {
    return {
      controls: mx()
    };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...Tl.ownDefaults
    };
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = 2, e.strokeStyle = pu, e.stroke(), e.restore());
  }
}
const bp = Tl;
ne.setClass(bp, "Image");
class po extends kt {
  id;
  tScale;
  isSelected = !1;
  display;
  trim;
  static type = "Video";
  static defaultProps = {
    objectCaching: !1,
    rx: 8,
    ry: 8,
    fill: "#27272a"
  };
  constructor(e) {
    super(Object.assign({}, po.defaultProps, e)), this.id = e.id, this.tScale = e.tScale, this.display = e.display, this.trim = e.trim;
  }
  static createControls() {
    return { controls: s6() };
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = 2, e.strokeStyle = pu, e.stroke(), e.restore());
  }
}
ne.setClass(po, "Video");
const s6 = () => ({
  mr: new gt({
    x: 0.5,
    y: 0,
    render: yi,
    actionHandler: W0,
    cursorStyleHandler: Kt.scaleSkewCursorStyleHandler,
    actionName: "resizing"
  }),
  ml: new gt({
    x: -0.5,
    y: 0,
    render: yi,
    actionHandler: W0,
    cursorStyleHandler: Kt.scaleSkewCursorStyleHandler,
    actionName: "resizing"
  })
}), { wrapWithFireEvent: o6, getLocalPoint: a6 } = Kt, c6 = (r, e, t, n) => {
  const i = a6(
    e,
    e.originX,
    e.originY,
    t,
    n
  );
  if (Ne(e.originX) === Ne("center") || Ne(e.originX) === Ne("right") && i.x < 0 || Ne(e.originX) === Ne("left") && i.x > 0) {
    const { target: s } = e;
    return s.width !== s.width;
  }
  return !1;
};
function vx(r) {
  return (e, t, n, i) => {
    const { target: s, originX: a, originY: c } = t, u = s.getRelativeCenterPoint(), h = s.translateToOriginPoint(
      u,
      a,
      c
    ), d = r(e, t, n, i);
    return s.setPositionByOrigin(h, a, c), d;
  };
}
const W0 = o6(
  "resizing",
  vx(c6)
);
class di extends kt {
  id;
  itemType = "audio";
  isSelected = !1;
  trim;
  src;
  tScale;
  display;
  static ownDefaults = {
    rx: 6,
    ry: 6,
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 0,
    fill: "#27272a",
    borderOpacityWhenMoving: 1,
    hoverCursor: "default"
  };
  static type = "Audio";
  constructor(e) {
    super({
      ...di.getDefaults(),
      ...e
    }), this.id = e.id, this.tScale = e.tScale, this.display = e.display, this.trim = e.trim, this.src = e.src;
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...di.ownDefaults
    };
  }
  static createControls() {
    return { controls: l6() };
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      di.ownDefaults.rx
    ), e.lineWidth = 2, e.strokeStyle = pu, e.stroke(), e.restore());
  }
}
ne.setClass(di, "Audio");
const l6 = () => ({
  mr: new gt({
    x: 0.5,
    y: 0,
    render: yi,
    actionHandler: H0,
    cursorStyleHandler: Kt.scaleSkewCursorStyleHandler,
    actionName: "resizing"
  }),
  ml: new gt({
    x: -0.5,
    y: 0,
    render: yi,
    actionHandler: H0,
    cursorStyleHandler: Kt.scaleSkewCursorStyleHandler,
    actionName: "resizing"
  })
}), { wrapWithFireEvent: u6, getLocalPoint: h6 } = Kt, d6 = (r, e, t, n) => {
  const i = h6(
    e,
    e.originX,
    e.originY,
    t,
    n
  );
  if (Ne(e.originX) === Ne("center") || Ne(e.originX) === Ne("right") && i.x < 0 || Ne(e.originX) === Ne("left") && i.x > 0) {
    const { target: s } = e, a = s.strokeWidth / (s.strokeUniform ? s.scaleX : 1), c = f6(e) ? 2 : 1, u = s.width, h = Math.ceil(
      Math.abs(i.x * c / s.scaleX) - a
    );
    if (e.corner === "mr") {
      const d = s.trim.to, p = h - u, g = Ji(p, s.tScale), v = d + g;
      if (v > s.duration) return !1;
      s.set("width", Math.max(h, 0)), s.trim.to = v;
    } else {
      if (s.left < 0) return !1;
      const d = u - h;
      if (s.left + d < 0)
        return s.set("width", s.width + s.left), !0;
      const p = h - u, g = s.trim.from, v = Ji(p, s.tScale), y = g - v;
      if (y < 0) return !1;
      s.set("width", Math.max(h, 0)), s.trim.from = y;
    }
    return u !== s.width;
  }
  return !1;
};
function f6(r) {
  return Ne(r.originX) === Ne("center") && Ne(r.originY) === Ne("center");
}
const H0 = u6(
  "resizing",
  vx(d6)
);
class El extends kt {
  static type = "TransitionGuide";
  static ownDefaults = {
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 1.5,
    fill: "rgba(0,0,0,0.85)",
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    lockMovementX: !0,
    lockMovementY: !0,
    duration: 1500,
    rx: 8,
    ry: 8
  };
  tScale;
  duration = 0;
  fromId;
  toId;
  itemType = "none";
  isSelected = !1;
  id;
  constructor(e) {
    super(e), Object.assign(this, El.ownDefaults), this.id = e.id;
  }
  static createControls() {
    return {
      controls: p6()
    };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...El.ownDefaults
    };
  }
  updateCoords() {
    const e = this.canvas;
    if (!e) return;
    const t = e.getObjects().find((s) => s.id === this.fromId);
    if (!t) return;
    const n = Ot(this.duration, this.tScale), i = t.left + t.width - n / 2;
    this.set({
      width: n,
      left: i
    });
  }
  _render(e) {
    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);
  }
  drawTextIdentity(e) {
    const t = new Path2D(
      "M3 5.30359C3 3.93159 4.659 3.24359 5.629 4.21359L11.997 10.5826L10.583 11.9966L5 6.41359V17.5856L10.586 11.9996L10.583 11.9966L11.997 10.5826L12 10.5856L18.371 4.21459C19.341 3.24459 21 3.93159 21 5.30359V18.6956C21 20.0676 19.341 20.7556 18.371 19.7856L12 13.5L13.414 11.9996L19 17.5866V6.41359L13.414 11.9996L13.421 12.0056L12.006 13.4206L12 13.4136L5.629 19.7846C4.659 20.7546 3 20.0676 3 18.6956V5.30359Z"
    );
    e.save(), e.translate(-12, -12), e.fillStyle = "#ffffff", e.fill(t), e.restore();
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = 1, e.strokeStyle = "rgba(255, 255, 255,1.0)", e.stroke(), e.restore());
  }
}
function p6() {
  return {
    mr: new gt({
      x: 0.5,
      y: 0,
      actionHandler: Cl,
      cursorStyleHandler: Kt.scaleSkewCursorStyleHandler,
      actionName: "resizing",
      render: U0
    }),
    ml: new gt({
      x: -0.5,
      y: 0,
      actionHandler: Cl,
      cursorStyleHandler: Kt.scaleSkewCursorStyleHandler,
      actionName: "resizing",
      render: U0
    })
  };
}
function U0(r, e, t, n, i) {
  r.save(), r.translate(e, t), r.rotate(Gw.degreesToRadians(90 + i.angle)), r.lineWidth = 6, r.lineCap = "round", r.strokeStyle = "white", r.beginPath(), r.moveTo(-6, 0), r.lineTo(6, 0), r.stroke(), r.lineWidth = 4, r.strokeStyle = "black", r.beginPath(), r.moveTo(-6, 0), r.lineTo(6, 0), r.stroke(), r.restore();
}
class kl extends kt {
  static type = "PreviewTrackItem";
  static ownDefaults = {
    objectCaching: !1,
    borderColor: "transparent",
    stroke: "transparent",
    strokeWidth: 0,
    borderOpacityWhenMoving: 1,
    hoverCursor: "default",
    rx: 4,
    ry: 4
  };
  duration = 0;
  fromId = "";
  toId = "";
  isSelected = !1;
  name;
  durationString;
  id;
  constructor(e) {
    super(e), Object.assign(this, kl.ownDefaults), this.id = e.id, this.name = e.name || "item", this.durationString = "00:05", this.fill = "#27272a";
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...kl.ownDefaults
    };
  }
  _render(e) {
    e.save(), super._render(e), e.beginPath(), e.rect(-this.width / 2, -this.height / 2, this.width, this.height), e.clip(), this.drawTextIdentity(e), e.restore();
  }
  drawTextIdentity(e) {
    e.font = "600 12px 'Geist variable'", e.textAlign = "left";
    const u = e.measureText(this.name).width, h = e.measureText(this.durationString).width, d = -this.height / 2 + 4, p = -this.width / 2, g = p + u + 8 * 2 + 4, v = u + 8 * 2;
    this.drawRoundedRect(
      e,
      p,
      d,
      v,
      20,
      4
    ), e.fillStyle = "#f4f4f5", e.fillText(this.name, p + 8, d + 12 + 2);
    const y = h + 8 * 2;
    this.drawRoundedRect(
      e,
      g,
      d,
      y,
      20,
      4
    ), e.fillStyle = "#f4f4f5", e.fillText(
      this.durationString,
      g + 8,
      d + 12 + 2
    );
  }
  drawRoundedRect(e, t, n, i, s, a) {
    e.fillStyle = "rgba(0, 0, 0, 0.5)", e.roundRect ? (e.beginPath(), e.roundRect(t, n, i, s, a), e.fill()) : e.fillRect(t, n, i, s);
  }
}
function g6(r, e) {
  e.forEach((t) => {
    Object.getOwnPropertyNames(t.prototype).forEach((n) => {
      if (n !== "constructor") {
        const i = Object.getOwnPropertyDescriptor(
          t.prototype,
          n
        );
        i && Object.defineProperty(r.prototype, n, i);
      }
    });
  });
}
const wp = (r, e) => {
  const t = {
    x: r.size.width / 2,
    y: r.size.height / 2
  }, n = {
    x: e.width / 2,
    y: e.height / 2
  }, i = t.x - n.x, s = t.y - n.y, a = Math.min(
    r.size.width / e.width,
    r.size.height / e.height
  );
  return {
    top: `${s}px`,
    left: `${i}px`,
    transform: `scale(${a})`
  };
}, m6 = (r) => new Promise((e, t) => {
  const n = new Audio();
  n.preload = "auto", n.addEventListener("loadedmetadata", () => {
    const i = n.duration * 1e3;
    e({
      duration: i
    });
  }), n.addEventListener("error", (i) => {
    t(i);
  }), n.src = r, n.crossOrigin = "anonymous", n.load();
}), v6 = (r) => new Promise((e, t) => {
  const n = new Image();
  console.warn("Consider updating CDN config for CORS issues?"), n.onload = () => {
    const i = n.width, s = n.height;
    e({ width: i, height: s });
  }, n.onerror = (i) => {
    t(i);
  }, n.crossOrigin = "anonymous", n.src = r;
}), y6 = (r) => new Promise((e, t) => {
  const n = document.createElement("video");
  n.preload = "auto", n.addEventListener("loadedmetadata", () => {
    const i = n.duration * 1e3, s = n.videoWidth, a = n.videoHeight;
    e({
      duration: i,
      width: s,
      height: a
    });
  }), n.addEventListener("error", (i) => {
    t(i);
  }), n.src = r, n.load();
}), el = (r, e) => {
  const t = document.createElement("div");
  Object.keys(e).forEach((i) => {
    i !== "height" && (t.style[i] = e[i]);
  }), document.body.appendChild(t), t.textContent = r, t.style.width = `${e.width}px`, t.style.fontSize = `${e.fontSize}px`;
  const n = getComputedStyle(t).height;
  return document.body.removeChild(t), parseFloat(n);
}, kn = (r) => Object.keys(r).reduce((e, t) => {
  const {
    display: { to: n }
  } = r[t];
  return Math.max(e, n);
}, 0), b6 = (r, e) => {
  if (!r)
    return {
      from: 0,
      to: e.duration
    };
  const { from: t, to: n } = r;
  return {
    from: t ?? 0,
    to: n ?? e.duration
  };
}, w6 = (r, e) => {
  const { duration: t, trim: n } = e, i = n ? n.to - n.from : t || 5e3, s = {
    from: 0,
    to: i
  };
  if (!r)
    return s;
  if (r.from !== void 0 && r.from < 0)
    return console.error(
      "'from' must be a non-negative number. Returning default display."
    ), s;
  if (r.from !== void 0 && r.to === void 0)
    return {
      from: r.from,
      to: r.from + i
    };
  if (r.to !== void 0) {
    if (r.to < 0)
      return console.error(
        "'to' must be a non-negative number. Returning default display."
      ), s;
    if (r.to < r.from)
      return console.error(
        "'to' must be greater than or equal to 'from'. Returning default display."
      ), s;
  }
  return r;
};
function x6(r, e) {
  return r.map((t) => {
    const n = t.items.filter(
      (i) => !e.includes(i)
    );
    return { ...t, items: n };
  }).filter((t) => t.items.length > 0);
}
const _6 = async (r, e) => {
  const t = r.details, n = await v6(t.src), i = wp(e, n);
  return {
    id: r.id,
    type: "image",
    name: "",
    display: {
      from: e.origin || 0,
      to: (e.origin || 5e3) + 5e3
    },
    details: {
      src: t.src || "",
      width: t.width || n.width || 100,
      height: t.height || n.height || 100,
      opacity: t.opacity ?? 100,
      transform: i.transform,
      border: t.border || "none",
      borderRadius: t.borderRadius || "0",
      boxShadow: t.boxShadow || "none",
      top: i.top || "0px",
      left: i.left || "0px"
    },
    metadata: r.metadata || {}
  };
}, S6 = async (r, e) => {
  const t = r.details.src, n = await y6(t), i = wp(e, {
    ...n
  }), s = b6(r.trim, { duration: n.duration }), a = {
    width: n.width,
    height: n.height,
    duration: n.duration,
    src: t,
    volume: r.details.volume ?? 100,
    top: r.details.top || i.top || "0px",
    left: r.details.left || i.left || "0px",
    text: r.details.text
    // Default volume
  };
  return {
    ...r,
    trim: s,
    type: "video",
    details: a,
    display: w6(r?.display, {
      duration: n.duration,
      trim: s
    })
  };
}, C6 = async (r) => {
  const e = r.details, t = (await m6(e.src)).duration, n = r?.display?.from ?? 0;
  return {
    id: r.id,
    name: "",
    type: "audio",
    display: {
      from: n,
      to: n + t
    },
    trim: {
      from: 0,
      to: t
    },
    details: {
      src: e.src,
      duration: t,
      volume: e.volume ?? 100,
      text: e.text
      // Default volume
    },
    metadata: {
      ...r.metadata
    }
  };
}, T6 = 5e3, yx = async (r, e) => {
  const t = r.id;
  await uA([
    {
      fontFamily: r.details.fontFamily ?? "",
      fontUrl: r.details.fontUrl ?? ""
    }
  ]);
  const n = {
    fontFamily: r.details.fontFamily ?? "Arial",
    fontSize: r.details.fontSize ?? "16px",
    fontWeight: r.details.fontWeight ?? "normal",
    fontStyle: r.details.fontStyle ?? "normal",
    textDecoration: r.details.textDecoration ?? "none",
    textAlign: r.details.textAlign ?? "left",
    lineHeight: r.details.lineHeight ?? "normal",
    letterSpacing: r.details.letterSpacing ?? "normal",
    wordSpacing: r.details.wordSpacing ?? "normal",
    color: r.details.color ?? "#ffffff",
    backgroundColor: r.details.backgroundColor ?? "transparent",
    border: r.details.border ?? "none",
    textShadow: r.details.textShadow ?? "none",
    text: r.details.text ?? "",
    opacity: r.details.opacity ?? 100,
    width: r.details.width ?? 300,
    wordWrap: r.details.wordWrap ?? "normal",
    wordBreak: r.details.wordBreak ?? "normal",
    WebkitTextStrokeColor: r.details.WebkitTextStrokeColor ?? "#ffffff",
    WebkitTextStrokeWidth: r.details.WebkitTextStrokeWidth ?? "0px",
    top: r.details.top ?? "0px",
    left: r.details.left ?? "0px"
  }, i = el(r.details.text ?? "", n), s = wp(e, {
    width: n.width ?? 0,
    height: i
  });
  return {
    id: t,
    name: "",
    type: "text",
    display: {
      from: 0,
      to: T6
    },
    details: {
      ...n,
      height: i,
      top: s.top,
      left: s.left,
      fontUrl: r.details.fontUrl,
      text: r.details.text ?? ""
    },
    metadata: {}
  };
}, E6 = (r, e) => {
  const t = r.display, n = Ot(t.from, e.tScale), i = Ot(t.to - t.from, e.tScale), s = ne.getClass("Audio") || di;
  return new s({
    width: i,
    height: 42,
    top: 10,
    left: n,
    id: r.id,
    display: t,
    text: r.details.text,
    trim: r.trim || {
      from: 0,
      to: r.details.duration
    },
    duration: r.details.duration,
    src: r.details.src,
    tScale: e.tScale
  });
}, k6 = (r, e) => {
  const t = Ot(r.display.from, e.tScale), n = Ot(r.details.duration || 5e3, e.tScale), i = ne.getClass("Image") || bp;
  return new i({
    width: n,
    height: 42,
    id: r.id,
    src: r.details.src,
    tScale: e.tScale,
    top: 10,
    left: t,
    display: r.display
  });
}, O6 = (r, e) => {
  const t = Ot(r.trim.from, e.tScale), n = Ot(r.trim.to - r.trim.from, e.tScale), i = ne.getClass("Video") || po;
  return new i({
    width: n,
    height: 42,
    id: r.id,
    tScale: e.tScale,
    fill: "#333333",
    top: 10,
    left: t,
    display: r.trim,
    trim: r.trim,
    text: r.details.text
  });
}, I6 = (r, e) => {
  const t = r.display, n = Ot(t.from, e.tScale), i = Ot(t.to - t.from, e.tScale), s = ne.getClass("Text") || qs;
  return new s({
    width: i,
    height: 42,
    id: r.id,
    display: t,
    top: 10,
    left: n,
    text: r.details.text,
    tScale: e.tScale
  });
}, A6 = {
  video: 42,
  image: 42,
  audio: 42,
  text: 42,
  caption: 42,
  template: 42
}, M6 = (r = {}) => {
  const e = { ...A6, ...r };
  return Object.fromEntries(
    Object.entries(e).filter(([, t]) => typeof t == "number")
  );
};
let P6 = class extends di {
  static type = "Audio";
  text;
  constructor(e) {
    super(e), this.text = e.text ?? "Audio";
  }
  _render(e) {
    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);
  }
  drawTextIdentity(e) {
    const t = new Path2D(
      "M8.24092 0C8.24092 2.51565 10.2795 4.55419 12.7951 4.55419C12.9677 4.55419 13.1331 4.62274 13.2552 4.74475C13.3772 4.86676 13.4457 5.03224 13.4457 5.20479C13.4457 5.37734 13.3772 5.54282 13.2552 5.66483C13.1331 5.78685 12.9677 5.85539 12.7951 5.85539C11.9218 5.85605 11.0594 5.66105 10.2713 5.28471C9.48319 4.90838 8.78942 4.36027 8.24092 3.68066V13.8794C8.24094 14.8271 7.91431 15.7458 7.31606 16.4808C6.71781 17.2157 5.88451 17.722 4.95657 17.9143C4.02863 18.1066 3.06276 17.9731 2.22172 17.5364C1.38067 17.0997 0.715856 16.3865 0.339286 15.5169C-0.0372842 14.6473 -0.10259 13.6744 0.154372 12.7622C0.411334 11.8501 0.974857 11.0544 1.74999 10.5092C2.52512 9.96403 3.46449 9.7027 4.40981 9.76924C5.35512 9.83579 6.24861 10.2261 6.93972 10.8745V0H8.24092ZM6.93972 13.8794C6.93972 13.1317 6.6427 12.4146 6.11398 11.8859C5.58527 11.3572 4.86818 11.0602 4.12046 11.0602C3.37275 11.0602 2.65566 11.3572 2.12694 11.8859C1.59823 12.4146 1.3012 13.1317 1.3012 13.8794C1.3012 14.6272 1.59823 15.3443 2.12694 15.873C2.65566 16.4017 3.37275 16.6987 4.12046 16.6987C4.86818 16.6987 5.58527 16.4017 6.11398 15.873C6.6427 15.3443 6.93972 14.6272 6.93972 13.8794Z"
    );
    e.save(), e.translate(-this.width / 2, -this.height / 2), e.translate(0, 10), e.font = "600 12px 'Geist variable'", e.fillStyle = "#f4f4f5", e.textAlign = "left", e.clip(), e.fillText(this.text, 36, 14), e.translate(10, 1), e.fillStyle = "#f4f4f5", e.fill(t), e.restore();
  }
};
class D6 extends po {
  static type = "Video";
  text;
  constructor(e) {
    super(e), this.text = e.text ?? "Video";
  }
  _render(e) {
    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);
  }
  drawTextIdentity(e) {
    const t = new Path2D(
      "M16.5625 0.925L12.5 3.275V0.625L11.875 0H0.625L0 0.625V9.375L0.625 10H11.875L12.5 9.375V6.875L16.5625 9.2125L17.5 8.625V1.475L16.5625 0.925ZM11.25 8.75H1.25V1.25H11.25V8.75ZM16.25 7.5L12.5 5.375V4.725L16.25 2.5V7.5Z"
    );
    e.save(), e.translate(-this.width / 2, -this.height / 2), e.translate(0, 14), e.font = "600 12px 'Geist variable'", e.fillStyle = "#f4f4f5", e.textAlign = "left", e.clip(), e.fillText(this.text, 36, 10), e.translate(8, 1), e.fillStyle = "#f4f4f5", e.fill(t), e.restore();
  }
}
class bx extends qs {
  static type = "Text";
  constructor(e) {
    super(e), this.fill = "#303030";
  }
  _render(e) {
    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);
  }
  drawTextIdentity(e) {
    const t = new Path2D(
      "M6.23982 0.361968C6.18894 0.253743 6.10832 0.162234 6.00736 0.0981357C5.9064 0.034038 5.78929 0 5.6697 0C5.55012 0 5.433 0.034038 5.33204 0.0981357C5.23109 0.162234 5.15046 0.253743 5.09959 0.361968L0.0599035 11.0713C0.0246926 11.1462 0.00457285 11.2272 0.000693114 11.3099C-0.00318662 11.3925 0.00924959 11.4751 0.0372917 11.553C0.0939253 11.7102 0.210687 11.8384 0.361891 11.9095C0.513095 11.9806 0.686354 11.9888 0.843555 11.9322C1.00076 11.8755 1.12902 11.7588 1.20013 11.6075L2.51202 8.81998H8.82738L10.1393 11.6075C10.1745 11.6824 10.2241 11.7496 10.2853 11.8053C10.3465 11.861 10.418 11.9041 10.4958 11.9322C10.5737 11.9602 10.6563 11.9726 10.7389 11.9687C10.8216 11.9649 10.9026 11.9447 10.9775 11.9095C11.0524 11.8743 11.1196 11.8247 11.1753 11.7635C11.231 11.7023 11.2741 11.6308 11.3021 11.553C11.3302 11.4751 11.3426 11.3925 11.3387 11.3099C11.3348 11.2272 11.3147 11.1462 11.2795 11.0713L6.23982 0.361968ZM3.10498 7.56005L5.6697 2.11011L8.23443 7.56005H3.10498ZM15.1191 3.78029C14.1143 3.78029 13.3292 4.05354 12.7859 4.59294C12.6721 4.71153 12.6092 4.86987 12.6106 5.03419C12.6119 5.19851 12.6774 5.3558 12.7931 5.4725C12.9088 5.58921 13.0655 5.6561 13.2298 5.6589C13.3941 5.6617 13.553 5.60018 13.6726 5.48748C13.9718 5.19062 14.46 5.04021 15.1191 5.04021C16.1609 5.04021 17.009 5.74892 17.009 6.61511V6.86867C16.45 6.49465 15.7917 6.29663 15.1191 6.30013C13.382 6.30013 11.9693 7.57187 11.9693 9.13495C11.9693 10.698 13.382 11.9698 15.1191 11.9698C15.792 11.9727 16.4503 11.7739 17.009 11.3989C17.0168 11.566 17.0907 11.7231 17.2144 11.8357C17.3381 11.9483 17.5014 12.0071 17.6685 11.9993C17.8356 11.9915 17.9927 11.9176 18.1053 11.7939C18.2179 11.6702 18.2767 11.5069 18.2689 11.3398V6.61511C18.2689 5.05202 16.8562 3.78029 15.1191 3.78029ZM15.1191 10.7099C14.0773 10.7099 13.2292 10.0012 13.2292 9.13495C13.2292 8.26876 14.0773 7.56005 15.1191 7.56005C16.1609 7.56005 17.009 8.26876 17.009 9.13495C17.009 10.0012 16.1609 10.7099 15.1191 10.7099Z"
    );
    e.save(), e.translate(-this.width / 2, -this.height / 2), e.translate(0, 12), e.font = "600 12px 'Geist variable'", e.fillStyle = "#f4f4f5", e.textAlign = "left", e.clip(), e.fillText(this.text, 36, 12), e.translate(8, 1), e.fillStyle = "#f4f4f5", e.fill(t), e.restore();
  }
}
let R6 = class extends bp {
  static type = "Image";
  text;
  constructor(e) {
    super(e), this.text = e.text ?? "Image";
  }
  _render(e) {
    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);
  }
  drawTextIdentity(e) {
    const t = new Path2D(
      "M1.55556 0H14.4444C15.3031 0 16 0.696889 16 1.55556V14.4444C16 14.857 15.8361 15.2527 15.5444 15.5444C15.2527 15.8361 14.857 16 14.4444 16H1.55556C1.143 16 0.747335 15.8361 0.455612 15.5444C0.163889 15.2527 0 14.857 0 14.4444V1.55556C0 0.696889 0.696889 0 1.55556 0ZM14.4444 1.33333H1.55556C1.49662 1.33333 1.4401 1.35675 1.39842 1.39842C1.35675 1.4401 1.33333 1.49662 1.33333 1.55556V14.4444C1.33333 14.5671 1.43289 14.6667 1.55556 14.6667H1.72444L10.456 5.93511C10.6004 5.79065 10.7719 5.67605 10.9607 5.59787C11.1494 5.51968 11.3517 5.47944 11.556 5.47944C11.7603 5.47944 11.9626 5.51968 12.1513 5.59787C12.3401 5.67605 12.5116 5.79065 12.656 5.93511L14.6667 7.94578V1.55556C14.6667 1.49662 14.6433 1.4401 14.6016 1.39842C14.5599 1.35675 14.5034 1.33333 14.4444 1.33333ZM14.6667 9.83111L11.7129 6.87733C11.6922 6.85664 11.6677 6.84022 11.6407 6.82902C11.6137 6.81781 11.5848 6.81205 11.5556 6.81205C11.5263 6.81205 11.4974 6.81781 11.4704 6.82902C11.4434 6.84022 11.4189 6.85664 11.3982 6.87733L3.60978 14.6667H14.4444C14.5034 14.6667 14.5599 14.6433 14.6016 14.6016C14.6433 14.5599 14.6667 14.5034 14.6667 14.4444V9.83111ZM4.88889 7.11111C4.29952 7.11111 3.73429 6.87699 3.31754 6.46024C2.90079 6.04349 2.66667 5.47826 2.66667 4.88889C2.66667 4.29952 2.90079 3.73429 3.31754 3.31754C3.73429 2.90079 4.29952 2.66667 4.88889 2.66667C5.47826 2.66667 6.04349 2.90079 6.46024 3.31754C6.87699 3.73429 7.11111 4.29952 7.11111 4.88889C7.11111 5.47826 6.87699 6.04349 6.46024 6.46024C6.04349 6.87699 5.47826 7.11111 4.88889 7.11111ZM4.88889 5.77778C5.12464 5.77778 5.35073 5.68413 5.51743 5.51743C5.68413 5.35073 5.77778 5.12464 5.77778 4.88889C5.77778 4.65314 5.68413 4.42705 5.51743 4.26035C5.35073 4.09365 5.12464 4 4.88889 4C4.65314 4 4.42705 4.09365 4.26035 4.26035C4.09365 4.42705 4 4.65314 4 4.88889C4 5.12464 4.09365 5.35073 4.26035 5.51743C4.42705 5.68413 4.65314 5.77778 4.88889 5.77778Z"
    );
    e.save(), e.translate(-this.width / 2, -this.height / 2), e.translate(0, 12), e.font = "600 12px 'Geist variable'", e.fillStyle = "#f4f4f5", e.textAlign = "left", e.clip(), e.fillText(this.text, 36, 12), e.translate(8, 1), e.fillStyle = "#f4f4f5", e.fill(t), e.restore();
  }
};
class j6 extends rs {
  static type = "Track";
  constructor(e) {
    super(e), this.fill = "#18181b";
  }
  _render(e) {
    super._render(e);
    const t = new Path2D(
      "M14.4444 13.3263H11.0667C12.5384 12.3991 13.6259 10.9716 14.1289 9.30644C14.632 7.64131 14.5169 5.85051 13.8048 4.26348C13.0927 2.67645 11.8314 1.39993 10.2531 0.668736C8.67478 -0.0624548 6.8855 -0.199136 5.21442 0.283835C3.54334 0.766806 2.10285 1.83695 1.15794 3.2974C0.213035 4.75785 -0.172743 6.51038 0.0715766 8.23261C0.315896 9.95484 1.17388 11.5309 2.4877 12.671C3.80151 13.811 5.4828 14.4383 7.22227 14.4374H14.4444C14.5918 14.4374 14.7331 14.3789 14.8373 14.2747C14.9415 14.1705 15 14.0292 15 13.8819C15 13.7345 14.9415 13.5932 14.8373 13.489C14.7331 13.3848 14.5918 13.3263 14.4444 13.3263ZM1.1112 7.21523C1.1112 6.00658 1.46961 4.82506 2.14111 3.8201C2.8126 2.81514 3.76702 2.03187 4.88367 1.56934C6.00032 1.10681 7.22905 0.985789 8.41449 1.22159C9.59992 1.45738 10.6888 2.03941 11.5435 2.89405C12.3981 3.7487 12.9801 4.83759 13.2159 6.02302C13.4517 7.20845 13.3307 8.43719 12.8682 9.55384C12.4056 10.6705 11.6224 11.6249 10.6174 12.2964C9.61244 12.9679 8.43093 13.3263 7.22227 13.3263C5.60208 13.3245 4.04878 12.68 2.90313 11.5344C1.75748 10.3887 1.11304 8.83542 1.1112 7.21523ZM7.22227 5.54858C7.55191 5.54858 7.87414 5.45083 8.14822 5.2677C8.4223 5.08456 8.63592 4.82426 8.76206 4.51972C8.88821 4.21518 8.92121 3.88007 8.85691 3.55677C8.7926 3.23347 8.63386 2.9365 8.40078 2.70342C8.16769 2.47033 7.87072 2.3116 7.54742 2.24729C7.22412 2.18298 6.88901 2.21599 6.58447 2.34213C6.27993 2.46828 6.01964 2.6819 5.8365 2.95598C5.65337 3.23006 5.55562 3.55229 5.55562 3.88192C5.55562 4.32395 5.73121 4.74787 6.04377 5.06043C6.35633 5.37298 6.78025 5.54858 7.22227 5.54858ZM7.22227 3.32637C7.33215 3.32637 7.43956 3.35895 7.53092 3.42C7.62228 3.48104 7.69349 3.56781 7.73554 3.66932C7.77759 3.77084 7.78859 3.88254 7.76715 3.9903C7.74572 4.09807 7.6928 4.19706 7.61511 4.27476C7.53741 4.35245 7.43842 4.40536 7.33066 4.4268C7.22289 4.44824 7.11119 4.43723 7.00967 4.39519C6.90816 4.35314 6.82139 4.28193 6.76035 4.19057C6.69931 4.09921 6.66672 3.9918 6.66672 3.88192C6.66672 3.73458 6.72525 3.59327 6.82944 3.48909C6.93363 3.3849 7.07493 3.32637 7.22227 3.32637ZM8.88893 10.5485C8.88893 10.2189 8.79118 9.89668 8.60805 9.6226C8.42491 9.34852 8.16462 9.1349 7.86008 9.00875C7.55553 8.88261 7.22043 8.8496 6.89713 8.91391C6.57383 8.97822 6.27686 9.13695 6.04377 9.37004C5.81069 9.60313 5.65195 9.9001 5.58764 10.2234C5.52334 10.5467 5.55634 10.8818 5.68249 11.1863C5.80863 11.4909 6.02225 11.7512 6.29633 11.9343C6.57041 12.1175 6.89264 12.2152 7.22227 12.2152C7.6643 12.2152 8.08822 12.0396 8.40078 11.727C8.71334 11.4145 8.88893 10.9906 8.88893 10.5485ZM6.66672 10.5485C6.66672 10.4387 6.69931 10.3313 6.76035 10.2399C6.82139 10.1485 6.90816 10.0773 7.00967 10.0353C7.11119 9.99323 7.22289 9.98223 7.33066 10.0037C7.43842 10.0251 7.53741 10.078 7.61511 10.1557C7.6928 10.2334 7.74572 10.3324 7.76715 10.4402C7.78859 10.5479 7.77759 10.6596 7.73554 10.7611C7.69349 10.8627 7.62228 10.9494 7.53092 11.0105C7.43956 11.0715 7.33215 11.1041 7.22227 11.1041C7.07493 11.1041 6.93363 11.0456 6.82944 10.9414C6.72525 10.8372 6.66672 10.6959 6.66672 10.5485ZM10.5556 8.88189C10.8852 8.88189 11.2074 8.78414 11.4815 8.60101C11.7556 8.41787 11.9692 8.15758 12.0954 7.85303C12.2215 7.54849 12.2545 7.21338 12.1902 6.89008C12.1259 6.56678 11.9672 6.26982 11.7341 6.03673C11.501 5.80364 11.204 5.64491 10.8807 5.5806C10.5574 5.51629 10.2223 5.5493 9.91778 5.67544C9.61324 5.80159 9.35295 6.01521 9.16981 6.28929C8.98668 6.56337 8.88893 6.8856 8.88893 7.21523C8.88893 7.65726 9.06452 8.08118 9.37708 8.39374C9.68964 8.70629 10.1136 8.88189 10.5556 8.88189ZM10.5556 6.65968C10.6655 6.65968 10.7729 6.69226 10.8642 6.75331C10.9556 6.81435 11.0268 6.90112 11.0688 7.00263C11.1109 7.10415 11.1219 7.21585 11.1005 7.32362C11.079 7.43138 11.0261 7.53037 10.9484 7.60807C10.8707 7.68576 10.7717 7.73867 10.664 7.76011C10.5562 7.78155 10.4445 7.77054 10.343 7.7285C10.2415 7.68645 10.1547 7.61524 10.0937 7.52388C10.0326 7.43252 10 7.32511 10 7.21523C10 7.06789 10.0586 6.92658 10.1628 6.8224C10.2669 6.71821 10.4082 6.65968 10.5556 6.65968ZM3.88896 5.54858C3.55933 5.54858 3.2371 5.64633 2.96302 5.82946C2.68894 6.01259 2.47532 6.27289 2.34918 6.57743C2.22303 6.88197 2.19002 7.21708 2.25433 7.54038C2.31864 7.86368 2.47737 8.16065 2.71046 8.39374C2.94355 8.62682 3.24052 8.78556 3.56382 8.84986C3.88711 8.91417 4.22222 8.88117 4.52677 8.75502C4.83131 8.62888 5.0916 8.41526 5.27474 8.14118C5.45787 7.8671 5.55562 7.54487 5.55562 7.21523C5.55562 6.77321 5.38003 6.34929 5.06747 6.03673C4.75491 5.72417 4.33099 5.54858 3.88896 5.54858ZM3.88896 7.77078C3.77909 7.77078 3.67168 7.7382 3.58032 7.67716C3.48896 7.61611 3.41775 7.52935 3.3757 7.42783C3.33365 7.32632 3.32265 7.21462 3.34409 7.10685C3.36552 6.99908 3.41843 6.90009 3.49613 6.8224C3.57382 6.7447 3.67281 6.69179 3.78058 6.67036C3.88835 6.64892 4.00005 6.65992 4.10156 6.70197C4.20308 6.74402 4.28984 6.81522 4.35089 6.90658C4.41193 6.99794 4.44452 7.10535 4.44452 7.21523C4.44452 7.36257 4.38598 7.50388 4.2818 7.60807C4.17761 7.71225 4.03631 7.77078 3.88896 7.77078Z"
    );
    this.items.length || (e.save(), e.translate(-this.width / 2, -this.height / 2), e.translate(0, 12), e.font = "600 12px 'Geist variable'", e.fillStyle = "#A0A4A2", e.textAlign = "left", e.clip(), e.fillText("Drag and drop media here", 32, 12), e.translate(8, 1), e.fillStyle = "#A0A4A2", e.fill(t), e.restore());
  }
}
class F6 extends Ta {
  static type = "Helper";
  constructor(e) {
    e.activeGuideFill = "#ffffff", super(e);
  }
}
class L6 {
  addTrackItem(e) {
    const t = e.id, n = sd(e, {
      tScale: this.tScale,
      sizesMap: this.sizesMap
    });
    this.add(n), this.trackItemIds.push(t), this.renderTracks(), this.alignItemsToTrack(), this.calcBounding(), this.duration = kn(this.trackItemsMap);
  }
  alignItemsToTrack() {
    this.pauseEventListeners();
    const e = new Map(
      this.getObjects("Track").map((n) => [n.id, n])
    ), t = this.getObjects("Image", "Video", "Text", "Audio");
    this.trackItemIds.forEach((n) => {
      const i = this.tracks.find((c) => c.items.includes(n));
      if (!i) return;
      const s = e.get(i.id);
      this.duration;
      const a = this.getObjects().find((c) => c.id === n);
      a && s && (a.isMain = !1, this.trackItemsMap[n].isMain = !1, a.set({ top: s.top }), a.setCoords());
    }), e.forEach((n) => {
      n.items = t.filter((i) => i.top === n.top).map((i) => i.id);
    }), this.resumeEventListeners();
  }
  updateTrackItemsPosition() {
    const e = this.getObjects("Image", "Text", "Video", "Audio");
    e.sort((t, n) => t.top - n.top), this.trackItemIds = e.map((t) => t.id).reverse();
  }
  restoreTrackItemPositions() {
  }
  updateTrackItemsState() {
    this.pauseEventListeners();
    const e = this.getObjects("Image", "Video", "Text", "Audio"), t = {};
    e.forEach((n) => {
      const { id: i, left: s, width: a } = n, c = this.trackItemsMap[i], u = Ji(s, this.tScale), h = u + Ji(a, this.tScale), d = { from: u, to: h }, p = {
        ...c,
        display: d,
        trim: n instanceof po || n instanceof di ? n.trim : void 0
      };
      n.display = d, t[i] = p;
    }), this.trackItemsMap = t, this.resumeEventListeners();
  }
  deleteActiveTrackItem() {
    const e = this.getActiveObjects();
    if (!e.length) return !1;
    const t = e.map((i) => i.id), n = ol(this.tracks, t);
    this.trackItemsMap = Object.keys(this.trackItemsMap).reduce((i, s) => (t.includes(s) || (i[s] = this.trackItemsMap[s]), i), {}), this.trackItemIds = this.trackItemIds.filter(
      (i) => !t.includes(i)
    ), this.tracks = n, this.discardActiveObject(), this.remove(...e), this.setActiveIds([]), this.renderTracks(), this.alignItemsToTrack(), this.updateState({ updateHistory: !0, kind: "remove" });
  }
  updateTrackItemsToHistory() {
    this.pauseEventListeners();
    const e = this.getObjects();
    this.trackItemIds.forEach((t) => {
      const n = this.tracks.find(
        (h) => h.items.includes(t)
      ), i = e.find(
        (h) => h.id === n?.id
      )?.top;
      if (!i) {
        console.warn(`Track top not found for trackItemId: ${t}`);
        return;
      }
      const s = this.trackItemsMap[t], a = e.find((h) => h.id === t);
      if (!a) {
        console.warn(`Object not found for trackItemId: ${t}`);
        return;
      }
      const c = Ot(s.display.from, this.tScale), u = Ot(
        s.display.to - s.display.from,
        this.tScale
      );
      a.set({ left: c, width: u, top: i }), a.setCoords();
    }), this.requestRenderAll(), this.resumeEventListeners();
  }
  cloneActiveTrackItem(e) {
    const t = e?.trackItemId || this.activeIds[0];
    if (!t) return !1;
    const i = {
      ...this.trackItemsMap[t],
      id: Ft()
    }, s = this.tracks.find(
      (d) => d.items.includes(t)
    ), a = this.tracks.findIndex((d) => d.id === s?.id) + 1;
    this.findOrCreateTrack(i, { trackIndex: a });
    const c = sd(i, {
      tScale: this.tScale
    });
    c && this.add(c);
    const { audioData: u, ...h } = i.metadata || {};
    i.metadata = h, this.trackItemsMap[i.id] = i, this.trackItemIds.push(i.id), this.alignItemsToTrack(), this.updateTransitions(), this.updateState();
  }
  splitActiveTrackItem(e) {
    const t = e.trackItemId ?? this.activeIds[0];
    if (!t || this.activeIds.length > 1) return !1;
    const n = this.trackItemsMap[t], i = e.time;
    if (n.display.from >= i || n.display.to <= i)
      return !1;
    const s = {
      ...n,
      display: { from: n.display.from, to: i }
    }, a = {
      ...n,
      display: { from: i, to: n.display.to },
      id: Ft()
    };
    if (n.type === "video" || n.type === "audio") {
      const d = i - s.display.from;
      s.trim = {
        from: n.trim.from,
        to: n.trim.from + d
      }, a.trim = {
        from: s.trim.to,
        to: n.trim.to
      };
    }
    const c = this.getObjects().find(
      (d) => d.id === t
    );
    c.display = s.display, this.tracks.find(
      (d) => d.items.includes(t)
    )?.items.push(a.id);
    const h = sd(a, {
      tScale: this.tScale
    });
    h && this.add(h), this.trackItemsMap[a.id] = a, this.trackItemsMap[t] = s, this.trackItemIds.push(a.id), this.updateTrackItemCoords(s.id), this.alignItemsToTrack(), this.updateTransitions(), this.updateState();
  }
  updateTrackItemCoords(e) {
    const t = this.getObjects().find((a) => a.id === e), n = this.trackItemsMap[e], i = Ot(n.display.from, this.tScale), s = Ot(
      n.display.to - n.display.from,
      this.tScale
    );
    t?.set({ left: i, width: s }), t?.setCoords();
  }
  updateTrackItemDetails(e, t) {
    const n = t?.trackItemId;
    if (!n) return !1;
    const i = this.trackItemsMap[n], s = { ...i.details, ...e.details };
    ("fontSize" in s || "lineHeight" in s) && (s.height = el(
      s.text,
      s
    )), this.trackItemsMap[n] = {
      ...i,
      ...e,
      details: s
    }, this.updateState();
  }
  updateTrackItem(e, t) {
    const n = t.trackItemId;
    if (!n) return !1;
    const i = this.trackItemsMap[n], s = { ...i.details, ...e.details };
    if (i.type === "text" && e.details.text) {
      const a = this.getObjects("Text").find(
        (c) => c.id === n
      );
      a instanceof bx && (a.text = e.details.text, this.requestRenderAll());
    }
    ("fontSize" in s || "lineHeight" in s) && (s.height = el(
      s.text,
      s
    )), this.trackItemsMap[n] = {
      ...i,
      ...e,
      details: s
    }, this.updateState();
  }
  updateTrackItemsDetails(e, t) {
    t?.trackItemIds?.forEach((n, i) => {
      const s = this.trackItemsMap[n], a = {
        ...s.details,
        ...e[i].details
      };
      ("fontSize" in a || "lineHeight" in a) && (a.height = el(
        a.text,
        a
      )), this.trackItemsMap[n] = {
        ...s,
        ...e[i],
        details: a
      };
    }), this.updateState();
  }
  getTrackItems() {
    return this.getObjects(...N6);
  }
  setActiveTrackItemCoords() {
    this.getActiveObjects().forEach((e) => e.setCoords());
  }
  deleteTrackItemById(e) {
    const t = this.getObjects().filter(
      (n) => e.includes(n.id)
    );
    this.tracks = ol(this.tracks, e), this.trackItemsMap = Object.keys(this.trackItemsMap).filter((n) => !e.includes(n)).reduce((n, i) => (n[i] = this.trackItemsMap[i], n), {}), this.trackItemIds = this.trackItemIds.filter((n) => !e.includes(n)), this.discardActiveObject(), this.remove(...t), this.renderTracks(), this.alignItemsToTrack(), this.calcBounding(), this.duration = kn(this.trackItemsMap);
  }
  selectTrackItemByIds(e) {
    const t = this.getActiveObjects().map((i) => i.id);
    if (Xe.isEqual(t, e)) return;
    const n = this.getTrackItems().filter(
      (i) => e.includes(i.id)
    );
    if (n.length === 0)
      this.discardActiveObject();
    else if (n.length === 1)
      this.setActiveObject(n[0]);
    else {
      const i = new _n(n);
      this.setActiveObject(i);
    }
    this.requestRenderAll();
  }
}
const N6 = ["Image", "Text", "Video", "Audio", "Caption", "Template"], sd = (r, e) => {
  const n = {
    text: I6,
    video: O6,
    image: k6,
    audio: E6
  }[r.type];
  return n(r, e);
}, Fs = {
  text: 32,
  image: 40,
  video: 40,
  audio: 32,
  main: 40
}, $0 = (r) => {
  switch (r) {
    case "text":
      return Fs.text;
    case "image":
      return Fs.image;
    case "video":
      return Fs.video;
    case "audio":
      return Fs.audio;
    case "helperTop":
      return 40;
    case "helperBottom":
      return 40;
    case "helperCenter":
      return 8;
    case "main":
      return Fs.main;
    default:
      return Fs.text;
  }
};
class B6 {
  // Метод для нахождения или создания нового трека
  findOrCreateTrack(e, { trackId: t, trackIndex: n }) {
    const i = t;
    if (i) {
      const a = this.tracks.find((c) => c.id === i);
      if (a)
        return a.items.push(e.id), i;
    }
    const s = {
      id: Ft(),
      // Генерация уникального ID
      items: [e.id],
      type: e.type,
      accepts: this.acceptsMap?.[e.type]
    };
    return n !== void 0 ? this.tracks.splice(n, 0, s) : this.tracks.push(s), this.renderTracks(), s.id;
  }
  // Метод для удаления всех треков и вспомогательных объектов
  removeTracks() {
    this.getObjects("Track", "Helper")?.forEach((e) => this.remove(e));
  }
  // Метод для отображения треков
  renderTracks() {
    this.updateTracksState(), this.removeTracks();
    const e = this.width, t = this.tracks.flatMap((c) => [
      c,
      {
        id: `after-${c.id}`,
        type: "helper",
        items: [],
        accepts: []
      }
    ]).slice(0, -1);
    let n = 0;
    const i = ne.getClass("Helper") || Ta, s = new i({
      id: "helperLineTop",
      top: n,
      selectable: !1,
      evented: !1,
      tScale: this.tScale,
      width: e,
      kind: "top",
      metadata: {}
    });
    n += $0("helperTop"), this.insertAt(0, s), t.forEach((c, u) => {
      if (c.type === "helper") {
        const h = $0("helperCenter"), d = new i({
          id: c.id,
          top: n,
          tScale: this.tScale,
          width: e,
          height: h,
          metadata: { order: (u + 1) / 2 },
          kind: "center"
        });
        n += h, this.insertAt(0, d);
      } else {
        const h = ne.getClass("Track") || rs, d = new h({
          id: c.id,
          top: n,
          left: 0,
          fill: "#18181b",
          height: 42,
          width: e,
          tScale: this.tScale,
          accepts: this.acceptsMap?.[c.type] || [],
          items: c.items
        });
        n += 42, this.insertAt(0, d);
      }
    });
    const a = new i({
      id: "helperLineBottom",
      top: n,
      selectable: !1,
      evented: !1,
      tScale: this.tScale,
      width: e,
      kind: "bottom",
      metadata: {}
    });
    this.insertAt(0, a);
  }
  // Метод для обновления состояния треков
  updateTracksState() {
    const e = this.tracks.filter(
      (n) => n.items.length || n.type === "main"
    ), t = /* @__PURE__ */ new Map();
    e.forEach((n) => t.set(n.id, n)), this.tracks = Array.from(t.values());
  }
  // Метод для обновления координат треков
  updateTrackCoords() {
    const e = this.bounding.width + this.spacing.right;
    this.getObjects("Track", "Helper").forEach((t) => {
      t.updateCoords(e), t.setCoords();
    });
  }
}
const V6 = 60, z6 = 188;
function Y0(r, e = 1, t = 1) {
  const n = z6 * e;
  return r * (V6 / 1e3) * n / t;
}
class W6 {
  // Удаление всех переходов
  removeTransitions() {
    const e = this.getObjects("Transition");
    this.remove(...e);
  }
  // Рендеринг переходов
  renderTransitions() {
    this.removeTransitions(), this.transitionIds.forEach((e) => {
      const t = this.transitionsMap[e], n = t.fromId, i = t.toId, s = this.getObjects(), a = s.find((g) => g.id === n), c = s.find((g) => g.id === i);
      if (!a || !c) return;
      const u = Y0(t.duration, this.tScale), h = a.left + a.width - u / 2, d = a.height, p = new hn({
        id: t.id,
        left: h,
        top: a.top,
        height: d,
        width: u,
        tScale: this.tScale,
        duration: t.duration,
        fromId: a.id,
        toId: c.id,
        kind: t.kind
      });
      t.kind === "none" && (p.visible = !1), this.add(p);
    });
  }
  // Обновление координат переходов
  updateTransitionCoordinates() {
    this.pauseEventListeners(), this.getObjects("Transition").forEach((e) => {
      e.tScale = this.tScale, e.updateCoords(), e.setCoords();
    }), this.resumeEventListeners();
  }
  // Выравнивание переходов по треку
  alignTransitionsToTrack() {
    this.pauseEventListeners(), this.transitionIds.forEach((e) => {
      const t = this.getObjects("Transition").find(
        (n) => n.id === e
      );
      if (t instanceof hn) {
        const n = this.getObjects().find(
          (a) => a.id === t.fromId
        );
        if (!n) return;
        const i = Y0(t.duration, this.tScale), s = n.left + n.width - i / 2;
        t.set({ left: s, top: n.top }), t.setCoords();
      }
    }), this.resumeEventListeners();
  }
  // Обновление переходов
  updateTransitions(e = !0) {
    e && this.pauseEventListeners();
    const t = this.getObjects("Track"), n = this.getObjects("Video", "Image");
    this.removeTransitions();
    const i = {}, s = [];
    t.forEach((a) => {
      const c = n.filter((u) => a.items.includes(u.id)).sort((u, h) => u.left - h.left);
      for (let u = 0; u < c.length - 1; u++) {
        const h = c[u], d = c[u + 1];
        if (Math.abs(h.left + h.width - d.left) <= 1) {
          const p = `${h.id}-${d.id}`;
          if (this.transitionIds.includes(p))
            i[p] = this.transitionsMap[p];
          else {
            const g = {
              id: p,
              duration: 1500,
              fromId: h.id,
              toId: d.id,
              kind: "none",
              trackId: a.id,
              type: "transition"
            };
            i[p] = g;
          }
          s.push(p);
        }
      }
    }), this.transitionIds = s, this.transitionsMap = i, this.renderTransitions(), e && this.resumeEventListeners();
  }
}
const Q = {
  canvas: null,
  enableGuideRedraw: !0,
  isPointerOverHelperTrack: !1,
  draggingOverTrack: null,
  primaryMovingObjects: [],
  secondaryMovingObjects: [],
  placeholderMovingObjects: [],
  objectInitialPositions: {},
  originTrack: {},
  trackToItemsMap: {},
  activeTrackToItemsMap: {},
  trackTopToIdMap: {},
  trackTops: [],
  activeObjects: [],
  primaryTracks: {},
  secondaryTracks: {}
}, Tt = {
  guide: null,
  object: null,
  objects: []
}, i9 = () => Q, s9 = (r) => {
  Object.assign(Q, r);
}, H6 = (r) => {
  r.on("before:transform", wx.bind(r));
}, U6 = (r) => {
  r.off("before:transform", wx.bind(r));
};
function wx(r) {
  Q.canvas = this, Q.activeTrackToItemsMap = {}, Q.primaryTracks = {}, Q.secondaryTracks = {}, Q.trackTops = [], Q.trackToItemsMap = {}, Q.activeObjects = [], Q.trackTopToIdMap = {}, Q.canvas.trackIdAfterTransform = "", Q.canvas.positionAfterTransform = {};
  const e = Q.canvas.getActiveObject();
  if (!e) return;
  Q.activeObjects = e instanceof _n ? e.getObjects() : [e];
  const t = Q.canvas.getScenePoint(r.e), n = Q.canvas.getObjects("Track");
  Q.originTrack = n.find((a) => {
    const c = a.getBoundingRect();
    return t.x >= c.left && t.x <= c.left + c.width && t.y >= c.top && t.y <= c.top + c.height;
  }) ?? {};
  const i = Q.canvas.getObjects(
    "Video",
    "Image",
    "Audio",
    "Text",
    "Element"
  );
  n.forEach((a) => {
    const c = i.filter(
      (u) => a.items.includes(u.id)
    );
    Q.trackToItemsMap[a.id] = c, Q.trackTopToIdMap[a.top] = a.id, Q.trackTops.push(a.top);
  }), Q.trackTops.sort((a, c) => a - c), Q.activeObjects.forEach((a) => {
    const c = n?.find(
      (h) => h.items.includes(a.id)
    );
    if (!c) return;
    const u = c.id;
    Q.activeTrackToItemsMap[u] ? Q.activeTrackToItemsMap[u].push(a) : Q.activeTrackToItemsMap[u] = [a];
  }), Q.primaryMovingObjects = Q.activeObjects.filter(
    (a) => {
      const c = a.getBoundingRect();
      return t.y >= c.top && t.y <= c.top + c.height && !(a instanceof hn);
    }
  ), Q.primaryMovingObjects.forEach((a) => {
    const c = a.getBoundingRect().top, u = Q.trackTopToIdMap[c];
    if (Q.primaryTracks[u])
      Q.primaryTracks[u].objects.push(a);
    else {
      const h = af(
        Q.trackTops,
        Q.originTrack.top,
        c
      );
      if (typeof h != "number") return;
      Q.primaryTracks[u] = { objects: [a], index: h };
    }
  }), Q.primaryMovingObjects = Q.primaryMovingObjects.sort(
    (a, c) => a.left - c.left
  ), Q.secondaryMovingObjects = Q.activeObjects.filter(
    (a) => !Q.primaryMovingObjects.includes(a) && !(a instanceof hn)
  ), Q.secondaryMovingObjects.forEach((a) => {
    const c = a.getBoundingRect().top, u = Q.trackTopToIdMap[a.getBoundingRect().top];
    if (Q.secondaryTracks[u])
      Q.secondaryTracks[u].objects.push(a);
    else {
      const h = af(
        Q.trackTops,
        Q.originTrack.top,
        c
      );
      if (typeof h != "number") return;
      Q.secondaryTracks[u] = { objects: [a], index: h };
    }
  }), Q.originTrack && (Q.canvas.trackOriginBeforeTransform = Q.originTrack.id), e && (Q.canvas.positionBeforeTransform = {
    top: e.top,
    left: e.left
  }), ("transform" in r ? r.transform : {}).action === "drag" && (Q.placeholderMovingObjects = Q.primaryMovingObjects.map(
    (a) => {
      const c = a.getBoundingRect();
      Q.objectInitialPositions[a.id] = {
        top: c.top,
        left: c.left
      };
      const u = new ca({
        id: `${a.id}-placeholder`,
        left: c.left,
        top: c.top,
        width: c.width,
        height: c.height,
        for: $6[a.type]
      });
      return u.draggedObject = a, u;
    }
  ), Q.canvas.add(...Q.placeholderMovingObjects));
}
function af(r, e, t) {
  const n = r.indexOf(e), i = r.indexOf(t);
  return n === -1 || i === -1 ? null : i - n;
}
const $6 = {
  trackitemvideo: "video",
  trackitemimage: "image",
  trackitemaudio: "audio",
  trackitemtext: "text"
};
function xx(r) {
  if (!Tt.guide) return !1;
  r.e.preventDefault();
  const e = this, t = e.getViewportPoint(r.e);
  Tt.guide.set({
    left: t.x - 16,
    top: t.y - Tt.guide.height / 2
  });
  const n = Y6(
    t,
    Tt.objects
  );
  n && (Tt.object = n, n.strokeDashArray = [5, 1], n.setSelected(!0)), Tt.objects.forEach((i) => {
    i !== n && i.setSelected(!1);
  }), e.requestRenderAll();
}
function Y6(r, e) {
  let t = 1 / 0, n = null;
  const i = new B(r.x, r.y);
  return e.forEach((s) => {
    const a = X6(s, i);
    a < t && (t = a, n = s);
  }), n;
}
function X6(r, e) {
  return Math.sqrt(
    Math.pow(r.left - e.x, 2) + Math.pow(r.top - e.y, 2)
  );
}
const G6 = [
  "transition",
  "image",
  "video",
  "audio",
  "caption",
  "text"
];
function _x(r) {
  const e = r.e.dataTransfer?.types[0];
  if (!e) return;
  const t = JSON.parse(e), { type: n, duration: i = 5e3 } = t;
  if (!G6.includes(n)) return;
  const s = this;
  s.discardActiveObject();
  const a = Ot(i, s.tScale);
  Tt.guide = q6({
    width: a,
    height: 48,
    id: "TransitionGuide",
    left: 0,
    top: 0,
    type: n
  }), s.add(Tt.guide), n === "transition" && (Tt.objects = s.getObjects("Transition"), Tt.objects.forEach((c) => {
    c.visible = !0;
  })), We.dispatch(b1);
}
function q6({ width: r, height: e, id: t, left: n, top: i, type: s }) {
  return s === "transition" ? new El({
    top: 0,
    left: 0,
    height: 48,
    width: 48,
    id: "TransitionGuide"
  }) : new kl({
    top: i,
    left: n,
    height: e,
    width: r,
    id: t,
    name: "Rivers in the mountains"
  });
}
function Sx() {
  if (!Tt.guide) return;
  We.dispatch(sl);
  const r = this;
  K6(Tt.objects), r.remove(Tt.guide);
}
function K6(r) {
  r.forEach((e) => {
    e.strokeDashArray = [], e.setSelected(!1), e.kind === "none" && (e.visible = !1);
  });
}
var Z6 = typeof global == "object" && global && global.Object === Object && global, J6 = typeof self == "object" && self && self.Object === Object && self, xp = Z6 || J6 || Function("return this")(), bi = xp.Symbol, Cx = Object.prototype, Q6 = Cx.hasOwnProperty, ej = Cx.toString, zo = bi ? bi.toStringTag : void 0;
function tj(r) {
  var e = Q6.call(r, zo), t = r[zo];
  try {
    r[zo] = void 0;
    var n = !0;
  } catch {
  }
  var i = ej.call(r);
  return n && (e ? r[zo] = t : delete r[zo]), i;
}
var rj = Object.prototype, nj = rj.toString;
function ij(r) {
  return nj.call(r);
}
var sj = "[object Null]", oj = "[object Undefined]", X0 = bi ? bi.toStringTag : void 0;
function _p(r) {
  return r == null ? r === void 0 ? oj : sj : X0 && X0 in Object(r) ? tj(r) : ij(r);
}
function Sp(r) {
  return r != null && typeof r == "object";
}
var aj = "[object Symbol]";
function Cp(r) {
  return typeof r == "symbol" || Sp(r) && _p(r) == aj;
}
function cj(r, e) {
  for (var t = -1, n = r == null ? 0 : r.length, i = Array(n); ++t < n; )
    i[t] = e(r[t], t, r);
  return i;
}
var Ea = Array.isArray, G0 = bi ? bi.prototype : void 0, q0 = G0 ? G0.toString : void 0;
function Tx(r) {
  if (typeof r == "string")
    return r;
  if (Ea(r))
    return cj(r, Tx) + "";
  if (Cp(r))
    return q0 ? q0.call(r) : "";
  var e = r + "";
  return e == "0" && 1 / r == -1 / 0 ? "-0" : e;
}
function Ol(r) {
  var e = typeof r;
  return r != null && (e == "object" || e == "function");
}
function lj(r) {
  return r;
}
var uj = "[object AsyncFunction]", hj = "[object Function]", dj = "[object GeneratorFunction]", fj = "[object Proxy]";
function pj(r) {
  if (!Ol(r))
    return !1;
  var e = _p(r);
  return e == hj || e == dj || e == uj || e == fj;
}
var od = xp["__core-js_shared__"], K0 = function() {
  var r = /[^.]+$/.exec(od && od.keys && od.keys.IE_PROTO || "");
  return r ? "Symbol(src)_1." + r : "";
}();
function gj(r) {
  return !!K0 && K0 in r;
}
var mj = Function.prototype, vj = mj.toString;
function yj(r) {
  if (r != null) {
    try {
      return vj.call(r);
    } catch {
    }
    try {
      return r + "";
    } catch {
    }
  }
  return "";
}
var bj = /[\\^$.*+?()[\]{}|]/g, wj = /^\[object .+?Constructor\]$/, xj = Function.prototype, _j = Object.prototype, Sj = xj.toString, Cj = _j.hasOwnProperty, Tj = RegExp(
  "^" + Sj.call(Cj).replace(bj, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Ej(r) {
  if (!Ol(r) || gj(r))
    return !1;
  var e = pj(r) ? Tj : wj;
  return e.test(yj(r));
}
function kj(r, e) {
  return r?.[e];
}
function Tp(r, e) {
  var t = kj(r, e);
  return Ej(t) ? t : void 0;
}
function Oj(r, e, t) {
  switch (t.length) {
    case 0:
      return r.call(e);
    case 1:
      return r.call(e, t[0]);
    case 2:
      return r.call(e, t[0], t[1]);
    case 3:
      return r.call(e, t[0], t[1], t[2]);
  }
  return r.apply(e, t);
}
var Ij = 800, Aj = 16, Mj = Date.now;
function Pj(r) {
  var e = 0, t = 0;
  return function() {
    var n = Mj(), i = Aj - (n - t);
    if (t = n, i > 0) {
      if (++e >= Ij)
        return arguments[0];
    } else
      e = 0;
    return r.apply(void 0, arguments);
  };
}
function Dj(r) {
  return function() {
    return r;
  };
}
var Il = function() {
  try {
    var r = Tp(Object, "defineProperty");
    return r({}, "", {}), r;
  } catch {
  }
}(), Rj = Il ? function(r, e) {
  return Il(r, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Dj(e),
    writable: !0
  });
} : lj, jj = Pj(Rj), Fj = 9007199254740991, Lj = /^(?:0|[1-9]\d*)$/;
function Ex(r, e) {
  var t = typeof r;
  return e = e ?? Fj, !!e && (t == "number" || t != "symbol" && Lj.test(r)) && r > -1 && r % 1 == 0 && r < e;
}
function Nj(r, e, t) {
  e == "__proto__" && Il ? Il(r, e, {
    configurable: !0,
    enumerable: !0,
    value: t,
    writable: !0
  }) : r[e] = t;
}
function kx(r, e) {
  return r === e || r !== r && e !== e;
}
var Bj = Object.prototype, Vj = Bj.hasOwnProperty;
function zj(r, e, t) {
  var n = r[e];
  (!(Vj.call(r, e) && kx(n, t)) || t === void 0 && !(e in r)) && Nj(r, e, t);
}
var Z0 = Math.max;
function Wj(r, e, t) {
  return e = Z0(e === void 0 ? r.length - 1 : e, 0), function() {
    for (var n = arguments, i = -1, s = Z0(n.length - e, 0), a = Array(s); ++i < s; )
      a[i] = n[e + i];
    i = -1;
    for (var c = Array(e + 1); ++i < e; )
      c[i] = n[i];
    return c[e] = t(a), Oj(r, this, c);
  };
}
var Hj = 9007199254740991;
function Uj(r) {
  return typeof r == "number" && r > -1 && r % 1 == 0 && r <= Hj;
}
var $j = "[object Arguments]";
function J0(r) {
  return Sp(r) && _p(r) == $j;
}
var Ox = Object.prototype, Yj = Ox.hasOwnProperty, Xj = Ox.propertyIsEnumerable, Ix = J0(/* @__PURE__ */ function() {
  return arguments;
}()) ? J0 : function(r) {
  return Sp(r) && Yj.call(r, "callee") && !Xj.call(r, "callee");
}, Gj = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, qj = /^\w*$/;
function Kj(r, e) {
  if (Ea(r))
    return !1;
  var t = typeof r;
  return t == "number" || t == "symbol" || t == "boolean" || r == null || Cp(r) ? !0 : qj.test(r) || !Gj.test(r) || e != null && r in Object(e);
}
var la = Tp(Object, "create");
function Zj() {
  this.__data__ = la ? la(null) : {}, this.size = 0;
}
function Jj(r) {
  var e = this.has(r) && delete this.__data__[r];
  return this.size -= e ? 1 : 0, e;
}
var Qj = "__lodash_hash_undefined__", eF = Object.prototype, tF = eF.hasOwnProperty;
function rF(r) {
  var e = this.__data__;
  if (la) {
    var t = e[r];
    return t === Qj ? void 0 : t;
  }
  return tF.call(e, r) ? e[r] : void 0;
}
var nF = Object.prototype, iF = nF.hasOwnProperty;
function sF(r) {
  var e = this.__data__;
  return la ? e[r] !== void 0 : iF.call(e, r);
}
var oF = "__lodash_hash_undefined__";
function aF(r, e) {
  var t = this.__data__;
  return this.size += this.has(r) ? 0 : 1, t[r] = la && e === void 0 ? oF : e, this;
}
function ns(r) {
  var e = -1, t = r == null ? 0 : r.length;
  for (this.clear(); ++e < t; ) {
    var n = r[e];
    this.set(n[0], n[1]);
  }
}
ns.prototype.clear = Zj;
ns.prototype.delete = Jj;
ns.prototype.get = rF;
ns.prototype.has = sF;
ns.prototype.set = aF;
function cF() {
  this.__data__ = [], this.size = 0;
}
function gu(r, e) {
  for (var t = r.length; t--; )
    if (kx(r[t][0], e))
      return t;
  return -1;
}
var lF = Array.prototype, uF = lF.splice;
function hF(r) {
  var e = this.__data__, t = gu(e, r);
  if (t < 0)
    return !1;
  var n = e.length - 1;
  return t == n ? e.pop() : uF.call(e, t, 1), --this.size, !0;
}
function dF(r) {
  var e = this.__data__, t = gu(e, r);
  return t < 0 ? void 0 : e[t][1];
}
function fF(r) {
  return gu(this.__data__, r) > -1;
}
function pF(r, e) {
  var t = this.__data__, n = gu(t, r);
  return n < 0 ? (++this.size, t.push([r, e])) : t[n][1] = e, this;
}
function go(r) {
  var e = -1, t = r == null ? 0 : r.length;
  for (this.clear(); ++e < t; ) {
    var n = r[e];
    this.set(n[0], n[1]);
  }
}
go.prototype.clear = cF;
go.prototype.delete = hF;
go.prototype.get = dF;
go.prototype.has = fF;
go.prototype.set = pF;
var gF = Tp(xp, "Map");
function mF() {
  this.size = 0, this.__data__ = {
    hash: new ns(),
    map: new (gF || go)(),
    string: new ns()
  };
}
function vF(r) {
  var e = typeof r;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? r !== "__proto__" : r === null;
}
function mu(r, e) {
  var t = r.__data__;
  return vF(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
function yF(r) {
  var e = mu(this, r).delete(r);
  return this.size -= e ? 1 : 0, e;
}
function bF(r) {
  return mu(this, r).get(r);
}
function wF(r) {
  return mu(this, r).has(r);
}
function xF(r, e) {
  var t = mu(this, r), n = t.size;
  return t.set(r, e), this.size += t.size == n ? 0 : 1, this;
}
function ms(r) {
  var e = -1, t = r == null ? 0 : r.length;
  for (this.clear(); ++e < t; ) {
    var n = r[e];
    this.set(n[0], n[1]);
  }
}
ms.prototype.clear = mF;
ms.prototype.delete = yF;
ms.prototype.get = bF;
ms.prototype.has = wF;
ms.prototype.set = xF;
var _F = "Expected a function";
function Ep(r, e) {
  if (typeof r != "function" || e != null && typeof e != "function")
    throw new TypeError(_F);
  var t = function() {
    var n = arguments, i = e ? e.apply(this, n) : n[0], s = t.cache;
    if (s.has(i))
      return s.get(i);
    var a = r.apply(this, n);
    return t.cache = s.set(i, a) || s, a;
  };
  return t.cache = new (Ep.Cache || ms)(), t;
}
Ep.Cache = ms;
var SF = 500;
function CF(r) {
  var e = Ep(r, function(n) {
    return t.size === SF && t.clear(), n;
  }), t = e.cache;
  return e;
}
var TF = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, EF = /\\(\\)?/g, kF = CF(function(r) {
  var e = [];
  return r.charCodeAt(0) === 46 && e.push(""), r.replace(TF, function(t, n, i, s) {
    e.push(i ? s.replace(EF, "$1") : n || t);
  }), e;
});
function OF(r) {
  return r == null ? "" : Tx(r);
}
function vu(r, e) {
  return Ea(r) ? r : Kj(r, e) ? [r] : kF(OF(r));
}
function kp(r) {
  if (typeof r == "string" || Cp(r))
    return r;
  var e = r + "";
  return e == "0" && 1 / r == -1 / 0 ? "-0" : e;
}
function IF(r, e) {
  e = vu(e, r);
  for (var t = 0, n = e.length; r != null && t < n; )
    r = r[kp(e[t++])];
  return t && t == n ? r : void 0;
}
function AF(r, e) {
  for (var t = -1, n = e.length, i = r.length; ++t < n; )
    r[i + t] = e[t];
  return r;
}
var Q0 = bi ? bi.isConcatSpreadable : void 0;
function MF(r) {
  return Ea(r) || Ix(r) || !!(Q0 && r && r[Q0]);
}
function PF(r, e, t, n, i) {
  var s = -1, a = r.length;
  for (t || (t = MF), i || (i = []); ++s < a; ) {
    var c = r[s];
    t(c) ? AF(i, c) : i[i.length] = c;
  }
  return i;
}
function DF(r) {
  var e = r == null ? 0 : r.length;
  return e ? PF(r) : [];
}
function RF(r) {
  return jj(Wj(r, void 0, DF), r + "");
}
function jF(r, e) {
  return r != null && e in Object(r);
}
function FF(r, e, t) {
  e = vu(e, r);
  for (var n = -1, i = e.length, s = !1; ++n < i; ) {
    var a = kp(e[n]);
    if (!(s = r != null && t(r, a)))
      break;
    r = r[a];
  }
  return s || ++n != i ? s : (i = r == null ? 0 : r.length, !!i && Uj(i) && Ex(a, i) && (Ea(r) || Ix(r)));
}
function LF(r, e) {
  return r != null && FF(r, e, jF);
}
function NF(r, e, t, n) {
  if (!Ol(r))
    return r;
  e = vu(e, r);
  for (var i = -1, s = e.length, a = s - 1, c = r; c != null && ++i < s; ) {
    var u = kp(e[i]), h = t;
    if (u === "__proto__" || u === "constructor" || u === "prototype")
      return r;
    if (i != a) {
      var d = c[u];
      h = void 0, h === void 0 && (h = Ol(d) ? d : Ex(e[i + 1]) ? [] : {});
    }
    zj(c, u, h), c = c[u];
  }
  return r;
}
function BF(r, e, t) {
  for (var n = -1, i = e.length, s = {}; ++n < i; ) {
    var a = e[n], c = IF(r, a);
    t(c, a) && NF(s, vu(a, r), c);
  }
  return s;
}
function VF(r, e) {
  return BF(r, e, function(t, n) {
    return LF(r, n);
  });
}
var zF = RF(function(r, e) {
  return r == null ? {} : VF(r, e);
});
function Ax(r) {
  const e = r.e.dataTransfer?.types[0];
  if (!e) return;
  const t = JSON.parse(
    r.e.dataTransfer.getData(e)
  ), n = this;
  if (t.type !== "transition") {
    WF(t), n.remove(Tt.guide), n.requestRenderAll(), We.dispatch(sl);
    return;
  }
  Tt.guide && (Tt.object && HF(t, n), Tt.objects.forEach((i) => {
    i.strokeDashArray = [], i.setSelected(!1), i.kind === "none" && (i.visible = !1);
  }), n.remove(Tt.guide), n.requestRenderAll(), We.dispatch(sl));
}
function WF(r) {
  const e = { ...r, id: Ft() };
  switch (r.type) {
    case "image":
      We.dispatch(va, { payload: e });
      break;
    case "video":
      We.dispatch(ga, { payload: e });
      break;
    case "audio":
      We.dispatch(ma, { payload: e });
      break;
  }
}
function HF(r, e) {
  const t = Tt.object?.id, n = zF(r, ["kind", "direction"]);
  Object.entries(n).forEach(([i, s]) => {
    i === "kind" ? Tt.object.kind = s : Tt.object[i] = s;
  }), e.transitionsMap[t] = {
    ...e.transitionsMap[t],
    ...n
  }, e.updateState();
}
const UF = (r) => {
  r.on("dragover", xx), r.on("dragenter", _x), r.on("dragleave", Sx), r.on("drop", Ax);
}, $F = (r) => {
  r.off("dragover", xx), r.off("dragenter", _x), r.off("dragleave", Sx), r.off("drop", Ax);
}, Mx = (r) => {
  const e = r.target.canvas, t = r.target;
  if (r.action === "resizing" && t instanceof hn && e) {
    const n = t.id, i = e.getObjects("Transition").find((s) => s.id === n);
    if (i && i instanceof hn) {
      const s = Xe.cloneDeep(e.transitionsMap), a = {
        ...s,
        [n]: {
          ...s[n],
          width: i.width,
          duration: i.duration
        }
      };
      e.transitionsMap = a, e.updateState();
    }
  }
  e && (YF(e, e.getObjects()), XF(e.getObjects("Helper")), Q.isPointerOverHelperTrack = !1, Q.draggingOverTrack = null);
}, YF = (r, e) => {
  e.forEach((t) => {
    t.isAlignmentAuxiliary && r.remove(t);
  });
}, XF = (r) => {
  r.forEach((e) => e.setSelected(!1));
};
function Px(r) {
  const e = r.target.canvas;
  if (!e) return;
  const t = e.getActiveObject();
  if (!t || !e.positionBeforeTransform) return;
  const n = e.getScenePoint(r.e), i = e.getObjects("Track", "Helper").find((s) => {
    const a = s.getBoundingRect();
    return n.x >= a.left && n.x <= a.left + a.width && n.y >= a.top && n.y <= a.top + a.height;
  });
  if (r.action === "resizing") {
    const s = (Q.trackToItemsMap[Q.originTrack.id] || []).filter((c) => c !== t);
    t.setCoords();
    const a = yu(
      s,
      t.getBoundingRect()
    );
    return e.fire("track-items:resized", {
      trackId: Q.originTrack.id,
      trackItemIds: [t.id],
      isOverlapped: !!a
    }), !1;
  }
  if (!i)
    return t && (t?.set(e.positionBeforeTransform), t?.setCoords()), !1;
  if (i instanceof Ta) {
    let s;
    switch (i.kind) {
      case "top":
        s = 0;
        break;
      case "center":
        s = i.metadata.order || 0;
        break;
      case "bottom":
        s = -1;
        break;
      default:
        return;
    }
    const a = {
      isSecondaryOverlapped: !1,
      secondaryTracks: Q.secondaryTracks,
      primaryTracks: Q.primaryTracks,
      primaryPositions: {
        trackIndex: s,
        trackId: e.trackIdAfterTransform,
        positions: e.positionAfterTransform
      }
    };
    ZF(a);
  } else if (i instanceof rs) {
    const s = {
      isSecondaryOverlapped: qF(),
      secondaryTracks: Q.secondaryTracks,
      primaryTracks: Q.primaryTracks,
      primaryPositions: {
        trackId: e.trackIdAfterTransform,
        positions: e.positionAfterTransform
      }
    };
    GF(s);
  }
}
const GF = (r) => {
  Q.canvas && Q.canvas.fire("track-items:moved", r);
};
function qF() {
  const r = KF();
  return Object.keys(r).some((e) => {
    const t = Q.trackToItemsMap[e], n = r[e].objects;
    return t?.length ? t.filter((i) => !n.includes(i)).some(
      (i) => yu(n, i.getBoundingRect())
    ) : !0;
  });
}
function KF() {
  const [r] = Q.primaryMovingObjects, e = r.id, n = Q.canvas.positionAfterTransform[e].top - r.getBoundingRect().top, i = {};
  return Q.secondaryMovingObjects.forEach((s) => {
    const a = s.getBoundingRect().top + n, c = Q.trackTopToIdMap[a], u = af(
      Q.trackTops,
      Q.originTrack.top,
      a
    );
    i[c] ? i[c].objects.push(s) : i[c] = {
      objects: [s],
      index: u
    };
  }), i;
}
const ZF = (r) => {
  Q.canvas && Q.canvas.fire("track:create", r);
};
function yu(r, e) {
  return r.find((t) => {
    const n = t.getBoundingRect();
    return e.left < n.left + n.width && e.left + e.width > n.left && e.top < n.top + n.height && e.top + e.height > n.top;
  });
}
const JF = (r) => {
  r.on("object:modified", Mx), r.on("object:modified", Px);
}, QF = (r) => {
  r.off("object:modified", Mx), r.off("object:modified", Px);
};
function e8(r, e) {
  r.remove(...e), e.length = 0;
}
function Dx() {
  e8(this, Q.placeholderMovingObjects);
}
function Rx(r) {
  const e = this.height < this.bounding.height, t = this.width < this.bounding.width;
  if (!e && !t) return;
  const n = this.viewportTransform;
  let i = n[4], s = n[5];
  const a = 2;
  r.e.shiftKey ? i = n[4] - r.e.deltaY * a : (e && (s = n[5] - r.e.deltaY * a), i = n[4] - r.e.deltaX * a), this.setViewportPos(i, s);
}
const t8 = (r) => {
  r.on("mouse:wheel", Rx), r.on("mouse:up", Dx.bind(r));
}, r8 = (r) => {
  r.off("mouse:wheel", Rx), r.off("mouse:up", Dx.bind(r));
};
function jx(r) {
  const e = this;
  if (!e) return;
  const t = e.getScenePoint(r.e), n = e.getObjects("Helper", "Track");
  Q.draggingOverTrack = n.find((h) => {
    const d = h.getBoundingRect();
    return t.x >= d.left && t.x <= d.left + d.width && t.y >= d.top && t.y <= d.top + d.height;
  }) ?? null, n.forEach((h) => {
    if (ty(h)) {
      const d = Q.draggingOverTrack;
      h.setSelected(h === d);
    }
  }), Q.isPointerOverHelperTrack = ty(
    Q.draggingOverTrack
  ), e.getObjects();
  const i = r.target;
  i.getBoundingRect(), i.setCoords();
  const s = [
    i,
    ...e.getActiveObjects(),
    ...e.getObjects("Track", "Helper", "Transition", "Placeholder")
  ], a = n8(s, e), c = s8(i);
  i8(
    a,
    c
  ).forEach((h) => {
    h.orientation === "V" ? i.left = h.lineGuide + h.offset : i.top = h.lineGuide + h.offset;
  });
}
const n8 = (r, e) => {
  const t = [], n = [];
  return e.getObjects().filter((i) => i.visible).forEach((i) => {
    if (r.some(
      (c) => c.id === i.id
    ) || i.isAlignmentAuxiliary) return;
    const a = i.getBoundingRect();
    t.push(
      ey(
        a.left,
        a.width,
        a.top,
        a.height
      )
    ), n.push(
      ey(
        a.top,
        a.height,
        a.left,
        a.width
      )
    );
  }), {
    vertical: t.flat(),
    horizontal: []
  };
}, ey = (r, e, t, n) => [r, r + e].map((i) => ({
  val: i,
  start: t,
  end: t + n
})), i8 = (r, e) => {
  const t = [], n = [];
  r.vertical.forEach((u) => {
    e.vertical.forEach((h) => {
      const d = Math.abs(u.val - h.guide);
      d < 10 && t.push({
        lineGuide: u.val,
        diff: d,
        orientation: "V",
        snap: h.snap,
        offset: h.offset,
        targetDim: {
          start: u.start,
          end: u.end
        }
      });
    });
  }), r.horizontal.forEach((u) => {
    e.horizontal.forEach((h) => {
      const d = Math.abs(u.val - h.guide);
      d < 10 && n.push({
        lineGuide: u.val,
        diff: d,
        orientation: "H",
        snap: h.snap,
        offset: h.offset,
        targetDim: {
          start: u.start,
          end: u.end
        }
      });
    });
  });
  const s = [], a = t.sort(
    (u, h) => u.diff - h.diff
  )[0], c = n.sort(
    (u, h) => u.diff - h.diff
  )[0];
  return a && s.push({
    lineGuide: a.lineGuide,
    offset: a.offset,
    orientation: "V",
    snap: a.snap,
    targetDim: a.targetDim
  }), c && s.push({
    lineGuide: c.lineGuide,
    offset: c.offset,
    orientation: "H",
    snap: c.snap,
    targetDim: c.targetDim
  }), s;
}, s8 = (r) => {
  const e = r.getBoundingRect();
  return {
    vertical: [
      {
        guide: Math.round(e.left),
        offset: Math.round(r.left - e.left),
        snap: "start"
      },
      {
        guide: Math.round(e.left + e.width),
        offset: Math.round(
          r.left - e.left - e.width
        ),
        snap: "end"
      }
    ],
    horizontal: [
      {
        guide: Math.round(e.top),
        offset: Math.round(r.top - e.top),
        snap: "start"
      },
      {
        guide: Math.round(e.top + e.height),
        offset: Math.round(r.top - e.top - e.height),
        snap: "end"
      }
    ]
  };
}, ty = (r) => r instanceof Ta;
function o8(r) {
  r.opacity = Q.isPointerOverHelperTrack ? 0 : 1;
}
const Fx = f8((r) => {
  const e = r.target.canvas;
  if (p8(r), !Q.draggingOverTrack) return;
  const t = Q.placeholderMovingObjects.map(
    (s) => s.draggedObject
  ), n = (Q.trackToItemsMap[Q.draggingOverTrack.id] || []).filter((s) => !t.includes(s)), i = n.find(
    (s) => yu(t, s.getBoundingRect())
  );
  Q.placeholderMovingObjects.forEach((s) => {
    const a = s.draggedObject;
    a?.setCoords(), o8(s);
    const c = a8(
      a,
      n,
      i,
      Q.placeholderMovingObjects.length > 1
    );
    e.trackIdAfterTransform = Q.trackTopToIdMap[c.top], e.positionAfterTransform[a?.id] = {
      top: c.top,
      left: c.left
    }, s.left = c.left, s.top = c.top;
  });
}, 5), a8 = (r, e, t, n) => !c8(r) || n && t ? Lx(r) : t ? l8(r, t, e) : d8(r), c8 = (r) => Q.draggingOverTrack ? Q.draggingOverTrack.accepts?.includes(r.type) ?? !1 : !1, Lx = (r) => ({
  top: Q.objectInitialPositions[r.id].top,
  left: Q.objectInitialPositions[r.id].left
}), l8 = (r, e, t) => {
  const n = u8(r, e);
  return !h8(t, r, n) || Q.activeObjects.length !== 1 ? Lx(r) : {
    left: n,
    top: e.top
  };
}, u8 = (r, e) => {
  const t = r.left + r.width / 2, n = e.left + e.width / 2;
  return t < n ? e.left - r.width : e.left + e.width;
}, h8 = (r, e, t) => !(t < 0 || yu(r, {
  ...e.getBoundingRect(),
  left: t
})), d8 = (r) => ({
  left: r.getBoundingRect().left,
  top: Q.draggingOverTrack?.top ?? 0
});
function f8(r, e) {
  let t = null;
  return function(...n) {
    const i = Date.now();
    (t === null || i - t >= e) && (t = i, r(...n));
  };
}
function p8(r) {
  const e = r.target, t = e.canvas, n = e.top, i = -e.height * 0.75, s = t.height + e.height * 0.75;
  e.top = Math.min(Math.max(n, i), s - e.height);
  const a = e.left;
  e.left = Math.max(a, 0);
}
const g8 = (r) => {
  r.on("object:moving", jx.bind(r)), r.on("object:moving", Fx);
}, m8 = (r) => {
  r.off("object:moving", jx.bind(r)), r.off("object:moving", Fx);
};
function Nx() {
  const r = this, e = r.getActiveObject(), t = r.getActiveObjects().map((n) => n.id);
  e instanceof Xr ? (e.borderColor = "rgba(0, 216, 214, 0.75)", e.hasControls = !1, e.hoverCursor = "default", e.borderScaleFactor = 1, e.padding = 0, e.getObjects().forEach((n) => {
    n.setSelected(!0);
  })) : e?.setSelected(!0), this.setActiveIds(t);
}
function Bx(r) {
  const e = this, t = e.getActiveObject();
  t instanceof Xr && (t.borderColor = "transparent", t.hasControls = !1, t.hoverCursor = "default"), r.selected.forEach((i) => {
    i.setSelected(!0);
  }), r.deselected.forEach((i) => {
    i.setSelected(!1);
  });
  const n = e.getActiveObjects().map((i) => i.id);
  this.setActiveIds(n);
}
function Vx(r) {
  this.getObjects().forEach((t) => {
    t.isSelected && (t.isSelected = !1);
  }), r.deselected.forEach((t) => {
    t.setSelected(!1);
  });
  const e = this.getActiveObjects().map((t) => t.id);
  this.setActiveIds(e);
}
const v8 = (r) => {
  r.on("selection:created", Nx), r.on("selection:updated", Bx), r.on("selection:cleared", Vx);
}, y8 = (r) => {
  r.off("selection:created", Nx), r.off("selection:updated", Bx), r.off("selection:cleared", Vx);
};
let zx, Wx, Hx;
const b8 = (r) => {
  const { state: e } = r;
  zx = e.subscribeToActiveIds(({ activeIds: t }) => {
    if (t.length === 1) {
      const n = t[0], { trackItemIds: i, trackItemsMap: s } = e.getState();
      i.forEach((a) => {
        s[a].type;
      }), r.selectTrackItemByIds([n]);
    } else
      r.selectTrackItemByIds(t);
  }), Wx = e.subscribeToHistory((t) => {
    const { tracks: n, trackItemsMap: i, trackItemIds: s, trackItemDetailsMap: a } = t;
    r.tracks = n, r.trackItemsMap = i, r.trackItemIds = s, r.trackItemDetailsMap = a, r.renderTracks(), r.updateTrackItemsToHistory(), r.alignItemsToTrack(), r.calcBounding(), r.updateTransitions(), r.duration = kn(r.trackItemsMap);
  }), Hx = e.subscribeToAddOrRemoveItems(() => {
    const t = r.getTrackItems().map((c) => c.id), { trackItemIds: n, trackItemsMap: i, trackItemDetailsMap: s } = e.getState(), a = [];
    t.forEach((c) => {
      n.includes(c) || a.push(c);
    }), r.deleteTrackItemById(a), r.tracks = e.getState().tracks, r.trackItemsMap = i, r.trackItemDetailsMap = s, n.forEach((c) => {
      if (!t.includes(c)) {
        const u = {
          ...i[c],
          details: {
            ...s[c].details
          }
        };
        r.addTrackItem(u);
      }
    }), r.renderTracks(), r.alignItemsToTrack(), n.forEach((c) => {
      r.updateTrackItemCoords(c);
    }), r.updateTransitions(), r.updateTrackCoords();
  });
}, w8 = (r) => {
  zx.unsubscribe(), Wx.unsubscribe(), Hx.unsubscribe();
};
function Ux(r) {
  const {
    isSecondaryOverlapped: e,
    secondaryTracks: t,
    primaryTracks: n,
    primaryPositions: i
  } = r, { trackId: s, positions: a } = i, c = this.tracks.findIndex((v) => v.id === s), u = O1(
    Object.keys(t).map(
      (v) => t[v].objects.map((y) => y.id)
    )
  ), h = ol(this.tracks, [
    ...Object.keys(a),
    ...u
  ]);
  Object.keys(n).forEach((v) => {
    this.pauseEventListeners();
    const { objects: y } = n[v];
    y.forEach((_) => {
      const C = a[_.id];
      _.left = C.left;
    }), this.resumeEventListeners();
    const x = h.find((_) => _.id === s);
    x && x.items.push(...Object.keys(a)), this.tracks = h;
  });
  const d = this.tracks[c], p = [];
  Object.keys(t).forEach((v) => {
    const { objects: y, index: x } = t[v], _ = y.map((k) => k.id), [C] = _, E = this.trackItemsMap[C];
    if (e) {
      const k = {
        id: Ft(),
        items: _,
        type: E.type,
        accepts: this.acceptsMap?.[E.type],
        tempIndex: x
      };
      p.push(k);
    } else {
      const k = h[c + x];
      k && k.items.push(..._), this.tracks = h;
    }
  });
  const g = I1(
    d,
    p
  );
  g.length && h.splice(c, 1, ...g), this.tracks = h, this.renderTracks(), this.alignItemsToTrack(), this.updateTrackItemsPosition(), this.updateTransitions(), this.updateState({ updateHistory: !0, kind: "update" });
}
function $x({
  trackItemIds: r,
  isOverlapped: e
}) {
  const [t] = r;
  if (t) {
    if (!this.getObjects("Transition").find(
      (n) => n.id === t
    )) {
      const n = this.tracks.find((i) => i.items.includes(t));
      if (e) {
        const i = x8(this.tracks, r), s = {
          id: Ft(),
          items: [t],
          type: n?.type,
          accepts: n?.accepts
        }, a = this.tracks.findIndex((c) => c.id === n?.id);
        i.splice(a, 0, s), this.tracks = i;
      }
    }
    this.renderTracks(), this.alignItemsToTrack(), this.alignTransitionsToTrack(), this.updateTransitions(), this.updateTrackItemsPosition(), this.updateState({ updateHistory: !0, kind: "update" });
  }
}
function x8(r, e) {
  return r.map((t) => ({
    ...t,
    items: t.items.filter(
      (n) => !e.includes(n)
    )
  }));
}
function Yx(r) {
  const {
    secondaryTracks: e,
    primaryTracks: t,
    primaryPositions: n
  } = r, { positions: i, trackIndex: s } = n, a = s === -1 ? this.tracks.length : s, [c] = Object.keys(t), u = this.tracks.find((x) => x.id == c), h = t[c], d = {
    id: Ft(),
    items: h.objects.map((x) => x.id),
    type: u?.type,
    accepts: u?.accepts
  }, p = O1(
    Object.keys(e).map(
      (x) => e[x].objects.map((_) => _.id)
    )
  ), g = ol(this.tracks, [
    ...Object.keys(i),
    ...p
  ]), v = [];
  Object.keys(e).forEach((x) => {
    const { objects: _, index: C } = e[x], E = this.tracks.find(
      (P) => P.id == x
    ), k = _.map((P) => P.id), O = {
      id: Ft(),
      items: k,
      type: E?.type,
      accepts: E?.accepts,
      tempIndex: C
    };
    v.push(O);
  });
  const y = I1(d, v);
  y.length && g.splice(a, 0, ...y), this.tracks = g, this.renderTracks(), this.alignItemsToTrack(), this.updateTrackItemsPosition(), this.updateTransitions(), this.updateState({ updateHistory: !0, kind: "update" });
}
const _8 = (r) => {
  r.on("track:create", Yx.bind(r)), r.on("track-items:resized", $x.bind(r)), r.on("track-items:moved", Ux.bind(r));
}, S8 = (r) => {
  r.off("track:create", Yx.bind(r)), r.off("track-items:resized", $x.bind(r)), r.off("track-items:moved", Ux.bind(r));
}, C8 = (r) => {
  UF(r), JF(r), t8(r), g8(r), _8(r), v8(r), H6(r), b8(r);
}, T8 = (r) => {
  $F(r), QF(r), r8(r), m8(r), S8(r), y8(r), U6(r), w8();
}, E8 = {
  video: ["*"],
  image: ["*"],
  audio: ["*"],
  text: ["*"]
}, k8 = ["video", "image", "audio", "text"];
let Op = class extends rf {
  acceptsMap;
  tracks = [];
  trackItemsMap = {};
  trackItemIds = [];
  transitionIds = [];
  transitionsMap = {};
  trackItemDetailsMap = {};
  bounding;
  onScroll;
  tScale;
  store;
  state;
  activeIds = [];
  spacing;
  scale;
  sizesMap;
  duration;
  setupFabricDefaults() {
    rt.ownDefaults.borderColor = "transparent", rt.ownDefaults.cornerColor = "white", rt.ownDefaults.cornerStrokeColor = "transparent", rt.ownDefaults.strokeWidth = 0, rt.ownDefaults.borderOpacityWhenMoving = 1, rt.ownDefaults.borderScaleFactor = 1, rt.ownDefaults.cornerSize = 8, rt.ownDefaults.cornerStyle = "rect", rt.ownDefaults.centeredScaling = !1, rt.ownDefaults.centeredRotation = !0, rt.ownDefaults.transparentCorners = !1;
  }
  constructor(e, t) {
    super(e, t), this.bounding = t.bounding || {
      width: t.width || 0,
      height: t.height || 0
    }, this.spacing = {
      left: 16,
      right: 80,
      ...t.spacing
    };
    const n = this.viewportTransform;
    n[4] = this.spacing.left, this.tScale = t.tScale || 1 / 300, this.store = t.store, this.state = t.state, this.scale = t.scale, this.onScroll = t.onScroll, this.acceptsMap = this.createAcceptsItemMap(t.acceptsMap), this.sizesMap = M6(t.sizesMap), this.setupFabricDefaults(), this.initEventListeners();
  }
  createAcceptsItemMap(e = E8) {
    const t = {};
    return Object.keys(e).forEach((n) => {
      const i = e[n];
      t[n] = i.includes("*") ? k8 : i;
    }), t;
  }
  // setActiveIds(e: any) {
  //   this.activeIds = e;
  //   eventBus.dispatch(LAYER_SELECTION, {
  //     payload: {
  //       activeIds: this.activeIds,
  //     },
  //   });
  // }
  setActiveIds(e) {
    this.activeIds = e, this.getObjects("Transition").some(
      (n) => e.includes(n.id)
    ) || (this.state?.updateState({
      activeIds: Xe.cloneDeep(this.activeIds)
    }), We.dispatch(wI, {
      payload: {
        activeIds: this.activeIds
      }
    }));
  }
  purge() {
    T8(this), this.dispose();
  }
  static registerItems(e) {
    Object.keys(e).forEach((t) => {
      ne.setClass(e[t], t);
    });
  }
  initEventListeners() {
    C8(this);
  }
  getUpdatedState() {
    const e = kn(this.trackItemsMap);
    return {
      tracks: this.tracks,
      trackItemIds: this.trackItemIds,
      trackItemsMap: this.trackItemsMap,
      transitionIds: this.transitionIds,
      transitionsMap: this.transitionsMap,
      // tScale: this.tScale,
      scale: this.scale,
      duration: e
    };
  }
  getState() {
    const e = kn(this.trackItemsMap);
    return {
      tracks: this.tracks,
      trackItemIds: this.trackItemIds,
      trackItemsMap: this.trackItemsMap,
      transitionIds: this.transitionIds,
      transitionsMap: this.transitionsMap,
      trackItemDetailsMap: this.trackItemDetailsMap,
      // tScale: this.tScale,
      scale: this.scale,
      duration: e
    };
  }
  notify(e = { updateHistory: !1 }) {
    const t = this.getUpdatedState();
    this.state.updateState(t, e);
  }
  updateState(e) {
    this.updateTracksState(), this.updateTrackItemsState(), this.requestRenderAll(), this.calcBounding(), this.updateTrackCoords();
    const t = this.getUpdatedState();
    this.state.updateState(t, e);
  }
  scrollTo({
    scrollLeft: e,
    scrollTop: t
  }) {
    const n = [...this.viewportTransform];
    let i = !1;
    if (typeof e == "number" && (n[4] = -e + this.spacing.left, i = !0), typeof t == "number" && (n[5] = -t, i = !0), i) {
      this.viewportTransform = n;
      const s = this.getActiveObject();
      s && s.setCoords(), this.requestRenderAll();
    }
  }
  setBoundingBox(e) {
    this.bounding = e;
  }
  calcBounding() {
    const e = this.getTrackItems().reduce(
      (t, n) => {
        const { left: i, top: s, width: a, height: c } = n.getBoundingRect();
        return {
          left: Math.min(t.left, i),
          top: Math.min(t.top, s),
          width: Math.max(t.width, i + a),
          height: Math.max(t.height, s + c)
        };
      },
      { left: 1 / 0, top: 1 / 0, width: this.width, height: 0 }
    );
    this.bounding = e, We.dispatch(w1, {
      payload: { bounding: e }
    });
  }
  setScale(e) {
    this.pauseEventListeners(), this.tScale = e.zoom, this.scale = e;
    const t = this.getState();
    this.getObjects("Video", "Image", "Text", "Audio").forEach(
      (n) => {
        const i = t.trackItemsMap[n.id], { from: s, to: a } = i.display, c = Ot(s, this.tScale), u = Ot(
          a - s,
          this.tScale,
          n.playbackRate
        );
        n.set({ left: c, width: u, tScale: e.zoom }), n.setCoords();
      }
    ), this.requestRenderAll(), this.calcBounding(), this.updateTrackCoords(), this.updateTransitions(!1), this.resumeEventListeners(), this.notify();
  }
  setViewportPos(e, t) {
    const n = this.getViewportPos(e, t), i = this.viewportTransform;
    i[4] = n.x, i[5] = n.y, this.requestRenderAll(), this.setActiveTrackItemCoords();
    const s = this.onScroll;
    s && s.call(this, {
      scrollTop: n.y,
      scrollLeft: n.x - this.spacing.left
    });
  }
  getViewportPos(e, t) {
    const n = this.bounding.width - 100 >= this.width ? this.spacing.right : 0, i = this.width - this.bounding.width - n, s = this.spacing.left, a = Math.max(i, Math.min(e, s));
    if (this.bounding.height < this.height) return { x: a, y: 0 };
    const c = this.height - this.bounding.height - 40, u = Math.max(c, Math.min(t, 0));
    return { x: a, y: u };
  }
};
g6(Op, [
  UR,
  L6,
  B6,
  W6
]);
function O8(r) {
  const e = We.subject.pipe($i(({ key: t }) => t.startsWith(_I))).subscribe((t) => {
    if (t.key === y1) {
      const n = t.value;
      r.setScale(n?.payload.scale ?? void 0);
    }
  });
  return {
    unsubscribe: () => {
      e.unsubscribe();
    }
  };
}
Op.registerItems({
  Text: bx,
  Image: R6,
  Video: D6,
  Audio: P6,
  Track: j6,
  Helper: F6
});
const a9 = ({ stateManager: r }) => {
  const e = be(!1), [t, n] = he(0), i = be(null), s = be(null), a = be(null), c = be(null), u = be(null), [h, d] = he({
    width: 0,
    height: 0
  }), [p, g] = he({
    width: 0,
    height: 0
  }), {
    scale: v,
    playerRef: y,
    fps: x,
    setState: _,
    timeline: C
  } = Qi(), { setTimeline: E } = Qi(), k = kf(y ?? void 0), O = (F) => {
    u.current && c.current && (c.current.scrollTop = -F.scrollTop, u.current.scrollLeft = -F.scrollLeft, n(-F.scrollLeft));
  };
  ue(() => {
    const F = Ot(k / x * 1e3, v.zoom), $ = s.current?.getBoundingClientRect().x + s.current?.clientWidth;
    if (F - t + 40 >= $) {
      const G = u.current?.clientWidth, H = u.current?.scrollWidth, Y = u.current?.scrollLeft, ge = (H - (G + Y)) / G;
      ge >= 0 && (ge > 1 ? u.current?.scrollTo({
        left: Y + G
      }) : u.current?.scrollTo({
        left: H - G
      }));
    }
  }, [k]), ue(() => {
    const F = s.current, $ = i.current;
    if (!F || !$) return;
    const z = $.clientWidth, G = $.clientHeight, H = new Op(F, {
      width: z,
      height: G,
      bounding: {
        width: z,
        height: 0
      },
      selectionColor: "rgba(0, 216, 214,0.1)",
      selectionBorderColor: "rgba(0, 216, 214,1.0)",
      onScroll: O,
      // tScale: scale.zoom,
      // store,
      state: r,
      scale: v,
      spacing: {
        left: Ef,
        right: Tv
      }
    }), Y = O8(H);
    a.current = H, d({
      width: z,
      height: G
    }), g({
      width: z,
      height: 0
    }), E(H);
    const te = r.subscribeToSize(
      (re) => {
        _(re);
      }
    ), ge = r.subscribeToScale((re) => {
      _(re);
    }), Z = r.subscribeToTracks(
      (re) => {
        _(re);
      }
    ), de = r.subscribeToDuration(
      (re) => {
        _(re);
      }
    ), oe = r.subscribeToUpdateTrackItem(() => {
      const re = r.getState();
      _({
        duration: re.duration,
        trackItemsMap: re.trackItemsMap
      });
    }), ie = r.subscribeToAddOrRemoveItems(
      () => {
        const re = r.getState();
        _({
          trackItemDetailsMap: re.trackItemDetailsMap,
          trackItemsMap: re.trackItemsMap,
          trackItemIds: re.trackItemIds,
          tracks: re.tracks
        });
      }
    ), pe = r.subscribeToUpdateItemDetails(() => {
      const re = r.getState();
      _({
        trackItemDetailsMap: re.trackItemDetailsMap
      });
    });
    return () => {
      Y.unsubscribe(), H.purge(), ge.unsubscribe(), Z.unsubscribe(), de.unsubscribe(), ie.unsubscribe(), oe.unsubscribe(), pe.unsubscribe(), te.unsubscribe();
    };
  }, []), ue(() => {
    const $ = We.subject.pipe(
      $i(({ key: z }) => z.startsWith(CI))
    ).subscribe((z) => {
      if (z.key === w1) {
        const G = z.value?.payload?.bounding;
        G && g({
          width: G.width,
          height: G.height
        });
      }
    });
    return () => {
      $.unsubscribe();
    };
  }, []);
  const P = (F) => {
    const $ = F.currentTarget.scrollLeft;
    e.current && a.current.scrollTo({ scrollLeft: $ }), n($);
  }, j = (F) => {
    const $ = F.currentTarget.scrollTop;
    e.current && a.current.scrollTo({ scrollTop: $ });
  };
  ue(() => {
    const F = u.current?.scrollWidth;
    if (!F || !C) return;
    const $ = C.width;
    F < $ + t && C.scrollTo({ scrollLeft: F - $ });
  }, [v]);
  const V = (F) => {
    if (!a.current) return;
    const z = Ji(F, v.zoom);
    y?.current?.seekTo(z * x / 1e3);
  };
  return /* @__PURE__ */ b.jsxs("div", { className: "relative overflow-hidden h-80 w-full", children: [
    /* @__PURE__ */ b.jsx(EA, {}),
    /* @__PURE__ */ b.jsx(
      P4,
      {
        onClick: V,
        scrollLeft: t
      }
    ),
    /* @__PURE__ */ b.jsx(M4, { scrollLeft: t }),
    /* @__PURE__ */ b.jsxs("div", { className: "flex", children: [
      /* @__PURE__ */ b.jsx("div", { className: "relative w-10 flex-none" }),
      /* @__PURE__ */ b.jsxs("div", { className: "relative h-[230px] flex-1", children: [
        /* @__PURE__ */ b.jsx(
          "div",
          {
            ref: i,
            className: "absolute top-0 h-[230px] w-full text-sm text-white ",
            children: /* @__PURE__ */ b.jsx(
              "canvas",
              {
                ref: s,
                id: "designcombo-timeline-canvas"
              }
            )
          }
        ),
        /* @__PURE__ */ b.jsxs(
          il,
          {
            type: "always",
            style: {
              position: "absolute",
              width: "calc(100vw - 40px)",
              height: "10px"
            },
            className: "ScrollAreaRootH",
            children: [
              /* @__PURE__ */ b.jsx(
                yd,
                {
                  onScroll: P,
                  className: "ScrollAreaViewport",
                  id: "viewportH",
                  ref: u,
                  children: /* @__PURE__ */ b.jsx(
                    "div",
                    {
                      style: {
                        width: p.width > h.width ? p.width + Tv : p.width
                      },
                      className: "pointer-events-none h-[10px]"
                    }
                  )
                }
              ),
              /* @__PURE__ */ b.jsx(
                mv,
                {
                  className: "ScrollAreaScrollbar",
                  orientation: "horizontal",
                  children: /* @__PURE__ */ b.jsx(
                    vv,
                    {
                      className: "ScrollAreaThumb",
                      onMouseDown: () => {
                        e.current = !0;
                      },
                      onMouseUp: () => {
                        e.current = !1;
                      }
                    }
                  )
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ b.jsxs(
          il,
          {
            type: "always",
            style: {
              position: "absolute",
              height: "230px",
              width: "10px"
            },
            className: "ScrollAreaRootV",
            children: [
              /* @__PURE__ */ b.jsx(
                yd,
                {
                  onScroll: j,
                  className: "ScrollAreaViewport",
                  ref: c,
                  children: /* @__PURE__ */ b.jsx(
                    "div",
                    {
                      style: {
                        height: p.height > h.height ? p.height + 40 : h.height
                      },
                      className: "pointer-events-none w-[10px]"
                    }
                  )
                }
              ),
              /* @__PURE__ */ b.jsx(
                mv,
                {
                  className: "ScrollAreaScrollbar",
                  orientation: "vertical",
                  children: /* @__PURE__ */ b.jsx(
                    vv,
                    {
                      className: "ScrollAreaThumb",
                      onMouseDown: () => {
                        e.current = !0;
                      },
                      onMouseUp: () => {
                        e.current = !1;
                      }
                    }
                  )
                }
              )
            ]
          }
        )
      ] })
    ] })
  ] });
}, I8 = { Date: !0, RegExp: !0, String: !0, Number: !0 };
function Xx(r, e, t = { cyclesFix: !0 }, n = []) {
  let i = [];
  const s = Array.isArray(r);
  for (const c in r) {
    const u = r[c], h = s ? +c : c;
    if (!(c in e)) {
      i.push({
        type: "REMOVE",
        path: [h],
        oldValue: r[c]
      });
      continue;
    }
    const d = e[c], p = typeof u == "object" && typeof d == "object" && Array.isArray(u) === Array.isArray(d);
    u && d && p && !I8[Object.getPrototypeOf(u)?.constructor?.name] && (!t.cyclesFix || !n.includes(u)) ? i.push.apply(i, Xx(u, d, t, t.cyclesFix ? n.concat([u]) : []).map((g) => (g.path.unshift(h), g))) : u !== d && // treat NaN values as equivalent
    !(Number.isNaN(u) && Number.isNaN(d)) && !(p && (isNaN(u) ? u + "" == d + "" : +u == +d)) && i.push({
      path: [h],
      type: "CHANGE",
      value: d,
      oldValue: u
    });
  }
  const a = Array.isArray(e);
  for (const c in e)
    c in r || i.push({
      type: "CREATE",
      path: [a ? +c : c],
      value: e[c]
    });
  return i;
}
var Ip = Symbol.for("immer-nothing"), ea = Symbol.for("immer-draftable"), Rr = Symbol.for("immer-state"), Gx = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(r) {
    return `The plugin for '${r}' has not been loaded into Immer. To enable the plugin, import and call \`enable${r}()\` when initializing your application.`;
  },
  function(r) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${r}'`;
  },
  "This object has been frozen and should not be mutated",
  function(r) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + r;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(r) {
    return `'current' expects a draft, got: ${r}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(r) {
    return `'original' expects a draft, got: ${r}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function jt(r, ...e) {
  if (process.env.NODE_ENV !== "production") {
    const t = Gx[r], n = typeof t == "function" ? t.apply(null, e) : t;
    throw new Error(`[Immer] ${n}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${r}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var is = Object.getPrototypeOf;
function ss(r) {
  return !!r && !!r[Rr];
}
function wi(r) {
  return r ? qx(r) || Array.isArray(r) || !!r[ea] || !!r.constructor?.[ea] || ka(r) || Oa(r) : !1;
}
var A8 = Object.prototype.constructor.toString();
function qx(r) {
  if (!r || typeof r != "object")
    return !1;
  const e = is(r);
  if (e === null)
    return !0;
  const t = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return t === Object ? !0 : typeof t == "function" && Function.toString.call(t) === A8;
}
function ua(r, e) {
  os(r) === 0 ? Reflect.ownKeys(r).forEach((t) => {
    e(t, r[t], r);
  }) : r.forEach((t, n) => e(n, t, r));
}
function os(r) {
  const e = r[Rr];
  return e ? e.type_ : Array.isArray(r) ? 1 : ka(r) ? 2 : Oa(r) ? 3 : 0;
}
function ha(r, e) {
  return os(r) === 2 ? r.has(e) : Object.prototype.hasOwnProperty.call(r, e);
}
function ad(r, e) {
  return os(r) === 2 ? r.get(e) : r[e];
}
function Kx(r, e, t) {
  const n = os(r);
  n === 2 ? r.set(e, t) : n === 3 ? r.add(t) : r[e] = t;
}
function M8(r, e) {
  return r === e ? r !== 0 || 1 / r === 1 / e : r !== r && e !== e;
}
function ka(r) {
  return r instanceof Map;
}
function Oa(r) {
  return r instanceof Set;
}
function Vi(r) {
  return r.copy_ || r.base_;
}
function cf(r, e) {
  if (ka(r))
    return new Map(r);
  if (Oa(r))
    return new Set(r);
  if (Array.isArray(r))
    return Array.prototype.slice.call(r);
  const t = qx(r);
  if (e === !0 || e === "class_only" && !t) {
    const n = Object.getOwnPropertyDescriptors(r);
    delete n[Rr];
    let i = Reflect.ownKeys(n);
    for (let s = 0; s < i.length; s++) {
      const a = i[s], c = n[a];
      c.writable === !1 && (c.writable = !0, c.configurable = !0), (c.get || c.set) && (n[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: c.enumerable,
        value: r[a]
      });
    }
    return Object.create(is(r), n);
  } else {
    const n = is(r);
    if (n !== null && t)
      return { ...r };
    const i = Object.create(n);
    return Object.assign(i, r);
  }
}
function Ap(r, e = !1) {
  return bu(r) || ss(r) || !wi(r) || (os(r) > 1 && (r.set = r.add = r.clear = r.delete = P8), Object.freeze(r), e && Object.entries(r).forEach(([t, n]) => Ap(n, !0))), r;
}
function P8() {
  jt(2);
}
function bu(r) {
  return Object.isFrozen(r);
}
var lf = {};
function as(r) {
  const e = lf[r];
  return e || jt(0, r), e;
}
function D8(r, e) {
  lf[r] || (lf[r] = e);
}
var da;
function Zx() {
  return da;
}
function R8(r, e) {
  return {
    drafts_: [],
    parent_: r,
    immer_: e,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function ry(r, e) {
  e && (as("Patches"), r.patches_ = [], r.inversePatches_ = [], r.patchListener_ = e);
}
function uf(r) {
  hf(r), r.drafts_.forEach(j8), r.drafts_ = null;
}
function hf(r) {
  r === da && (da = r.parent_);
}
function ny(r) {
  return da = R8(da, r);
}
function j8(r) {
  const e = r[Rr];
  e.type_ === 0 || e.type_ === 1 ? e.revoke_() : e.revoked_ = !0;
}
function iy(r, e) {
  e.unfinalizedDrafts_ = e.drafts_.length;
  const t = e.drafts_[0];
  return r !== void 0 && r !== t ? (t[Rr].modified_ && (uf(e), jt(4)), wi(r) && (r = Al(e, r), e.parent_ || Ml(e, r)), e.patches_ && as("Patches").generateReplacementPatches_(
    t[Rr].base_,
    r,
    e.patches_,
    e.inversePatches_
  )) : r = Al(e, t, []), uf(e), e.patches_ && e.patchListener_(e.patches_, e.inversePatches_), r !== Ip ? r : void 0;
}
function Al(r, e, t) {
  if (bu(e))
    return e;
  const n = e[Rr];
  if (!n)
    return ua(
      e,
      (i, s) => sy(r, n, e, i, s, t)
    ), e;
  if (n.scope_ !== r)
    return e;
  if (!n.modified_)
    return Ml(r, n.base_, !0), n.base_;
  if (!n.finalized_) {
    n.finalized_ = !0, n.scope_.unfinalizedDrafts_--;
    const i = n.copy_;
    let s = i, a = !1;
    n.type_ === 3 && (s = new Set(i), i.clear(), a = !0), ua(
      s,
      (c, u) => sy(r, n, i, c, u, t, a)
    ), Ml(r, i, !1), t && r.patches_ && as("Patches").generatePatches_(
      n,
      t,
      r.patches_,
      r.inversePatches_
    );
  }
  return n.copy_;
}
function sy(r, e, t, n, i, s, a) {
  if (process.env.NODE_ENV !== "production" && i === t && jt(5), ss(i)) {
    const c = s && e && e.type_ !== 3 && // Set objects are atomic since they have no keys.
    !ha(e.assigned_, n) ? s.concat(n) : void 0, u = Al(r, i, c);
    if (Kx(t, n, u), ss(u))
      r.canAutoFreeze_ = !1;
    else
      return;
  } else a && t.add(i);
  if (wi(i) && !bu(i)) {
    if (!r.immer_.autoFreeze_ && r.unfinalizedDrafts_ < 1)
      return;
    Al(r, i), (!e || !e.scope_.parent_) && typeof n != "symbol" && Object.prototype.propertyIsEnumerable.call(t, n) && Ml(r, i);
  }
}
function Ml(r, e, t = !1) {
  !r.parent_ && r.immer_.autoFreeze_ && r.canAutoFreeze_ && Ap(e, t);
}
function F8(r, e) {
  const t = Array.isArray(r), n = {
    type_: t ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: e ? e.scope_ : Zx(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: e,
    // The base state.
    base_: r,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let i = n, s = Mp;
  t && (i = [n], s = fa);
  const { revoke: a, proxy: c } = Proxy.revocable(i, s);
  return n.draft_ = c, n.revoke_ = a, c;
}
var Mp = {
  get(r, e) {
    if (e === Rr)
      return r;
    const t = Vi(r);
    if (!ha(t, e))
      return L8(r, t, e);
    const n = t[e];
    return r.finalized_ || !wi(n) ? n : n === cd(r.base_, e) ? (ld(r), r.copy_[e] = ff(n, r)) : n;
  },
  has(r, e) {
    return e in Vi(r);
  },
  ownKeys(r) {
    return Reflect.ownKeys(Vi(r));
  },
  set(r, e, t) {
    const n = Jx(Vi(r), e);
    if (n?.set)
      return n.set.call(r.draft_, t), !0;
    if (!r.modified_) {
      const i = cd(Vi(r), e), s = i?.[Rr];
      if (s && s.base_ === t)
        return r.copy_[e] = t, r.assigned_[e] = !1, !0;
      if (M8(t, i) && (t !== void 0 || ha(r.base_, e)))
        return !0;
      ld(r), df(r);
    }
    return r.copy_[e] === t && // special case: handle new props with value 'undefined'
    (t !== void 0 || e in r.copy_) || // special case: NaN
    Number.isNaN(t) && Number.isNaN(r.copy_[e]) || (r.copy_[e] = t, r.assigned_[e] = !0), !0;
  },
  deleteProperty(r, e) {
    return cd(r.base_, e) !== void 0 || e in r.base_ ? (r.assigned_[e] = !1, ld(r), df(r)) : delete r.assigned_[e], r.copy_ && delete r.copy_[e], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(r, e) {
    const t = Vi(r), n = Reflect.getOwnPropertyDescriptor(t, e);
    return n && {
      writable: !0,
      configurable: r.type_ !== 1 || e !== "length",
      enumerable: n.enumerable,
      value: t[e]
    };
  },
  defineProperty() {
    jt(11);
  },
  getPrototypeOf(r) {
    return is(r.base_);
  },
  setPrototypeOf() {
    jt(12);
  }
}, fa = {};
ua(Mp, (r, e) => {
  fa[r] = function() {
    return arguments[0] = arguments[0][0], e.apply(this, arguments);
  };
});
fa.deleteProperty = function(r, e) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(e)) && jt(13), fa.set.call(this, r, e, void 0);
};
fa.set = function(r, e, t) {
  return process.env.NODE_ENV !== "production" && e !== "length" && isNaN(parseInt(e)) && jt(14), Mp.set.call(this, r[0], e, t, r[0]);
};
function cd(r, e) {
  const t = r[Rr];
  return (t ? Vi(t) : r)[e];
}
function L8(r, e, t) {
  const n = Jx(e, t);
  return n ? "value" in n ? n.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    n.get?.call(r.draft_)
  ) : void 0;
}
function Jx(r, e) {
  if (!(e in r))
    return;
  let t = is(r);
  for (; t; ) {
    const n = Object.getOwnPropertyDescriptor(t, e);
    if (n)
      return n;
    t = is(t);
  }
}
function df(r) {
  r.modified_ || (r.modified_ = !0, r.parent_ && df(r.parent_));
}
function ld(r) {
  r.copy_ || (r.copy_ = cf(
    r.base_,
    r.scope_.immer_.useStrictShallowCopy_
  ));
}
var N8 = class {
  constructor(r) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (e, t, n) => {
      if (typeof e == "function" && typeof t != "function") {
        const s = t;
        t = e;
        const a = this;
        return function(u = s, ...h) {
          return a.produce(u, (d) => t.call(this, d, ...h));
        };
      }
      typeof t != "function" && jt(6), n !== void 0 && typeof n != "function" && jt(7);
      let i;
      if (wi(e)) {
        const s = ny(this), a = ff(e, void 0);
        let c = !0;
        try {
          i = t(a), c = !1;
        } finally {
          c ? uf(s) : hf(s);
        }
        return ry(s, n), iy(i, s);
      } else if (!e || typeof e != "object") {
        if (i = t(e), i === void 0 && (i = e), i === Ip && (i = void 0), this.autoFreeze_ && Ap(i, !0), n) {
          const s = [], a = [];
          as("Patches").generateReplacementPatches_(e, i, s, a), n(s, a);
        }
        return i;
      } else
        jt(1, e);
    }, this.produceWithPatches = (e, t) => {
      if (typeof e == "function")
        return (a, ...c) => this.produceWithPatches(a, (u) => e(u, ...c));
      let n, i;
      return [this.produce(e, t, (a, c) => {
        n = a, i = c;
      }), n, i];
    }, typeof r?.autoFreeze == "boolean" && this.setAutoFreeze(r.autoFreeze), typeof r?.useStrictShallowCopy == "boolean" && this.setUseStrictShallowCopy(r.useStrictShallowCopy);
  }
  createDraft(r) {
    wi(r) || jt(8), ss(r) && (r = B8(r));
    const e = ny(this), t = ff(r, void 0);
    return t[Rr].isManual_ = !0, hf(e), t;
  }
  finishDraft(r, e) {
    const t = r && r[Rr];
    (!t || !t.isManual_) && jt(9);
    const { scope_: n } = t;
    return ry(n, e), iy(void 0, n);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(r) {
    this.autoFreeze_ = r;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(r) {
    this.useStrictShallowCopy_ = r;
  }
  applyPatches(r, e) {
    let t;
    for (t = e.length - 1; t >= 0; t--) {
      const i = e[t];
      if (i.path.length === 0 && i.op === "replace") {
        r = i.value;
        break;
      }
    }
    t > -1 && (e = e.slice(t + 1));
    const n = as("Patches").applyPatches_;
    return ss(r) ? n(r, e) : this.produce(
      r,
      (i) => n(i, e)
    );
  }
};
function ff(r, e) {
  const t = ka(r) ? as("MapSet").proxyMap_(r, e) : Oa(r) ? as("MapSet").proxySet_(r, e) : F8(r, e);
  return (e ? e.scope_ : Zx()).drafts_.push(t), t;
}
function B8(r) {
  return ss(r) || jt(10, r), Qx(r);
}
function Qx(r) {
  if (!wi(r) || bu(r))
    return r;
  const e = r[Rr];
  let t;
  if (e) {
    if (!e.modified_)
      return e.base_;
    e.finalized_ = !0, t = cf(r, e.scope_.immer_.useStrictShallowCopy_);
  } else
    t = cf(r, !0);
  return ua(t, (n, i) => {
    Kx(t, n, Qx(i));
  }), e && (e.finalized_ = !1), t;
}
function oy() {
  process.env.NODE_ENV !== "production" && Gx.push(
    'Sets cannot have "replace" patches.',
    function(g) {
      return "Unsupported patch operation: " + g;
    },
    function(g) {
      return "Cannot apply patch, path doesn't resolve: " + g;
    },
    "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
  );
  const e = "replace", t = "add", n = "remove";
  function i(g, v, y, x) {
    switch (g.type_) {
      case 0:
      case 2:
        return a(
          g,
          v,
          y,
          x
        );
      case 1:
        return s(g, v, y, x);
      case 3:
        return c(
          g,
          v,
          y,
          x
        );
    }
  }
  function s(g, v, y, x) {
    let { base_: _, assigned_: C } = g, E = g.copy_;
    E.length < _.length && ([_, E] = [E, _], [y, x] = [x, y]);
    for (let k = 0; k < _.length; k++)
      if (C[k] && E[k] !== _[k]) {
        const O = v.concat([k]);
        y.push({
          op: e,
          path: O,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: p(E[k])
        }), x.push({
          op: e,
          path: O,
          value: p(_[k])
        });
      }
    for (let k = _.length; k < E.length; k++) {
      const O = v.concat([k]);
      y.push({
        op: t,
        path: O,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: p(E[k])
      });
    }
    for (let k = E.length - 1; _.length <= k; --k) {
      const O = v.concat([k]);
      x.push({
        op: n,
        path: O
      });
    }
  }
  function a(g, v, y, x) {
    const { base_: _, copy_: C } = g;
    ua(g.assigned_, (E, k) => {
      const O = ad(_, E), P = ad(C, E), j = k ? ha(_, E) ? e : t : n;
      if (O === P && j === e)
        return;
      const V = v.concat(E);
      y.push(j === n ? { op: j, path: V } : { op: j, path: V, value: P }), x.push(
        j === t ? { op: n, path: V } : j === n ? { op: t, path: V, value: p(O) } : { op: e, path: V, value: p(O) }
      );
    });
  }
  function c(g, v, y, x) {
    let { base_: _, copy_: C } = g, E = 0;
    _.forEach((k) => {
      if (!C.has(k)) {
        const O = v.concat([E]);
        y.push({
          op: n,
          path: O,
          value: k
        }), x.unshift({
          op: t,
          path: O,
          value: k
        });
      }
      E++;
    }), E = 0, C.forEach((k) => {
      if (!_.has(k)) {
        const O = v.concat([E]);
        y.push({
          op: t,
          path: O,
          value: k
        }), x.unshift({
          op: n,
          path: O,
          value: k
        });
      }
      E++;
    });
  }
  function u(g, v, y, x) {
    y.push({
      op: e,
      path: [],
      value: v === Ip ? void 0 : v
    }), x.push({
      op: e,
      path: [],
      value: g
    });
  }
  function h(g, v) {
    return v.forEach((y) => {
      const { path: x, op: _ } = y;
      let C = g;
      for (let P = 0; P < x.length - 1; P++) {
        const j = os(C);
        let V = x[P];
        typeof V != "string" && typeof V != "number" && (V = "" + V), (j === 0 || j === 1) && (V === "__proto__" || V === "constructor") && jt(19), typeof C == "function" && V === "prototype" && jt(19), C = ad(C, V), typeof C != "object" && jt(18, x.join("/"));
      }
      const E = os(C), k = d(y.value), O = x[x.length - 1];
      switch (_) {
        case e:
          switch (E) {
            case 2:
              return C.set(O, k);
            case 3:
              jt(16);
            default:
              return C[O] = k;
          }
        case t:
          switch (E) {
            case 1:
              return O === "-" ? C.push(k) : C.splice(O, 0, k);
            case 2:
              return C.set(O, k);
            case 3:
              return C.add(k);
            default:
              return C[O] = k;
          }
        case n:
          switch (E) {
            case 1:
              return C.splice(O, 1);
            case 2:
              return C.delete(O);
            case 3:
              return C.delete(y.value);
            default:
              return delete C[O];
          }
        default:
          jt(17, _);
      }
    }), g;
  }
  function d(g) {
    if (!wi(g))
      return g;
    if (Array.isArray(g))
      return g.map(d);
    if (ka(g))
      return new Map(
        Array.from(g.entries()).map(([y, x]) => [y, d(x)])
      );
    if (Oa(g))
      return new Set(Array.from(g).map(d));
    const v = Object.create(is(g));
    for (const y in g)
      v[y] = d(g[y]);
    return ha(g, ea) && (v[ea] = g[ea]), v;
  }
  function p(g) {
    return ss(g) ? d(g) : g;
  }
  D8("Patches", {
    applyPatches_: h,
    generatePatches_: i,
    generateReplacementPatches_: u
  });
}
var jr = new N8(), V8 = jr.produce;
jr.produceWithPatches.bind(
  jr
);
jr.setAutoFreeze.bind(jr);
jr.setUseStrictShallowCopy.bind(jr);
var z8 = jr.applyPatches.bind(jr);
jr.createDraft.bind(jr);
jr.finishDraft.bind(jr);
function W8(r) {
  const e = r.value, t = [];
  if (e?.payload?.trackItemIds) {
    const n = e.payload.trackItemIds;
    t.push(n), this.updateState({ activeIds: t });
  }
  if (r.key === f1) {
    const n = r.value?.payload.trackItemIds, i = Xe.cloneDeep(this.getState()), s = n?.length ? n : i.activeIds, a = i.trackItemIds.filter(
      (p) => !s.includes(p)
    ), c = Object.fromEntries(
      Object.entries(i.trackItemDetailsMap).filter(
        ([p]) => !s.includes(p)
      )
    ), u = x6(i.tracks, s), h = Object.fromEntries(
      Object.entries(i.trackItemsMap).filter(
        ([p]) => !s.includes(p)
      )
    ), d = kn(h);
    this.updateState(
      {
        trackItemIds: a,
        trackItemDetailsMap: c,
        activeIds: [],
        trackItemsMap: h,
        tracks: u,
        duration: d
      },
      { updateHistory: !0, kind: "remove" }
    );
  }
  if (r.key === p1) {
    const n = Xe.cloneDeep(this.getState()), i = [], s = r.value?.payload.trackItemIds || n.activeIds;
    if (s.length === 0) return;
    s.forEach((c) => {
      const u = n.trackItemsMap[c], h = n.trackItemDetailsMap[c], d = Ft();
      i.push(d), n.trackItemsMap = {
        ...n.trackItemsMap,
        [d]: { ...Xe.cloneDeep(u), id: d }
      }, n.trackItemDetailsMap = {
        ...n.trackItemDetailsMap,
        [d]: { ...Xe.cloneDeep(h) }
      }, n.trackItemIds.push(d);
    });
    const a = n.tracks.map((c) => {
      const u = {
        ...c,
        id: Ft(),
        items: c.items.filter((h) => s.includes(h)).map((h) => {
          const d = s.indexOf(h);
          return i[d];
        })
      };
      return u.items.length ? u : null;
    }).filter(Boolean);
    n.tracks.unshift(...a), this.updateState(
      {
        trackItemDetailsMap: n.trackItemDetailsMap,
        tracks: n.tracks,
        trackItemIds: n.trackItemIds,
        trackItemsMap: n.trackItemsMap
      },
      {
        updateHistory: !0,
        kind: "update"
      }
    );
  }
  if (r.key === g1) {
    const n = Xe.cloneDeep(this.getState()), i = r.value?.options.time;
    if (n.activeIds.length !== 1) return;
    const s = n.activeIds[0], a = n.trackItemsMap[s];
    if (i <= a.display.from || i >= a.display.to)
      return;
    const c = Ft(), u = {
      ...a,
      id: c,
      display: { from: i, to: a.display.to },
      trim: { from: i, to: a.display.to }
    };
    n.trackItemsMap[s].display.to = i, n.trackItemsMap[c] = u, n.trackItemDetailsMap[c] = n.trackItemDetailsMap[s], n.trackItemIds.push(c), n.tracks.forEach((h) => {
      h.items.includes(s) && h.items.push(c);
    }), this.updateState(
      {
        trackItemsMap: n.trackItemsMap,
        trackItemDetailsMap: n.trackItemDetailsMap,
        trackItemIds: n.trackItemIds,
        tracks: n.tracks
      },
      { updateHistory: !0, kind: "update" }
    );
  }
}
async function H8(r) {
  if (r.key === "scene:load") {
    const e = r.value?.payload, t = e.size, n = e.trackItemIds, i = e.trackItemsMap, s = e.trackItemDetailsMap;
    if (!n) return;
    const a = n?.map(async (u) => {
      try {
        const h = s[u], d = i[u];
        if (h.type === "text") {
          const p = await yx(
            { id: u, details: h.details, ...d },
            {
              size: t
            }
          ), { details: g, ...v } = p;
          s[u] = { type: "text", details: g }, i[u] = v;
        }
        return !0;
      } catch {
        return !1;
      }
    });
    await Promise.all(a);
    const c = kn(i);
    this.updateState({
      ...e,
      trackItemsMap: i,
      duration: c
    });
  }
}
async function U8(r) {
  const e = Xe.cloneDeep(this.getState()), t = r.value?.options?.trackId, n = r.value?.options?.trackIndex;
  let i = [], s;
  if (r.key === ga) {
    s = "video";
    const c = await S6(r.value?.payload, {
      size: e.size
    }), { details: u, ...h } = c;
    e.trackItemDetailsMap[h.id] = {
      type: s,
      details: u
    }, e.trackItemsMap[h.id] = h, e.trackItemIds.push(h.id), i = [h.id];
  }
  if (r.key === va) {
    s = "image";
    const c = await _6(r.value?.payload, {
      size: e.size
    }), { details: u, ...h } = c;
    e.trackItemDetailsMap[h.id] = {
      type: s,
      details: u
    }, e.trackItemsMap[h.id] = h, e.trackItemIds.push(h.id), i = [h.id];
  }
  if (r.key === ma) {
    s = "audio";
    const c = await C6(r.value?.payload), { details: u, ...h } = c;
    e.trackItemDetailsMap[h.id] = {
      type: s,
      details: u
    }, e.trackItemsMap[h.id] = h, e.trackItemIds.push(h.id), i = [h.id];
  }
  if (r.key === d1) {
    s = "text";
    const { details: c, ...u } = await yx(
      r.value?.payload ?? void 0,
      {
        size: e.size
      }
    );
    e.trackItemDetailsMap[u.id] = { type: s, details: c }, e.trackItemsMap[u.id] = u, e.trackItemIds.push(u.id), i.push(u.id);
  }
  const a = $8(
    i,
    e.tracks,
    e.trackItemsMap,
    t,
    n
  );
  if (a.trackId)
    e.tracks.find((u) => u.id === a.trackId)?.items.push(...i);
  else if (a.trackIndex !== void 0) {
    const c = ay(s, i);
    e.tracks.splice(a.trackIndex, 0, c);
  } else {
    const c = ay(s, i);
    e.tracks.unshift(c);
  }
  e.duration = kn(e.trackItemsMap), this.updateState(
    {
      trackItemIds: e.trackItemIds,
      trackItemDetailsMap: e.trackItemDetailsMap,
      trackItemsMap: e.trackItemsMap,
      tracks: e.tracks,
      duration: e.duration,
      structure: e.structure
    },
    {
      updateHistory: !0,
      kind: "add"
    }
  );
}
function ay(r, e) {
  return {
    id: Ft(),
    accepts: ["text", "audio", "helper", "video", "image"],
    type: r,
    items: e,
    magnetic: !1,
    static: !1
  };
}
const $8 = (r, e, t, n, i) => {
  if (n === void 0 && i === void 0)
    return { trackId: void 0, trackIndex: void 0 };
  const s = i !== void 0 ? e[Math.max(0, Math.min(i, e.length - 1))] : e.find((u) => u.id === n);
  if (!s)
    return {
      trackId: void 0,
      trackIndex: i !== void 0 ? Math.max(0, Math.min(i, e.length - 1)) : void 0
    };
  const a = s.items.map((u) => t[u]), c = r.map((u) => t[u]);
  for (const u of a) {
    const h = u.display.from, d = u.display.to;
    for (const p of c) {
      const g = p.display.from;
      if (!(p.display.to <= h || g >= d))
        return {
          trackId: void 0,
          trackIndex: e.indexOf(s)
        };
    }
  }
  return {
    trackId: s.id,
    trackIndex: e.indexOf(s)
  };
}, cy = [
  "tracks",
  "trackItemsMap",
  "trackItemDetailsMap",
  "transitionIds",
  "transitionsMap",
  "trackItemIds"
], Y8 = {
  size: {
    width: 1080,
    height: 1920
  },
  tracks: [],
  trackItemIds: [],
  trackItemsMap: {},
  transitionIds: [],
  transitionsMap: {},
  scale: {
    unit: 1,
    zoom: 1,
    segments: 1,
    index: 1
  },
  duration: 0,
  activeIds: [],
  trackItemDetailsMap: {},
  structure: []
};
class c9 {
  stateSubject;
  stateHistorySubject;
  prevState;
  undos;
  redos;
  listener;
  constructor(e) {
    this.stateSubject = null, this.stateHistorySubject = null, this.prevState = null, this.undos = [], this.redos = [], this.listener = null;
    const t = e || Y8;
    this.stateSubject = new Sv(t), this.stateHistorySubject = new Sv({
      handleRedo: !1,
      handleUndo: !1
    }), this.prevState = t, this.initListeners();
  }
  initListeners() {
    X8(this);
  }
  destroyListeners() {
    this.listener && this.listener.unsubscribe();
  }
  purge() {
    this.destroyListeners();
  }
  updateHistory(e, t) {
    const n = Xe.pick(e, cy), i = Xe.pick(this.getState(), cy), s = Xx(i, n);
    s.length && (this.undos.push({ undos: s, type: t }), this.redos = []);
  }
  getStateHistory() {
    return this.stateHistorySubject.getValue();
  }
  subscribeHistory(e) {
    return this.stateHistorySubject.subscribe(e);
  }
  getState() {
    return this.stateSubject.getValue();
  }
  subscribe(e) {
    return this.stateSubject.subscribe(e);
  }
  updateState(e, t = { updateHistory: !1, kind: void 0 }) {
    const n = this.getState(), i = { ...n, ...e };
    if (!Xe.isEqual(n, i)) {
      t.updateHistory && this.updateHistory(i, t.kind);
      const { duration: s, trackItemsMap: a, ...c } = n;
      this.prevState = {
        ...c,
        duration: this.prevState.duration,
        trackItemsMap: this.prevState.trackItemsMap
      }, this.stateSubject.next(i);
    }
  }
  subscribeToSize(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      Xe.isEqual(t.size, this.prevState.size) || e({ size: t.size });
    });
  }
  subscribeToScale(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      Xe.isEqual(t.scale, this.prevState.scale) || e({ scale: t.scale });
    });
  }
  subscribeToUpdateTrackItem(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      Xe.isEqual(t.trackItemsMap, this.prevState.trackItemsMap) || e({ trackItemsMap: t.trackItemsMap });
    });
  }
  subscribeToUpdateItemDetails(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      Xe.isEqual(
        t.trackItemDetailsMap,
        this.prevState.trackItemDetailsMap
      ) || e({ trackItemDetailsMap: t.trackItemDetailsMap });
    });
  }
  subscribeToDuration(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      t.duration !== this.prevState.duration && e({ duration: t.duration });
    });
  }
  subscribeToHistory(e) {
    return this.stateHistorySubject.asObservable().subscribe((t) => {
      if (t.handleRedo) {
        const n = this.undos[this.undos.length - 1]?.type;
        n === "update" && e({ ...this.getState(), type: n }), this.stateHistorySubject.next({
          handleRedo: !1,
          handleUndo: !1
        });
      }
      if (t.handleUndo) {
        const n = this.redos[this.redos.length - 1]?.type;
        n === "update" && e({ ...this.getState(), type: n }), this.stateHistorySubject.next({
          handleRedo: !1,
          handleUndo: !1
        });
      }
    });
  }
  subscribeToAddOrRemoveItems(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      (!t.trackItemIds?.every(
        (n) => this.prevState.trackItemIds?.includes(n)
      ) || !Xe.isEqual(t.tracks, this.prevState.tracks)) && e({ trackItemIds: t.trackItemIds });
    });
  }
  subscribeToActiveIds(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      Xe.isEqual(t.activeIds, this.prevState.activeIds) || e({ activeIds: t.activeIds });
    });
  }
  subscribeToTracks(e) {
    return this.stateSubject.asObservable().subscribe((t) => {
      (!Xe.isEqual(t.tracks, this.prevState.tracks) || !Xe.isEqual(t.trackItemIds, this.prevState.trackItemIds) || !Xe.isEqual(t.trackItemsMap, this.prevState.trackItemsMap) || !Xe.isEqual(t.transitionIds, this.prevState.transitionIds) || !Xe.isEqual(t.transitionsMap, this.prevState.transitionsMap) || !Xe.isEqual(
        t.trackItemDetailsMap,
        this.prevState.trackItemDetailsMap
      )) && e({
        tracks: t.tracks,
        trackItemIds: t.trackItemIds,
        trackItemsMap: t.trackItemsMap,
        transitionIds: t.transitionIds,
        transitionsMap: t.transitionsMap,
        trackItemDetailsMap: t.trackItemDetailsMap
        // structure: currentState.structure,
      });
    });
  }
  undo() {
    const e = this.undos.pop(), t = e?.undos, n = e?.type;
    if (!t || !n) return;
    oy();
    const {
      trackItemDetailsMap: i,
      trackItemIds: s,
      tracks: a,
      transitionIds: c,
      transitionsMap: u,
      trackItemsMap: h
    } = this.getState(), d = Xe.cloneDeep({
      trackItemDetailsMap: i,
      trackItemIds: s,
      tracks: a,
      transitionIds: c,
      transitionsMap: u,
      trackItemsMap: h
    }), p = [], g = [], v = [], y = [], x = [], _ = [];
    t.forEach((H) => {
      let Y;
      const te = H.path.slice(1);
      H.type === "CREATE" ? Y = {
        path: te,
        op: "remove",
        value: H.value
      } : H.type === "CHANGE" ? Y = {
        path: te,
        op: "replace",
        value: H.oldValue
      } : Y = {
        path: te,
        op: "add",
        value: H.oldValue
      }, H.path.includes("trackItemIds") ? v.push(Y) : H.path.includes("transitionIds") ? g.push(Y) : H.path.includes("trackItemsMap") ? x.push(Y) : H.path.includes("transitionsMap") ? y.push(Y) : H.path.includes("tracks") ? p.push(Y) : H.path.includes("trackItemDetailsMap") && _.push(Y);
    });
    const C = this.applyPatch(d.tracks, p), E = this.applyPatch(
      d.transitionIds,
      g
    ), k = this.applyPatch(
      d.trackItemIds,
      v
    ), O = this.applyPatch(
      d.transitionsMap,
      y
    ), P = this.applyPatch(
      d.trackItemsMap,
      x
    ), j = this.applyPatch(
      d.trackItemDetailsMap,
      _
    ), V = Xe.cloneDeep({
      tracks: C,
      transitionIds: E,
      trackItemIds: k,
      transitionsMap: O,
      trackItemsMap: P,
      trackItemDetailsMap: j
    }), F = Xe.cloneDeep(this.getState()), $ = { ...F, ...V };
    this.prevState = F;
    const z = { redos: t, type: n };
    this.redos.push(z);
    const G = kn($.trackItemsMap);
    this.stateSubject.next({ ...$, duration: G }), this.stateHistorySubject.next({ handleRedo: !1, handleUndo: !0 });
  }
  redo() {
    const e = this.redos.pop();
    if (!e?.redos || !e?.type) return;
    oy();
    const t = this.getState(), {
      trackItemDetailsMap: n,
      trackItemIds: i,
      tracks: s,
      transitionIds: a,
      transitionsMap: c,
      trackItemsMap: u
    } = t, h = Xe.cloneDeep({
      trackItemDetailsMap: n,
      trackItemIds: i,
      tracks: s,
      transitionIds: a,
      transitionsMap: c,
      trackItemsMap: u
    }), d = [], p = [], g = [], v = [], y = [], x = [];
    e.redos.forEach((O) => {
      const P = O.path.slice(1);
      let j = {};
      switch (O.type) {
        case "CREATE":
          j = {
            path: P,
            op: "add",
            value: O.value
          };
          break;
        case "CHANGE":
          j = {
            path: P,
            op: "replace",
            value: O.value
          };
          break;
        case "REMOVE":
          j = {
            path: P,
            op: "remove",
            value: O.oldValue
          };
          break;
        default:
          return null;
      }
      O.path.includes("trackItemIds") ? g.push(j) : O.path.includes("transitionIds") ? p.push(j) : O.path.includes("trackItemsMap") ? y.push(j) : O.path.includes("transitionsMap") ? v.push(j) : O.path.includes("trackItemDetailsMap") ? x.push(j) : d.push(j);
    });
    const _ = {
      tracks: this.applyPatch(h.tracks, d),
      transitionIds: this.applyPatch(h.transitionIds, p),
      trackItemIds: this.applyPatch(h.trackItemIds, g),
      transitionsMap: this.applyPatch(h.transitionsMap, v),
      trackItemsMap: this.applyPatch(h.trackItemsMap, y),
      trackItemDetailsMap: this.applyPatch(h.trackItemDetailsMap, x)
    }, C = Xe.cloneDeep(_), E = { ...Xe.cloneDeep(t), ...C };
    this.prevState = t, this.undos.push({ undos: e.redos, type: e.type });
    const k = kn(E.trackItemsMap);
    this.stateSubject.next({ ...E, duration: k }), this.stateHistorySubject.next({ handleRedo: !0, handleUndo: !1 });
  }
  applyPatch(e, t) {
    return t.reverse().reduce(
      (n, i) => V8(n, (s) => {
        z8(s, [i]);
      }),
      e
    );
  }
}
function X8(r) {
  const e = We.subject.pipe($i(({ key: s }) => s.startsWith(xI))).subscribe((s) => {
    s.key === m1 && r.undo(), s.key === v1 && r.redo();
  }), t = We.subject.pipe($i(({ key: s, value: a }) => s.startsWith(mI))).subscribe((s) => {
    U8.bind(r)(s);
  }), n = We.subject.pipe(
    $i(({ key: s, value: a }) => s.startsWith("scene"))
  ).subscribe(async (s) => {
    await H8.bind(r)(s);
  }), i = We.subject.pipe($i(({ key: s }) => s.startsWith(bI))).subscribe(async (s) => {
    W8.bind(r)(s);
  });
  return () => {
    e.unsubscribe(), t.unsubscribe(), i.unsubscribe(), n.unsubscribe();
  };
}
export {
  p1 as ACTIVE_CLONE,
  f1 as ACTIVE_DELETE,
  _L as ACTIVE_PASTE,
  bI as ACTIVE_PREFIX,
  xL as ACTIVE_SET,
  g1 as ACTIVE_SPLIT,
  uL as ADD_ANIMATION,
  ma as ADD_AUDIO,
  va as ADD_IMAGE,
  cL as ADD_MASK,
  aL as ADD_PLACEHOLDER,
  mI as ADD_PREFIX,
  eL as ADD_SUFFIX,
  d1 as ADD_TEXT,
  lL as ADD_TRANSITION,
  ga as ADD_VIDEO,
  OA as AUDIOS,
  P6 as Audio,
  di as AudioObject,
  XL as BASE_TIMELINE_ELEMENT_DURATION_MS,
  nr as Button,
  UR as CanvasMixin,
  ZL as DEFAULT_AUDIO_BITRATE,
  KL as DEFAULT_AUDIO_SAMPLE_RATE,
  N7 as DEFAULT_BLUR,
  L7 as DEFAULT_BLUR_STEP,
  y7 as DEFAULT_BRIGHTNESS,
  v7 as DEFAULT_BRIGHTNESS_STEP,
  A7 as DEFAULT_CONTRAST,
  I7 as DEFAULT_CONTRAST_STEP,
  a7 as DEFAULT_FADE_IN,
  c7 as DEFAULT_FADE_OUT,
  o7 as DEFAULT_FADE_STEP,
  f7 as DEFAULT_FLIP_X,
  p7 as DEFAULT_FLIP_Y,
  Ev as DEFAULT_FONT,
  JI as DEFAULT_FRAMERATE,
  F7 as DEFAULT_MAX_BLUR,
  m7 as DEFAULT_MAX_BRIGHTNESS,
  O7 as DEFAULT_MAX_CONTRAST,
  s7 as DEFAULT_MAX_FADE,
  P7 as DEFAULT_MAX_OPACITY,
  u7 as DEFAULT_MAX_ROTATION,
  w7 as DEFAULT_MAX_SATURATION,
  V7 as DEFAULT_MAX_SPEED,
  C7 as DEFAULT_MAX_TEMPERATURE,
  U7 as DEFAULT_MAX_VOLUME,
  t7 as DEFAULT_MEDIA_PANEL_WIDTH,
  j7 as DEFAULT_MIN_BLUR,
  g7 as DEFAULT_MIN_BRIGHTNESS,
  k7 as DEFAULT_MIN_CONTRAST,
  i7 as DEFAULT_MIN_FADE,
  M7 as DEFAULT_MIN_OPACITY,
  l7 as DEFAULT_MIN_ROTATION,
  b7 as DEFAULT_MIN_SATURATION,
  B7 as DEFAULT_MIN_SPEED,
  S7 as DEFAULT_MIN_TEMPERATURE,
  H7 as DEFAULT_MIN_VOLUME,
  R7 as DEFAULT_OPACITY,
  D7 as DEFAULT_OPACITY_STEP,
  QL as DEFAULT_PREVIEW_HEIGHT,
  E1 as DEFAULT_PREVIEW_SCALE,
  JL as DEFAULT_PREVIEW_WIDTH,
  d7 as DEFAULT_ROTATION,
  h7 as DEFAULT_ROTATION_STEP,
  _7 as DEFAULT_SATURATION,
  x7 as DEFAULT_SATURATION_STEP,
  n7 as DEFAULT_SETTINGS_PANEL_WIDTH,
  W7 as DEFAULT_SPEED,
  z7 as DEFAULT_SPEED_STEP,
  E7 as DEFAULT_TEMPERATURE,
  T7 as DEFAULT_TEMPERATURE_STEP,
  ZI as DEFAULT_VIDEO_HEIGHT,
  qL as DEFAULT_VIDEO_MAX_BITRATE,
  GL as DEFAULT_VIDEO_MIN_BITRATE,
  KI as DEFAULT_VIDEO_WIDTH,
  Y7 as DEFAULT_VOLUME,
  $7 as DEFAULT_VOLUME_STEP,
  YL as DEFAULT_WEIGHT,
  sl as DRAG_END,
  SI as DRAG_PREFIX,
  b1 as DRAG_START,
  Ll as Draggable,
  XI as DroppableArea,
  dL as EDIT_OBJECT,
  hL as EDIT_PREFIX,
  pL as EDIT_SHAPE,
  fL as EDIT_TEXT,
  gL as ENTER_EDIT_MODE,
  QI as FRAME_INTERVAL,
  BL as GIANT_ICON_SIZE,
  xI as HISTORY_PREFIX,
  v1 as HISTORY_REDO,
  LL as HISTORY_RESET,
  m1 as HISTORY_UNDO,
  EA as Header,
  F6 as Helper,
  Ta as HelperObject,
  IA as IMAGES,
  R6 as Image,
  bp as ImageObject,
  HL as LARGER_FONT_SIZE,
  UL as LARGE_FONT_SIZE,
  VL as LARGE_ICON_SIZE,
  DL as LAYER_CLONE,
  ML as LAYER_COPY,
  jL as LAYER_CUT,
  FL as LAYER_DELETE,
  AL as LAYER_EDITING_NAME,
  TL as LAYER_HIDDEN,
  CL as LAYER_LOCKED,
  EL as LAYER_MOVE,
  PL as LAYER_PASTE,
  SL as LAYER_PREFIX,
  IL as LAYER_RENAME,
  kL as LAYER_SELECT,
  wI as LAYER_SELECTION,
  OL as LAYER_SEND_TO,
  RL as LAYER_SPLIT,
  r7 as MAX_MEDIA_PANEL_WIDTH,
  e7 as MIN_MEDIA_PANEL_WIDTH,
  Q7 as MenuItem,
  $L as NORMAL_FONT_SIZE,
  zL as NORMAL_ICON_SIZE,
  e9 as NavbarComponent,
  yI as PLAYER_PAUSE,
  vI as PLAYER_PLAY,
  mL as PLAYER_PREFIX,
  vL as PLAYER_SEEK,
  bL as PLAYER_SEEK_BY,
  yL as PLAYER_SEEK_TO,
  wL as PLAYER_TOGGLE_PLAY,
  Vl as PREVIEW_FRAME_WIDTH,
  ca as Placeholder,
  A4 as Player,
  M4 as PlayheadComponent,
  kl as PreviewTrackItem,
  P4 as RulerComponent,
  qI as SECONDARY_FONT,
  GI as SMALL_FONT_SIZE,
  WL as SMALL_ICON_SIZE,
  oL as STATE_CHANGED,
  sL as STATE_PREFIX,
  t9 as Scene,
  NL as SceneBoard,
  Qs as ScrollArea,
  Uy as ScrollBar,
  i4 as SequenceItem,
  FO as Slider,
  c9 as StateManager,
  w1 as TIMELINE_BOUNDING_CHANGED,
  Ef as TIMELINE_OFFSET_CANVAS_LEFT,
  Tv as TIMELINE_OFFSET_CANVAS_RIGHT,
  Od as TIMELINE_OFFSET_X,
  CI as TIMELINE_PREFIX,
  y1 as TIMELINE_SCALE_CHANGED,
  _I as TIMELINE_SCALE_PREFIX,
  Tn as TIMELINE_ZOOM_LEVELS,
  nL as TRACKS_CHANGED,
  iL as TRACK_ITEMS_CHANGED,
  rL as TRACK_ITEMS_PREFIX,
  tL as TRACK_PREFIX,
  MA as TRANSITIONS,
  gI as Tabs,
  xd as TabsContent,
  h1 as TabsList,
  wd as TabsTrigger,
  bx as Text,
  qs as TextObject,
  Op as Timeline,
  a9 as TimelineComponent,
  j6 as Track,
  L6 as TrackItemsMixin,
  rs as TrackObject,
  B6 as TracksMixin,
  hn as Transition,
  El as TransitionGuide,
  W6 as TransitionsMixin,
  J7 as UPLOADS,
  AA as VIDEOS,
  D6 as Video,
  po as VideoObject,
  C8 as addEventListeners,
  g6 as applyMixins,
  hO as buttonVariants,
  w6 as calculateDisplayRange,
  kn as calculateDuration,
  wp as calculatePosition,
  lA as calculateTimelineWidth,
  b6 as calculateTrim,
  cs as cn,
  l6 as createAudioControls,
  p6 as createControls,
  s6 as createMediaControls,
  mx as createResizeControls,
  pu as defaultColor,
  A6 as defaultSizes,
  x6 as filterAndCleanTracks,
  k1 as findIndex,
  K8 as formatBytes,
  X7 as formatTimeToHumanReadable,
  eA as formatTimelineUnit,
  tA as frameToTimeString,
  nA as getCurrentTime,
  G7 as getFitZoomLevel,
  i9 as getMovingState,
  oA as getNextZoom,
  cA as getNextZoomIndex,
  aA as getNextZoomLevel,
  Ne as getOffset,
  sA as getPreviousZoom,
  K7 as getPreviousZoomIndex,
  iA as getPreviousZoomLevel,
  el as getTextHeight,
  q7 as getZoomByIndex,
  O8 as handleEvents,
  Cl as handleResize,
  m6 as loadAudio,
  C6 as loadAudioItem,
  E6 as loadAudioObject,
  uA as loadFonts,
  v6 as loadImage,
  _6 as loadImageItem,
  k6 as loadImageObject,
  yx as loadTextItem,
  I6 as loadTextObject,
  y6 as loadVideo,
  S6 as loadVideoItem,
  O6 as loadVideoObject,
  M6 as mergeSizes,
  O1 as mergeTrackObjects,
  Q as movingState,
  $R as positionOffsets,
  Z7 as randomInt,
  T8 as removeEventListeners,
  ol as removeItemsFromTrack,
  yi as renderControl,
  I1 as reorderTracksByIndex,
  X8 as setupHistoryListeners,
  Ot as timeMsToUnits,
  rA as timeToString,
  Tt as transitionStore,
  Ji as unitsToTimeMs,
  s9 as updateMovingState,
  kf as useCurrentPlayerFrame,
  zl as useIsDraggingOverTimeline,
  P1 as useLayoutStore,
  Qi as useStore,
  vx as wrapResizeWithAnchorPosition
};
